[["index.html", "Introduction à R et au tidyverse À propos de ce document Remerciements Licence", " Introduction à R et au tidyverse Julien Barnier 2021-10-29 À propos de ce document Ce document est une introduction à l’utilisation du logiciel libre de traitement de données et d’analyse statistique R. Il se veut le plus accessible possible, y compris pour ceux qui ne sont pas particulièrement familiers avec l’informatique. Il se base à la fois sur les fonctionnalités de R “de base”, et sur une série d’extensions regroupées sous l’appellation tidyverse. Ce document n’est pas une introduction aux méthodes statistiques d’analyse de données. Il est basé sur R version 4.1.1 (2021-08-10). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://juba.github.io/tidyverse Le code source est disponible sur GitHub. Pour toute suggestion ou correction, il est possible de me contacter par mail ou sur Twitter. Remerciements Un remerciement tout particulier à mes formidables collègues Sofiane Bouzid, Behnaz Khosravi et Karine Pietropaoli pour leurs nombreux et utiles retours sur la partie Aller plus loin. Ce document a également bénéficié de la relecture, des suggestions et des corrections de Diane Rodet, Mayeul Kauffmann, Jimmy Raturat, Fabienne Marquant, Julien Biaudet, Frédérique Giraud, Joël Gombin, Milan Bouchet-Valat et Joseph Larmarange. Ce document est généré par l’excellente extension bookdown de Yihui Xie. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons "],["01-presentation.html", "Partie 1 Présentation 1.1 À propos de R 1.2 À propos de RStudio 1.3 À propos du tidyverse 1.4 Structure du document 1.5 Prérequis", " Partie 1 Présentation 1.1 À propos de R R est un langage orienté vers le traitement et l’analyse quantitative de données, dérivé du langage . Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une large communauté d’utilisateurs et utilisatrices. C’est un logiciel libre, publié sous licence GNU GPL. L’utilisation de R présente plusieurs avantages : c’est un logiciel multiplateforme, qui fonctionne aussi bien sur des sytèmes Linux, Mac OS X ou Windows. c’est un logiciel libre, développé par ses utilisateurs et utilisatrices, diffusable et modifiable par tout un chacun. c’est un logiciel gratuit. c’est un logiciel très puissant, dont les fonctionnalités de base peuvent être étendues à l’aide d’extensions développées par la communauté. Il en existe plusieurs milliers. c’est un logiciel dont le développement est très actif et dont la communauté d’utilisateurs et d’utilisatrices et l’usage ne cessent de grandir. c’est un logiciel avec d’excellentes capacités graphiques. Comme rien n’est parfait, on peut également trouver quelques inconvénients : le logiciel, la documentation de référence et les principales ressources sont en anglais. Il est toutefois parfaitement possible d’utiliser R sans spécialement maîtriser cette langue et il existe de plus en plus de ressources francophones. R n’est pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à l’aide de scripts (des petits programmes) édités et exécutés au fur et à mesure de l’analyse. en tant que langage de programmation, R a la réputation d’être difficile d’accès, notamment pour ceux n’ayant jamais programmé auparavant. Ce document ne demande aucun prérequis en informatique ou en programmation. Juste un peu de motivation pour l’apprentissage du langage et, si possible, des données intéressantes sur lesquelles appliquer les connaissances acquises. L’aspect langage de programmation et la difficulté qui en découle peuvent sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite d’instructions effectuant les différentes opérations d’une analyse) présente cependant de nombreux avantages : le script garde par ordre chronologique l’ensemble des étapes d’une analyse, de l’importation des données à leur analyse en passant par les manipulations et les recodages. on peut à tout moment revenir en arrière et modifier ce qui a été fait. il est très rapide de réexécuter une suite d’opérations complexes. on peut très facilement mettre à jour les résultats en cas de modification des données sources. le script garantit, sous certaines conditions, la reproductibilité des résultats obtenus. 1.2 À propos de RStudio RStudio n’est pas à proprement parler une interface graphique pour R, il s’agit plutôt d’un environnement de développement intégré, qui propose des outils et facilite l’écriture de scripts et l’usage de R au quotidien. C’est une interface bien supérieure à celles fournies par défaut lorsqu’on installe R sous Windows ou sous Mac1. Pour paraphraser Hadrien Commenges, il n’y a pas d’obligation à utiliser RStudio, mais il y a une obligation à ne pas utiliser les interfaces de R par défaut. RStudio est également un logiciel libre et gratuit. Une version payante existe, mais elle ne propose pas de fonctionnalités indispensables. 1.3 À propos du tidyverse Le tidyverse est un ensemble d’extensions pour R (code développé par la communauté permettant de rajouter des fonctionnalités à R) construites autour d’une philosophie commune et conçues pour fonctionner ensemble. Elles facilitent l’utilisation de R dans les domaines les plus courants : manipulation des données, recodages, production de graphiques, etc. La deuxième partie de ce document est entièrement basée sur les extensions du tidyverse, qui est présenté plus en détail chapitre 6. 1.4 Structure du document Ce document est composé de trois grandes parties : Une Introduction à R, qui présente les bases du langage R et de l’interface RStudio Une Introduction au tidyverse qui présente cet ensemble d’extensions pour la visualisation, la manipulation des données et l’export de résultats Une partie Aller plus loin qui présente comment créer ses propres fonctions et introduit des notions de programmation plus avancées Les personnes déjà familières avec R “de base” peuvent sauter toute la partie Introduction à R et passer directement à l’Introduction au tidyverse. 1.5 Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes 2 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Sous Linux R n’est fourni que comme un outil en ligne de commande.↩︎ Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎ "],["02-prise_en_main.html", "Partie 2 Prise en main 2.1 La console 2.2 Objets 2.3 Fonctions 2.4 Regrouper ses commandes dans des scripts 2.5 Installer et charger des extensions (packages) 2.6 Exercices", " Partie 2 Prise en main Une fois R et RStudio installés sur votre machine, nous n’allons pas lancer R mais plutôt RStudio. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts (voir section 1.2). 2.1 La console 2.1.1 L’invite de commandes Au premier lancement de RStudio, l’écran principal est découpé en trois grandes zones : Interface de Rstudio La zone de gauche se nomme Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui. La Console doit normalement afficher un texte de bienvenue ressemblant à ceci : R version 4.1.1 (2021-08-10) -- &quot;Kick Things&quot; Copyright (C) 2021 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R est un logiciel libre livré sans AUCUNE GARANTIE. Vous pouvez le redistribuer sous certaines conditions. Tapez &#39;license()&#39; ou &#39;licence()&#39; pour plus de détails. Natural language support but running in an English locale R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Tapez &#39;demo()&#39; pour des démonstrations, &#39;help()&#39; pour l&#39;aide en ligne ou &#39;help.start()&#39; pour obtenir l&#39;aide au format HTML. Tapez &#39;q()&#39; pour quitter R. suivi d’une ligne commençant par le caractère &gt; et sur laquelle devrait se trouver votre curseur. Cette ligne est appelée l’invite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine commande. Nous pouvons tout de suite lui fournir une première commande, en saisissant le texte suivant puis en appuyant sur Entrée : 2 + 2 #&gt; [1] 4 R nous répond immédiatement, et nous pouvons constater avec soulagement qu’il sait faire des additions à un chiffre3. On peut donc continuer avec d’autres opérations : 5 - 7 #&gt; [1] -2 4 * 12 #&gt; [1] 48 -10 / 3 #&gt; [1] -3.333333 5^2 #&gt; [1] 25 Cette dernière opération utilise le symbole ^ qui représente l’opération puissance. 5^2 signifie donc “5 au carré”, soit 25. 2.1.2 Précisions concernant la saisie des commandes Lorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code. 10+2 10 + 2 10 + 2 Quand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut et vers le bas pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée. Enfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe + : 4 * + Cela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap. 2.2 Objets 2.2.1 Objets simples Faire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller. Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche. Prenons tout de suite un exemple : x &lt;- 2 Cette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”. Si on exécute une commande comportant juste le nom d’un objet, R affiche son contenu : x #&gt; [1] 2 On voit donc que notre objet x contient bien la valeur 2. On peut évidemment réutiliser cet objet dans d’autres opérations. R le remplacera alors par sa valeur : x + 4 #&gt; [1] 6 On peut créer autant d’objets qu’on le souhaite. x &lt;- 2 y &lt;- 5 resultat &lt;- x + y resultat #&gt; [1] 7 Les noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat. De manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets. De même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite). Quand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire. x &lt;- 2 x &lt;- 5 x #&gt; [1] 5 De la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche : x &lt;- 1 y &lt;- 3 x &lt;- y x #&gt; [1] 3 ## Si on modifie y, cela ne modifie pas x y &lt;- 4 x #&gt; [1] 3 On le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") : chien &lt;- &quot;Chihuahua&quot; chien #&gt; [1] &quot;Chihuahua&quot; 2.2.2 Vecteurs Imaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien : taille1 &lt;- 156 taille2 &lt;- 164 taille3 &lt;- 197 taille4 &lt;- 147 taille5 &lt;- 173 (taille1 + taille2 + taille3 + taille4 + taille5) / 5 #&gt; [1] 167.4 Cette manière de faire n’est évidemment pas pratique du tout. On va plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante : tailles &lt;- c(156, 164, 197, 147, 173) Si on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies : tailles #&gt; [1] 156 164 197 147 173 Un vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre. L’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire : tailles_m &lt;- tailles / 100 tailles_m #&gt; [1] 1.56 1.64 1.97 1.47 1.73 Cela fonctionne pour toutes les opérations de base : tailles + 10 #&gt; [1] 166 174 207 157 183 tailles^2 #&gt; [1] 24336 26896 38809 21609 29929 Imaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut alors créer un deuxième vecteur : poids &lt;- c(45, 59, 110, 44, 88) On peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré : imc &lt;- poids / (tailles / 100) ^ 2 imc #&gt; [1] 18.49112 21.93635 28.34394 20.36189 29.40292 Un vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) diplome #&gt; [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; L’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R : x &lt;- 1:10 x #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Enfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré. Par exemple : diplome[2] #&gt; [1] &quot;Bac&quot; Cette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur. Dernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme : [1] 294 425 339 914 114 896 716 648 915 587 181 926 489 [14] 848 583 182 662 888 417 133 146 322 400 698 506 944 [27] 237 324 333 443 487 658 793 288 897 588 697 439 697 [40] 914 694 126 969 744 927 337 439 226 704 635 On remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc. Ceci explique le [1] qu’on obtient quand on affiche un simple nombre4 : [1] 4 2.3 Fonctions 2.3.1 Principe Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard. Pour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions. Formellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat. Prenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière : length(tailles) #&gt; [1] 5 Ici, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre. Autre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres : min(tailles) #&gt; [1] 147 max(tailles) #&gt; [1] 197 La fonction mean calcule et retourne la moyenne d’un vecteur de nombres : mean(tailles) #&gt; [1] 167.4 La fonction sum retourne la somme de tous les éléments du vecteur : sum(tailles) #&gt; [1] 837 Jusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum : range(tailles) #&gt; [1] 147 197 Ou encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) unique(diplome) #&gt; [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;Bac+3&quot; 2.3.2 Arguments Une fonction peut prendre plusieurs arguments, dans ce cas on les indique toujours entre parenthèses, séparés par des virgules. On a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur5 : tailles &lt;- c(156, 164, 197, 181, 173) Ici, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs. Supposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA : tailles &lt;- c(156, 164, 197, NA, 173) tailles #&gt; [1] 156 164 197 NA 173 NA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc. Si je calcule maintenant la taille moyenne à l’aide de la fonction mean, j’obtiens : mean(tailles) #&gt; [1] NA En effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Il considère alors que cette moyenne est elle-même “non disponible” et renvoie donc comme résultat NA. On peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai) : mean(tailles, na.rm = TRUE) #&gt; [1] 172.5 Positionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul. Si on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes : mean(tailles) #&gt; [1] NA mean(tailles, na.rm = FALSE) #&gt; [1] NA Lorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé. 2.3.3 Aide sur une fonction Il est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help : help(&quot;mean&quot;) On peut aussi utiliser le raccourci ?mean. Ces deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée. Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. 2.4 Regrouper ses commandes dans des scripts Jusqu’ici on a utilisé R de manière “interactive”, en saisissant des commandes directement dans la console. Ça n’est cependant pas la manière dont on va utiliser R au quotidien, pour une raison simple : lorsque R redémarre, tout ce qui a été effectué dans la console est perdu. Plutôt que de saisir nos commandes dans la console, on va donc les regrouper dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” les données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script. Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save. Un script est un fichier texte brut, qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne (comme on pouvait s’y attendre). Pour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup. Au final, un script pourra ressembler à quelque chose comme ça : tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) mean(tailles) mean(poids) imc &lt;- poids / (tailles / 100) ^ 2 min(imc) max(imc) 2.4.1 Commentaires Les commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption. Pour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jussqu’à la fin de la ligne. On peut donc documenter le script précédent : # Saisie des tailles et poids des enquêtés tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) # Calcul des tailles et poids moyens mean(tailles) mean(poids) # Calcul de l&#39;IMC (poids en kilo divisé par les tailles en mètre au carré) imc &lt;- poids / (tailles / 100) ^ 2 # Valeurs extrêmes de l&#39;IMC min(imc) max(imc) 2.5 Installer et charger des extensions (packages) R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). Pour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Installer une extension Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install. Installation d’une extension On peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande : install.packages(&quot;questionr&quot;) Installer une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC. Une fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante : library(questionr) Ainsi, bien souvent, on regroupe en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme : library(readxl) library(ggplot2) library(questionr) Si vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante. 2.6 Exercices Exercice 1 Construire le vecteur x suivant : #&gt; [1] 120 134 256 12 x &lt;- c(120, 134, 256, 12) Utiliser ce vecteur x pour générer les deux vecteurs suivants : #&gt; [1] 220 234 356 112 #&gt; [1] 240 268 512 24 x + 100 x * 2 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. revenu_total &lt;- conjoint1 + conjoint2 revenu_total / nb_personnes Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) range(conjoint1) Recommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) range(conjoint1, na.rm = TRUE) Exercice 4 Les deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes sur la ville de Lyon, pour chaque mois de l’année, entre 1981 et 2010 : temperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4) precipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2) Calculer la température moyenne sur l’année. Calculer la quantité totale de précipitations sur l’année. mean(temperature) sum(precipitations) À quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire. cumsum(precipitations) #&gt; [1] 47.2 91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9 Même question pour : diff(temperature) #&gt; [1] 1.4 3.6 3.0 4.4 3.6 2.8 -0.6 -4.0 -4.2 -5.8 -3.2 cumsum(precipitations) correspond à la somme cumulée des précipitations sur l’année. Par exemple, la 6e valeur du vecteur résultat correspond au total de précipitations de janvier à juin. diff(temperature) correspond à la différence de température d’un mois sur l’autre. Par exemple, la 2e valeur de ce vecteur correspond à l’écart de température entre le mois de février et le mois de janvier. Exercice 5 On a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs : maths &lt;- c(12, 16, 8, 18, 6, 10) anglais &lt;- c(14, 9, 13, 15, 17, 11) sport &lt;- c(18, 11, 14, 10, 8, 12) Calculer la moyenne des élèves de la classe en anglais. Calculer la moyenne générale de chaque élève. mean(anglais) (maths + anglais + sport) / 3 Essayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) : pmin(maths, anglais, sport) #&gt; [1] 12 9 8 10 6 10 pmax(maths, anglais, sport) #&gt; [1] 18 16 14 18 17 12 pmin et pmax renvoient les minimum et maximum “parallèles” des trois vecteurs passés en argument. Ainsi, pmin renvoie pour chaque élève la note minimale dans les trois matières, et pmax la note maximale. On peut ignorer pour le moment la présence du [1] en début de ligne.↩︎ Et permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎ c est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎ "],["03-premier_travail.html", "Partie 3 Premier travail avec des données 3.1 Jeu de données d’exemple 3.2 Tableau de données (data frame) 3.3 Analyse univariée 3.4 Exercices", " Partie 3 Premier travail avec des données 3.1 Jeu de données d’exemple Dans cette partie nous allons (enfin) travailler sur des “vraies” données, et utiliser un jeu de données présent dans l’extension questionr. Nous devons donc avant toute chose installer cette extension. Pour installer ce package, deux possibilités : Dans l’onglet Packages de la zone de l’écran en bas à droite, cliquez sur le bouton Install. Dans le dialogue qui s’ouvre, entrez “questionr” dans le champ Packages puis cliquez sur Install. Saisissez directement la commande suivante dans la console : install.packages(\"questionr\") Dans les deux cas, tout un tas de messages devraient s’afficher dans la console. Attendez que l’invite de commandes &gt; apparaisse à nouveau. Pour plus d’informations sur les extensions et leur installation, voir la section 2.5. Le jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour une description plus complète et une liste des variables, voir la section A.3.2.2. Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) : library(questionr) L’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension. Nous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data : data(hdv2003) Cette commande ne renvoie aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003 : Onglet Environment Cet objet est d’un type nouveau : il s’agit d’un tableau de données. 3.2 Tableau de données (data frame) Un data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel. Si on se contente d’exécuter le nom de notre tableau de données : hdv2003 R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile. Une autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment : View icon Ou d’utiliser la fonction View : View(hdv2003) Dans les deux cas votre tableau devrait s’afficher dans RStudio avec une interface de type tableur : Interface “View” Il est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille6. Sous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine. Un data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire : d &lt;- hdv2003 ce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite. Pour résumer, comme nous avons désormais décidé de saisir nos commandes dans un script et non plus directement dans la console, les premières lignes de notre fichier de travail sur les données de l’enquête Histoire de vie pourraient donc ressembler à ceci : ## Chargement des extensions nécessaires library(questionr) ## Jeu de données hdv2003 data(hdv2003) d &lt;- hdv2003 3.2.1 Structure du tableau Un tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau : nrow(d) #&gt; [1] 2000 ncol(d) #&gt; [1] 20 La fonction dim renvoie ses dimensions, donc les deux nombres précédents : dim(d) #&gt; [1] 2000 20 La fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables : names(d) #&gt; [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; #&gt; [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; #&gt; [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; #&gt; [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; #&gt; [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; Enfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type 7 et affiche les premières valeurs : str(d) #&gt; &#39;data.frame&#39;: 2000 obs. of 20 variables: #&gt; $ id : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ age : int 28 23 59 34 71 35 60 47 20 28 ... #&gt; $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 2 2 1 1 2 2 2 1 2 1 ... #&gt; $ nivetud : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8 3 6 3 6 NA 7 ... #&gt; $ poids : num 2634 9738 3994 5732 4329 ... #&gt; $ occup : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3 1 1 4 1 6 1 3 1 ... #&gt; $ qualif : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 6 NA 3 3 6 6 2 2 NA 7 ... #&gt; $ freres.soeurs: int 8 2 2 1 0 5 1 5 4 2 ... #&gt; $ clso : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1 2 2 1 2 1 2 1 2 ... #&gt; $ relig : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4 4 3 1 4 3 4 3 2 ... #&gt; $ trav.imp : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA 2 3 NA 1 NA 4 NA 3 ... #&gt; $ trav.satisf : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA 3 1 NA 3 NA 2 NA 1 ... #&gt; $ hard.rock : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ lecture.bd : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 2 2 1 1 ... #&gt; $ cuisine : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 2 1 1 2 2 1 1 ... #&gt; $ bricol : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 2 1 1 1 2 1 1 ... #&gt; $ cinema : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 2 1 2 1 1 2 2 ... #&gt; $ sport : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 2 1 2 1 1 1 2 ... #&gt; $ heures.tv : num 0 1 0 2 3 2 2.9 1 2 2 ... Sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment : Structure d’un objet 3.2.2 Accéder aux variables d’un tableau Une opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape : d$sexe #&gt; [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme Homme #&gt; [13] Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme Femme Femme #&gt; [25] Femme Homme Femme Homme Homme Homme Homme Homme Homme Homme Femme Femme #&gt; [37] Homme Femme Femme Homme Femme Homme Homme Femme Femme Homme Femme Femme #&gt; [49] Femme Femme Homme Femme Homme Femme Homme Femme Femme Femme Homme Femme #&gt; [61] Femme Homme Homme Homme Homme Femme Homme Homme Femme Femme Homme Homme #&gt; [73] Femme Femme Femme Femme Homme Femme Femme Femme Femme Femme Femme Homme #&gt; [85] Homme Femme Homme Homme Homme Homme Homme Femme Homme Femme Femme Femme #&gt; [97] Homme Homme Femme Femme Femme Homme Femme Homme Homme Femme Femme Femme #&gt; [109] Femme Homme Homme Homme Homme Homme Femme Homme Homme Femme Homme Homme #&gt; [121] Femme Femme Femme Homme Femme Femme Homme Femme Femme Homme Femme Homme #&gt; [133] Femme Femme Femme Homme Homme Homme Homme Homme Homme Homme Homme Femme #&gt; [145] Homme Homme Homme Femme Femme Femme Homme Femme Femme Femme Femme Homme #&gt; [157] Femme Homme Homme Homme Femme Homme Femme Homme Femme Homme Homme Femme #&gt; [169] Femme Femme Homme Femme Homme Femme Femme Femme Homme Homme Homme Femme #&gt; [181] Homme Femme Femme Homme Homme Femme Femme Femme Femme Femme Homme Homme #&gt; [193] Femme Homme Homme Femme Homme Femme Homme Femme #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] #&gt; Levels: Homme Femme R va nous afficher l’ensemble des valeurs de notre variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment. La fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères. Si on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail : head(d$age) #&gt; [1] 28 23 59 34 71 35 tail(d$age, 10) #&gt; [1] 52 42 50 41 46 45 46 24 24 66 Le deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher. 3.2.3 Créer une nouvelle variable On peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur. Par exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé : head(d$heures.tv, 10) #&gt; [1] 0.0 1.0 0.0 2.0 3.0 2.0 2.9 1.0 2.0 2.0 On peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée mais en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante : d$minutes.tv &lt;- d$heures.tv * 60 On peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau : head(d$minutes.tv) #&gt; [1] 0 60 0 120 180 120 3.3 Analyse univariée On a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $. Si on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.). 3.3.1 Analyser une variable quantitative Une variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv). 3.3.1.1 Indicateurs de centralité Caractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent. Pour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range : min(d$age) #&gt; [1] 18 max(d$age) #&gt; [1] 97 range(d$age) #&gt; [1] 18 97 On peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean : mean(d$age) #&gt; [1] 48.157 Il existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median : median(d$age) #&gt; [1] 48 Une différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2013, le salaire net moyen des salariés à temps plein en France était de 2202 euros, tandis que le salaire net médian n’était que de 1772 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut. 3.3.1.2 Indicateurs de dispersion Les indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées. L’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations : max(d$age) - min(d$age) #&gt; [1] 79 Les indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation) : var(d$age) #&gt; [1] 287.0249 sd(d$age) #&gt; [1] 16.94181 Plus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées. Une autre manière de mesurer la dispersion est de calculer les quartiles : le premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus le deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane) le troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus On peut les calculer avec la fonction quantile : ## Premier quartile quantile(d$age, prob = 0.25) #&gt; 25% #&gt; 35 ## Troisième quartile quantile(d$age, prob = 0.75) #&gt; 75% #&gt; 60 quantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc. Notons enfin que la fonction summary permet d’obtenir d’un coup plusieurs indicateurs classiques : summary(d$age) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 18.00 35.00 48.00 48.16 60.00 97.00 3.3.1.3 Représentation graphique L’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique. La représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist : hist(d$age) Cette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio. On peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite. hist(d$age, breaks = 10) hist(d$age, breaks = 70) Le choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances. Les arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col8, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. : hist(d$age, col = &quot;skyblue&quot;, main = &quot;Répartition des âges des enquêtés&quot;, xlab = &quot;Âge&quot;, ylab = &quot;Effectif&quot;) La fonction hist fait partie des fonctions graphique de base de R. On verra plus en détail d’autres fonctions graphiques dans la partie 8 de ce document, consacrée à l’extension ggplot2, qui fait partie du tidyverse et qui permet la production et la personnalisation de graphiques complexes. 3.3.2 Analyser une variable qualitative Une variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)… À noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs. 3.3.2.1 Tri à plat L’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table : table(d$sexe) #&gt; #&gt; Homme Femme #&gt; 899 1101 Ce tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes. table(d$qualif) #&gt; #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 203 292 86 #&gt; Profession intermediaire Cadre Employe #&gt; 160 260 594 #&gt; Autre #&gt; 58 Un tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif. On peut donc faire : tab &lt;- table(d$qualif) sort(tab) #&gt; #&gt; Autre Technicien Profession intermediaire #&gt; 58 86 160 #&gt; Ouvrier specialise Cadre Ouvrier qualifie #&gt; 203 260 292 #&gt; Employe #&gt; 594 Attention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = “always”, soit : table(d$qualif, useNA = “always”). À noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles : summary(d$qualif) #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 203 292 86 #&gt; Profession intermediaire Cadre Employe #&gt; 160 260 594 #&gt; Autre NA&#39;s #&gt; 58 347 Par défaut ces tris à plat sont en effectifs et ne sont donc pas toujours très lisibles, notamment quand on a des effectifs importants. On leur rajoute donc en général la répartition en pourcentages. Pour cela, nous allons utiliser la fonction freq de l’extension questionr, qui devra donc avoir précédemment été chargée avec library(questionr) : ## À rajouter en haut de script et à exécuter library(questionr) On peut alors utiliser la fonction : freq(d$qualif) #&gt; n % val% #&gt; Ouvrier specialise 203 10.2 12.3 #&gt; Ouvrier qualifie 292 14.6 17.7 #&gt; Technicien 86 4.3 5.2 #&gt; Profession intermediaire 160 8.0 9.7 #&gt; Cadre 260 13.0 15.7 #&gt; Employe 594 29.7 35.9 #&gt; Autre 58 2.9 3.5 #&gt; NA 347 17.3 NA La colonne n représente les effectifs de chaque catégorie, la colonne % le pourcentage, et la colonne val% le pourcentage calculé sur les valeurs valides, donc en excluant les NA. Une ligne a également été rajoutée pour indiquer le nombre et la proportion de NA. freq accepte un certain nombre d’arguments pour personnaliser son affichage. Par exemple : valid indique si on souhaite ou non afficher les pourcentages sur les valeurs valides cum indique si on souhaite ou non afficher les pourcentages cumulés total permet d’ajouter une ligne avec les effectifs totaux sort permet de trier le tableau par fréquence croissante (sort=\"inc\") ou décroissante (sort=\"dec\"). freq(d$qualif, valid = FALSE, total = TRUE, sort = &quot;dec&quot;) #&gt; n % #&gt; Employe 594 29.7 #&gt; Ouvrier qualifie 292 14.6 #&gt; Cadre 260 13.0 #&gt; Ouvrier specialise 203 10.2 #&gt; Profession intermediaire 160 8.0 #&gt; Technicien 86 4.3 #&gt; Autre 58 2.9 #&gt; NA 347 17.3 #&gt; Total 2000 100.0 3.3.2.2 Représentations graphiques On peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes : tab &lt;- table(d$clso) barplot(tab) On peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique : barplot(sort(tab)) Une alternative au graphique en barres est le diagramme de Cleveland, qu’on peut obtenir avec la fonction dotchart. Celle-ci s’applique elle aussi au tri à plat de la variable calculé avec table. dotchart(table(d$qualif)) Là aussi, pour améliorer la lisibilité du graphique il est préférable de trier le tri à plat de la variable avant de le représenter : dotchart(sort(table(d$qualif))) 3.4 Exercices Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr charger le jeu de données nommé hdv2003 copier le jeu de données dans un nouvel objet nommé df afficher les dimensions et la liste des variables de df library(questionr) data(hdv2003) df &lt;- hdv2003 dim(df) names(df) Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. summary(df$heures.tv) sd(df$heures.tv) hist(df$heures.tv, breaks = 10) Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. table(df$trav.imp) Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ? freq(df$trav.imp) Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres. tab &lt;- sort(table(df$trav.imp)) barplot(tab) Utilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato. barplot(tab, col = &quot;tomato&quot;) Tapez colors() dans la console pour afficher l’ensemble des noms de couleurs disponibles dans R. Testez chaque couleur une à une pour trouver votre couleur préférée. C’est une blague, hein ! Cela dit moccasin ou palevioletred sont pas mal, si vous voulez essayer :-) La seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎ Les différents types de variables seront décrits plus en détail dans le chapitre 9 sur les recodages.↩︎ Les différentes manières de spécifier des couleurs sont indiquées dans l’encadré de la section 8.7.3.↩︎ "],["04-bivarie.html", "Partie 4 Analyse bivariée 4.1 Croisement de deux variables qualitatives 4.2 Croisement d’une variable quantitative et d’une variable qualitative 4.3 Croisement de deux variables quantitatives 4.4 Exercices", " Partie 4 Analyse bivariée Faire une analyse bivariée, c’est étudier la relation entre deux variables : sont-elles liées ? les valeurs de l’une influencent-elles les valeurs de l’autre ? ou sont-elles au contraire indépendantes ? À noter qu’on va parler ici d’influence ou de lien, mais pas de relation de cause à effet : les outils présentés permettent de visualiser ou de déterminer une relation, mais des liens de causalité proprement dit sont plus difficiles à mettre en évidence. Il faut en effet vérifier que c’est bien telle variable qui influence telle autre et pas l’inverse, qu’il n’y a pas de “variable cachée”, etc. Là encore, le type d’analyse ou de visualisation est déterminé par la nature qualitative ou quantitative des deux variables. 4.1 Croisement de deux variables qualitatives 4.1.1 Tableaux croisés On va continuer à travailler avec le jeu de données tiré de l’enquête Histoire de vie inclus dans l’extension questionr. On commence donc par charger l’extension, le jeu de données, et à le renommer en un nom plus court pour gagner un peu de temps de saisie au clavier : library(questionr) data(hdv2003) d &lt;- hdv2003 Quand on veut croiser deux variables qualitatives, on fait un tableau croisé. Comme pour un tri à plat ceci s’obtient avec la fonction table de R, mais à laquelle on passe cette fois deux variables en argument. Par exemple, si on veut croiser la catégorie socio-professionnelle et le sexe des enquêtés : table(d$qualif, d$sexe) #&gt; #&gt; Homme Femme #&gt; Ouvrier specialise 96 107 #&gt; Ouvrier qualifie 229 63 #&gt; Technicien 66 20 #&gt; Profession intermediaire 88 72 #&gt; Cadre 145 115 #&gt; Employe 96 498 #&gt; Autre 21 37 Pour pouvoir interpréter ce tableau on doit passer du tableau en effectifs au tableau en pourcentages ligne ou colonne. Pour cela, on peut utiliser les fonctions lprop et cprop de l’extension questionr, qu’on applique au tableau croisé précédent. Pour calculer les pourcentages ligne : tab &lt;- table(d$qualif, d$sexe) lprop(tab) #&gt; #&gt; Homme Femme Total #&gt; Ouvrier specialise 47.3 52.7 100.0 #&gt; Ouvrier qualifie 78.4 21.6 100.0 #&gt; Technicien 76.7 23.3 100.0 #&gt; Profession intermediaire 55.0 45.0 100.0 #&gt; Cadre 55.8 44.2 100.0 #&gt; Employe 16.2 83.8 100.0 #&gt; Autre 36.2 63.8 100.0 #&gt; All 44.8 55.2 100.0 Et pour les pourcentages colonne : cprop(tab) #&gt; #&gt; Homme Femme All #&gt; Ouvrier specialise 13.0 11.7 12.3 #&gt; Ouvrier qualifie 30.9 6.9 17.7 #&gt; Technicien 8.9 2.2 5.2 #&gt; Profession intermediaire 11.9 7.9 9.7 #&gt; Cadre 19.6 12.6 15.7 #&gt; Employe 13.0 54.6 35.9 #&gt; Autre 2.8 4.1 3.5 #&gt; Total 100.0 100.0 100.0 Pour savoir si on doit faire des pourcentages ligne ou colonne, on pourra se référer à l’article suivant : http://alain-leger.lescigales.org/textes/lignecolonne.pdf En résumé, quand on fait un tableau croisé, celui-ci est parfaitement symétrique : on peut inverser les lignes et les colonnes, ça ne change pas son interprétation. Par contre, on a toujours en tête un “sens” de lecture dans le sens où on considère que l’une des variables dépend de l’autre. Par exemple, si on croise sexe et type de profession, on dira que le type de profession dépend du sexe, et non l’inverse : le type de profession est alors la variable dépendante (à expliquer), et le sexe la variable indépendante (explicative). Pour faciliter la lecture d’un tableau croisé, il est recommandé de faire les pourcentages sur la variable indépendante. Dans notre exemple, la variable indépendante est le sexe, elle est en colonne, on calcule donc les pourcentages colonnes qui permettent de comparer directement, pour chaque sexe, la répartition des catégories socio-professionnelles. 4.1.2 Test du χ² Comme on travaille sur un échantillon et pas sur une population entière, on peut compléter ce tableau croisé par un test d’indépendance du χ². Celui-ci permet de rejeter l’hypothèse d’indépendance des lignes et des colonnes du tableau, c’est à dire de rejeter l’hypothèse que les écarts à l’indépendance observés seraient uniquement dus au biais d’échantillonnage (au fait qu’on n’a pas interrogé toute notre population). Pour effectuer un test de ce type, on applique la fonction chisq.test au tableau croisé calculé précédemment : chisq.test(tab) #&gt; #&gt; Pearson&#39;s Chi-squared test #&gt; #&gt; data: tab #&gt; X-squared = 387.56, df = 6, p-value &lt; 2.2e-16 Le résultat nous indique trois valeurs : X-squared, la valeur de la statistique du χ² pour notre tableau, c’est-à-dire une “distance” entre notre tableau observé et celui attendu si les deux variables étaient indépendantes. df, le nombre de degrés de libertés du test. p-value, le fameux p, qui indique la probabilité d’obtenir une valeur de la statistique du χ² au moins aussi extrême sous l’hypothèse d’indépendance. Ici, le p est extrêmement petit (la notation &lt; 2.2e-16 indique qu’il est plus petit que la plus petite valeur proche de zéro calculable par R), donc certainement en-dessous du seuil de décision choisi préalablement au test (souvent 5%, soit 0.05). On peut donc rejeter l’hypothèse d’indépendance des lignes et des colonnes du tableau. En complément du test du χ², on peut aussi regarder les résidus de ce test pour affiner la lecture du tableau. Ceux-ci s’obtiennent avec la fonction chisq.residuals de questionr : chisq.residuals(tab) #&gt; #&gt; Homme Femme #&gt; Ouvrier specialise 0.52 -0.47 #&gt; Ouvrier qualifie 8.57 -7.73 #&gt; Technicien 4.42 -3.98 #&gt; Profession intermediaire 1.92 -1.73 #&gt; Cadre 2.64 -2.38 #&gt; Employe -10.43 9.41 #&gt; Autre -0.98 0.88 L’interprétation des résidus est la suivante : si la valeur du résidu pour une case est inférieure à -2, alors il y a une sous-représentation de cette case dans le tableau : les effectifs sont significativement plus faibles que ceux attendus sous l’hypothèse d’indépendance à l’inverse, si le résidu est supérieur à 2, il y a sur-représentatation de cette case si le résidu est compris entre -2 et 2, il n’y a pas d’écart à l’indépendance significatif Les résidus peuvent être une aide utile à l’interprétation, notamment pour des tableaux de grande dimension. 4.1.3 Représentation graphique Il est possible de faire une représentation graphique d’un tableau croisé, par exemple avec la fonction mosaicplot : mosaicplot(tab) On peut améliorer ce graphique en colorant les cases selon les résidus du test du χ² (argument shade = TRUE) et en orientant verticalement les labels de colonnes (argument las = 3) : mosaicplot(tab, las = 3, shade = TRUE) Chaque rectangle de ce graphique représente une case de tableau. Sa largeur correspond au pourcentage des modalités en colonnes (il y’a beaucoup d’employés et d’ouvriers et très peu d’“autres”). Sa hauteur correspond aux pourcentages colonnes : la proportion d’hommes chez les cadres est plus élevée que chez les employés. Enfin, la couleur de la case correspond au résidu du test du χ² correspondant : les cases en rouge sont sous-représentées, les cases en bleu sur-représentées, et les cases blanches sont proches des effectifs attendus sous l’hypothèse d’indépendance. 4.2 Croisement d’une variable quantitative et d’une variable qualitative 4.2.1 Représentation graphique Croiser une variable quantitative et une variable qualitative, c’est essayer de voir si les valeurs de la variable quantitative se répartissent différemment selon la catégorie d’appartenance de la variable qualitative. Pour cela, l’idéal est de commencer par une représentation graphique de type “boîte à moustache” à l’aide de la fonction boxplot. Par exemple, si on veut visualiser la répartition des âges selon la pratique ou non d’un sport, on va utiliser la syntaxe suivante : boxplot(d$age ~ d$sport) Cette syntaxe de boxplot utilise une nouvelle notation de type “formule”. Celle-ci est utilisée notamment pour la spécification des modèles de régression. Ici le ~ peut se lire comme “en fonction de” : on veut représenter le boxplot de l’âge en fonction du sport. Ce qui va nous donner le résultat suivant : L’interprétation d’un boxplot est la suivante : Les bords inférieurs et supérieurs du carré central représentent le premier et le troisième quartile de la variable représentée sur l’axe vertical. On a donc 50% de nos observations dans cet intervalle. Le trait horizontal dans le carré représente la médiane. Enfin, des “moustaches” s’étendent de chaque côté du carré, jusqu’aux valeurs minimales et maximales, avec une exception : si des valeurs sont éloignées du carré de plus de 1,5 fois l’écart interquartile (la hauteur du carré), alors on les représente sous forme de points (symbolisant des valeurs considérées comme “extrêmes”). Dans le graphique ci-dessus, on voit que ceux qui ont pratiqué un sport au cours des douze derniers mois ont l’air d’être sensiblement plus jeunes que les autres. 4.2.2 Calculs d’indicateurs On peut aussi vouloir comparer certains indicateurs (moyenne, médiane) d’une variable quantitative selon les modalités d’une variable qualitative. Si on reprend l’exemple précédent, on peut calculer la moyenne d’âge pour ceux qui pratiquent un sport et pour ceux qui n’en pratiquent pas. Une première méthode pour cela est d’extraire de notre population autant de sous-populations qu’il y a de modalités dans la variable qualitative. On peut le faire notamment avec la fonction filter du package dplyr 9. On commence par charger dplyr (en l’ayant préalablement installé) : library(dplyr) Puis on applique filter pour créer deux sous-populations, stockées dans deux nouveaux tableaux de données : d_sport &lt;- filter(d, sport == &quot;Oui&quot;) d_nonsport &lt;- filter(d, sport == &quot;Non&quot;) On peut ensuite utiliser ces deux nouveaux tableaux de données comme on en a l’habitude, et calculer les deux moyennes d’âge : mean(d_sport$age) #&gt; [1] 40.92531 mean(d_nonsport$age) #&gt; [1] 52.25137 Une autre possibilité est d’utiliser la fonction tapply, qui prend en paramètre une variable quantitative, une variable qualitative et une fonction, puis applique automatiquement la fonction aux valeurs de la variables quantitative pour chaque niveau de la variable qualitative : tapply(d$age, d$sport, mean) #&gt; Non Oui #&gt; 52.25137 40.92531 On verra dans la partie 10 d’autres méthodes basées sur dplyr pour effectuer ce genre d’opérations. 4.2.3 Tests statistiques Un des tests les plus connus est le test du t de Student, qui permet de tester si les moyennes de deux sous-populations peuvent être considérées comme différentes (compte tenu des fluctuations aléatoires provenant du biais d’échantillonnage). Un test t s’effectue à l’aide de la fonction t.test. Ainsi, on peut tester l’hypothèse d’égalité des âges moyens selon la pratique ou non d’un sport avec la commande suivante : t.test(d$age ~ d$sport) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: d$age by d$sport #&gt; t = 15.503, df = 1600.4, p-value &lt; 2.2e-16 #&gt; alternative hypothesis: true difference in means between group Non and group Oui is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 9.893117 12.759002 #&gt; sample estimates: #&gt; mean in group Non mean in group Oui #&gt; 52.25137 40.92531 Le résultat du test est significatif, avec un p extrêmement petit, et on peut rejeter l’hypothèse nulle d’égalité des moyennes des deux groupes. Le test nous donne même un intervalle de confiance à 95% pour la valeur de la différence entre les deux moyennes. Nous sommes cependant allés un peu vite, et avons négligé le fait que le test t s’applique normalement à des distributions normales. On peut se faire un premier aperçu visuel de cette normalité en traçant les histogrammes des deux répartitions : hist(d_sport$age) hist(d_nonsport$age) Si l’âge dans le groupe des non sportifs se rapproche d’une distribution normale, celui des sportifs en semble assez éloigné, notamment du fait de la limite d’âge à 18 ans imposée par construction de l’enquête. On peut tester cette normalité à l’aide du test de Shapiro-Wilk et de la fonction shapiro.test : shapiro.test(d_sport$age) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: d_sport$age #&gt; W = 0.96203, p-value = 9.734e-13 shapiro.test(d_nonsport$age) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: d_nonsport$age #&gt; W = 0.98844, p-value = 1.654e-08 Le test est significatif dans les deux cas et rejette l’hypothèse d’une normalité des deux distributions. Dans ce cas on peut faire appel à un test non-paramétrique, qui ne fait donc pas d’hypothèses sur les lois de distribution des variables testées, en l’occurrence le test des rangs de Wilcoxon, à l’aide de la fonction wilcox.test : wilcox.test(d$age ~ d$sport) #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: d$age by d$sport #&gt; W = 640577, p-value &lt; 2.2e-16 #&gt; alternative hypothesis: true location shift is not equal to 0 La valeur p étant à nouveau extrêmement petite, on peut rejeter l’hypothèse d’indépendance et considérer que les distributions des âges dans les deux sous-populations sont différentes. 4.3 Croisement de deux variables quantitatives Le jeu de données hdv2003 comportant assez peu de variables quantitatives, on va s’intéresser maintenant à un autre jeu de données comportant des informations du recensement de la population de 2012. On le charge avec : data(rp2012) Un nouveau tableau de données rp2012 devrait apparaître dans votre environnement. Celui-ci comprend les 5170 communes de France métropolitaine de plus de 2000 habitants, et une soixantaine de variables telles que le département, la population, le taux de chômage, etc. Pour une description plus complète et une liste des variables, voir section A.3.2.3. 4.3.1 Représentation graphique Quand on croise deux variables quantitatives, l’idéal est de faire une représentation graphique sous forme de nuage de points à l’aide de la fonction plot. On va représenter le croisement entre le pourcentage de cadres et le pourcentage de propriétaires dans la commune : plot(rp2012$cadres, rp2012$proprio) Une représentation graphique est l’idéal pour visualiser l’existence d’un lien entre les deux variables. Voici quelques exemples d’interprétation : Dans ce premier graphique généré sur nos données, il semble difficile de mettre en évidence une relation de dépendance. Si par contre on croise le pourcentage de cadres et celui de diplômés du supérieur, on obtient une belle relation de dépendance linéaire. plot(rp2012$cadres, rp2012$dipl_sup) 4.3.2 Calcul d’indicateurs En plus d’une représentation graphique, on peut calculer certains indicateurs permettant de mesurer le degré d’association de deux variables quantitatives. 4.3.2.1 Corrélation linéaire (Pearson) La corrélation est une mesure du lien d’association linéaire entre deux variables quantitatives. Sa valeur varie entre -1 et 1. Si la corrélation vaut -1, il s’agit d’une association linéaire négative parfaite. Si elle vaut 1, il s’agit d’une association linéaire positive parfaite. Si elle vaut 0, il n’y a aucune association linéaire entre les variables. On la calcule dans R à l’aide de la fonction cor. Ainsi la corrélation entre le pourcentage de cadres et celui de diplômés du supérieur vaut : cor(rp2012$cadres, rp2012$dipl_sup) #&gt; [1] 0.9371629 Ce qui est extrêmement fort. Il y a donc un lien linéaire et positif entre les deux variables (quand la valeur de l’une augmente, la valeur de l’autre augmente également). À l’inverse, la corrélation entre le pourcentage de cadres et le pourcentage de propriétaires vaut : cor(rp2012$cadres, rp2012$proprio) #&gt; [1] 0.1622786 Ce qui indique, pour nos données, une absence de liaison linéaire entre les deux variables. 4.3.2.2 Corrélation des rangs (Spearman) Le coefficient de corrélation de Pearson ci-dessus fait une hypothèse forte sur les données : elles doivent être liées par une association linéaire. Quand ça n’est pas le cas mais qu’on est en présence d’une association monotone, on peut utiliser un autre coefficient, le coefficient de corrélation des rangs de Spearman. Plutôt que de se baser sur les valeurs des variables, cette corrélation va se baser sur leurs rangs, c’est-à-dire sur leur position parmi les différentes valeurs prises par les variables. Ainsi, si la valeur la plus basse de la première variable est associée à la valeur la plus basse de la deuxième, et ainsi de suite jusqu’à la valeur la plus haute, on obtiendra une corrélation de 1. Si la valeur la plus forte de la première variable est associée à la valeur la plus faible de la seconde, et ainsi de suite, et que la valeur la plus faible de la première est associée à la plus forte de la deuxième, on obtiendra une corrélation de -1. Si les rangs sont “mélangés”, sans rapports entre eux, on obtiendra une corrélation autour de 0. La corrélation des rangs a aussi pour avantage d’être moins sensibles aux valeurs extrêmes ou aux points isolés. On dit qu’elle est plus “robuste”. Pour calculer une corrélation de Spearman, on utilise la fonction cor mais avec l’argument method = \"spearman\" : cor(rp2012$cadres, rp2012$dipl_sup, method = &quot;spearman&quot;) #&gt; [1] 0.9036273 4.3.3 Régression linéaire Quand on est en présence d’une association linéaire entre deux variables, on peut vouloir faire la régression linéaire d’une des variables sur l’autres. Une régression linéaire simple se fait à l’aide de la fonction lm : lm(rp2012$cadres ~ rp2012$dipl_sup) #&gt; #&gt; Call: #&gt; lm(formula = rp2012$cadres ~ rp2012$dipl_sup) #&gt; #&gt; Coefficients: #&gt; (Intercept) rp2012$dipl_sup #&gt; 0.9217 1.0816 On retrouve avec lm la syntaxe “formule” déjà rencontrée avec boxplot. Elle permet ici de spécifier des modèles de régression : la variable dépendante se place à gauche du ~, et la variable indépendante à droite. Si on souhaite faire une régression multiple avec plusieurs variables indépendantes, on aura une formule du type dep ~ indep1 + indep2. Il est également possible de spécifier des termes plus complexes, des interactions, etc. lm nous renvoie par défaut les coefficients de la droite de régression : l’ordonnée à l’origine (Intercept) vaut 0.92 le coefficient associé à dipl_sup vaut 1.08 Pour des résultats plus détaillés, on peut stocker le résultat de la régression dans un objet et utiliser la fonction summary : reg &lt;- lm(rp2012$cadres ~ rp2012$dipl_sup) summary(reg) #&gt; #&gt; Call: #&gt; lm(formula = rp2012$cadres ~ rp2012$dipl_sup) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -33.218 -1.606 -0.172 1.491 13.001 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 0.921661 0.071814 12.83 &lt;2e-16 *** #&gt; rp2012$dipl_sup 1.081636 0.005601 193.10 &lt;2e-16 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 2.701 on 5168 degrees of freedom #&gt; Multiple R-squared: 0.8783, Adjusted R-squared: 0.8783 #&gt; F-statistic: 3.729e+04 on 1 and 5168 DF, p-value: &lt; 2.2e-16 Ces résultats montrent notamment que les coefficients sont significativement différents de 0. La part de cadres augmente donc bien avec celle de diplômés du supérieur. On peut enfin représenter la droite de régression sur notre nuage de points à l’aide de la fonction abline : plot(rp2012$dipl_sup, rp2012$cadres) abline(reg, col=&quot;red&quot;) 4.4 Exercices Exercice 1 Dans le jeu de données hdv2003, faire le tableau croisé entre la catégorie socio-professionnelle (variable qualif) et le fait de croire ou non en l’existence des classes sociales (variable clso). Identifier la variable indépendante et la variable dépendante, et calculer les pourcentages ligne ou colonne. Interpréter le résultat. library(questionr) data(hdv2003) tab &lt;- table(hdv2003$qualif, hdv2003$clso) ## Ici la variable indépendante est `qualif`, on calcule donc ## les pourcentages lignes lprop(tab) Faire un test du χ². Peut-on rejeter l’hypothèse d’indépendance ? chisq.test(tab) ## On peut rejeter l&#39;hypothèse d&#39;indépendance au seuil de 0.05, ## et même au seuil de 0.001 Représenter ce tableau croisé sous la forme d’un mosaicplot en colorant les cases selon les résidus du test du χ². mosaicplot(tab, shade = TRUE) Exercice 2 Toujours sur le jeu de données hdv2003, faire le boxplot qui croise le nombre d’heures passées devant la télévision (variable heures.tv) avec le statut d’occupation (variable occup). boxplot(hdv2003$heures.tv ~ hdv2003$occup) Calculer la durée moyenne devant la télévision en fonction du statut d’occupation à l’aide de tapply. tapply(hdv2003$heures.tv, hdv2003$occup, mean, na.rm = TRUE) Exercice 3 Sur le jeu de données rp2012, représenter le nuage de points croisant le pourcentage de personnes sans diplôme (variable dipl_aucun) et le pourcentage de propriétaires (variable proprio). library(questionr) data(rp2012) plot(rp2012$dipl_aucun, rp2012$proprio) Calculer le coefficient de corrélation linéaire correspondant. cor(rp2012$dipl_aucun, rp2012$proprio) Le package en question est présenté en détail dans la partie 10.↩︎ "],["05-organiser.html", "Partie 5 Organiser ses scripts 5.1 Les projets dans RStudio 5.2 Créer des sections dans un script 5.3 Répartir son travail entre plusieurs scripts 5.4 Désactiver la sauvegarde de l’espace de travail", " Partie 5 Organiser ses scripts On l’a vu, le script est l’élément central de toute analyse dans R. C’est lui qui contient l’ensemble des opérations constitutives d’une analyse, dans leur ordre d’exécution : chargement des données, recodages, manipulations, analyses, exports de résultats, etc. Une conséquence est qu’un script peut rapidement devenir très long, et on peut finir par s’y perdre. Il est donc nécessaire d’organiser son travail pour pouvoir se retrouver facilement parmi les différentes étapes d’un projet d’analyse. 5.1 Les projets dans RStudio La notion de projet est une fonctionnalité très pratique de RStudio, qui permet d’organiser son travail et de faciliter l’accès à l’ensemble des fichiers constitutifs d’une analyse (données, scripts, documentation, etc.). En pratique, un projet est un dossier que vous avez créé où bon vous semble sur votre disque dur, et dans lequel vous regrouperez tous les fichiers en question. Utiliser des projets procure plusieurs avantages : RStudio lance automatiquement R dans le dossier du projet et facilite ainsi grandement l’accès aux fichiers de données à importer (plus besoin de taper le chemin d’accès complet). De même, si vous déplacez votre dossier sur votre disque, le projet continuera à fonctionner. L’onglet Files de la zone en bas à droite de l’interface de RStudio vous permet de naviguer facilement dans les fichiers de votre projet. Vous pouvez très facilement passer d’un projet à l’autre si vous travaillez sur plusieurs jeux de données en parallèle. Pour créer un projet, il faut aller dans le menu File puis sélectionner New project. Création d’un nouveau projet Selon que le dossier du projet existe déjà ou pas, on choisira Existing directory ou New directory. L’étape d’après consiste à créer ou sélectionner le dossier, puis on n’a plus qu’à cliquer sur Create project. À la création du projet, et chaque fois que vous l’ouvrirez, une nouvelle session R est lancée dans la fenêtre Console avec le dossier du projet comme répertoire de travail, et l’onglet Files affiche les fichiers contenus dans ce dossier. Une fois le projet créé, son nom est affiché dans un petit menu déroulant en haut à droite de l’interface de RStudio (menu qui permet de passer facilement d’un projet à un autre). Menu projets Si vous ne retrouvez pas le nom du projet dans ce menu, vous pouvez l’ouvrir en sélectionnant File puis Open Project… et en allant sélectionner le fichier .Rproj qui se trouve dans le dossier du projet à ouvrir. 5.2 Créer des sections dans un script Lorsqu’un script est long, RStudio permet de créer des “sections” facilitant la navigation. Pour créer une section, il suffit de faire suivre une ligne de commentaires par plusieurs tirets -, comme ceci  : ## Titre de la section ------------------------------------- Le nombre de tirets n’a pas d’importance, il doit juste y’en avoir plus de quatre. RStudio affiche alors dans la marge de gauche du script un petit triangle noir qui permet de replier ou déplier le contenu de la section : Section de script dépliée Section de script repliée De plus, en cliquant sur l’icône Show document outline (la plus à droite de la barre d’outils de la fenêtre du script), ou en utilisant le raccourci clavier Ctrl+Maj+O, RStudio affiche une “table des matières” automatiquement mise à jour qui liste les sections existantes et permet de naviguer facilement dans le script : Liste dynamique des sections 5.3 Répartir son travail entre plusieurs scripts Si le script devient très long, les sections peuvent ne plus être suffisantes. De plus, il est souvent intéressant d’isoler certaines parties d’un script, par exemple pour pouvoir les mutualiser. On peut alors répartir les étapes d’une analyse entre plusieurs scripts. Un exemple courant concerne les recodages et la manipulation des données. Il est fréquent, au cours d’une analyse, de calculer de nouvelles variables, recoder des variables qualitatives existantes, etc. Il peut alors être intéressant de regrouper tous ces recodages dans un script à part (nommé, par exemple, recodages.R). Ce fichier contient alors l’ensemble des recodages “validés”, ceux qu’on a testé et qu’on sait vouloir conserver. Pour exécuter ces recodages, on peut évidemment ouvrir le script recodages.R dans RStudio et lancer l’ensemble du code qu’il contient. Mais une méthode plus pratique est d’utiliser la fonction source : celle-ci prend en paramètre un nom de fichier .R, et quand on l’exécute elle va exécuter l’ensemble du code contenu dans ce fichier. Ainsi, un début de script analyse.R pourra ressembler à ceci : # Analyse des données Histoire de vie 2003 # Chargement des extensions et des données -------------------------- library(questionr) data(hdv2003) source(&quot;recodages.R&quot;) # Analyse de l&#39;âge -------------------------------------------------- hist(hdv2003$age) (...) L’avantage principal est qu’on peut à tout moment revenir à nos données d’origine et aux recodages “validés” simplement en exécutant les deux lignes : data(hdv2003) source(&quot;recodages.R&quot;) L’autre avantage est qu’on peut répartir nos analyses entre différents scripts, et conserver ces deux lignes en haut de chaque script, ce qui permet de “mutualiser” les recodages validés. On pourrait ainsi créer un deuxième script analyse_qualif.R qui pourrait ressembler à ceci : # Analyse des données Histoire de vie 2003 - Qualifications # Chargement des extensions et des données -------------------------- library(questionr) data(hdv2003) source(&quot;recodages.R&quot;) # Analyse des qualifications -------------------------------------------------- freq(hdv2003$qualif) (...) On peut évidemment répartir les recodages entre plusieurs fichiers et faire appel à autant de source que l’on souhaite. Cette organisation recalcule l’ensemble des recodages à chaque début de script. C’est intéressant et pratique pour des données de taille raisonnable, mais pour des fichiers plus volumineux les calculs peuvent être trop longs. Dans ce cas il est préférable de créer des scripts dédiés qui chargent les données source, effectuent calculs et recodages, et enregistrent les données résultantes dans un fichier de données (voir le chapitre sur l’import/export de données). Et c’est ce fichier résultat qui sera chargé par les scripts d’analyse. Enfin, pour des projets un peu complexes, on pourra se référer à l’extension ProjectTemplate, qui propose une architecture de dossiers spécifique et des outils associés. 5.4 Désactiver la sauvegarde de l’espace de travail Vous avez sans doute remarqué qu’au moment de quitter RStudio, une boîte de dialogue semblable à celle-ci s’affiche parfois : Dialogue d’enregistrement de l’espace de travail Et il est bien difficile de comprendre de quoi cela parle. Il s’agit en fait d’une fonctionnalité de R lui-même qui propose d’enregistrer notre espace de travail (workspace), c’est-à-dire l’ensemble des objets qui existent actuellement dans notre environnement, dans un fichier nommé .RData. La prochaine fois que R est lancé dans le même dossier (par exemple à la réouverture du projet), s’il trouve un fichier .RData il va le lire automatiquement et restaurer l’ensemble des objets dans l’état où ils étaient. Ceci peut sembler pratique, mais c’est en fait une mauvaise idée, pour deux raisons : on peut se retrouver avec des objets dont on ne sait plus d’où ils viennent et comment ils ont été calculés cette manière de faire casse la logique principale de R, qui est que c’est le script qui est central, et que c’est lui qui retrace toutes les étapes de notre analyse et permet de les reproduire Il est donc fortement recommandé, juste après l’installation de RStudio, de désactiver cette fonctionnalité. Pour cela, aller dans le menu Tools, puis Global Options, et s’assurer que : la case Restore .RData into workspace at startup est décochée le champ Save workspace to .RData on exit vaut Never Options d’enregistrement de l’espace de travail "],["06-tidyverse.html", "Partie 6 Le tidyverse 6.1 Extensions 6.2 Installation 6.3 tidy data 6.4 tibbles", " Partie 6 Le tidyverse 6.1 Extensions Le terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune. Elles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) : visualisation manipulation des tableaux de données import/export de données manipulation de variables extraction de données du Web programmation Un des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio. 6.2 Installation tidyverse est également le nom d’une extension qu’on peut installer de manière classique, soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande : install.packages(&quot;tidyverse&quot;) Cette commande va en fait installer plusieurs extensions qui constituent le “coeur” du tidyverse, à savoir : ggplot2 (visualisation) dplyr (manipulation des données) tidyr (remise en forme des données) purrr (programmation) readr (importation de données) tibble (tableaux de données) forcats (variables qualitatives) stringr (chaînes de caractères) Packages de l’extension tidyverse De la même manière, charger l’extension avec : library(tidyverse) Chargera l’ensemble des extensions précédentes. Il existe d’autres extensions qui font partie du tidyverse mais qui doivent être chargées explicitement, comme par exemple readxl (pour l’importation de données depuis des fichiers Excel). La liste complète des extensions se trouve sur le site officiel du tidyverse. Ce document est basé sur les versions d’extension suivantes : #&gt; ggplot2 3.3.5 purrr 0.3.4 #&gt; tibble 3.1.5 dplyr 1.0.7 #&gt; tidyr 1.1.4 stringr 1.4.0 #&gt; readr 2.0.2 forcats 0.5.1 6.3 tidy data Le tidyverse est en partie fondé sur le concept de tidy data, développé à l’origine par Hadley Wickham dans un article de 2014 du Journal of Statistical Software. Il s’agit d’un modèle d’organisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation préalable à la mise en oeuvre de méthodes d’analyse. Les principes d’un jeu de données tidy sont les suivants : chaque variable est une colonne chaque observation est une ligne chaque type d’observation est dans une table différente On verra plus précisément dans la section 12 comment définir et rendre des données tidy avec l’extension tidyr. Les extensions du tidyverse, notamment ggplot2 et dplyr, sont prévues pour fonctionner avec des données tidy. 6.4 tibbles Une autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble, qui est une évolution plus moderne du classique data frame du R de base. Ce format est fourni est géré par l’extension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse acceptent des data frames en entrée, mais retournent un objet de classe tibble. Contrairement aux data frames, les tibbles : n’ont pas de noms de lignes (rownames) autorisent des noms de colonnes invalides pour les data frames (espaces, caractères spéciaux, nombres…)10 s’affichent plus intelligemment que les data frames : seules les premières lignes sont affichées, ainsi que quelques informations supplémentaires utiles (dimensions, types des colonnes…) ne font pas de partial matching sur les noms de colonnes11 affichent un avertissement si on essaie d’accéder à une colonne qui n’existe pas Pour autant, les tibbles restent compatibles avec les data frames. On peut ainsi facilement convertir un data frame en tibble avec as_tibble : as_tibble(mtcars) #&gt; # A tibble: 32 × 11 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 #&gt; 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 #&gt; 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 #&gt; # … with 22 more rows Si le data frame d’origine a des rownames, on peut d’abord les convertir en colonnes avec rownames_to_columns : d &lt;- as_tibble(rownames_to_column(mtcars)) d #&gt; # A tibble: 32 × 12 #&gt; rowname mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 #&gt; 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 #&gt; 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 #&gt; # … with 22 more rows À l’inverse, on peut à tout moment convertir un tibble en data frame avec as.data.frame : as.data.frame(d) #&gt; rowname mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; 11 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; 12 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; 13 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; 14 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; 15 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; 16 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; 17 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; 18 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; 19 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; 20 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; 21 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; 22 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; 23 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; 24 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; 25 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; 26 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; 27 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; 28 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; 29 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; 30 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; 31 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 #&gt; 32 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Là encore, on peut convertir la colonne rowname en “vrais” rownames avec column_to_rownames : column_to_rownames(as.data.frame(d)) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Les deux fonctions column_to_rownames et rownames_to_column acceptent un argument supplémentaire var qui permet d’indiquer un nom de colonne autre que le nom rowname utilisé par défaut pour créer ou identifier la colonne contenant les noms de lignes. Quand on veut utiliser des noms de ce type, on doit les entourer avec des backticks (`)↩︎ Dans R de base, si une table d contient une colonne qualif, d$qual retournera cette colonne.↩︎ "],["07-import.html", "Partie 7 Importer et exporter des données 7.1 Import de fichiers textes 7.2 Import depuis un fichier Excel 7.3 Import de fichiers SAS, SPSS et Stata 7.4 Import de fichiers dBase 7.5 Connexion à des bases de données 7.6 Export de données", " Partie 7 Importer et exporter des données R n’est pas prévu pour la saisie de données, mais il bénéficie de nombreuses fonctions et packages permettant l’import de données depuis un grand nombre de formats. Seuls les plus courants seront abordés ici. Il est très vivement conseillé de travailler avec les projets de RStudio pour faciliter l’accès aux fichiers et pouvoir regrouper l’ensemble des éléments d’une analyse dans un dossier (voir partie 5.1). Les projets permettent notamment de ne pas avoir à spécifier un chemin complet vers un fichier (sous Windows, quelque chose du genre C:\\Users\\toto\\Documents\\quanti\\projet\\data\\donnees.xls) mais un chemin relatif au dossier du projet (juste donnees.xls si le fichier se trouve à la racine du projet, data/donnees.xls s’il se trouve dans un sous-dossier data, etc.) 7.1 Import de fichiers textes L’extension readr, qui fait partie du tidyverse, permet l’importation de fichiers texte, notamment au format CSV (Comma separated values), format standard pour l’échange de données tabulaires entre logiciels. Cette extension fait partie du “coeur” du tidyverse, elle est donc automatiquement chargée avec : library(tidyverse) Si votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read_csv en lui passant en argument le nom du fichier : d &lt;- read_csv(&quot;fichier.csv&quot;) Si votre fichier vient d’Excel, avec des valeurs séparées par des points virgule, utilisez la fonction read_csv2 : d &lt;- read_csv2(&quot;fichier.csv&quot;) Dans la même famille de fonction, read_tsv permet d’importer des fichiers dont les valeurs sont séparées par des tabulations, et read_delim des fichiers délimités par un séparateur indiqué en argument. Chaque fonction dispose de plusieurs arguments, parmi lesquels : col_names indique si la première ligne contient le nom des colonnes (TRUE par défaut) col_types permet de spécifier manuellement le type des colonnes si readr ne les identifie pas correctement na est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(\"\", \"NA\") par défaut Il peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut alors spécifier manuellement l’encodage du fichier importé à l’aide de l’option locale. Par exemple, si l’on est sous Mac ou Linux et que le fichier a été créé sous Windows, il est possible qu’il soit encodé au format iso-8859-1. On peut alors l’importer avec : d &lt;- read_csv(&quot;fichier.csv&quot;, locale = locale(encoding = &quot;ISO-8859-1&quot;)) À l’inverse, si vous importez un fichier sous Windows et que les accents ne sont pas affichés correctement, il est sans doute encodé en UTF-8 : d &lt;- read_csv(&quot;fichier.csv&quot;, locale = locale(encoding = &quot;UTF-8&quot;)) Pour plus d’informations sur ces fonctions, voir le site de l’extension readr. À noter que si vous souhaitez importer des fichiers textes très volumineux le plus rapidement possible, la fonction fread de l’extension data.table est plus rapide que read_csv. 7.1.1 Interface interactive d’import de fichiers RStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour y accéder, dans l’onglet Environment, cliquez sur le bouton Import Dataset : Menu Import Dataset Sélectionnez From Text (readr)…. Une nouvelle fenêtre s’affiche : Dialogue d’importation Il vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct : Exemple de dialogue d’importation Vous pouvez modifier les options d’importation, changer le type des colonnes, etc. et l’aperçu se met à jour. De même, le code correspondant à l’importation du fichier avec les options sélectionnées est affiché dans la partie Code Preview. Important : une fois que l’import semble correct, ne cliquez pas sur le bouton Import. À la place, sélectionnez le code généré et copiez-le (ou cliquez sur l’icône en forme de presse papier) et choisissez Cancel. Ensuite, collez le code dans votre script et exécutez-le (vous pouvez supprimer la ligne commençant par View). Cette manière de faire permet “d’automatiser” l’importation des données, puisqu’à la prochaine ouverture du script vous aurez juste à exécuter le code en question, sans repasser par l’interface d’import. 7.2 Import depuis un fichier Excel L’extension readxl, qui fait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx. Elle ne fait pas partie du “coeur” du tidyverse, il faut donc la charger explicitement avec : library(readxl) On peut alors utiliser la fonction read_excel en lui spécifiant le nom du fichier : d &lt;- read_excel(&quot;fichier.xls&quot;) Il est possible de spécifier la feuille et la plage de cellules que l’on souhaite importer avec les arguments sheet et range : d &lt;- read_excel(&quot;fichier.xls&quot;, sheet = &quot;Feuille2&quot;, range = &quot;C1:F124&quot;) Comme pour l’import de fichiers texte, une interface interactive d’import de fichiers Excel est disponible dans RStudio dans l’onglet Environment. Pour y accéder, cliquez sur Import Dataset puis From Excel…. Dialogue d’importation d’un fichier Excel Spécifiez le chemin ou l’URL du fichier dans le premier champ, vérifiez l’import dans la partie Data Preview, modifiez si besoin les options d’importation, copiez le code d’importation généré dans la partie Code Preview et collez le dans votre script. Pour plus d’informations, voir le site de l’extension readxl. 7.3 Import de fichiers SAS, SPSS et Stata L’import de fichiers de données au format SAS, SPSS ou Stata se fait via les fonctions de l’extension haven. Celle-ci fait partie du tidyverse, mais doit être chargée explicitement avec : library(haven) Pour les fichiers provenant de SAS, vous pouvez utiliser les fonctions read_sas ou read_xpt Pour les fichiers provenant de SPSS, vous pouvez utiliser read_sav ou read_por Pour les fichiers provenant de Stata, utilisez read_dta Chaque fonction dispose de plusieurs options. Le plus simple est d’utiliser, là aussi l’interface interactive d’importation de données de RStudio : dans l’onglet Environment, sélectionnez Import Dataset puis From SPSS, From SAS ou From Stata. Indiquez le chemin ou l’url du fichier, réglez les options d’importation, puis copiez le code d’importation généré et collez le dans votre script. Pour plus d’informations, voir le site de l’extension haven 7.4 Import de fichiers dBase Le format dBase est encore utilisé, notamment par l’INSEE, pour la diffusion de données volumineuses. Les fichiers au format dbf peuvent être importées à l’aide de la fonction read.dbf de l’extension foreign 12 : library(foreign) d &lt;- read.dbf(&quot;fichier.dbf&quot;) La fonction read.dbf n’admet qu’un seul argument, as.is. Si as.is = FALSE (valeur par défaut), les chaînes de caractères sont automatiquement converties en factor à l’importation. Si as.is = TRUE, elles sont conservées telles quelles. 7.5 Connexion à des bases de données 7.5.1 Interfaçage via l’extension DBI R est capable de s’interfacer avec différents systèmes de bases de données relationnelles, dont SQLite, MS SQL Server, PostgreSQL, MariaDB, etc. Pour illustrer rapidement l’utilisation de bases de données, on va créer une base SQLite d’exemple à l’aide du code R suivant, qui copie la table du jeu de données mtcars dans une base de données bdd.sqlite : library(DBI) library(RSQLite) con &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = &quot;resources/bdd.sqlite&quot;) data(mtcars) mtcars$name &lt;- rownames(mtcars) dbWriteTable(con, &quot;mtcars&quot;, mtcars) dbDisconnect(con) Si on souhaite se connecter à cette base de données par la suite, on peut utiliser l’extension DBI, qui propose une interface générique entre R et différents systèmes de bases de données. On doit aussi avoir installé et chargé l’extension spécifique à notre base, ici RSQLite. On commence par ouvrir une connexion à l’aide de la fonction dbConnect de DBI : library(DBI) library(RSQLite) con &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = &quot;resources/bdd.sqlite&quot;) La connexion est stockée dans un objet con, qu’on va utiliser à chaque fois qu’on voudra interroger la base. On peut vérifier la liste des tables présentes et les champs de ces tables avec dbListTables et dbListFields : dbListTables(con) #&gt; [1] &quot;mtcars&quot; dbListFields(con, &quot;mtcars&quot;) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; &quot;name&quot; On peut également lire le contenu d’une table dans un objet de notre environnement avec dbReadTable : cars &lt;- dbReadTable(con, &quot;mtcars&quot;) On peut également envoyer une requête SQL directement à la base et récupérer le résultat : dbGetQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb name #&gt; 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Datsun 710 #&gt; 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 240D #&gt; 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 230 #&gt; 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Fiat 128 #&gt; 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Honda Civic #&gt; 6 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corolla #&gt; 7 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Toyota Corona #&gt; 8 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Fiat X1-9 #&gt; 9 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Porsche 914-2 #&gt; 10 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Lotus Europa #&gt; 11 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Volvo 142E Enfin, quand on a terminé, on peut se déconnecter à l’aide de dbDisconnect : dbDisconnect(con) Ceci n’est évidemment qu’un tout petit aperçu des fonctionnalités de DBI. 7.5.2 Utilisation de dplyr et dbplyr L’extension dplyr est dédiée à la manipulation de données, elle est présentée chapitre 10. En installant l’extension complémentaire dbplyr, on peut utiliser dplyr directement sur une connection à une base de données générée par DBI : library(DBI) library(RSQLite) library(dplyr) con &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = &quot;resources/bdd.sqlite&quot;) La fonction tbl notamment permet de créer un nouvel objet qui représente une table de la base de données : cars_tbl &lt;- tbl(con, &quot;mtcars&quot;) Ici l’objet cars_tbl n’est pas un tableau de données, c’est juste un objet permettant d’interroger la table de notre base de données. On peut utiliser cet objet avec les verbes de dplyr : cars_tbl %&gt;% filter(cyl == 4) %&gt;% select(name, mpg, cyl) #&gt; # Source: lazy query [?? x 3] #&gt; # Database: sqlite 3.36.0 #&gt; # [/home/runner/work/tidyverse/tidyverse/resources/bdd.sqlite] #&gt; name mpg cyl #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Datsun 710 22.8 4 #&gt; 2 Merc 240D 24.4 4 #&gt; 3 Merc 230 22.8 4 #&gt; 4 Fiat 128 32.4 4 #&gt; 5 Honda Civic 30.4 4 #&gt; 6 Toyota Corolla 33.9 4 #&gt; 7 Toyota Corona 21.5 4 #&gt; 8 Fiat X1-9 27.3 4 #&gt; 9 Porsche 914-2 26 4 #&gt; 10 Lotus Europa 30.4 4 #&gt; # … with more rows dbplyr s’occupe, de manière transparente, de transformer les instructions dplyr en requête SQL, d’interroger la base de données et de renvoyer le résultat. De plus, tout est fait pour qu’un minimum d’opérations sur la base, parfois coûteuses en temps de calcul, ne soient effectuées. Il est possible de modifier des objets de type tbl, par exemple avec mutate : cars_tbl &lt;- cars_tbl %&gt;% mutate(type = “voiture”) Dans ce cas la nouvelle colonne type est bien créée et on peut y accéder par la suite. Mais cette création se fait dans une table temporaire : elle n’existe que le temps de la connexion à la base de données. À la prochaine connexion, cette nouvelle colonne n’apparaîtra pas dans la table. Bien souvent on utilisera une base de données quand les données sont trop volumineuses pour être gérées par un ordinateur de bureau. Mais si les données ne sont pas trop importantes, il sera toujours plus rapide de récupérer l’intégralité de la table dans notre session R pour pouvoir la manipuler comme les tableaux de données habituels. Ceci se fait grâce à la fonction collect de dplyr : cars &lt;- cars_tbl %&gt;% collect Ici, cars est bien un tableau de données classique, copie de la table de la base au moment du collect. Et dans tous les cas, on n’oubliera pas de se déconnecter avec : dbDisconnect(con) 7.5.3 Ressources Pour plus d’informations, voir la documentation très complète (en anglais) proposée par RStudio. Par ailleurs, depuis la version 1.1, RStudio facilite la connexion à certaines bases de données grâce à l’onglet Connections. Pour plus d’informations on pourra se référer à l’article (en anglais) Using RStudio Connections. 7.6 Export de données 7.6.1 Export de tableaux de données On peut avoir besoin d’exporter un tableau de données dans R vers un fichier dans différents formats. La plupart des fonctions d’import disposent d’un équivalent permettant l’export de données. On citera notamment : write_csv, write_csv2, read_tsv permettent d’enregistrer un data frame ou un tibble dans un fichier au format texte délimité write_sas permet d’exporter au format SAS write_sav permet d’exporter au format SPSS write_dta permet d’exporter au format Stata Il n’existe par contre pas de fonctions permettant d’enregistrer directement au format xls ou xlsx. On peut dans ce cas passer par un fichier CSV. Ces fonctions sont utiles si on souhaite diffuser des données à quelqu’un d’autre, ou entre deux logiciels. Si vous travaillez sur des données de grandes dimensions, les formats texte peuvent être lents à exporter et importer. Dans ce cas, l’extension feather peut être utile : elle permet d’enregistrer un data frame au format feather, qui n’est pas le plus compact mais qui est extrêmement rapide à lire et écrire 13. Les fonctions read_feather et write_feather permettent d’importer et exporter des tableaux de données dans ce format. 7.6.2 Sauvegarder des objets Une autre manière de sauvegarder des données est de les enregistrer au format RData. Ce format propre à R est compact, rapide, et permet d’enregistrer plusieurs objets R, quel que soit leur type, dans un même fichier. Pour enregistrer des objets, il suffit d’utiliser la fonction save et de lui fournir la liste des objets à sauvegarder et le nom du fichier : save(d, rp2012, tab, file = &quot;fichier.RData&quot;) Pour charger des objets préalablement enregistrés, utiliser load : load(&quot;fichier.RData&quot;) Les objets d, rp2012 et tab devraient alors apparaître dans votre environnement. Attention, quand on utilise load, les objets chargés sont importés directement dans l’environnement en cours avec leur nom d’origine. Si d’autres objets du même nom existaient déjà, ils sont écrasés sans avertissement. foreign est une extension installée de base avec R, vous n’avez pas besoin de l’installer, il vous suffit de la charger avec library↩︎ feather est un format compatible avec Python, R et Julia. Pour plus d’informations voir https://github.com/wesm/feather↩︎ "],["08-ggplot2.html", "Partie 8 Visualiser avec ggplot2 8.1 Préparation 8.2 Initialisation 8.3 Exemples de geom 8.4 Mappages 8.5 Représentation de plusieurs geom 8.6 Faceting 8.7 Scales 8.8 Thèmes 8.9 L’add-in esquisse 8.10 Ressources 8.11 Exercices", " Partie 8 Visualiser avec ggplot2 ggplot2 est une extension du tidyverse qui permet de générer des graphiques avec une syntaxe cohérente et puissante. Elle nécessite l’apprentissage d’un “mini-langage” supplémentaire, mais permet la construction de graphiques complexes de manière efficace. Une des particularités de ggplot2 est qu’elle part du principe que les données relatives à un graphique sont stockées dans un tableau de données (data frame, tibble ou autre). 8.1 Préparation ggplot2 fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec : library(tidyverse) On peut également la charger explicitement avec : library(ggplot2) Dans ce qui suit on utilisera le jeu de données issu du recensement de la population de 2012 inclus dans l’extension questionr (résultats partiels concernant les communes de plus de 2000 habitants de France métropolitaine). On charge ces données et on en extrait les données de 5 départements (l’utilisation de la fonction filter sera expliquée dans la section 10.2.2 de la partie sur dplyr : library(questionr) data(rp2012) rp &lt;- filter(rp2012, departement %in% c(&quot;Oise&quot;, &quot;Rhône&quot;, &quot;Hauts-de-Seine&quot;, &quot;Lozère&quot;, &quot;Bouches-du-Rhône&quot;)) 8.2 Initialisation Un graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction : ggplot(data = rp) ## Ou, équivalent ggplot(rp) On a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. Ces éléments sont appelés des geom, et on les ajoute à l’objet graphique de base avec l’opérateur +. Un des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante : ggplot(rp) + geom_histogram() Reste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter sur l’axe des x (l’axe horizontal). Ainsi, si on souhaite représenter la distribution des communes du jeu de données selon le pourcentage de cadres dans leur population active (variable cadres), on pourra faire : ggplot(rp) + geom_histogram(aes(x = cadres)) Si on veut représenter une autre variable, il suffit de changer la valeur de x : ggplot(rp) + geom_histogram(aes(x = ouvr)) Quand on spécifie une variable, inutile d’indiquer le nom du tableau de données sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué avec le paramètre data. On peut donc se contenter de ouvr. Certains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points, on peut le faire en ajoutant un geom_point. On doit alors indiquer à la fois la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points, il faut donc passer ces deux arguments à aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) On peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres), color = &quot;darkgreen&quot;, size = 3, alpha = 0.3) On notera que dans ce cas les arguments sont dans la fonction geom mais à l’extérieur du aes(). Plus d’explications sur ce point dans quelques instants. 8.3 Exemples de geom Il existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre les geom_histogram et geom_point que l’on vient de voir, on pourra noter les geom suivants. 8.3.1 geom_boxplot geom_boxplot permet de représenter des boîtes à moustaches. On lui passe en y la variable numérique dont on veut étudier la répartition, et en x la variable qualitative contenant les classes qu’on souhaite comparer. Ainsi, si on veut comparer la répartition du pourcentage de maisons en fonction du département de la commune, on pourra faire : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) On peut personnaliser la présentation avec différents argument supplémentaires comme fill ou color : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison), fill = &quot;wheat&quot;, color = &quot;tomato4&quot;) Un autre argument utile, varwidth, permet de faire varier la largeur des boîtes en fonction des effectifs de la classe (donc, ici, en fonction du nombre de communes de chaque département) : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison), varwidth = TRUE) 8.3.2 geom_violin geom_violin est très semblable à geom_boxplot, mais utilise des graphes en violon à la place des boîtes à moustache. ggplot(rp) + geom_violin(aes(x = departement, y = maison)) Les graphes en violon peuvent donner une lecture plus fine des différences de distribution selon les classes. 8.3.3 geom_bar geom_bar permet de produire un graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité. Par exemple, si on veut afficher le nombre de communes de notre jeu de données pour chaque département : ggplot(rp) + geom_bar(aes(x = departement)) Un cas assez fréquent mais un peu plus complexe survient quand on a déjà calculé le tri à plat de la variable à représenter. Dans ce cas on souhaite que geom_bar représente les effectifs sans les calculer : cela se fait en indiquant un mappage y pour la variable contenant les effectifs précalculés, et en ajoutant l’argument stat = \"identity\". Par exemple, si on a les données sous cette forme dans un tableau de données nommé df : df #&gt; departement n #&gt; 1 Bouches-du-Rhône 98 #&gt; 2 Hauts-de-Seine 35 #&gt; 3 Lozère 5 #&gt; 4 Oise 75 #&gt; 5 Rhône 119 On peut obtenir le graphique souhaité ainsi : ggplot(df) + geom_bar(aes(x = departement, y = n), stat = &quot;identity&quot;) À noter qu’on peut aussi utiliser geom_col qui est un raccourci pour appliquer un geom_bar avec stat = \"identity\". La commande précédente est donc équivalente à : ggplot(df) + geom_col(aes(x = departement, y = n)) Là aussi, on peut modifier l’apparence du graphique avec des arguments supplémentaires comme fill ou width : ggplot(rp) + geom_bar(aes(x = departement), fill = &quot;darkblue&quot;, width = .5) 8.3.4 geom_text geom_text permet d’afficher des étiquettes de texte. On doit lui passer x et y pour la position des étiquettes, et label pour leur texte. Par exemple, si on souhaite représenter le nuage croisant la part des diplômés du supérieur et la part de cadres, mais en affichant le nom de la commune (variable commune) plutôt qu’un simple point, on peut faire : ggplot(rp) + geom_text(aes(x = dipl_sup, y = cadres, label = commune)) On peut personnaliser l’apparence et la position du texte avec des arguments comme size, color, etc. ggplot(rp) + geom_text(aes(x = dipl_sup, y = cadres, label = commune), color = &quot;darkred&quot;, size = 2) 8.3.5 geom_label geom_label est identique à geom_text, mais avec une présentation un peu différente. ggplot(rp) + geom_label(aes(x = dipl_sup, y = cadres, label = commune)) 8.3.6 geom_density geom_density permet d’afficher l’estimation de densité d’une variable numérique. Son usage est similaire à celui de geom_histogram. Ainsi, si on veut afficher la densité de la répartition de la part des cadres dans les communes de notre jeu de données : ggplot(rp) + geom_density(aes(x = cadres)) On peut utiliser différents arguments pour ajuster le calcul de l’estimation de densité, parmi lesquels kernel et bw (voir la page d’aide de la fonction density pour plus de détails). bw (abbréviation de bandwidth, bande passante) permet de régler la “finesse” de l’estimation de densité, un peu comme le choix du nombre de classes dans un histogramme : ggplot(rp) + geom_density(aes(x = cadres), bw = 1) 8.3.7 geom_line geom_line trace des lignes connectant les différentes observations entre elles. Il est notamment utilisé pour la représentation de séries temporelles. On passe à geom_line deux paramètres : x et y. Les observations sont alors connectées selon l’ordre des valeurs passées en x. Comme il n’y a pas de données adaptées pour ce type de représentation dans notre jeu de données d’exemple, on va utiliser ici le jeu de données economics inclus dans ggplot2 et représenter l’évolution du taux de chômage aux États-Unis (variable unemploy) dans le temps (variable date) : data(&quot;economics&quot;) economics #&gt; # A tibble: 574 × 6 #&gt; date pce pop psavert uempmed unemploy #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1967-07-01 507. 198712 12.6 4.5 2944 #&gt; 2 1967-08-01 510. 198911 12.6 4.7 2945 #&gt; 3 1967-09-01 516. 199113 11.9 4.6 2958 #&gt; 4 1967-10-01 512. 199311 12.9 4.9 3143 #&gt; 5 1967-11-01 517. 199498 12.8 4.7 3066 #&gt; 6 1967-12-01 525. 199657 11.8 4.8 3018 #&gt; 7 1968-01-01 531. 199808 11.7 5.1 2878 #&gt; 8 1968-02-01 534. 199920 12.3 4.5 3001 #&gt; 9 1968-03-01 544. 200056 11.7 4.1 2877 #&gt; 10 1968-04-01 544 200208 12.3 4.6 2709 #&gt; # … with 564 more rows ggplot(economics) + geom_line(aes(x = date, y = unemploy)) 8.4 Mappages Un mappage, dans ggplot2, est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données. Ces mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic). 8.4.1 Exemples de mappages On a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) dépend de la valeur des variables passées comme arguments x et y dans aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) Mais on peut ajouter d’autres mappages. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable. Ainsi, on peut vouloir colorer les points selon le département de la commune correspondante : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) On peut aussi faire varier la taille des points avec size. Ici, la taille dépend de la population totale de la commune : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)) On peut même associer la transparence des points à une variable avec alpha : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)) Chaque geom possède sa propre liste de mappages. 8.4.2 aes() or not aes() ? Comme on l’a déjà vu, parfois on souhaite changer un attribut sans le relier à une variable. Par exemple, on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres), color = &quot;red&quot;) Par contre, si on veut faire varier la couleur en fonction des valeurs prises par une variable, on réalise un mappage, et on doit donc placer l’attribut color à l’intérieur de aes(). ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) On peut évidemment mélanger attributs liés à une variable (mappage, donc dans aes()) et attributs constants (donc à l’extérieur). Dans l’exemple suivant, la taille varie en fonction de la variable pop_tot, mais la couleur est constante pour tous les points : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot), color = &quot;royalblue&quot;) La règle est donc simple mais très importante : Si on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit en-dehors de la fonction aes(). 8.4.3 geom_bar et position Un des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une deuxième variable : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl)) L’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut on a position = \"stack\" et elles sont donc “empilées”. Mais on peut préciser position = \"dodge\" pour les mettre côte à côte : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl), position = &quot;dodge&quot;) Ou encore position = \"fill\" pour représenter non plus des effectifs, mais des proportions : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl), position = &quot;fill&quot;) 8.5 Représentation de plusieurs geom On peut représenter plusieurs geom simultanément sur un même graphique, il suffit de les ajouter à tour de rôle avec l’opérateur +. Par exemple, on peut superposer la position des points au-dessus d’un boxplot. On va pour cela ajouter un geom_point après avoir ajouté notre geom_boxplot : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) + geom_point(aes(x = departement, y = maison), col = &quot;red&quot;, alpha = 0.2) Quand une commande ggplot2 devient longue, il peut être plus lisible de la répartir sur plusieurs lignes. Dans ce cas, il faut penser à placer l’opérateur + en fin de ligne, afin que R comprenne que la commande n’est pas complète et qu’il prenne en compte la suite. Pour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) + geom_jitter(aes(x = departement, y = maison), col = &quot;red&quot;, alpha = 0.2) Pour simplifier un peu le code, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages) : ggplot(rp, aes(x = departement, y = maison)) + geom_boxplot() + geom_jitter(color = &quot;red&quot;, alpha = 0.2) Autre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth : ggplot(rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_smooth(method = &quot;lm&quot;) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Et on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d : ggplot(rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_density2d(color = &quot;red&quot;) + geom_smooth(method = &quot;lm&quot;) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; 8.5.1 Plusieurs sources de données On peut aussi associer à différents geom des sources de données différentes. Supposons qu’on souhaite afficher sur un nuage de points les noms des communes de plus de 50000 habitants. On peut commencer par créer un tableau de données avec seulement ces communes à l’aide de la fonction filter : com50 &lt;- filter(rp, pop_tot &gt;= 50000) On fait ensuite le nuage de points comme précédemment : ggplot(data = rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) Pour superposer les noms de communes de plus de 50 000 habitants, on peut ajouter un geom_text, mais en spécifiant que les données proviennent du nouveau tableau com50 et non de notre tableau initial rp. On le fait en passant un argument data spécifique à geom_text : ggplot(data = rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_text(data = com50, aes(label = commune), color = &quot;red&quot;, size = 3) Ainsi, on obtient un graphique avec deux geom superposés, mais dont les données proviennent de deux tableaux différents. 8.6 Faceting Le faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives. Par exemple, on a vu qu’on peut représenter l’histogramme du pourcentage de cadres dans nos communes avec le code suivant : ggplot(data = rp) + geom_histogram(aes(x = cadres)) On peut vouloir comparer cette répartition de la part des cadres selon le département, et donc faire un histogramme pour chacun de ces départements. C’est ce que permettent les fonctions facet_wrap et facet_grid. facet_wrap prend un paramètre de la forme vars(variable), où variable est le nom de la variable en fonction de laquelle on souhaite faire les différents graphiques. Ceux-ci sont alors affichés les uns à côté des autres et répartis automatiquement dans la page : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_wrap(vars(departement)) Pour facet_grid, les graphiques sont disposés selon une grille. La fonction prend alors deux arguments, rows et cols, auxquels on passe les variables à afficher en ligne ou en colonne via la fonction vars(). ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_grid(cols = vars(departement)) Un des intérêts du faceting dans ggplot2 est que tous les graphiques générés ont les mêmes échelles, ce qui permet une comparaison directe. Enfin, notons qu’on peut même faire du faceting sur plusieurs variables à la fois. On peut par exemple faire des histogrammes de la répartition de la part des cadres pour chaque croisement des variables departement et pop_cl : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_grid(rows = vars(departement), cols = vars(pop_cl)) L’histogramme en haut à gauche représente la répartition du pourcentage de cadres parmi les communes de 2000 à 3000 habitants dans les Bouches-du-Rhône, etc. 8.7 Scales On a vu qu’avec ggplot2 on définit des mappages entre des attributs graphiques (position, taille, couleur, etc.) et des variables d’un tableau de données. Ces mappages sont définis, pour chaque geom, via la fonction aes(). Les scales dans ggplot2 permettent de modifier la manière dont un attribut graphique va être relié aux valeurs d’une variable, et dont la légende correspondante va être affichée. Par exemple, pour l’attribut color, on pourra définir la palette de couleur utilisée. Pour size, les tailles minimales et maximales, etc. Pour modifier une scale existante, on ajoute un nouvel élément à notre objet ggplot2 avec l’opérateur +. Cet élément prend la forme scale_&lt;attribut&gt;_&lt;type&gt;. Voyons tout de suite quelques exemples. 8.7.1 scale_size Si on souhaite modifier les tailles minimales et maximales des objets quand on a effectué un mappage de type size, on peut utiliser la fonction scale_size et son argument range : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(range = c(0,20)) À comparer par exemple à : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(range = c(2,8)) On peut ajouter d’autres paramètres à scale_size. Le premier argument est toujours le titre donné à la légende : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(&quot;Population&quot;, range = c(0,15)) On peut aussi définir manuellement les éléments de légende représentés : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(&quot;Population&quot;, range = c(0,15), breaks = c(1000,5000,10000,50000)) 8.7.2 scale_x, scale_y Les scales scale_x et scale_y modifient les axes x et y du graphique. scale_x_continuous et scale_y_continuous s’appliquent lorsque la variable x ou y est numérique (quantitative). C’est le cas de notre nuage de points croisant part de cadres et part de diplômés du supérieur : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) Comme on représente des pourcentages, on peut vouloir forcer les axes x et y à s’étendre des valeurs 0 à 100. On peut le faire en ajoutant un élément scale_x_continuous et un élément scale_y_continuous, et en utilisant leur argument limits : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) + scale_x_continuous(limits = c(0,100)) + scale_y_continuous(limits = c(0,100)) Là aussi, on peut modifier les étiquettes des axes en indiquant une chaîne de caractères en premier argument : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) + scale_x_continuous(&quot;Part des diplômés du supérieur (%)&quot;, limits = c(0,100)) + scale_y_continuous(&quot;Part des cadres (%)&quot;, limits = c(0,100)) On peut utiliser scale_x_log10 et scale_y_log10 pour passer un axe à une échelle logarithmique : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) + scale_x_log10(&quot;Diplômés du supérieur&quot;) scale_x_discrete et scale_y_discrete s’appliquent quant à elles lorsque l’axe correspond à une variable discrète (qualitative). C’est le cas de l’axe des x dans un diagramme en bâtons : ggplot(rp) + geom_bar(aes(x = departement)) + scale_x_discrete(&quot;Département&quot;) L’argument limits de scale_x_discrete permet d’indiquer quelles valeurs sont affichées et dans quel ordre. ggplot(rp) + geom_bar(aes(x = departement)) + scale_x_discrete(&quot;Département&quot;, limits = c(&quot;Oise&quot;, &quot;Lozère&quot;, &quot;Rhône&quot;)) #&gt; Warning: Removed 133 rows containing non-finite values (stat_count). 8.7.3 scale_color, scale_fill Ces scales permettent, entre autre, de modifier les palettes de couleur utilisées pour le dessin (color) ou le remplissage (fill) des éléments graphiques. Dans ce qui suit, pour chaque fonction scale_color présentée il existe une fonction scale_fill équivalente et avec en général les mêmes arguments. 8.7.3.1 Variables quantitatives Le graphique suivant colore les points selon la valeur d’une variable numérique quantitative (ici la part de chômeurs) : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) On peut modifier les couleurs utilisées avec les arguments low et high de la fonction scale_color_gradient. Ici on souhaite que la valeur la plus faible soit blanche, et la plus élevée rouge : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) + scale_color_gradient(&quot;Taux de chômage&quot;, low = &quot;white&quot;, high = &quot;red&quot;) On peut aussi utiliser des palettes prédéfinies. L’une des plus populaires est la palette viridis, accessible en utilisant scale_color_viridis_c : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) + scale_color_viridis_c(&quot;Taux de chômage&quot;) viridis propose également trois autres palettes, magma, inferno et plasma, accessibles via l’argument option : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) + scale_color_viridis_c(&quot;Taux de chômage&quot;, option = &quot;plasma&quot;) On peut aussi utiliser scale_color_distiller, qui transforme une des palettes pour variable qualitative de scale_color_brewer en palette continue pour variable numérique : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) + scale_color_distiller(&quot;Taux de chômage&quot;, palette = &quot;Spectral&quot;) La liste des palettes de scale_color_brewer est indiquée en fin de section suivante. 8.7.3.2 Variables qualitatives Si on a fait un mappage avec une variable discrète (qualitative), comme ici avec le département : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) Une première possibilité est de modifier la palette manuellement avec scale_color_manual et son argument values : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) + scale_color_manual(&quot;Département&quot;, values = c(&quot;red&quot;, &quot;#FFDD45&quot;, rgb(0.1,0.2,0.6), &quot;darkgreen&quot;, &quot;grey80&quot;)) L’exemple précédent montre plusieurs manières de définir manuellement des couleurs dans R : Par code hexadécimal : “#FFDD45” En utilisant la fonction rgb et en spécifiant les composantes rouge, vert, bleu par des nombres entre 0 et 1 (et optionnellement une quatrième composante d’opacité, toujours entre 0 et 1) : rgb(0.1,0.2,0.6) En donnant un nom de couleur : “red”, “darkgreen” La liste complète des noms de couleurs connus par R peut être obtenu avec la fonction colors(). Vous pouvez aussi retrouver en ligne la liste des couleurs et leur nom (PDF). Il est cependant souvent plus pertinent d’utiliser des palettes prédéfinies. Celles du site Colorbrewer, initialement prévues pour la cartographie, permettent une bonne lisibilité, et peuvent être adaptées pour certains types de daltonisme. Ces palettes s’utilisent via la fonction scale_color_brewer, en passant le nom de la palette via l’argument palette. Par exemple, si on veut utiliser la palette Set1 : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) + scale_color_brewer(&quot;Département&quot;, palette = &quot;Set1&quot;) Le graphique suivant, accessible via la fonction display.brewer.all(), montre la liste de toutes les palettes disponibles via scale_color_brewer. Elles sont réparties en trois familles : les palettes séquentielles (pour une variable quantitative), les palettes qualitatives, et les palettes divergentes (typiquement pour une variable quantitative avec une valeur de référence, souvent 0, et deux palettes continues distinctes pour les valeurs inférieures et pour les valeurs supérieures). RColorBrewer::display.brewer.all() Il existe d’autres méthodes pour définir les couleurs : pour plus d’informations on pourra se reporter à l’article de la documentation officielle sur ce sujet. 8.8 Thèmes Les thèmes permettent de contrôler l’affichage de tous les éléments du graphique qui ne sont pas reliés aux données : titres, grilles, fonds, etc. Il existe un certain nombre de thèmes préexistants, par exemple le thème theme_bw : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme_bw() Ou le thème theme_minimal : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme_minimal() On peut cependant modifier manuellement les différents éléments. Par exemple, les fonctions ggtitle, xlab et ylab permettent d’ajouter ou de modifier le titre du graphique, ainsi que les étiquettes des axes x et y : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + ggtitle(&quot;Un bien bel histogramme&quot;) + xlab(&quot;Pourcentage de cadres&quot;) + ylab(&quot;Effectif&quot;) Les éléments personnalisables étant nombreux, un bon moyen de se familiariser avec tous les arguments est sans doute l’addin RStudio ggThemeAssist. Pour l’utiliser il suffit d’installer le package du même nom, de sélectionner dans son script RStudio le code correspondant à un graphique ggplot2, puis d’aller dans le menu Addins et choisir ggplot Theme Assistant. Une interface graphique s’affiche alors permettant de modifier les différents éléments. Si on clique sur Done, le code sélectionné dans le script est alors automatiquement mis à jour pour correspondre aux modifications effectuées. Ce qui permet d’obtenir très facilement des résultats extrêmement moches : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme(panel.grid.major = element_line(colour = &quot;dodgerblue&quot;, size = 0.5, linetype = &quot;dotdash&quot;), axis.title = element_text(family = &quot;serif&quot;, size = 18, face = &quot;italic&quot;, colour = &quot;white&quot;), axis.text = element_text(family = &quot;serif&quot;, size = 15, face = &quot;bold&quot;), axis.text.x = element_text(family = &quot;mono&quot;), plot.title = element_text(family = &quot;serif&quot;), legend.text = element_text(family = &quot;serif&quot;), legend.title = element_text(family = &quot;serif&quot;), panel.background = element_rect(fill = &quot;coral&quot;), plot.background = element_rect(fill = &quot;blueviolet&quot;)) 8.9 L’add-in esquisse esquisse est un package développé notamment par Victor Perrier de dreamRs et qui fournit une interface graphique pour la construction de graphiques avec ggplot2. Pour l’utiliser, il faut évidemment préalablement installer l’extension : install.packages(&quot;esquisse&quot;) Pour lancer l’interface, ouvrez le menu Addins dans la barre d’outils de RStudio, et cliquez sur ‘ggplot2’ builder14. Une fenêtre s’ouvre : la première étape consiste à choisir un data frame de votre environnement, et éventuellement à ne sélectionner que certaines de ses variables. Une fois le choix effectué, cliquez sur Validate imported data. L’interface principale s’affiche alors. La liste des variables du data frame apparaît en haut, et vous pouvez les faire glisser dans les zones X, Y, Fill, Color, Size et Facet pour créer des mappages. Le graphique se met automatiquement à jour. Par défaut, esquisse sélectionne le type de graphique le plus approprié selon la nature de vos variables. Mais vous pouvez choisir un autre type de graphique à l’aide de l’icône en haut à gauche, parmi onze disponibles (dont Auto): . Enfin, une série de menus en bas de l’interface vous permet de personnaliser les titres, les annotations (labels), la présentation ou de filtrer des valeurs de vos variables. Quand vous avez généré un graphique que vous souhaitez conserver, ouvrez le menu Export &amp; code : Vous y trouverez le code R correspondant au graphique actuellement affiché. Vous pouvez dès lors le copier pour le coller dans votre script, ou cliquer sur Insert code in script pour l’insérer directement dans votre script à l’endroit où se trouve votre curseur. esquisse ne propose pas (encore) tous les geom ou toutes les possibilités de ggplot2, mais ça peut être un outil très utile et pratique pour une exploration rapide de données ou lorsqu’on est un peu perdu dans la syntaxe et les fonctions de l’extension. Pour plus d’informations, vous pouvez vous référer à la page du projet sur GitHub (en anglais). 8.10 Ressources La documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne. Une “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Cheatsheets &gt; Data visualization with ggplot2) ou en ligne. Les parties Data visualisation et Graphics for communication de l’ouvrage en ligne R for data science, de Hadley Wickham, sont une très bonne introduction à ggplot2. Plusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, toujours de Hadley Wickham, et le R Graphics Cookbook de Winston Chang. Le site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes. Enfin, si ggplot2 présente déjà un très grand nombre de fonctionnalités, il existe aussi un système d’extensions permettant d’ajouter des geom, des thèmes, etc. Le site ggplot2 extensions est une très bonne ressource pour les parcourir et les découvrir, notamment grâce à sa galerie. 8.11 Exercices Pour les exercices qui suivent, on commence par charger les extensions nécessaires et les données du jeu de données rp2012. On crée alors un objet rp69 comprenant uniquement les communes du Rhône et de la Loire. library(tidyverse) library(questionr) data(rp2012) rp69 &lt;- filter(rp2012, departement %in% c(&quot;Rhône&quot;, &quot;Loire&quot;)) Exercice 1 Faire un nuage de points croisant le pourcentage de sans diplôme (dipl_aucun) et le pourcentage d’ouvriers (ouvr). ggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr)) Exercice 2 Faire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers, avec les points en rouge et de transparence 0.2. ggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr), color = &quot;red&quot;, alpha = 0.2) Exercice 3 Représenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches. ggplot(rp69) + geom_boxplot(aes(x = pop_cl, y = proprio)) Exercice 4 Représenter la répartition du nombre de communes selon la taille de la commune en classes sous la forme d’un diagramme en bâtons. ggplot(rp69) + geom_bar(aes(x = pop_cl)) Exercice 5 Faire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Faire varier la couleur selon le département (departement). ggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr, color = departement)) Sur le même graphique, faire varier la taille des points selon la population totale de la commune (pop_tot). ggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr, color = departement, size = pop_tot)) Enfin, toujours sur le même graphique, rendre les points transparents en plaçant leur opacité à 0.5. ggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr, color = departement, size = pop_tot), alpha = 0.5) Exercice 6 Représenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches. Faire varier la couleur de remplissage (attribut fill) selon le département. ggplot(rp69) + geom_boxplot(aes(x = pop_cl, y = proprio, fill = departement)) Exercice 7 Représenter la répartition du nombre de communes selon la taille de la commune en classes (variable pop_cl) sous forme de diagramme en bâtons empilés, avec une couleur différente selon le département. ggplot(rp69) + geom_bar(aes(x = pop_cl, fill = departement)) Faire varier la valeur du paramètre position pour afficher les barres les unes à côté des autres. ggplot(rp69) + geom_bar(aes(x = pop_cl, fill = departement), position = &quot;dodge&quot;) Changer à nouveau la valeur du paramètre position pour représenter les proportions de communes de chaque département pour chaque catégorie de taille. ggplot(rp69) + geom_bar(aes(x = pop_cl, fill = departement), position = &quot;fill&quot;) Exercice 8 Faire un nuage de points représentant en abscisse le pourcentage de cadres (cadres) et en ordonnée le pourcentage de diplômés du supérieur (dipl_sup). Représenter ce nuage par deux graphiques différents selon le département en utilisant facet_grid. ggplot(rp69) + geom_point(aes(x = cadres, y = dipl_sup)) + facet_grid(cols = vars(departement)) Sur le même graphique, faire varier la taille des points selon la population totale de la communes (variable pop_tot) et rendre les points transparents. ggplot(rp69) + geom_point(aes(x = cadres, y = dipl_sup, size = pop_tot), alpha = 0.5) + facet_grid(cols = vars(departement)) Exercice 9 Faire le nuage de points croisant pourcentage de chômeurs (chom) et pourcentage de sans diplôme. Y ajouter les noms des communes correspondant (variable commune), en rouge et en taille 2.5 : ggplot(rp69, aes(x = chom, y = dipl_aucun)) + geom_point() + geom_text(aes(label = commune), color = &quot;red&quot;, size = 2.5) Exercice 10 Dans le graphique précédent, n’afficher que le nom des communes ayant plus de 15% de chômage. chom15 &lt;- filter(rp69, chom &gt; 15) ggplot(rp69, aes(x = chom, y = dipl_aucun)) + geom_point(alpha = 0.15) + geom_text(data = chom15, aes(label = commune), color=&quot;red&quot;, size=3) Vous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎ "],["09-recodages.html", "Partie 9 Recoder des variables 9.1 Rappel sur les variables et les vecteurs 9.2 Tests et comparaison 9.3 Recoder une variable qualitative 9.4 Combiner plusieurs variables 9.5 Découper une variable numérique en classes 9.6 Exercices", " Partie 9 Recoder des variables 9.1 Rappel sur les variables et les vecteurs Dans R, une variable, en général une colonne d’un tableau de données, est un objet de type vecteur. Un vecteur est un ensemble d’éléments, tous du même type. On a vu qu’on peut construire un vecteur manuellement de différentes manières : couleur &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) nombres &lt;- 1:10 Mais le plus souvent on manipule des vecteurs faisant partie d’une table importée dans R. Dans ce qui suit on va utiliser le jeu de données d’exemple hdv2003 de l’extension questionr. library(questionr) data(hdv2003) Quand on veut accéder à un vecteur d’un tableau de données, on peut utiliser l’opérateur $ : hdv2003$qualif On peut facilement créer de nouvelles variables (ou colonnes) dans un tableau de données en utilisant le $ dans une assignation : hdv2003$minutes.tv &lt;- hdv2003$heures.tv * 60 Les vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent. On a ainsi des vecteurs de type integer ou double, qui contiennent respectivement des nombres entiers ou décimaux : typeof(hdv2003$age) #&gt; [1] &quot;integer&quot; typeof(hdv2003$heures.tv) #&gt; [1] &quot;double&quot; Des vecteurs de type character, qui contiennent des chaînes de caractères : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) typeof(vec) #&gt; [1] &quot;character&quot; Et des vecteurs de type logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE). vec &lt;- c(TRUE, FALSE, FALSE, TRUE) typeof(vec) #&gt; [1] &quot;logical&quot; On peut convertir un vecteur d’un type en un autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA. x &lt;- c(&quot;1&quot;, &quot;2.35&quot;, &quot;8.2e+03&quot;, &quot;foo&quot;) as.numeric(x) #&gt; Warning: NAs introduced by coercion #&gt; [1] 1.00 2.35 8200.00 NA y &lt;- 2:6 as.character(y) #&gt; [1] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; On peut sélectionner certains éléments d’un vecteur à l’aide de l’opérateur []. La manière la plus simple est d’indiquer la position des éléments qu’on veut sélectionner : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) vec[c(1,3)] #&gt; [1] &quot;Jaune&quot; &quot;Rouge&quot; La sélection peut aussi être utilisée pour modifier certains éléments d’un vecteur, par exemple : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) vec[2] &lt;- &quot;Violet&quot; vec #&gt; [1] &quot;Jaune&quot; &quot;Violet&quot; &quot;Rouge&quot; &quot;Vert&quot; 9.2 Tests et comparaison Un test est une opération logique de comparaison qui renvoie vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur. Parmi les opérateurs de comparaison disponibles, on trouve notamment : == qui teste l’égalité != qui teste la différence &gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité %in% qui teste l’appartenance à un ensemble de valeurs Exemple le plus simple : 2 == 3 #&gt; [1] FALSE 2 != 3 #&gt; [1] TRUE Exemple appliqué à un vecteur : x &lt;- 1:10 x &lt; 5 #&gt; [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE On peut combiner plusieurs tests avec les opérateurs logiques et (&amp;) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6 inclus, on peut faire : x &gt;= 3 &amp; x &lt;= 6 #&gt; [1] FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE Si on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) vec == &quot;Jaune&quot; | vec == &quot;Vert&quot; #&gt; [1] TRUE TRUE FALSE TRUE À noter que dans ce cas, on peut utiliser l’opérateur %in%15, qui teste si une valeur fait partie des éléments d’un vecteur : vec %in% c(&quot;Jaune&quot;, &quot;Vert&quot;) #&gt; [1] TRUE TRUE FALSE TRUE Attention, si on souhaite tester si une valeur x est inconnue (ou ‘manquante’), c’est-à-dire si elle est codée NA (Not Available), faire le test x == NA ne donnera pas le résultat escompté. En effet, fidèle à sa réputation de rigueur informaticienne, pour R NA == NA ne vaut pas TRUE mais… NA (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue). Pour tester si une valeur est inconnue (NA), il faut utiliser la fonction dédiée is.na et faire is.na(x). Cependant, par convention, NA %in% NA vaut TRUE. Enfin, on peut inverser un test avec l’opérateur non (!) : !(vec %in% c(&quot;Jaune&quot;, &quot;Vert&quot;)) #&gt; [1] FALSE FALSE TRUE FALSE Les tests sont notamment utilisés par le verbe filter de dplyr (voir section 10.2.2) qui permet de sélectionner certaines lignes d’un tableau de données. On peut ainsi sélectionner les individus ayant entre 20 et 40 ans en filtrant sur la variable age : filter(hdv2003, age &gt;= 20 &amp; age &lt;= 40) Ou sélectionner les personnes ayant comme catégorie socio-professionnelle Ouvrier specialise ou Ouvrier qualifie en filtrant sur la variable qualif : filter(hdv2003, qualif %in% c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;)) On peut utiliser les tests pour sélectionner certains éléments d’un vecteur. Si on passe un test à l’opérateur de sélection [], seuls les éléments pour lesquels ce test est vrai seront conservés : x &lt;- c(12, 8, 14, 7, 6, 18) x[x &gt; 10] #&gt; [1] 12 14 18 Enfin, on peut aussi utiliser les tests et la sélection pour modifier les valeurs d’un vecteur. Ainsi, si on assigne une valeur à une sélection, les éléments pour lesquels le test est vrai sont remplacés par cette valeur : x &lt;- c(12, 8, 14, 7, 6, 18) x[x &gt; 10] &lt;- 100 x #&gt; [1] 100 8 100 7 6 100 En utilisant cette assignation via un test, on peut effectuer des recodages de variables. Soit le vecteur suivant : vec &lt;- c(&quot;Femme&quot;, &quot;Homme&quot;, &quot;Femme&quot;, &quot;Garçon&quot;) Si on souhaite recoder la modalité “Garçon” en “Homme”, on peut utiliser la syntaxe suivante : vec[vec == &quot;Garçon&quot;] &lt;- &quot;Homme&quot; vec #&gt; [1] &quot;Femme&quot; &quot;Homme&quot; &quot;Femme&quot; &quot;Homme&quot; Cette synatxe est tout à fait valable et couramment utilisée, cependant dans la section suivante on va voir différentes fonctions qui facilitent ces opérations de recodage. 9.3 Recoder une variable qualitative Pour rappel, on appelle variable qualitative une variable pouvant prendre un nombre limité de modalités (de valeurs possibles). 9.3.1 Facteurs et forcats Dans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). Si vous utilisez les fonctions des extensions du tidyverse comme readr, readxl ou haven pour importer vos données, vos variables qualitatives seront importées sous forme de character. Mais dans les autres cas elles se retrouveront souvent sous forme de factor. C’est le cas dans notre jeu de données d’exemple : class(hdv2003$qualif) #&gt; [1] &quot;factor&quot; Les facteurs sont un type de variable ne pouvant prendre qu’un nombre défini de modalités nommés levels : levels(hdv2003$qualif) #&gt; [1] &quot;Ouvrier specialise&quot; &quot;Ouvrier qualifie&quot; #&gt; [3] &quot;Technicien&quot; &quot;Profession intermediaire&quot; #&gt; [5] &quot;Cadre&quot; &quot;Employe&quot; #&gt; [7] &quot;Autre&quot; Ceci complique les opérations de recodage car du coup l’opération suivante, qui tente de modifier une modalité de la variable, aboutit à un avertissement, et l’opération n’est pas effectuée : hdv2003$qualif[hdv2003$qualif == &quot;Ouvrier specialise&quot;] &lt;- &quot;Ouvrier&quot; #&gt; Warning in `[&lt;-.factor`(`*tmp*`, hdv2003$qualif == &quot;Ouvrier specialise&quot;, : #&gt; invalid factor level, NA generated forcats est une extension facilitant la manipulation des variables qualitatives, qu’elles soient sous forme de vecteurs character ou de facteurs. Elle fait partie du tidyverse, et est donc automatiquement chargée par : library(tidyverse) 9.3.2 Modifier les modalités d’une variable qualitative Une opération courante consiste à modifier les valeurs d’une variable qualitative, que ce soit pour avoir des intitulés plus courts ou plus clairs ou pour regrouper des modalités entre elles. Il existe plusieurs possibilités pour effectuer ce type de recodage, mais ici on va utiliser la fonction fct_recode de l’extension forcats. Celle-ci prend en argument une liste de recodages sous la forme \"Nouvelle valeur\" = \"Ancienne valeur\". Un exemple : f &lt;- c(&quot;Pomme&quot;, &quot;Poire&quot;, &quot;Pomme&quot;, &quot;Cerise&quot;) f &lt;- fct_recode( f, &quot;Fraise&quot; = &quot;Pomme&quot;, &quot;Ananas&quot; = &quot;Poire&quot; ) f #&gt; [1] Fraise Ananas Fraise Cerise #&gt; Levels: Cerise Ananas Fraise Autre exemple sur une “vraie” variable : freq(hdv2003$qualif) #&gt; n % val% #&gt; Ouvrier specialise 0 0.0 0.0 #&gt; Ouvrier qualifie 292 14.6 20.1 #&gt; Technicien 86 4.3 5.9 #&gt; Profession intermediaire 160 8.0 11.0 #&gt; Cadre 260 13.0 17.9 #&gt; Employe 594 29.7 41.0 #&gt; Autre 58 2.9 4.0 #&gt; NA 550 27.5 NA hdv2003$qualif5 &lt;- fct_recode( hdv2003$qualif, &quot;Ouvrier&quot; = &quot;Ouvrier specialise&quot;, &quot;Ouvrier&quot; = &quot;Ouvrier qualifie&quot;, &quot;Interm&quot; = &quot;Technicien&quot;, &quot;Interm&quot; = &quot;Profession intermediaire&quot; ) freq(hdv2003$qualif5) #&gt; n % val% #&gt; Ouvrier 292 14.6 20.1 #&gt; Interm 246 12.3 17.0 #&gt; Cadre 260 13.0 17.9 #&gt; Employe 594 29.7 41.0 #&gt; Autre 58 2.9 4.0 #&gt; NA 550 27.5 NA Attention, les anciennes valeurs saisies doivent être exactement égales aux valeurs des modalités de la variable recodée : toute différence d’accent ou d’espace fera que ce recodage ne sera pas pris en compte. Dans ce cas, forcats affiche un avertissement nous indiquant qu’une valeur saisie n’a pas été trouvée dans les modalités de la variable : hdv2003$qualif_test &lt;- fct_recode( hdv2003$qualif, &quot;Ouvrier&quot; = &quot;Ouvrier spécialisé&quot;, &quot;Ouvrier&quot; = &quot;Ouvrier qualifié&quot; ) #&gt; Warning: Unknown levels in `f`: Ouvrier spécialisé, Ouvrier qualifié Si on souhaite recoder une modalité de la variable en NA, il faut (contre intuitivement) lui assigner la valeur NULL : hdv2003$qualif_rec &lt;- fct_recode( hdv2003$qualif, NULL = &quot;Autre&quot; ) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Ouvrier specialise 0 0.0 0.0 #&gt; Ouvrier qualifie 292 14.6 21.0 #&gt; Technicien 86 4.3 6.2 #&gt; Profession intermediaire 160 8.0 11.5 #&gt; Cadre 260 13.0 18.7 #&gt; Employe 594 29.7 42.7 #&gt; NA 608 30.4 NA À l’inverse, si on souhaite recoder les NA d’une variable, on utilisera la fonction fct_explicit_na, qui convertit toutes les valeurs manquantes (NA) d’un facteur en une modalité spécifique : hdv2003$qualif_rec &lt;- fct_explicit_na(hdv2003$qualif, na_level = &quot;(Manquant)&quot;) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Ouvrier specialise 0 0.0 0.0 #&gt; Ouvrier qualifie 292 14.6 14.6 #&gt; Technicien 86 4.3 4.3 #&gt; Profession intermediaire 160 8.0 8.0 #&gt; Cadre 260 13.0 13.0 #&gt; Employe 594 29.7 29.7 #&gt; Autre 58 2.9 2.9 #&gt; (Manquant) 550 27.5 27.5 D’autres fonctions sont proposées par forcats pour faciliter certains recodage, comme fct_collapse, qui propose une autre syntaxe pratique quand on doit regrouper ensemble des modalités : hdv2003$qualif_rec &lt;- fct_collapse( hdv2003$qualif, &quot;Ouvrier&quot; = c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;), &quot;Interm&quot; = c(&quot;Technicien&quot;, &quot;Profession intermediaire&quot;) ) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Ouvrier 292 14.6 20.1 #&gt; Interm 246 12.3 17.0 #&gt; Cadre 260 13.0 17.9 #&gt; Employe 594 29.7 41.0 #&gt; Autre 58 2.9 4.0 #&gt; NA 550 27.5 NA fct_other, qui regroupe une liste de modalités en une seule modalité “Other” : hdv2003$qualif_rec &lt;- fct_other( hdv2003$qualif, drop = c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;, &quot;Cadre&quot;, &quot;Autre&quot;) ) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Technicien 86 4.3 5.9 #&gt; Profession intermediaire 160 8.0 11.0 #&gt; Employe 594 29.7 41.0 #&gt; Other 610 30.5 42.1 #&gt; NA 550 27.5 NA fct_lump, qui regroupe automatiquement les modalités les moins fréquentes en une seule modalité “Other” (avec possibilité d’indiquer des seuils de regroupement) : hdv2003$qualif_rec &lt;- fct_lump(hdv2003$qualif) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Ouvrier qualifie 292 14.6 20.1 #&gt; Profession intermediaire 160 8.0 11.0 #&gt; Cadre 260 13.0 17.9 #&gt; Employe 594 29.7 41.0 #&gt; Other 144 7.2 9.9 #&gt; NA 550 27.5 NA 9.3.2.1 Interface graphique de recodage L’extension questionr propose une interface graphique facilitant le recodage des modalités d’une variable qualitative. L’objectif est de permettre à la personne qui l’utilise de saisir les nouvelles valeurs dans un formulaire, et de générer ensuite le code R correspondant au recodage indiqué. Pour utiliser cette interface, sous RStudio vous pouvez aller dans le menu Addins (présent dans la barre d’outils principale) puis choisir Levels recoding. Sinon, vous pouvez lancer dans la console la fonction irec() en lui passant comme paramètre la variable à recoder. Interface graphique de irec L’interface se compose de trois onglets : l’onglet Variable et paramètres vous permet de sélectionner la variable à recoder, le nom de la nouvelle variable et d’autres paramètres, l’onglet Recodages vous permet de saisir les nouvelles valeurs des modalités, et l’onglet Code et résultat affiche le code R correspondant ainsi qu’un tableau permettant de vérifier les résultats. Une fois votre recodage terminé, cliquez sur le bouton Done et le code R sera inséré dans votre script R ou affiché dans la console. Attention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le recodage soit réellement effectif. 9.3.3 Ordonner les modalités d’une variable qualitative L’avantage des facteurs (par rapport aux vecteurs de type character) est que leurs modalités peuvent être ordonnées, ce qui peut faciliter la lecture de tableaux ou graphiques. On peut ordonner les modalités d’un facteur manuellement, par exemple avec la fonction fct_relevel() de l’extension forcats : hdv2003$qualif_rec &lt;- fct_relevel( hdv2003$qualif, &quot;Cadre&quot;, &quot;Profession intermediaire&quot;, &quot;Technicien&quot;, &quot;Employe&quot;, &quot;Ouvrier qualifie&quot;, &quot;Ouvrier specialise&quot;, &quot;Autre&quot; ) freq(hdv2003$qualif_rec) #&gt; n % val% #&gt; Cadre 260 13.0 17.9 #&gt; Profession intermediaire 160 8.0 11.0 #&gt; Technicien 86 4.3 5.9 #&gt; Employe 594 29.7 41.0 #&gt; Ouvrier qualifie 292 14.6 20.1 #&gt; Ouvrier specialise 0 0.0 0.0 #&gt; Autre 58 2.9 4.0 #&gt; NA 550 27.5 NA Une autre possibilité est d’ordonner les modalités d’un facteur selon les valeurs d’une autre variable. Par exemple, si on représente le boxplot de la répartition de l’âge selon le statut d’occupation : library(ggplot2) ggplot(hdv2003) + geom_boxplot(aes(x = occup, y = age)) Le graphique pourrait être plus lisible si les modalités étaient triées par âge median croissant. Ceci est possible en utilisant fct_reorder. Celle-ci prend 3 arguments : le facteur à réordonner, la variable dont les valeurs doivent être utilisées pour ce réordonnancement, et enfin une fonction à appliquer à cette deuxième variable. hdv2003$occup_age &lt;- fct_reorder(hdv2003$occup, hdv2003$age, median) ggplot(hdv2003) + geom_boxplot(aes(x = occup_age, y = age)) On peut aussi effectuer le réordonnancement directement dans l’appel à ggplot2, sans créer de nouvelle variable : ggplot(hdv2003) + geom_boxplot(aes(x = fct_reorder(occup, age, median), y = age)) Lorsqu’on effectue un diagramme en barres avec geom_bar, on peut aussi réordonner les modalités selon leurs effectifs à l’aide de fct_infreq : ggplot(hdv2003) + geom_bar(aes(x = fct_infreq(occup))) 9.3.3.1 Interface graphique questionr propose une interface graphique afin de faciliter les opérations de réordonnancement manuel. Pour la lancer, sélectionner le menu Addins puis Levels ordering, ou exécuter la fonction iorder() en lui passant comme paramètre le facteur à réordonner. Interface graphique de iorder Le fonctionnement de l’interface est similaire à celui de l’interface de recodage. Vous pouvez réordonner les modalités en les faisant glisser avec la souris, puis récupérer et exécuter le code R généré. 9.4 Combiner plusieurs variables Parfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions if_else pour les cas les plus simples, ou case_when pour les cas plus complexes. Ces deux fonctions sont incluses dans l’extension dplyr, qu’il faut donc avoir chargé précédemment. 9.4.1 if_else if_else prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux. Voici un exemple simple : v &lt;- c(12, 14, 8, 16) if_else(v &gt; 10, &quot;Supérieur à 10&quot;, &quot;Inférieur à 10&quot;) #&gt; [1] &quot;Supérieur à 10&quot; &quot;Supérieur à 10&quot; &quot;Inférieur à 10&quot; &quot;Supérieur à 10&quot; La fonction devient plus intéressante avec des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans : hdv2003$statut &lt;- if_else( hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$age &gt; 60, &quot;Homme de plus de 60 ans&quot;, &quot;Autre&quot; ) freq(hdv2003$statut) #&gt; n % val% #&gt; Autre 1778 88.9 88.9 #&gt; Homme de plus de 60 ans 222 11.1 11.1 9.4.2 case_when case_when est une génération du if_else qui permet d’indiquer plusieurs tests et leurs valeurs associées. Imaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante : hdv2003$statut &lt;- case_when( hdv2003$age &gt; 60 &amp; hdv2003$sexe == &quot;Homme&quot; ~ &quot;Homme de plus de 60 ans&quot;, hdv2003$age &gt; 60 &amp; hdv2003$sexe == &quot;Femme&quot; ~ &quot;Femme de plus de 60 ans&quot;, TRUE ~ &quot;Autre&quot; ) freq(hdv2003$statut) #&gt; n % val% #&gt; Autre 1512 75.6 75.6 #&gt; Femme de plus de 60 ans 266 13.3 13.3 #&gt; Homme de plus de 60 ans 222 11.1 11.1 case_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée. La clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie. Attention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général. Par exemple le recodage suivant ne fonctionne pas : hdv2003$statut &lt;- case_when( hdv2003$sexe == &quot;Homme&quot; ~ &quot;Homme&quot;, hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$age &gt; 60 ~ &quot;Homme de plus de 60 ans&quot;, TRUE ~ &quot;Autre&quot; ) freq(hdv2003$statut) #&gt; n % val% #&gt; Autre 1101 55 55 #&gt; Homme 899 45 45 Comme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" &amp; age &gt; 60, cette deuxième condition n’est jamais testée ! On n’obtiendra jamais la valeur correspondante. Pour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général : hdv2003$statut &lt;- case_when( hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$age &gt; 60 ~ &quot;Homme de plus de 60 ans&quot;, hdv2003$sexe == &quot;Homme&quot; ~ &quot;Homme&quot;, TRUE ~ &quot;Autre&quot; ) freq(hdv2003$statut) #&gt; n % val% #&gt; Autre 1101 55.0 55.0 #&gt; Homme 677 33.9 33.9 #&gt; Homme de plus de 60 ans 222 11.1 11.1 9.5 Découper une variable numérique en classes Une autre opération relativement courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer une variable revenu contenant le revenu mensuel en une variable qualitative avec des catégories Moins de 500 euros, 500-1000 euros, etc. On utilise pour cela la fonction cut() : hdv2003$agecl &lt;- cut(hdv2003$age, breaks = 5) freq(hdv2003$agecl) #&gt; n % val% #&gt; (17.9,33.8] 454 22.7 22.7 #&gt; (33.8,49.6] 628 31.4 31.4 #&gt; (49.6,65.4] 556 27.8 27.8 #&gt; (65.4,81.2] 319 16.0 16.0 #&gt; (81.2,97.1] 43 2.1 2.1 Si on donne un nombre entier à l’argument breaks, un nombre correspondant de classes d’amplitudes égales sont automatiquement calculées. Il est souvent préférable cependant d’avoir des limites “rondes”, on peut alors spécifier ces dernières manuellement en passant un vecteur à breaks : hdv2003$agecl &lt;- cut( hdv2003$age, breaks = c(18, 25, 35, 45, 55, 65, 97), include.lowest = TRUE ) freq(hdv2003$agecl) #&gt; n % val% #&gt; [18,25] 191 9.6 9.6 #&gt; (25,35] 338 16.9 16.9 #&gt; (35,45] 390 19.5 19.5 #&gt; (45,55] 414 20.7 20.7 #&gt; (55,65] 305 15.2 15.2 #&gt; (65,97] 362 18.1 18.1 Ici on a été obligé d’ajouter l’argument include.lowest = TRUE car sinon la valeur 18 n’aurait pas été incluse, et on aurait eu des valeurs manquantes. 9.5.1 Interface graphique Comme l’utilisation des arguments de cut n’est pas toujours très intuitive, l’extension questionr propose une interface graphique facilitant cette opération de découpage en classes d’une variable numérique. Pour lancer cette interface, sous RStudio ouvrir le menu Addins et sélectionner Numeric range dividing, ou exécuter la fonction icut() dans la console en lui passant comme argument la variable quantitative à découper. Interface graphique de icut Vous pouvez alors choisir la variable à découper dans l’onglet Variable et paramètres, indiquer les limites de vos classes ainsi que quelques options complémentaires dans l’onglet Découpage en classes, et vérifier le résultat dans l’onglet Code et résultat. Une fois le résultat satisfaisant, cliquez sur Done : si vous êtes sous RStudio le code généré sera directement inséré dans votre script actuel à l’emplacement du curseur. Sinon, ce code sera affiché dans la console et vous pourrez le copier/coller pour l’inclure dans votre script. Attention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le découpage soit réellement effectif. 9.6 Exercices 9.6.1 Préparation Pour la plupart de ces exercices, on a besoin des extensions forcats et questionr, et du jeu de données d’exemple hdv2003. library(forcats) library(questionr) data(hdv2003) 9.6.2 Vecteurs et tests Exercice 1.1 Construire le vecteur suivant : x &lt;- c(&quot;12&quot;, &quot;3.5&quot;, &quot;421&quot;, &quot;2,4&quot;) Et le convertir en vecteur numérique. Que remarquez-vous ? as.numeric(x) ## Un nombre avec une virgule comme séparateur décimal ## renvoie NA Exercice 1.2 Construire le vecteur suivant : x &lt;- c(1, 20, 21, 15.5, 14, 12, 8) Écrire le test qui indique si les éléments du vecteur sont strictement supérieurs à 15. Utiliser ce test pour extraire du vecteur les éléments correspondants. x &gt; 15 x[x &gt; 15] Exercice 1.3 Le code suivant génère un vecteur de 1000 nombres aléatoires compris entre 0 et 10 : x &lt;- runif(1000, 0, 10) Combien d’éléments de ce vecteur sont compris entre 2 et 4 ? ## Possibilité 1 length(x[x &gt;= 2 &amp; x &lt;= 4]) ## Possibilité 2 table(x &gt;= 2 &amp; x &lt;= 4) 9.6.3 Recodages de variable qualitative Exercice 2.1 Construire un vecteur f à l’aide du code suivant : f &lt;- c(&quot;Jan&quot;, &quot;Jan&quot;, &quot;Fev&quot;, &quot;Juil&quot;) Recoder le vecteur à l’aide de la fonction fct_recode pour obtenir le résultat suivant : #&gt; [1] Janvier Janvier Février Juillet #&gt; Levels: Février Janvier Juillet f &lt;- fct_recode(f, &quot;Janvier&quot; = &quot;Jan&quot;, &quot;Février&quot; = &quot;Fev&quot;, &quot;Juillet&quot; = &quot;Juil&quot;) f Exercice 2.2 À l’aide de l’interface graphique de questionr, recoder la variable relig du jeu de données hdv2003 pour obtenir le tri à plat suivant (il se peut que l’ordre des modalités dans le tri à plat soit différent) : #&gt; n % val% #&gt; Pratiquant 708 35.4 35.4 #&gt; Appartenance 760 38.0 38.0 #&gt; Ni croyance ni appartenance 399 20.0 20.0 #&gt; Rejet 93 4.7 4.7 #&gt; NSP 40 2.0 2.0 hdv2003$relig_rec &lt;- fct_recode( hdv2003$relig, &quot;Pratiquant&quot; = &quot;Pratiquant regulier&quot;, &quot;Pratiquant&quot; = &quot;Pratiquant occasionnel&quot;, &quot;Appartenance&quot; = &quot;Appartenance sans pratique&quot;, &quot;NSP&quot; = &quot;NSP ou NVPR&quot; ) freq(hdv2003$relig_rec) Exercice 2.3 À l’aide de l’interface graphique de questionr, recoder la variable nivetud pour obtenir le tri à plat suivant (il se peut que l’ordre des modalités dans le tri à plat soit différent) : #&gt; n % val% #&gt; N&#39;a jamais fait d&#39;etudes 39 2.0 2.1 #&gt; Études primaires 427 21.3 22.6 #&gt; 1er cycle 204 10.2 10.8 #&gt; 2eme cycle 183 9.2 9.7 #&gt; Enseignement technique ou professionnel 594 29.7 31.5 #&gt; Enseignement superieur 441 22.0 23.4 #&gt; NA 112 5.6 NA hdv2003$nivetud_rec &lt;- fct_recode( hdv2003$nivetud, &quot;Études primaires&quot; = &quot;A arrete ses etudes, avant la derniere annee d&#39;etudes primaires&quot;, &quot;Études primaires&quot; = &quot;Derniere annee d&#39;etudes primaires&quot;, &quot;Enseignement technique ou professionnel&quot; = &quot;Enseignement technique ou professionnel court&quot;, &quot;Enseignement technique ou professionnel&quot; = &quot;Enseignement technique ou professionnel long&quot;, &quot;Enseignement superieur&quot; = &quot;Enseignement superieur y compris technique superieur&quot; ) freq(hdv2003$nivetud_rec) Toujours à l’aide de l’interface graphique, réordonner les modalités de cette variable recodée pour obtenir le tri à plat suivant : #&gt; n % val% #&gt; Enseignement superieur 441 22.0 23.4 #&gt; Enseignement technique ou professionnel 594 29.7 31.5 #&gt; 2eme cycle 183 9.2 9.7 #&gt; 1er cycle 204 10.2 10.8 #&gt; Études primaires 427 21.3 22.6 #&gt; N&#39;a jamais fait d&#39;etudes 39 2.0 2.1 #&gt; NA 112 5.6 NA hdv2003$nivetud_rec &lt;- factor( hdv2003$nivetud_rec, levels = c( &quot;Enseignement superieur&quot;, &quot;Enseignement technique ou professionnel&quot;, &quot;2eme cycle&quot;, &quot;1er cycle&quot;, &quot;Études primaires&quot;, &quot;N&#39;a jamais fait d&#39;etudes&quot; ) ) freq(hdv2003$nivetud_rec) Exercice 2.4 À l’aide de la fonction fct_reorder, trier les modalités de la variable relig du jeu de données hdv2003 selon leur âge médian. Vérifier en générant le boxplot suivant : hdv2003$relig &lt;- fct_reorder(hdv2003$relig, hdv2003$age, median) ggplot(hdv2003) + geom_boxplot(aes(x = relig, y = age)) 9.6.4 Combiner plusieurs variables Exercice 3.1 À l’aide de la fonction if_else, créer une nouvelle variable cinema_bd permettant d’identifier les personnes qui vont au cinéma et déclarent lire des bandes dessinées. Vous devriez obtenir le tri à plat suivant pour cette nouvelle variable : #&gt; n % val% #&gt; Autre 1971 98.6 98.6 #&gt; Cinéma et BD 29 1.5 1.5 hdv2003$cinema_bd &lt;- if_else( hdv2003$cinema == &quot;Oui&quot; &amp; hdv2003$lecture.bd == &quot;Oui&quot;, &quot;Cinéma et BD&quot;, &quot;Autre&quot; ) freq(hdv2003$cinema_bd) Exercice 3.2 À l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes : Homme ayant plus de 2 frères et soeurs Femme ayant plus de 2 frères et soeurs Autre Vous devriez obtenir le tri à plat suivant : #&gt; n % val% #&gt; Autre 1001 50.0 50.0 #&gt; Femme ayant plus de 2 frères et soeurs 546 27.3 27.3 #&gt; Homme ayant plus de 2 frères et soeurs 453 22.7 22.7 hdv2003$groupe &lt;- case_when( hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$freres.soeurs &gt; 2 ~ &quot;Homme ayant plus de 2 frères et soeurs&quot;, hdv2003$sexe == &quot;Femme&quot; &amp; hdv2003$freres.soeurs &gt; 2 ~ &quot;Femme ayant plus de 2 frères et soeurs&quot;, TRUE ~ &quot;Autre&quot; ) freq(hdv2003$groupe) Exercice 3.3 À l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes : Homme de plus de 30 ans Homme de plus de 40 ans satisfait par son travail Femme pratiquant le sport ou le bricolage Autre Vous devriez obtenir le tri à plat suivant : #&gt; n % val% #&gt; Autre 714 35.7 35.7 #&gt; Femme pratiquant le sport ou le bricolage 549 27.5 27.5 #&gt; Homme de plus de 30 ans 610 30.5 30.5 #&gt; Homme de plus de 40 ans satisfait par son travail 127 6.3 6.3 hdv2003$groupe &lt;- case_when( hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$age &gt; 40 &amp; hdv2003$trav.satisf == &quot;Satisfaction&quot; ~ &quot;Homme de plus de 40 ans satisfait par son travail&quot;, hdv2003$sexe == &quot;Homme&quot; &amp; hdv2003$age &gt; 30 ~ &quot;Homme de plus de 30 ans&quot;, hdv2003$sexe == &quot;Femme&quot; &amp; (hdv2003$sport == &quot;Oui&quot; | hdv2003$bricol == &quot;Oui&quot;) ~ &quot;Femme pratiquant le sport ou le bricolage&quot;, TRUE ~ &quot;Autre&quot; ) freq(hdv2003$groupe) 9.6.5 Découper une variable numérique Exercice 4.1 Dans le jeu de données hdv2003, découper la variable heures.tv en classes de manière à obtenir au final le tri à plat suivant : #&gt; n % val% #&gt; [0,1] 684 34.2 34.3 #&gt; (1,2] 535 26.8 26.8 #&gt; (2,4] 594 29.7 29.8 #&gt; (4,6] 138 6.9 6.9 #&gt; (6,12] 44 2.2 2.2 #&gt; NA 5 0.2 NA hdv2003$tv_cl &lt;- cut( hdv2003$heures.tv, include.lowest = TRUE, right = TRUE, breaks = c(0, 1, 2, 4, 6, 12) ) freq(hdv2003$tv_cl) Pour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎ "],["10-dplyr.html", "Partie 10 Manipuler les données avec dplyr 10.1 Préparation 10.2 Les verbes de dplyr 10.3 Enchaîner les opérations avec le pipe 10.4 Opérations groupées 10.5 Autres fonctions utiles 10.6 Tables multiples 10.7 Ressources 10.8 Exercices", " Partie 10 Manipuler les données avec dplyr dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type. Ses fonctions sont en général plus rapides que leur équivalent sous R de base, elles permettent donc de traiter efficacement des données de grande dimension. dplyr part du principe que les données sont organisées selon le modèle des tidy data (voir la section 6.3). Les fonctions de l’extension peuvent s’appliquer à des tableaux de type data.frame ou tibble, et elles retournent systématiquement un tibble (voir la section 6.4). Le code présent dans ce document nécessite d’avoir installé la version 1.0 de dplyr (ou plus récente). 10.1 Préparation dplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec : library(tidyverse) On peut également la charger individuellement avec : library(dplyr) Dans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables : flights contient des informations sur les vols : date, départ, destination, horaires, retard… airports contient des informations sur les aéroports airlines contient des données sur les compagnies aériennes On va charger les trois tables du jeu de données : library(nycflights13) ## Chargement des trois tables data(flights) data(airports) data(airlines) Trois objets correspondant aux trois tables ont dû apparaître dans votre environnement. 10.2 Les verbes de dplyr La manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données. 10.2.1 slice Le verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres. Si on souhaite sélectionner la 345e ligne du tableau airports : slice(airports, 345) #&gt; # A tibble: 1 × 8 #&gt; faa name lat lon alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 CYF Chefornak Airport 60.1 -164. 40 -9 A America/Anchorage Si on veut sélectionner les 5 premières lignes : slice(airports, 1:5) #&gt; # A tibble: 5 × 8 #&gt; faa name lat lon alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/New… #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A America/Chi… #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/Chi… #&gt; 4 06N Randall Airport 41.4 -74.4 523 -5 A America/New… #&gt; 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/New… 10.2.2 filter filter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir la section 9.2. Par exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante : filter(flights, month == 1) #&gt; # A tibble: 27,004 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; 7 2013 1 1 555 600 -5 913 854 #&gt; 8 2013 1 1 557 600 -3 709 723 #&gt; 9 2013 1 1 557 600 -3 838 846 #&gt; 10 2013 1 1 558 600 -2 753 745 #&gt; # … with 26,994 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes : filter(flights, dep_delay &gt;= 10 &amp; dep_delay &lt;= 15) #&gt; # A tibble: 14,919 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 611 600 11 945 931 #&gt; 2 2013 1 1 623 610 13 920 915 #&gt; 3 2013 1 1 743 730 13 1107 1100 #&gt; 4 2013 1 1 743 730 13 1059 1056 #&gt; 5 2013 1 1 851 840 11 1215 1206 #&gt; 6 2013 1 1 912 900 12 1241 1220 #&gt; 7 2013 1 1 914 900 14 1058 1043 #&gt; 8 2013 1 1 920 905 15 1039 1025 #&gt; 9 2013 1 1 1011 1001 10 1133 1128 #&gt; 10 2013 1 1 1112 1100 12 1440 1438 #&gt; # … with 14,909 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat : filter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15) On peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols avec la plus grande distance : filter(flights, distance == max(distance)) #&gt; # A tibble: 342 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 857 900 -3 1516 1530 #&gt; 2 2013 1 2 909 900 9 1525 1530 #&gt; 3 2013 1 3 914 900 14 1504 1530 #&gt; 4 2013 1 4 900 900 0 1516 1530 #&gt; 5 2013 1 5 858 900 -2 1519 1530 #&gt; 6 2013 1 6 1019 900 79 1558 1530 #&gt; 7 2013 1 7 1042 900 102 1620 1530 #&gt; 8 2013 1 8 901 900 1 1504 1530 #&gt; 9 2013 1 9 641 900 1301 1242 1530 #&gt; 10 2013 1 10 859 900 -1 1449 1530 #&gt; # … with 332 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 10.2.3 select et rename select permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports : select(airports, lat, lon) #&gt; # A tibble: 1,458 × 2 #&gt; lat lon #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 41.1 -80.6 #&gt; 2 32.5 -85.7 #&gt; 3 42.0 -88.1 #&gt; 4 41.4 -74.4 #&gt; 5 31.1 -81.4 #&gt; 6 36.4 -82.2 #&gt; 7 41.5 -84.5 #&gt; 8 42.9 -76.8 #&gt; 9 39.8 -76.6 #&gt; 10 48.1 -123. #&gt; # … with 1,448 more rows Si on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée : select(airports, -lat, -lon) #&gt; # A tibble: 1,458 × 6 #&gt; faa name alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 1044 -5 A America/New_York #&gt; 2 06A Moton Field Municipal Airport 264 -6 A America/Chicago #&gt; 3 06C Schaumburg Regional 801 -6 A America/Chicago #&gt; 4 06N Randall Airport 523 -5 A America/New_York #&gt; 5 09J Jekyll Island Airport 11 -5 A America/New_York #&gt; 6 0A9 Elizabethton Municipal Airport 1593 -5 A America/New_York #&gt; 7 0G6 Williams County Airport 730 -5 A America/New_York #&gt; 8 0G7 Finger Lakes Regional Airport 492 -5 A America/New_York #&gt; 9 0P2 Shoestring Aviation Airfield 1000 -5 U America/New_York #&gt; 10 0S9 Jefferson County Intl 108 -8 A America/Los_Angeles #&gt; # … with 1,448 more rows select comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables : select(flights, starts_with(&quot;dep_&quot;)) #&gt; # A tibble: 336,776 × 2 #&gt; dep_time dep_delay #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 2 #&gt; 2 533 4 #&gt; 3 542 2 #&gt; 4 544 -1 #&gt; 5 554 -6 #&gt; 6 554 -4 #&gt; 7 555 -5 #&gt; 8 557 -3 #&gt; 9 557 -3 #&gt; 10 558 -2 #&gt; # … with 336,766 more rows La syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses16 : select(flights, year:day) #&gt; # A tibble: 336,776 × 3 #&gt; year month day #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 #&gt; 2 2013 1 1 #&gt; 3 2013 1 1 #&gt; 4 2013 1 1 #&gt; 5 2013 1 1 #&gt; 6 2013 1 1 #&gt; 7 2013 1 1 #&gt; 8 2013 1 1 #&gt; 9 2013 1 1 #&gt; 10 2013 1 1 #&gt; # … with 336,766 more rows Une variante de select est rename17, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude : rename(airports, longitude = lon, latitude = lat) #&gt; # A tibble: 1,458 × 8 #&gt; faa name latitude longitude alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/New_… #&gt; 2 06A Moton Field Municip… 32.5 -85.7 264 -6 A America/Chic… #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/Chic… #&gt; 4 06N Randall Airport 41.4 -74.4 523 -5 A America/New_… #&gt; 5 09J Jekyll Island Airpo… 31.1 -81.4 11 -5 A America/New_… #&gt; 6 0A9 Elizabethton Munici… 36.4 -82.2 1593 -5 A America/New_… #&gt; 7 0G6 Williams County Air… 41.5 -84.5 730 -5 A America/New_… #&gt; 8 0G7 Finger Lakes Region… 42.9 -76.8 492 -5 A America/New_… #&gt; 9 0P2 Shoestring Aviation… 39.8 -76.6 1000 -5 U America/New_… #&gt; 10 0S9 Jefferson County In… 48.1 -123. 108 -8 A America/Los_… #&gt; # … with 1,448 more rows Si les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) : tmp &lt;- rename( flights, &quot;retard départ&quot; = dep_delay, &quot;retard arrivée&quot; = arr_delay ) select(tmp, `retard départ`, `retard arrivée`) #&gt; # A tibble: 336,776 × 2 #&gt; `retard départ` `retard arrivée` #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2 11 #&gt; 2 4 20 #&gt; 3 2 33 #&gt; 4 -1 -18 #&gt; 5 -6 -25 #&gt; 6 -4 12 #&gt; 7 -5 19 #&gt; 8 -3 -14 #&gt; 9 -3 -8 #&gt; 10 -2 8 #&gt; # … with 336,766 more rows 10.2.4 arrange arrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes. Ainsi, si on veut trier le tableau flights selon le retard au départ croissant : arrange(flights, dep_delay) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 12 7 2040 2123 -43 40 2352 #&gt; 2 2013 2 3 2022 2055 -33 2240 2338 #&gt; 3 2013 11 10 1408 1440 -32 1549 1559 #&gt; 4 2013 1 11 1900 1930 -30 2233 2243 #&gt; 5 2013 1 29 1703 1730 -27 1947 1957 #&gt; 6 2013 8 9 729 755 -26 1002 955 #&gt; 7 2013 10 23 1907 1932 -25 2143 2143 #&gt; 8 2013 3 30 2030 2055 -25 2213 2250 #&gt; 9 2013 3 2 1431 1455 -24 1601 1631 #&gt; 10 2013 5 5 934 958 -24 1225 1309 #&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; On peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ : arrange(flights, month, dep_delay) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 11 1900 1930 -30 2233 2243 #&gt; 2 2013 1 29 1703 1730 -27 1947 1957 #&gt; 3 2013 1 12 1354 1416 -22 1606 1650 #&gt; 4 2013 1 21 2137 2159 -22 2232 2316 #&gt; 5 2013 1 20 704 725 -21 1025 1035 #&gt; 6 2013 1 12 2050 2110 -20 2310 2355 #&gt; 7 2013 1 12 2134 2154 -20 4 50 #&gt; 8 2013 1 14 2050 2110 -20 2329 2355 #&gt; 9 2013 1 4 2140 2159 -19 2241 2316 #&gt; 10 2013 1 11 1947 2005 -18 2209 2230 #&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() : arrange(flights, desc(dep_delay)) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; 7 2013 3 17 2321 810 911 135 1020 #&gt; 8 2013 6 27 959 1900 899 1236 2226 #&gt; 9 2013 7 22 2257 759 898 121 1026 #&gt; 10 2013 12 5 756 1700 896 1058 2020 #&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Combiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard : tmp &lt;- arrange(flights, desc(dep_delay)) slice(tmp, 1:3) #&gt; # A tibble: 3 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; # … with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 10.2.5 mutate mutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes. Par exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire : flights &lt;- mutate(flights, duree_h = air_time / 60) select(flights, air_time, duree_h) #&gt; # A tibble: 336,776 × 2 #&gt; air_time duree_h #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 227 3.78 #&gt; 2 227 3.78 #&gt; 3 160 2.67 #&gt; 4 183 3.05 #&gt; 5 116 1.93 #&gt; 6 150 2.5 #&gt; 7 158 2.63 #&gt; 8 53 0.883 #&gt; 9 140 2.33 #&gt; 10 138 2.3 #&gt; # … with 336,766 more rows On peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h. flights &lt;- mutate( flights, duree_h = air_time / 60, distance_km = distance / 0.62137, vitesse = distance_km / duree_h ) select(flights, air_time, duree_h, distance, distance_km, vitesse) #&gt; # A tibble: 336,776 × 5 #&gt; air_time duree_h distance distance_km vitesse #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 227 3.78 1400 2253. 596. #&gt; 2 227 3.78 1416 2279. 602. #&gt; 3 160 2.67 1089 1753. 657. #&gt; 4 183 3.05 1576 2536. 832. #&gt; 5 116 1.93 762 1226. 634. #&gt; 6 150 2.5 719 1157. 463. #&gt; 7 158 2.63 1065 1714. 651. #&gt; 8 53 0.883 229 369. 417. #&gt; 9 140 2.33 944 1519. 651. #&gt; 10 138 2.3 733 1180. 513. #&gt; # … with 336,766 more rows À noter que mutate est évidemment parfaitement compatible avec les fonctions vues dans le chapitre 9 sur les recodages : fct_recode, if_else, case_when… L’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un if_else ou d’un case_when : flights &lt;- mutate( flights, type_retard = case_when( dep_delay &gt; 0 &amp; arr_delay &gt; 0 ~ &quot;Retard départ et arrivée&quot;, dep_delay &gt; 0 &amp; arr_delay &lt;= 0 ~ &quot;Retard départ&quot;, dep_delay &lt;= 0 &amp; arr_delay &gt; 0 ~ &quot;Retard arrivée&quot;, TRUE ~ &quot;Aucun retard&quot; ) ) Ensuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante. 10.3 Enchaîner les opérations avec le pipe Quand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc. Quand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” : arrange(select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay), dep_delay) Cette notation a plusieurs inconvénients : elle est peu lisible les opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier. Il est difficile de voir quel paramètre se rapporte à quelle fonction Une autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire : tmp &lt;- filter(flights, dest == &quot;LAX&quot;) tmp &lt;- select(tmp, dep_delay, arr_delay) arrange(tmp, dep_delay) C’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin. Pour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe18. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr). Ainsi les deux expressions suivantes sont rigoureusement équivalentes : filter(flights, dest == &quot;LAX&quot;) flights %&gt;% filter(dest == &quot;LAX&quot;) Ce qui est intéressant dans cette histoire, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire : select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay) On va pouvoir faire : flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) À chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select. Le résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire. Si la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne : flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) %&gt;% arrange(dep_delay) On appelle une suite d’instructions de ce type un pipeline. Évidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. Par exemple, on peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante : delay_la &lt;- flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) %&gt;% arrange(dep_delay) Dans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange. Cette notation n’est pas forcément très intuitive au départ. Il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne. Une manière de le comprendre peut être de voir que la notation suivante : delay_la &lt;- flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) est équivalente à : delay_la &lt;- (flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay)) L’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit. Depuis la version 4.1, R propose un pipe “natif”, qui fonctionne partout, même si on n’utilise pas les extensions du tidyverse. Celui-ci est noté |&gt;. Il s’utilise de la même manière que %&gt;% : flights |&gt; filter(dest == “LAX”) Ce pipe natif est à la fois un peu plus rapide et un peu moins souple. Par exemple, il est possible avec %&gt;% d’appeler une fonction sans mettre de parenthèses : df %&gt;% View Ce n’est pas possible d’omettre les parenthèses avec |&gt;, on doit obligatoirement faire : df |&gt; View() Dans la suite de ce document on privilégiera (pour l’instant) le pipe du tidyverse %&gt;%, pour des raisons de compatibilité avec des versions de R moins récentes. 10.4 Opérations groupées 10.4.1 group_by Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois : flights %&gt;% group_by(month) #&gt; # A tibble: 336,776 × 22 #&gt; # Groups: month [12] #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; 7 2013 1 1 555 600 -5 913 854 #&gt; 8 2013 1 1 557 600 -3 709 723 #&gt; 9 2013 1 1 557 600 -3 838 846 #&gt; 10 2013 1 1 558 600 -2 753 745 #&gt; # … with 336,766 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Par défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations. Par exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau : flights %&gt;% group_by(month) %&gt;% slice(1) #&gt; # A tibble: 12 × 22 #&gt; # Groups: month [12] #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 2 1 456 500 -4 652 648 #&gt; 3 2013 3 1 4 2159 125 318 56 #&gt; 4 2013 4 1 454 500 -6 636 640 #&gt; 5 2013 5 1 9 1655 434 308 2020 #&gt; 6 2013 6 1 2 2359 3 341 350 #&gt; 7 2013 7 1 1 2029 212 236 2359 #&gt; 8 2013 8 1 12 2130 162 257 14 #&gt; 9 2013 9 1 9 2359 10 343 340 #&gt; 10 2013 10 1 447 500 -13 614 648 #&gt; 11 2013 11 1 5 2359 6 352 345 #&gt; 12 2013 12 1 13 2359 14 446 445 #&gt; # … with 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, #&gt; # distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Idem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie : flights %&gt;% group_by(carrier) %&gt;% mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;% select(dep_delay, month, mean_delay_carrier) #&gt; Adding missing grouping variables: `carrier` #&gt; # A tibble: 336,776 × 4 #&gt; # Groups: carrier [16] #&gt; carrier dep_delay month mean_delay_carrier #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 UA 2 1 12.1 #&gt; 2 UA 4 1 12.1 #&gt; 3 AA 2 1 8.59 #&gt; 4 B6 -1 1 13.0 #&gt; 5 DL -6 1 9.26 #&gt; 6 UA -4 1 12.1 #&gt; 7 B6 -5 1 13.0 #&gt; 8 EV -3 1 20.0 #&gt; 9 B6 -3 1 13.0 #&gt; 10 AA -2 1 8.59 #&gt; # … with 336,766 more rows Ceci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie : flights %&gt;% group_by(carrier) %&gt;% mutate( median_delay = median(dep_delay, na.rm = TRUE), delay_carrier = if_else( dep_delay &gt; median_delay, &quot;Supérieur&quot;, &quot;Inférieur ou égal&quot; ) ) %&gt;% select(dep_delay, month, median_delay, delay_carrier) #&gt; Adding missing grouping variables: `carrier` #&gt; # A tibble: 336,776 × 5 #&gt; # Groups: carrier [16] #&gt; carrier dep_delay month median_delay delay_carrier #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 UA 2 1 0 Supérieur #&gt; 2 UA 4 1 0 Supérieur #&gt; 3 AA 2 1 -3 Supérieur #&gt; 4 B6 -1 1 -1 Inférieur ou égal #&gt; 5 DL -6 1 -2 Inférieur ou égal #&gt; 6 UA -4 1 0 Inférieur ou égal #&gt; 7 B6 -5 1 -1 Inférieur ou égal #&gt; 8 EV -3 1 -1 Inférieur ou égal #&gt; 9 B6 -3 1 -1 Inférieur ou égal #&gt; 10 AA -2 1 -3 Supérieur #&gt; # … with 336,766 more rows group_by peut aussi être utile avec filter, par exemple pour sélectionner les vols avec le retard au départ le plus important pour chaque mois : flights %&gt;% group_by(month) %&gt;% filter(dep_delay == max(dep_delay, na.rm = TRUE)) #&gt; # A tibble: 12 × 22 #&gt; # Groups: month [12] #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 10 14 2042 900 702 2255 1127 #&gt; 3 2013 11 3 603 1645 798 829 1913 #&gt; 4 2013 12 5 756 1700 896 1058 2020 #&gt; 5 2013 2 10 2243 830 853 100 1106 #&gt; 6 2013 3 17 2321 810 911 135 1020 #&gt; 7 2013 4 10 1100 1900 960 1342 2211 #&gt; 8 2013 5 3 1133 2055 878 1250 2215 #&gt; 9 2013 6 15 1432 1935 1137 1607 2120 #&gt; 10 2013 7 22 845 1600 1005 1044 1815 #&gt; 11 2013 8 8 2334 1454 520 120 1710 #&gt; 12 2013 9 20 1139 1845 1014 1457 2210 #&gt; # … with 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, #&gt; # distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Attention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE. On peut voir la différence en comparant les deux résultats suivants : flights %&gt;% group_by(month) %&gt;% arrange(desc(dep_delay)) #&gt; # A tibble: 336,776 × 22 #&gt; # Groups: month [12] #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; 7 2013 3 17 2321 810 911 135 1020 #&gt; 8 2013 6 27 959 1900 899 1236 2226 #&gt; 9 2013 7 22 2257 759 898 121 1026 #&gt; 10 2013 12 5 756 1700 896 1058 2020 #&gt; # … with 336,766 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; flights %&gt;% group_by(month) %&gt;% arrange(desc(dep_delay), .by_group = TRUE) #&gt; # A tibble: 336,776 × 22 #&gt; # Groups: month [12] #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 1 10 1121 1635 1126 1239 1810 #&gt; 3 2013 1 1 848 1835 853 1001 1950 #&gt; 4 2013 1 13 1809 810 599 2054 1042 #&gt; 5 2013 1 16 1622 800 502 1911 1054 #&gt; 6 2013 1 23 1551 753 478 1812 1006 #&gt; 7 2013 1 10 1525 900 385 1713 1039 #&gt; 8 2013 1 1 2343 1724 379 314 1938 #&gt; 9 2013 1 2 2131 1512 379 2340 1741 #&gt; 10 2013 1 7 2021 1415 366 2332 1724 #&gt; # … with 336,766 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; 10.4.2 summarise et count summarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights : flights %&gt;% summarise( retard_dep = mean(dep_delay, na.rm = TRUE), retard_arr = mean(arr_delay, na.rm = TRUE) ) #&gt; # A tibble: 1 × 2 #&gt; retard_dep retard_arr #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 12.6 6.90 Cette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire : flights %&gt;% group_by(month) %&gt;% summarise( max_delay = max(dep_delay, na.rm = TRUE), min_delay = min(dep_delay, na.rm = TRUE), mean_delay = mean(dep_delay, na.rm = TRUE) ) #&gt; # A tibble: 12 × 4 #&gt; month max_delay min_delay mean_delay #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1301 -30 10.0 #&gt; 2 2 853 -33 10.8 #&gt; 3 3 911 -25 13.2 #&gt; 4 4 960 -21 13.9 #&gt; 5 5 878 -24 13.0 #&gt; 6 6 1137 -21 20.8 #&gt; 7 7 1005 -22 21.7 #&gt; 8 8 520 -26 12.6 #&gt; 9 9 1014 -24 6.72 #&gt; 10 10 702 -25 6.24 #&gt; 11 11 798 -32 5.44 #&gt; 12 12 896 -43 16.6 summarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser : flights %&gt;% group_by(dest) %&gt;% summarise(nb = n()) #&gt; # A tibble: 105 × 2 #&gt; dest nb #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 265 #&gt; 3 ALB 439 #&gt; 4 ANC 8 #&gt; 5 ATL 17215 #&gt; 6 AUS 2439 #&gt; 7 AVL 275 #&gt; 8 BDL 443 #&gt; 9 BGR 375 #&gt; 10 BHM 297 #&gt; # … with 95 more rows n() peut aussi être utilisée avec filter et mutate. À noter que quand on veut compter le nombre de lignes par groupe, on peut utiliser directement la fonction count. Ainsi le code suivant est identique au précédent : flights %&gt;% count(dest) #&gt; # A tibble: 105 × 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 265 #&gt; 3 ALB 439 #&gt; 4 ANC 8 #&gt; 5 ATL 17215 #&gt; 6 AUS 2439 #&gt; 7 AVL 275 #&gt; 8 BDL 443 #&gt; 9 BGR 375 #&gt; 10 BHM 297 #&gt; # … with 95 more rows Lorsque la variable de groupage est un facteur et que certaines valeurs du facteur ne sont pas présentes dans le tableau, l’argument .drop = FALSE de group_by permet de conserver ces niveaux dans le résultat d’une opération groupée. Par exemple, si on transforme la variable origin en facteur pour conserver la liste de ses modalités, et qu’on ne garde que les vols à destination de San Francisco (code SFO) : ff &lt;- flights %&gt;% mutate(origin = factor(origin)) %&gt;% filter(dest == &quot;SFO&quot;) Par défaut, si on compte le nombre de vols selon l’aéroport de départ, La Guardia n’apparaît pas car il ne compte aucun vol : ff %&gt;% group_by(origin) %&gt;% summarise(n = n()) #&gt; # A tibble: 2 × 2 #&gt; origin n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 EWR 5127 #&gt; 2 JFK 8204 Si on souhaite faire apparaître cette information dans la sortie du summarise, on peut ajouter l’argument .drop = FALSE au group_by : ff %&gt;% group_by(origin, .drop = FALSE) %&gt;% summarise(n = n()) #&gt; # A tibble: 3 × 2 #&gt; origin n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 EWR 5127 #&gt; 2 JFK 8204 #&gt; 3 LGA 0 Cet argument fonctionne aussi avec count : ff %&gt;% count(origin, .drop = FALSE) #&gt; # A tibble: 3 × 2 #&gt; origin n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 EWR 5127 #&gt; 2 JFK 8204 #&gt; 3 LGA 0 10.4.3 Grouper selon plusieurs variables On peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant le nombre de vols pour chaque mois et pour chaque destination, et trie le résultat par nombre de vols décroissant : flights %&gt;% group_by(month, dest) %&gt;% summarise(nb = n()) %&gt;% arrange(desc(nb)) #&gt; `summarise()` has grouped output by &#39;month&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 1,113 × 3 #&gt; # Groups: month [12] #&gt; month dest nb #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 8 ORD 1604 #&gt; 2 10 ORD 1604 #&gt; 3 5 ORD 1582 #&gt; 4 9 ORD 1582 #&gt; 5 7 ORD 1573 #&gt; 6 6 ORD 1547 #&gt; 7 7 ATL 1511 #&gt; 8 8 ATL 1507 #&gt; 9 8 LAX 1505 #&gt; 10 7 LAX 1500 #&gt; # … with 1,103 more rows On peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut : flights %&gt;% count(origin, dest) %&gt;% arrange(desc(n)) #&gt; # A tibble: 224 × 3 #&gt; origin dest n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 JFK LAX 11262 #&gt; 2 LGA ATL 10263 #&gt; 3 LGA ORD 8857 #&gt; 4 JFK SFO 8204 #&gt; 5 LGA CLT 6168 #&gt; 6 EWR ORD 6100 #&gt; 7 JFK BOS 5898 #&gt; 8 LGA MIA 5781 #&gt; 9 JFK MCO 5464 #&gt; 10 EWR BOS 5327 #&gt; # … with 214 more rows On peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le triplet compagnie aérienne / aéroport de départ / aéroport d’arrivée ayant le plus grand nombre de vols selon le mois de l’année, on devra procéder en deux étapes : d’abord grouper selon mois, compagnie, aéroports d’origine et d’arrivée pour calculer le nombre de vols puis grouper uniquement selon le mois pour sélectionner la ligne avec la valeur maximale. Au final, on obtient le code suivant : flights %&gt;% group_by(month, carrier, origin, dest) %&gt;% summarise(nb = n()) %&gt;% group_by(month) %&gt;% filter(nb == max(nb)) #&gt; `summarise()` has grouped output by &#39;month&#39;, &#39;carrier&#39;, &#39;origin&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 13 × 5 #&gt; # Groups: month [12] #&gt; month carrier origin dest nb #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 AA LGA DFW 437 #&gt; 2 1 DL LGA ATL 437 #&gt; 3 2 DL LGA ATL 402 #&gt; 4 3 DL LGA ATL 461 #&gt; 5 4 AA LGA ORD 501 #&gt; 6 5 AA LGA ORD 518 #&gt; 7 6 AA LGA ORD 520 #&gt; 8 7 AA LGA ORD 551 #&gt; 9 8 AA LGA ORD 545 #&gt; 10 9 AA LGA ORD 492 #&gt; 11 10 AA LGA ORD 516 #&gt; 12 11 DL LGA ATL 471 #&gt; 13 12 DL LGA ATL 489 Lorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est groupé par month et origin : flights %&gt;% group_by(month, origin, dest) %&gt;% summarise(nb = n()) #&gt; `summarise()` has grouped output by &#39;month&#39;, &#39;origin&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 2,313 × 4 #&gt; # Groups: month, origin [36] #&gt; month origin dest nb #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 EWR ALB 64 #&gt; 2 1 EWR ATL 362 #&gt; 3 1 EWR AUS 51 #&gt; 4 1 EWR AVL 2 #&gt; 5 1 EWR BDL 37 #&gt; 6 1 EWR BNA 111 #&gt; 7 1 EWR BOS 430 #&gt; 8 1 EWR BQN 31 #&gt; 9 1 EWR BTV 100 #&gt; 10 1 EWR BUF 119 #&gt; # … with 2,303 more rows Cela peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le pourcentage des trajets pour chaque destination par rapport à tous les trajets du mois : flights %&gt;% group_by(month, dest) %&gt;% summarise(nb = n()) %&gt;% mutate(pourcentage = nb / sum(nb) * 100) #&gt; `summarise()` has grouped output by &#39;month&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 1,113 × 4 #&gt; # Groups: month [12] #&gt; month dest nb pourcentage #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 ALB 64 0.237 #&gt; 2 1 ATL 1396 5.17 #&gt; 3 1 AUS 169 0.626 #&gt; 4 1 AVL 2 0.00741 #&gt; 5 1 BDL 37 0.137 #&gt; 6 1 BHM 25 0.0926 #&gt; 7 1 BNA 399 1.48 #&gt; 8 1 BOS 1245 4.61 #&gt; 9 1 BQN 93 0.344 #&gt; 10 1 BTV 223 0.826 #&gt; # … with 1,103 more rows On peut à tout moment “dégrouper” un tableau à l’aide de ungroup. Ce serait par exemple nécessaire, dans l’exemple précédent, si on voulait calculer le pourcentage sur le nombre total de vols plutôt que sur le nombre de vols par mois : flights %&gt;% group_by(month, dest) %&gt;% summarise(nb = n()) %&gt;% ungroup() %&gt;% mutate(pourcentage = nb / sum(nb) * 100) #&gt; `summarise()` has grouped output by &#39;month&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 1,113 × 4 #&gt; month dest nb pourcentage #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 ALB 64 0.0190 #&gt; 2 1 ATL 1396 0.415 #&gt; 3 1 AUS 169 0.0502 #&gt; 4 1 AVL 2 0.000594 #&gt; 5 1 BDL 37 0.0110 #&gt; 6 1 BHM 25 0.00742 #&gt; 7 1 BNA 399 0.118 #&gt; 8 1 BOS 1245 0.370 #&gt; 9 1 BQN 93 0.0276 #&gt; 10 1 BTV 223 0.0662 #&gt; # … with 1,103 more rows À noter que count, par contre, renvoie un tableau non groupé : flights %&gt;% count(month, dest) #&gt; # A tibble: 1,113 × 3 #&gt; month dest n #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 ALB 64 #&gt; 2 1 ATL 1396 #&gt; 3 1 AUS 169 #&gt; 4 1 AVL 2 #&gt; 5 1 BDL 37 #&gt; 6 1 BHM 25 #&gt; 7 1 BNA 399 #&gt; 8 1 BOS 1245 #&gt; 9 1 BQN 93 #&gt; 10 1 BTV 223 #&gt; # … with 1,103 more rows 10.5 Autres fonctions utiles dplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données. 10.5.1 slice_sample Ce verbe permet de sélectionner aléatoirement un nombre de lignes (avec l’argument n) ou une fraction des lignes (avec l’argument prop) d’un tableau. Ainsi si on veut choisir 5 lignes au hasard dans le tableau airports : airports %&gt;% slice_sample(n = 5) #&gt; # A tibble: 5 × 8 #&gt; faa name lat lon alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 24C Lowell City Airport 43.0 -85.3 681 -5 A America/New… #&gt; 2 DUJ DuBois Regional Airport 41.2 -78.9 1817 -5 A America/New… #&gt; 3 X59 Valkaria Municipal 28.0 -80.6 26 -5 A America/New… #&gt; 4 CTJ West Georgia Regional Airpo… 33.6 -85.2 1165 -5 A America/New… #&gt; 5 VBG Vandenberg Afb 34.7 -121. 369 -8 A America/Los… Si on veut tirer au hasard 10% des lignes de flights : flights %&gt;% slice_sample(prop = 0.1) #&gt; # A tibble: 33,677 × 22 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 8 8 1154 1200 -6 1436 1450 #&gt; 2 2013 8 4 1446 1455 -9 1631 1645 #&gt; 3 2013 4 11 2254 2120 94 35 2315 #&gt; 4 2013 1 21 1957 1815 102 2237 2037 #&gt; 5 2013 10 14 1244 1245 -1 1525 1600 #&gt; 6 2013 7 7 2306 1835 271 40 2010 #&gt; 7 2013 3 4 1401 1343 18 1706 1715 #&gt; 8 2013 11 12 1138 1135 3 1507 1439 #&gt; 9 2013 10 29 635 630 5 809 813 #&gt; 10 2013 12 23 740 745 -5 1006 1015 #&gt; # … with 33,667 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Ces fonctions sont utiles notamment pour faire de “l’échantillonnage” en tirant au hasard un certain nombre d’observations du tableau. 10.5.2 slice_head, slice_tail, slice_min, slice_max slice_head et slice_tail permettent de sélectionner les premières ou dernière lignes d’un tableau. On peut indiquer le nombre (avec n) ou la proportion (avec prop) de lignes qu’on souhaite. Ainsi si on veut afficher les trois premières lignes d’airport : airports %&gt;% slice_head(n = 3) #&gt; # A tibble: 3 × 8 #&gt; faa name lat lon alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/New… #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A America/Chi… #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/Chi… Si on veut afficher les dernières 20% des lignes de airlines : airlines %&gt;% slice_tail(prop = 0.2) #&gt; # A tibble: 3 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 VX Virgin America #&gt; 2 WN Southwest Airlines Co. #&gt; 3 YV Mesa Airlines Inc. slice_min et slice_max prennent en argument supplémentaire une variable du tableau et affichent n ou prop lignes du tableau ayant les valeurs les plus ou les moins élevées de cette variable. Ainsi si on veut les 1% de lignes de flights ayant les plus fortes valeurs de dep_delay : flights %&gt;% slice_max(dep_delay, prop = 0.01) #&gt; # A tibble: 3,387 × 22 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; 7 2013 3 17 2321 810 911 135 1020 #&gt; 8 2013 6 27 959 1900 899 1236 2226 #&gt; 9 2013 7 22 2257 759 898 121 1026 #&gt; 10 2013 12 5 756 1700 896 1058 2020 #&gt; # … with 3,377 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Si on veut les 2 aéroports avec l’altitude la plus basse : airports %&gt;% slice_min(alt, n = 2) #&gt; # A tibble: 2 × 8 #&gt; faa name lat lon alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 IPL Imperial Co 32.8 -116. -54 -8 A America/Los_Angeles #&gt; 2 NJK El Centro Naf 32.8 -116. -42 -8 A America/Los_Angeles On notera que le tableau renvoyé par slice_min et slice_max est trié selon la variable d’intérêt. 10.5.3 lead et lag lead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag). lead(1:5) #&gt; [1] 2 3 4 5 NA lag(1:5) #&gt; [1] NA 1 2 3 4 Ceci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre le retard au départ de chaque vol et celui du vol précédent : flights %&gt;% mutate( dep_delay_prev = lag(dep_delay), dep_delay_diff = dep_delay - dep_delay_prev ) %&gt;% select(dep_delay_prev, dep_delay, dep_delay_diff) #&gt; # A tibble: 336,776 × 3 #&gt; dep_delay_prev dep_delay dep_delay_diff #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 NA 2 NA #&gt; 2 2 4 2 #&gt; 3 4 2 -2 #&gt; 4 2 -1 -3 #&gt; 5 -1 -6 -5 #&gt; 6 -6 -4 2 #&gt; 7 -4 -5 -1 #&gt; 8 -5 -3 2 #&gt; 9 -3 -3 0 #&gt; 10 -3 -2 1 #&gt; # … with 336,766 more rows 10.5.4 distinct et n_distinct distinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double. flights %&gt;% select(day, month) %&gt;% distinct #&gt; # A tibble: 365 × 2 #&gt; day month #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 3 1 #&gt; 4 4 1 #&gt; 5 5 1 #&gt; 6 6 1 #&gt; 7 7 1 #&gt; 8 8 1 #&gt; 9 9 1 #&gt; 10 10 1 #&gt; # … with 355 more rows On peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles. flights %&gt;% distinct(month, day) #&gt; # A tibble: 365 × 2 #&gt; month day #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 1 2 #&gt; 3 1 3 #&gt; 4 1 4 #&gt; 5 1 5 #&gt; 6 1 6 #&gt; 7 1 7 #&gt; 8 1 8 #&gt; 9 1 9 #&gt; 10 1 10 #&gt; # … with 355 more rows L’option .keep_all permet, dans l’opération précédente, de conserver l’ensemble des colonnes du tableau : flights %&gt;% distinct(month, day, .keep_all = TRUE) #&gt; # A tibble: 365 × 22 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 2 42 2359 43 518 442 #&gt; 3 2013 1 3 32 2359 33 504 442 #&gt; 4 2013 1 4 25 2359 26 505 442 #&gt; 5 2013 1 5 14 2359 15 503 445 #&gt; 6 2013 1 6 16 2359 17 451 442 #&gt; 7 2013 1 7 49 2359 50 531 444 #&gt; 8 2013 1 8 454 500 -6 625 648 #&gt; 9 2013 1 9 2 2359 3 432 444 #&gt; 10 2013 1 10 3 2359 4 426 437 #&gt; # … with 355 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, #&gt; # distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; La fonction n_distinct, elle, renvoie le nombre de valeurs distinctes d’un vecteur. On peut notamment l’utiliser dans un summarise. Dans l’exemple qui suit on calcule, pour les trois aéroports de départ de la table flights le nombre de valeurs distinctes de l’aéroport d’arrivée : flights %&gt;% group_by(origin) %&gt;% summarise(n_dest = n_distinct(dest)) #&gt; # A tibble: 3 × 2 #&gt; origin n_dest #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 EWR 86 #&gt; 2 JFK 70 #&gt; 3 LGA 68 10.5.5 relocate relocate peut être utilisé pour réordonner les colonnes d’une table. Par défaut, si on lui passe un ou plusieurs noms de colonnes, relocate les place en début de tableau : airports %&gt;% relocate(lat, lon) #&gt; # A tibble: 1,458 × 8 #&gt; lat lon faa name alt tz dst tzone #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 41.1 -80.6 04G Lansdowne Airport 1044 -5 A America/… #&gt; 2 32.5 -85.7 06A Moton Field Municipal Airport 264 -6 A America/… #&gt; 3 42.0 -88.1 06C Schaumburg Regional 801 -6 A America/… #&gt; 4 41.4 -74.4 06N Randall Airport 523 -5 A America/… #&gt; 5 31.1 -81.4 09J Jekyll Island Airport 11 -5 A America/… #&gt; 6 36.4 -82.2 0A9 Elizabethton Municipal Airport 1593 -5 A America/… #&gt; 7 41.5 -84.5 0G6 Williams County Airport 730 -5 A America/… #&gt; 8 42.9 -76.8 0G7 Finger Lakes Regional Airport 492 -5 A America/… #&gt; 9 39.8 -76.6 0P2 Shoestring Aviation Airfield 1000 -5 U America/… #&gt; 10 48.1 -123. 0S9 Jefferson County Intl 108 -8 A America/… #&gt; # … with 1,448 more rows Les arguments supplémentaires .before et .after permettent de préciser à quel endroit déplacer la ou les colonnes indiquées : airports %&gt;% relocate(starts_with(&#39;tz&#39;), .after = name) #&gt; # A tibble: 1,458 × 8 #&gt; faa name tz tzone lat lon alt dst #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport -5 America/… 41.1 -80.6 1044 A #&gt; 2 06A Moton Field Municipal Airport -6 America/… 32.5 -85.7 264 A #&gt; 3 06C Schaumburg Regional -6 America/… 42.0 -88.1 801 A #&gt; 4 06N Randall Airport -5 America/… 41.4 -74.4 523 A #&gt; 5 09J Jekyll Island Airport -5 America/… 31.1 -81.4 11 A #&gt; 6 0A9 Elizabethton Municipal Airport -5 America/… 36.4 -82.2 1593 A #&gt; 7 0G6 Williams County Airport -5 America/… 41.5 -84.5 730 A #&gt; 8 0G7 Finger Lakes Regional Airport -5 America/… 42.9 -76.8 492 A #&gt; 9 0P2 Shoestring Aviation Airfield -5 America/… 39.8 -76.6 1000 U #&gt; 10 0S9 Jefferson County Intl -8 America/… 48.1 -123. 108 A #&gt; # … with 1,448 more rows 10.6 Tables multiples Le jeu de données nycflights13 est un exemple de données réparties en plusieurs tables. Ici on en a trois : les informations sur les vols dans flights, celles sur les aéroports dans airports et celles sur les compagnies aériennes dans airlines. dplyr propose différentes fonctions permettant de travailler avec des données structurées de cette manière. 10.6.1 Concaténation : bind_rows et bind_cols Les fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables. L’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows. On commence par créer trois tableaux t1, t2 et t3 : t1 &lt;- airports %&gt;% select(faa, name, lat, lon) %&gt;% slice(1:2) t1 #&gt; # A tibble: 2 × 4 #&gt; faa name lat lon #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 t2 &lt;- airports %&gt;% select(faa, name, lat, lon) %&gt;% slice(5:6) t2 #&gt; # A tibble: 2 × 4 #&gt; faa name lat lon #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 09J Jekyll Island Airport 31.1 -81.4 #&gt; 2 0A9 Elizabethton Municipal Airport 36.4 -82.2 t3 &lt;- airports %&gt;% select(faa, name) %&gt;% slice(100:101) t3 #&gt; # A tibble: 2 × 2 #&gt; faa name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ADW Andrews Afb #&gt; 2 AET Allakaket Airport On concaténe ensuite les trois tables avec bind_rows : bind_rows(t1, t2, t3) #&gt; # A tibble: 6 × 4 #&gt; faa name lat lon #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 #&gt; 3 09J Jekyll Island Airport 31.1 -81.4 #&gt; 4 0A9 Elizabethton Municipal Airport 36.4 -82.2 #&gt; 5 ADW Andrews Afb NA NA #&gt; 6 AET Allakaket Airport NA NA On remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes lat et lon de t3, des NA sont automatiquement insérées. Il peut être utile, quand on concatène des lignes, de garder une trace du tableau d’origine de chacune des lignes dans le tableau final. C’est possible grâce à l’argument .id de bind_rows. On passe à cet argument le nom d’une colonne qui contiendra l’indicateur d’origine des lignes : bind_rows(t1, t2, t3, .id = &quot;source&quot;) #&gt; # A tibble: 6 × 5 #&gt; source faa name lat lon #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 04G Lansdowne Airport 41.1 -80.6 #&gt; 2 1 06A Moton Field Municipal Airport 32.5 -85.7 #&gt; 3 2 09J Jekyll Island Airport 31.1 -81.4 #&gt; 4 2 0A9 Elizabethton Municipal Airport 36.4 -82.2 #&gt; 5 3 ADW Andrews Afb NA NA #&gt; 6 3 AET Allakaket Airport NA NA Par défaut la colonne .id ne contient qu’un nombre, différent pour chaque tableau. On peut lui spécifier des valeurs plus explicites en “nommant” les tables dans bind_rows de la manière suivante : bind_rows(table1 = t1, table2 = t2, table3 = t3, .id = &quot;source&quot;) #&gt; # A tibble: 6 × 5 #&gt; source faa name lat lon #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 table1 04G Lansdowne Airport 41.1 -80.6 #&gt; 2 table1 06A Moton Field Municipal Airport 32.5 -85.7 #&gt; 3 table2 09J Jekyll Island Airport 31.1 -81.4 #&gt; 4 table2 0A9 Elizabethton Municipal Airport 36.4 -82.2 #&gt; 5 table3 ADW Andrews Afb NA NA #&gt; 6 table3 AET Allakaket Airport NA NA bind_cols permet de concaténer des colonnes et fonctionne de manière similaire : t1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time) t2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest) t3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time) bind_cols(t1, t2, t3) #&gt; # A tibble: 5 × 6 #&gt; dep_delay dep_time origin dest arr_delay arr_time #&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2 517 EWR IAH 11 830 #&gt; 2 4 533 LGA IAH 20 850 #&gt; 3 2 542 JFK MIA 33 923 #&gt; 4 -1 544 JFK BQN -18 1004 #&gt; 5 -6 554 LGA ATL -25 812 À noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit être identique). Pour associer des tables par valeur, on doit utiliser des jointures. 10.6.2 Jointures 10.6.2.1 Clés implicites Très souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient seulement le code de la compagnie aérienne du vol dans la variable carrier : flights %&gt;% select(carrier) #&gt; # A tibble: 336,776 × 1 #&gt; carrier #&gt; &lt;chr&gt; #&gt; 1 UA #&gt; 2 UA #&gt; 3 AA #&gt; 4 B6 #&gt; 5 DL #&gt; 6 UA #&gt; 7 B6 #&gt; 8 EV #&gt; 9 B6 #&gt; 10 AA #&gt; # … with 336,766 more rows Et que par ailleurs la table airlines contient une information supplémentaire relative à ces compagnies, à savoir le nom complet. airlines #&gt; # A tibble: 16 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E Endeavor Air Inc. #&gt; 2 AA American Airlines Inc. #&gt; 3 AS Alaska Airlines Inc. #&gt; 4 B6 JetBlue Airways #&gt; 5 DL Delta Air Lines Inc. #&gt; 6 EV ExpressJet Airlines Inc. #&gt; 7 F9 Frontier Airlines Inc. #&gt; 8 FL AirTran Airways Corporation #&gt; 9 HA Hawaiian Airlines Inc. #&gt; 10 MQ Envoy Air #&gt; 11 OO SkyWest Airlines Inc. #&gt; 12 UA United Air Lines Inc. #&gt; 13 US US Airways Inc. #&gt; 14 VX Virgin America #&gt; 15 WN Southwest Airlines Co. #&gt; 16 YV Mesa Airlines Inc. Il est donc naturel de vouloir associer les deux, en l’occurrence pour ajouter les noms complets des compagnies à la table flights. Dans ce cas on va faire une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés. Pour faire une jointure de ce type, on va utiliser la fonction left_join : left_join(flights, airlines) Pour faciliter la lecture, on va afficher seulement certaines colonnes du résultat : left_join(flights, airlines) %&gt;% select(month, day, carrier, name) #&gt; Joining, by = &quot;carrier&quot; #&gt; # A tibble: 336,776 × 4 #&gt; month day carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 1 UA United Air Lines Inc. #&gt; 2 1 1 UA United Air Lines Inc. #&gt; 3 1 1 AA American Airlines Inc. #&gt; 4 1 1 B6 JetBlue Airways #&gt; 5 1 1 DL Delta Air Lines Inc. #&gt; 6 1 1 UA United Air Lines Inc. #&gt; 7 1 1 B6 JetBlue Airways #&gt; 8 1 1 EV ExpressJet Airlines Inc. #&gt; 9 1 1 B6 JetBlue Airways #&gt; 10 1 1 AA American Airlines Inc. #&gt; # … with 336,766 more rows On voit que la table résultat est bien la fusion des deux tables d’origine selon les valeurs des deux colonnes clés carrier. On est parti de la table flights, et pour chaque ligne on a ajouté les colonnes de airlines pour lesquelles la valeur de carrier est la même. On a donc bien une nouvelle colonne name dans notre table résultat, avec le nom complet de la compagnie aérienne. À noter qu’on peut tout à fait utiliser le pipe avec les fonctions de jointure : flights %&gt;% left_join(airlines). Nous sommes ici dans le cas le plus simple concernant les clés de jointure : les deux clés sont uniques et portent le même nom dans les deux tables. Par défaut, si on ne lui spécifie pas explicitement les clés, dplyr fusionne en utilisant l’ensemble des colonnes communes aux deux tables. On peut d’ailleurs voir dans cet exemple qu’un message a été affiché précisant que la jointure s’est faite sur la variable carrier. 10.6.2.2 Clés explicites La table airports, elle, contient des informations supplémentaires sur les aéroports : nom complet, altitude, position géographique, etc. Chaque aéroport est identifié par un code contenu dans la colonne faa. Si on regarde la table flights, on voit que le code d’identification des aéroports apparaît à deux endroits différents : pour l’aéroport de départ dans la colonne origin, et pour celui d’arrivée dans la colonne dest. On a donc deux clés de jointure possibles, et qui portent un nom différent de la clé de airports. On va commencer par fusionner les données concernant l’aéroport de départ. Pour simplifier l’affichage des résultats, on va se contenter d’un sous-ensemble des deux tables : flights_ex &lt;- flights %&gt;% select(month, day, origin, dest) airports_ex &lt;- airports %&gt;% select(faa, alt, name) Si on se contente d’un left_join comme à l’étape précédente, on obtient un message d’erreur car aucune colonne commune ne peut être identifiée comme clé de jointure : left_join(flights_ex, airports_ex) #&gt; Error: `by` must be supplied when `x` and `y` have no common variables. #&gt; ℹ use by = character()` to perform a cross-join. On doit donc spécifier explicitement les clés avec l’argument by de left_join. Ici la clé est nommée origin dans la première table, et faa dans la seconde. La syntaxe est donc la suivante : left_join(flights_ex, airports_ex, by = c(&quot;origin&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 × 6 #&gt; month day origin dest alt name #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 1 EWR IAH 18 Newark Liberty Intl #&gt; 2 1 1 LGA IAH 22 La Guardia #&gt; 3 1 1 JFK MIA 13 John F Kennedy Intl #&gt; 4 1 1 JFK BQN 13 John F Kennedy Intl #&gt; 5 1 1 LGA ATL 22 La Guardia #&gt; 6 1 1 EWR ORD 18 Newark Liberty Intl #&gt; 7 1 1 EWR FLL 18 Newark Liberty Intl #&gt; 8 1 1 LGA IAD 22 La Guardia #&gt; 9 1 1 JFK MCO 13 John F Kennedy Intl #&gt; 10 1 1 LGA ORD 22 La Guardia #&gt; # … with 336,766 more rows On constate que les deux nouvelles colonnes name et alt contiennent bien les données correspondant à l’aéroport de départ. On va stocker le résultat de cette jointure dans la table flights_ex : flights_ex &lt;- flights_ex %&gt;% left_join(airports_ex, by = c(&quot;origin&quot; = &quot;faa&quot;)) Supposons qu’on souhaite maintenant fusionner à nouveau les informations de la table airports, mais cette fois pour les aéroports d’arrivée de notre nouvelle table flights_ex. Les deux clés sont donc désormais dest dans la première table, et faa dans la deuxième. La syntaxe est donc la suivante : left_join(flights_ex, airports_ex, by=c(&quot;dest&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 × 8 #&gt; month day origin dest alt.x name.x alt.y name.y #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 1 EWR IAH 18 Newark Liberty Intl 97 George Bush Interco… #&gt; 2 1 1 LGA IAH 22 La Guardia 97 George Bush Interco… #&gt; 3 1 1 JFK MIA 13 John F Kennedy Intl 8 Miami Intl #&gt; 4 1 1 JFK BQN 13 John F Kennedy Intl NA &lt;NA&gt; #&gt; 5 1 1 LGA ATL 22 La Guardia 1026 Hartsfield Jackson … #&gt; 6 1 1 EWR ORD 18 Newark Liberty Intl 668 Chicago Ohare Intl #&gt; 7 1 1 EWR FLL 18 Newark Liberty Intl 9 Fort Lauderdale Hol… #&gt; 8 1 1 LGA IAD 22 La Guardia 313 Washington Dulles I… #&gt; 9 1 1 JFK MCO 13 John F Kennedy Intl 96 Orlando Intl #&gt; 10 1 1 LGA ORD 22 La Guardia 668 Chicago Ohare Intl #&gt; # … with 336,766 more rows Cela fonctionne, les informations de l’aéroport d’arrivée ont bien été ajoutées, mais on constate que les colonnes ont été renommées. En effet, ici les deux tables fusionnées contenaient toutes les deux des colonnes name et alt. Comme on ne peut pas avoir deux colonnes avec le même nom dans un tableau, dplyr a renommé les colonnes de la première table en name.x et alt.x, et celles de la deuxième en name.y et alt.y. C’est pratique, mais pas forcément très parlant. On pourrait renommer manuellement les colonnes avec rename avant de faire la jointure pour avoir des intitulés plus explicites, mais on peut aussi utiliser l’argument suffix de left_join, qui permet d’indiquer les suffixes à ajouter aux colonnes. Ainsi, on peut faire : left_join(flights_ex, airports_ex, by = c(&quot;dest&quot; = &quot;faa&quot;), suffix = c(&quot;_depart&quot;, &quot;_arrivee&quot;)) #&gt; # A tibble: 336,776 × 8 #&gt; month day origin dest alt_depart name_depart alt_arrivee name_arrivee #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 1 EWR IAH 18 Newark Liber… 97 George Bush In… #&gt; 2 1 1 LGA IAH 22 La Guardia 97 George Bush In… #&gt; 3 1 1 JFK MIA 13 John F Kenne… 8 Miami Intl #&gt; 4 1 1 JFK BQN 13 John F Kenne… NA &lt;NA&gt; #&gt; 5 1 1 LGA ATL 22 La Guardia 1026 Hartsfield Jac… #&gt; 6 1 1 EWR ORD 18 Newark Liber… 668 Chicago Ohare … #&gt; 7 1 1 EWR FLL 18 Newark Liber… 9 Fort Lauderdal… #&gt; 8 1 1 LGA IAD 22 La Guardia 313 Washington Dul… #&gt; 9 1 1 JFK MCO 13 John F Kenne… 96 Orlando Intl #&gt; 10 1 1 LGA ORD 22 La Guardia 668 Chicago Ohare … #&gt; # … with 336,766 more rows On obtient ainsi directement des noms de colonnes nettement plus clairs. 10.6.3 Types de jointures Jusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures. Partons de deux tables d’exemple, personnes et voitures : personnes &lt;- tibble( nom = c(&quot;Sylvie&quot;, &quot;Sylvie&quot;, &quot;Monique&quot;, &quot;Gunter&quot;, &quot;Rayan&quot;, &quot;Rayan&quot;), voiture = c(&quot;Twingo&quot;, &quot;Ferrari&quot;, &quot;Scenic&quot;, &quot;Lada&quot;, &quot;Twingo&quot;, &quot;Clio&quot;) ) nom voiture Sylvie Twingo Sylvie Ferrari Monique Scenic Gunter Lada Rayan Twingo Rayan Clio voitures &lt;- tibble( voiture = c(&quot;Twingo&quot;, &quot;Ferrari&quot;, &quot;Clio&quot;, &quot;Lada&quot;, &quot;208&quot;), vitesse = c(&quot;140&quot;, &quot;280&quot;, &quot;160&quot;, &quot;85&quot;, &quot;160&quot;) ) voiture vitesse Twingo 140 Ferrari 280 Clio 160 Lada 85 208 160 10.6.3.1 left_join Si on fait un left_join de voitures sur personnes : left_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Monique Scenic NA Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 On voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mise à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas. Si on fait un left_join cette fois de personnes sur voitures, c’est l’inverse : left_join(voitures, personnes) #&gt; Joining, by = &quot;voiture&quot; voiture vitesse nom Twingo 140 Sylvie Twingo 140 Rayan Ferrari 280 Sylvie Clio 160 Rayan Lada 85 Gunter 208 160 NA La ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan. En résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, et dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA pour les nouvelles colonnes. Intuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”. En général, left_join sera le type de jointures le plus fréquemment utilisé. 10.6.3.2 right_join La jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(y, x) : right_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 NA 208 160 10.6.3.3 inner_join Dans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont conservées (et si nécessaire dupliquées) dans la table résultat : inner_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 Ici la ligne 208 est absente, ainsi que la ligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA. 10.6.3.4 full_join Dans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table : full_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Monique Scenic NA Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 NA 208 160 10.6.3.5 semi_join et anti_join semi_join et anti_join sont des jointures filtrantes, c’est-à-dire qu’elles sélectionnent les lignes de x sans ajouter les colonnes de y. Ainsi, semi_join ne conservera que les lignes de x pour lesquelles une ligne de y existe également, et supprimera les autres. Dans notre exemple, la ligne Monique est donc supprimée : semi_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture Sylvie Twingo Sylvie Ferrari Gunter Lada Rayan Twingo Rayan Clio Un anti_join fait l’inverse, il ne conserve que les lignes de x absentes de y. Dans notre exemple, on ne garde donc que la ligne Monique : anti_join(personnes, voitures) #&gt; Joining, by = &quot;voiture&quot; nom voiture Monique Scenic 10.7 Ressources Toutes les ressources ci-dessous sont en anglais… Le livre R for data science, librement accessible en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment : Data transformation pour les manipulations Relational data pour les tables multiples Le site de l’extension comprend une liste des fonctions et les pages d’aide associées, mais aussi une introduction au package et plusieurs articles dont un spécifiquement sur les jointures. Enfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr. 10.8 Exercices On commence par charger les extensions et les données nécessaires. library(tidyverse) library(nycflights13) data(flights) data(airports) data(airlines) 10.8.1 Les verbes de base de dplyr Exercice 1.1 Sélectionner les lignes 100 à 105 du tableau des vols (flights). #&gt; # A tibble: 6 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 752 759 -7 955 959 #&gt; 2 2013 1 1 753 755 -2 1056 1110 #&gt; 3 2013 1 1 754 759 -5 1039 1041 #&gt; 4 2013 1 1 754 755 -1 1103 1030 #&gt; 5 2013 1 1 758 800 -2 1053 1054 #&gt; 6 2013 1 1 759 800 -1 1057 1127 #&gt; # … with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; slice(flights, 100:105) Exercice 1.2 Sélectionnez les vols du mois de juillet (variable month). #&gt; # A tibble: 29,425 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 7 1 1 2029 212 236 2359 #&gt; 2 2013 7 1 2 2359 3 344 344 #&gt; 3 2013 7 1 29 2245 104 151 1 #&gt; 4 2013 7 1 43 2130 193 322 14 #&gt; 5 2013 7 1 44 2150 174 300 100 #&gt; 6 2013 7 1 46 2051 235 304 2358 #&gt; 7 2013 7 1 48 2001 287 308 2305 #&gt; 8 2013 7 1 58 2155 183 335 43 #&gt; 9 2013 7 1 100 2146 194 327 30 #&gt; 10 2013 7 1 100 2245 135 337 135 #&gt; # … with 29,415 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, month == 7) Sélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes. #&gt; # A tibble: 36,392 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 554 558 -4 740 728 #&gt; 3 2013 1 1 558 600 -2 753 745 #&gt; 4 2013 1 1 558 600 -2 924 917 #&gt; 5 2013 1 1 600 600 0 837 825 #&gt; 6 2013 1 1 611 600 11 945 931 #&gt; 7 2013 1 1 623 610 13 920 915 #&gt; 8 2013 1 1 624 630 -6 840 830 #&gt; 9 2013 1 1 629 630 -1 824 810 #&gt; 10 2013 1 1 632 608 24 740 728 #&gt; # … with 36,382 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, arr_delay &gt;= 5 &amp; arr_delay &lt;= 15) Sélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier). #&gt; # A tibble: 139,504 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 554 600 -6 812 837 #&gt; 5 2013 1 1 554 558 -4 740 728 #&gt; 6 2013 1 1 558 600 -2 753 745 #&gt; 7 2013 1 1 558 600 -2 924 917 #&gt; 8 2013 1 1 558 600 -2 923 937 #&gt; 9 2013 1 1 559 600 -1 941 910 #&gt; 10 2013 1 1 559 600 -1 854 902 #&gt; # … with 139,494 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, carrier %in% c(&quot;DL&quot;, &quot;UA&quot;, &quot;AA&quot;)) Exercice 1.3 Triez la table flights par retard au départ décroissant. #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; 7 2013 3 17 2321 810 911 135 1020 #&gt; 8 2013 6 27 959 1900 899 1236 2226 #&gt; 9 2013 7 22 2257 759 898 121 1026 #&gt; 10 2013 12 5 756 1700 896 1058 2020 #&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights, desc(dep_delay)) Exercice 1.4 Sélectionnez les colonnes name, lat et lon de la table airports #&gt; # A tibble: 1,458 × 3 #&gt; name lat lon #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Lansdowne Airport 41.1 -80.6 #&gt; 2 Moton Field Municipal Airport 32.5 -85.7 #&gt; 3 Schaumburg Regional 42.0 -88.1 #&gt; 4 Randall Airport 41.4 -74.4 #&gt; 5 Jekyll Island Airport 31.1 -81.4 #&gt; 6 Elizabethton Municipal Airport 36.4 -82.2 #&gt; 7 Williams County Airport 41.5 -84.5 #&gt; 8 Finger Lakes Regional Airport 42.9 -76.8 #&gt; 9 Shoestring Aviation Airfield 39.8 -76.6 #&gt; 10 Jefferson County Intl 48.1 -123. #&gt; # … with 1,448 more rows select(airports, name, lat, lon) Sélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone #&gt; # A tibble: 1,458 × 6 #&gt; faa name lat lon alt dst #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 A #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 264 A #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 A #&gt; 4 06N Randall Airport 41.4 -74.4 523 A #&gt; 5 09J Jekyll Island Airport 31.1 -81.4 11 A #&gt; 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 A #&gt; 7 0G6 Williams County Airport 41.5 -84.5 730 A #&gt; 8 0G7 Finger Lakes Regional Airport 42.9 -76.8 492 A #&gt; 9 0P2 Shoestring Aviation Airfield 39.8 -76.6 1000 U #&gt; 10 0S9 Jefferson County Intl 48.1 -123. 108 A #&gt; # … with 1,448 more rows select(airports, -tz, -tzone) Toujours dans la table airports, renommez la colonne lat en latitude et lon en longitude. #&gt; # A tibble: 1,458 × 8 #&gt; faa name latitude longitude alt tz dst tzone #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/New_… #&gt; 2 06A Moton Field Municip… 32.5 -85.7 264 -6 A America/Chic… #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/Chic… #&gt; 4 06N Randall Airport 41.4 -74.4 523 -5 A America/New_… #&gt; 5 09J Jekyll Island Airpo… 31.1 -81.4 11 -5 A America/New_… #&gt; 6 0A9 Elizabethton Munici… 36.4 -82.2 1593 -5 A America/New_… #&gt; 7 0G6 Williams County Air… 41.5 -84.5 730 -5 A America/New_… #&gt; 8 0G7 Finger Lakes Region… 42.9 -76.8 492 -5 A America/New_… #&gt; 9 0P2 Shoestring Aviation… 39.8 -76.6 1000 -5 U America/New_… #&gt; 10 0S9 Jefferson County In… 48.1 -123. 108 -8 A America/Los_… #&gt; # … with 1,448 more rows rename(airports, latitude = lat, longitude = lon) Exercice 1.5 Dans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m. #&gt; # A tibble: 1,458 × 2 #&gt; alt alt_m #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1044 318. #&gt; 2 264 80.5 #&gt; 3 801 244. #&gt; 4 523 159. #&gt; 5 11 3.35 #&gt; 6 1593 486. #&gt; 7 730 223. #&gt; 8 492 150. #&gt; 9 1000 305. #&gt; 10 108 32.9 #&gt; # … with 1,448 more rows tmp &lt;- mutate(airports, alt_m = alt / 3.2808) select(tmp, alt, alt_m) 10.8.2 Enchaîner des opérations Exercice 2.1 Réécrire le code de l’exercice précédent en utilisant le pipe %&gt;%. airports %&gt;% mutate(alt_m = alt / 3.2808) %&gt;% select(alt, alt_m) Exercice 2.2 En utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay). #&gt; # A tibble: 13,331 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 9 20 1139 1845 1014 1457 2210 #&gt; 2 2013 7 7 2123 1030 653 17 1345 #&gt; 3 2013 7 7 2059 1030 629 106 1350 #&gt; 4 2013 7 6 149 1600 589 456 1935 #&gt; 5 2013 7 10 133 1800 453 455 2130 #&gt; 6 2013 7 10 2342 1630 432 312 1959 #&gt; 7 2013 7 7 2204 1525 399 107 1823 #&gt; 8 2013 7 7 2306 1630 396 250 1959 #&gt; 9 2013 6 23 1833 1200 393 NA 1507 #&gt; 10 2013 7 10 2232 1609 383 138 1928 #&gt; # … with 13,321 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights %&gt;% filter(dest == &quot;SFO&quot;) %&gt;% arrange(desc(dep_delay)) Exercice 2.3 Sélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, triez selon retard_h par ordre décroissant et conservez uniquement les 5 premières lignes. #&gt; # A tibble: 5 × 3 #&gt; dest dep_delay retard_h #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 SFO 1014 16.9 #&gt; 2 ATL 702 11.7 #&gt; 3 DTW 696 11.6 #&gt; 4 ATL 602 10.0 #&gt; 5 MSP 593 9.88 flights %&gt;% filter(month %in% c(9, 10)) %&gt;% select(dest, dep_delay) %&gt;% mutate(retard_h = dep_delay / 60) %&gt;% arrange(desc(retard_h)) %&gt;% slice(1:5) 10.8.3 group_by et summarise Exercice 3.1 Affichez le nombre de vols par mois. #&gt; # A tibble: 12 × 2 #&gt; month n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 27004 #&gt; 2 2 24951 #&gt; 3 3 28834 #&gt; 4 4 28330 #&gt; 5 5 28796 #&gt; 6 6 28243 #&gt; 7 7 29425 #&gt; 8 8 29327 #&gt; 9 9 27574 #&gt; 10 10 28889 #&gt; 11 11 27268 #&gt; 12 12 28135 flights %&gt;% group_by(month) %&gt;% summarise(n = n()) Triez la table résultat selon le nombre de vols croissant. #&gt; # A tibble: 12 × 2 #&gt; month n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 24951 #&gt; 2 1 27004 #&gt; 3 11 27268 #&gt; 4 9 27574 #&gt; 5 12 28135 #&gt; 6 6 28243 #&gt; 7 4 28330 #&gt; 8 5 28796 #&gt; 9 3 28834 #&gt; 10 10 28889 #&gt; 11 8 29327 #&gt; 12 7 29425 flights %&gt;% group_by(month) %&gt;% summarise(n = n()) %&gt;% arrange(n) Exercice 3.2 Calculer la distance moyenne des vols selon l’aéroport de départ. #&gt; # A tibble: 3 × 2 #&gt; origin distance_moyenne #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 EWR 1057. #&gt; 2 JFK 1266. #&gt; 3 LGA 780. flights %&gt;% group_by(origin) %&gt;% summarise(distance_moyenne = mean(distance)) Exercice 3.3 Calculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année. #&gt; # A tibble: 12 × 2 #&gt; month n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1159 #&gt; 2 2 1030 #&gt; 3 3 1178 #&gt; 4 4 1382 #&gt; 5 5 1453 #&gt; 6 6 1430 #&gt; 7 7 1500 #&gt; 8 8 1505 #&gt; 9 9 1384 #&gt; 10 10 1409 #&gt; 11 11 1336 #&gt; 12 12 1408 flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% count(month) Exercice 3.4 Calculer le nombre de vols selon le mois et la destination. #&gt; # A tibble: 1,113 × 3 #&gt; month dest n #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 ALB 64 #&gt; 2 1 ATL 1396 #&gt; 3 1 AUS 169 #&gt; 4 1 AVL 2 #&gt; 5 1 BDL 37 #&gt; 6 1 BHM 25 #&gt; 7 1 BNA 399 #&gt; 8 1 BOS 1245 #&gt; 9 1 BQN 93 #&gt; 10 1 BTV 223 #&gt; # … with 1,103 more rows flights %&gt;% count(month, dest) Ne conserver, pour chaque mois, que la destination avec le nombre maximal de vols. #&gt; # A tibble: 12 × 3 #&gt; # Groups: month [12] #&gt; month dest n #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 ATL 1396 #&gt; 2 2 ATL 1267 #&gt; 3 3 ATL 1448 #&gt; 4 4 ATL 1490 #&gt; 5 5 ORD 1582 #&gt; 6 6 ORD 1547 #&gt; 7 7 ORD 1573 #&gt; 8 8 ORD 1604 #&gt; 9 9 ORD 1582 #&gt; 10 10 ORD 1604 #&gt; 11 11 ATL 1384 #&gt; 12 12 ATL 1463 flights %&gt;% count(month, dest) %&gt;% group_by(month) %&gt;% filter(n == max(n)) Exercice 3.5 Calculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois. #&gt; # A tibble: 12 × 3 #&gt; month n pourcentage #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 27004 8.02 #&gt; 2 2 24951 7.41 #&gt; 3 3 28834 8.56 #&gt; 4 4 28330 8.41 #&gt; 5 5 28796 8.55 #&gt; 6 6 28243 8.39 #&gt; 7 7 29425 8.74 #&gt; 8 8 29327 8.71 #&gt; 9 9 27574 8.19 #&gt; 10 10 28889 8.58 #&gt; 11 11 27268 8.10 #&gt; 12 12 28135 8.35 flights %&gt;% count(month) %&gt;% mutate(pourcentage = n/sum(n) * 100) Exercice 3.6 Calculer, pour chaque destination et chaque mois, le retard moyen à l’arrivée. Pour chaque mois, trier les destinations selon ce retard moyen décroissant, et (toujours pour chaque mois) ne conserver que les trois destinations avec le retard le plus important. #&gt; `summarise()` has grouped output by &#39;month&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 36 × 3 #&gt; # Groups: month [12] #&gt; month dest retard_moyen #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 TUL 68.1 #&gt; 2 1 OKC 57.7 #&gt; 3 1 CAE 55.9 #&gt; 4 2 DSM 48.2 #&gt; 5 2 TUL 33.5 #&gt; 6 2 GSP 32.9 #&gt; 7 3 DSM 60.6 #&gt; 8 3 CAE 46.9 #&gt; 9 3 PVD 44.3 #&gt; 10 4 CAE 71.3 #&gt; # … with 26 more rows flights %&gt;% group_by(month, dest) %&gt;% summarise(retard_moyen = mean(arr_delay, na.rm = TRUE)) %&gt;% group_by(month) %&gt;% arrange(desc(retard_moyen), .by_group = TRUE) %&gt;% slice(1:3) 10.8.4 Jointures Exercice 4.1 Faire la jointure de la table airlines sur la table flights à l’aide de left_join. #&gt; # A tibble: 336,776 × 20 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; 7 2013 1 1 555 600 -5 913 854 #&gt; 8 2013 1 1 557 600 -3 709 723 #&gt; 9 2013 1 1 557 600 -3 838 846 #&gt; 10 2013 1 1 558 600 -2 753 745 #&gt; # … with 336,766 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # name &lt;chr&gt; flights %&gt;% left_join(airlines) Exercice 4.2 À partir de la table résultat de l’exercice précédent, calculer le retard moyen au départ pour chaque compagnie, trier selon ce retard décroissant et ne conserver que le nom de la compagnie et le retard correspondant. #&gt; # A tibble: 16 × 2 #&gt; name retard_moyen #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Frontier Airlines Inc. 20.2 #&gt; 2 ExpressJet Airlines Inc. 20.0 #&gt; 3 Mesa Airlines Inc. 19.0 #&gt; 4 AirTran Airways Corporation 18.7 #&gt; 5 Southwest Airlines Co. 17.7 #&gt; 6 Endeavor Air Inc. 16.7 #&gt; 7 JetBlue Airways 13.0 #&gt; 8 Virgin America 12.9 #&gt; 9 SkyWest Airlines Inc. 12.6 #&gt; 10 United Air Lines Inc. 12.1 #&gt; 11 Envoy Air 10.6 #&gt; 12 Delta Air Lines Inc. 9.26 #&gt; 13 American Airlines Inc. 8.59 #&gt; 14 Alaska Airlines Inc. 5.80 #&gt; 15 Hawaiian Airlines Inc. 4.90 #&gt; 16 US Airways Inc. 3.78 flights %&gt;% left_join(airlines) %&gt;% group_by(name) %&gt;% summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;% arrange(desc(retard_moyen)) Exercice 4.3 Faire la jointure de la table airports sur la table flights en utilisant comme clé le code de l’aéroport de destination. #&gt; # A tibble: 336,776 × 26 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; 7 2013 1 1 555 600 -5 913 854 #&gt; 8 2013 1 1 557 600 -3 709 723 #&gt; 9 2013 1 1 557 600 -3 838 846 #&gt; 10 2013 1 1 558 600 -2 753 745 #&gt; # … with 336,766 more rows, and 18 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # name &lt;chr&gt;, lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, #&gt; # tzone &lt;chr&gt; flights %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) À partir de cette table, afficher pour chaque mois le nom de l’aéroport de destination ayant eu le plus petit nombre de vol. #&gt; # A tibble: 14 × 3 #&gt; # Groups: month [12] #&gt; month name n #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 Key West Intl 1 #&gt; 2 2 Jackson Hole Airport 3 #&gt; 3 3 Bangor Intl 2 #&gt; 4 4 Key West Intl 1 #&gt; 5 4 Myrtle Beach Intl 1 #&gt; 6 5 Columbia Metropolitan 9 #&gt; 7 6 Myrtle Beach Intl 1 #&gt; 8 7 La Guardia 1 #&gt; 9 8 South Bend Rgnl 1 #&gt; 10 9 South Bend Rgnl 5 #&gt; 11 10 Albany Intl 1 #&gt; 12 10 South Bend Rgnl 1 #&gt; 13 11 Blue Grass 1 #&gt; 14 12 South Bend Rgnl 1 flights %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) %&gt;% count(month, name) %&gt;% group_by(month) %&gt;% filter(n == min(n)) Exercice 4.4 Créer une table indiquant, pour chaque trajet, le nom de l’aéroport de départ et celui de l’aéroport d’arrivée. #&gt; # A tibble: 336,776 × 2 #&gt; orig_name dest_name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Newark Liberty Intl George Bush Intercontinental #&gt; 2 La Guardia George Bush Intercontinental #&gt; 3 John F Kennedy Intl Miami Intl #&gt; 4 John F Kennedy Intl &lt;NA&gt; #&gt; 5 La Guardia Hartsfield Jackson Atlanta Intl #&gt; 6 Newark Liberty Intl Chicago Ohare Intl #&gt; 7 Newark Liberty Intl Fort Lauderdale Hollywood Intl #&gt; 8 La Guardia Washington Dulles Intl #&gt; 9 John F Kennedy Intl Orlando Intl #&gt; 10 La Guardia Chicago Ohare Intl #&gt; # … with 336,766 more rows flights %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) %&gt;% rename(dest_name = name) %&gt;% left_join(airports, by = c(&quot;origin&quot; = &quot;faa&quot;)) %&gt;% rename(orig_name = name) %&gt;% select(orig_name, dest_name) 10.8.5 Bonus Exercice 5.1 Calculer le nombre de vols selon l’aéroport de destination, et fusionnez la table airports sur le résultat avec left_join. Stocker le résultat final dans un objet nommé flights_dest. flights_dest &lt;- flights %&gt;% count(dest) %&gt;% left_join(airports, by = c(&quot;dest&quot;=&quot;faa&quot;)) Créez une carte interactive des résultats avec le package leaflet et le code suivant : library(leaflet) leaflet(data = flights_dest) %&gt;% addTiles %&gt;% addCircles(lng = ~lon, lat = ~lat, radius = ~n * 10, popup = ~name) #&gt; Warning in validateCoords(lng, lat, funcName): Data contains 4 rows with either #&gt; missing or invalid lat/lon values and will be ignored À noter que cette opération est un peu plus “fragile” que les autres, car si l’ordre des colonnes change elle peut renvoyer un résultat différent.↩︎ Il est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎ Le pipe a été introduit à l’origine par l’extension magrittr, et repris par dplyr↩︎ "],["11-stringr.html", "Partie 11 Manipuler du texte avec stringr 11.1 Expressions régulières 11.2 Concaténer des chaînes 11.3 Convertir en majuscules / minuscules 11.4 Découper des chaînes 11.5 Extraire des sous-chaînes par position 11.6 Détecter des motifs 11.7 Extraire des motifs 11.8 Remplacer des motifs 11.9 Modificateurs de motifs 11.10 Ressources 11.11 Exercices", " Partie 11 Manipuler du texte avec stringr Les fonctions de forcats vues précédemment permettent de modifier des modalités d’une variables qualitative globalement. Mais parfois on a besoin de manipuler le contenu même du texte d’une variable de type chaîne de caractères : combiner, rechercher, remplacer… On va utiliser ici les fonctions de l’extension stringr. Celle-ci fait partie du coeur du tidyverse, elle est donc automatiquement chargée avec : library(tidyverse) stringr est en fait une interface simplifiée aux fonctions d’une autre extension, stringi. Si les fonctions de stringr ne sont pas suffisantes ou si on manipule beaucoup de chaînes de caractères, ne pas hésiter à se reporter à la documentation de stringi. Dans ce qui suit on va utiliser le court tableau d’exemple d suivant : d &lt;- tibble( nom = c(&quot;Mr Félicien Machin&quot;, &quot;Mme Raymonde Bidule&quot;, &quot;M. Martial Truc&quot;, &quot;Mme Huguette Chose&quot;), adresse = c(&quot;3 rue des Fleurs&quot;, &quot;47 ave de la Libération&quot;, &quot;12 rue du 17 octobre 1961&quot;, &quot;221 avenue de la Libération&quot;), ville = c(&quot;Nouméa&quot;, &quot;Marseille&quot;, &quot;Vénissieux&quot;, &quot;Marseille&quot;) ) nom adresse ville Mr Félicien Machin 3 rue des Fleurs Nouméa Mme Raymonde Bidule 47 ave de la Libération Marseille M. Martial Truc 12 rue du 17 octobre 1961 Vénissieux Mme Huguette Chose 221 avenue de la Libération Marseille 11.1 Expressions régulières Les fonctions présentées ci-dessous sont pour la plupart prévues pour fonctionner avec des expressions régulières. Celles-ci constituent un mini-langage, qui peut paraître assez cryptique, mais qui est très puissant pour spécifier des motifs de chaînes de caractères. Elles permettent par exemple de sélectionner le dernier mot avant la fin d’une chaîne, l’ensemble des suites alphanumériques commençant par une majuscule, des nombres de 3 ou 4 chiffres situés en début de chaîne, et beaucoup beaucoup d’autres choses encore bien plus complexes. Pour donner un exemple concret, l’expression régulière suivante permet de détecter une adresse de courrier électronique19 : [\\w\\d+.-_]+@[\\w\\d.-]+\\.[a-zA-Z]{2,} Par souci de simplicité, dans ce qui suit les exemples seront donnés autant que possible avec de simples chaînes de caractères, sans expression régulière. Mais si vous pensez manipuler des données textuelles, il peut être très utile de s’intéresser à cette syntaxe. 11.2 Concaténer des chaînes La première opération de base consiste à concaténer des chaînes de caractères entre elles. On peut le faire avec la fonction paste. Par exemple, si on veut concaténer l’adresse et la ville : paste(d$adresse, d$ville) #&gt; [1] &quot;3 rue des Fleurs Nouméa&quot; #&gt; [2] &quot;47 ave de la Libération Marseille&quot; #&gt; [3] &quot;12 rue du 17 octobre 1961 Vénissieux&quot; #&gt; [4] &quot;221 avenue de la Libération Marseille&quot; Par défaut, paste concatène en ajoutant un espace entre les différentes chaînes. On peut spécifier un autre séparateur avec son argument sep : paste(d$adresse, d$ville, sep = &quot; - &quot;) #&gt; [1] &quot;3 rue des Fleurs - Nouméa&quot; #&gt; [2] &quot;47 ave de la Libération - Marseille&quot; #&gt; [3] &quot;12 rue du 17 octobre 1961 - Vénissieux&quot; #&gt; [4] &quot;221 avenue de la Libération - Marseille&quot; Il existe une variante, paste0, qui concatène sans mettre de séparateur, et qui est légèrement plus rapide : paste0(d$adresse, d$ville) #&gt; [1] &quot;3 rue des FleursNouméa&quot; #&gt; [2] &quot;47 ave de la LibérationMarseille&quot; #&gt; [3] &quot;12 rue du 17 octobre 1961Vénissieux&quot; #&gt; [4] &quot;221 avenue de la LibérationMarseille&quot; À noter que paste et paste0 sont des fonctions R de base. L’équivalent pour stringr se nomme str_c. Parfois on cherche à concaténer les différents éléments d’un vecteur non pas avec ceux d’un autre vecteur, comme on l’a fait précédemment, mais entre eux. Dans ce cas paste seule ne fera rien : paste(d$ville) #&gt; [1] &quot;Nouméa&quot; &quot;Marseille&quot; &quot;Vénissieux&quot; &quot;Marseille&quot; Il faut lui ajouter un argument collapse, avec comme valeur la chaîne à utiliser pour concaténer les éléments : paste(d$ville, collapse = &quot;, &quot;) #&gt; [1] &quot;Nouméa, Marseille, Vénissieux, Marseille&quot; 11.3 Convertir en majuscules / minuscules Les fonctions str_to_lower, str_to_upper et str_to_title permettent respectivement de mettre en minuscules, mettre en majuscules, ou de capitaliser les éléments d’un vecteur de chaînes de caractères : str_to_lower(d$nom) #&gt; [1] &quot;mr félicien machin&quot; &quot;mme raymonde bidule&quot; &quot;m. martial truc&quot; #&gt; [4] &quot;mme huguette chose&quot; str_to_upper(d$nom) #&gt; [1] &quot;MR FÉLICIEN MACHIN&quot; &quot;MME RAYMONDE BIDULE&quot; &quot;M. MARTIAL TRUC&quot; #&gt; [4] &quot;MME HUGUETTE CHOSE&quot; str_to_title(d$nom) #&gt; [1] &quot;Mr Félicien Machin&quot; &quot;Mme Raymonde Bidule&quot; &quot;M. Martial Truc&quot; #&gt; [4] &quot;Mme Huguette Chose&quot; 11.4 Découper des chaînes La fonction str_split permet de “découper” une chaîne de caractère en fonction d’un délimiteur. On passe la chaîne en premier argument, et le délimiteur en second : str_split(&quot;un-deux-trois&quot;, &quot;-&quot;) #&gt; [[1]] #&gt; [1] &quot;un&quot; &quot;deux&quot; &quot;trois&quot; On peut appliquer la fonction à un vecteur, dans ce cas le résultat sera une liste : str_split(d$nom, &quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;Mr&quot; &quot;Félicien&quot; &quot;Machin&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Mme&quot; &quot;Raymonde&quot; &quot;Bidule&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;M.&quot; &quot;Martial&quot; &quot;Truc&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;Mme&quot; &quot;Huguette&quot; &quot;Chose&quot; Ou un tableau (plus précisément une matrice) si on ajoute simplify = TRUE. str_split(d$nom, &quot; &quot;, simplify = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Mr&quot; &quot;Félicien&quot; &quot;Machin&quot; #&gt; [2,] &quot;Mme&quot; &quot;Raymonde&quot; &quot;Bidule&quot; #&gt; [3,] &quot;M.&quot; &quot;Martial&quot; &quot;Truc&quot; #&gt; [4,] &quot;Mme&quot; &quot;Huguette&quot; &quot;Chose&quot; Si on souhaite créer de nouvelles colonnes dans un tableau de données en découpant une colonne de type texte, on pourra utiliser la fonction separate de l’extension tidyr. Celle-ci est expliquée section 12.3.3. Voici juste un exemple de son utilisation : library(tidyr) d %&gt;% separate(nom, c(&quot;genre&quot;, &quot;prenom&quot;, &quot;nom&quot;), sep = &quot; &quot;) #&gt; # A tibble: 4 × 5 #&gt; genre prenom nom adresse ville #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mr Félicien Machin 3 rue des Fleurs Nouméa #&gt; 2 Mme Raymonde Bidule 47 ave de la Libération Marseille #&gt; 3 M. Martial Truc 12 rue du 17 octobre 1961 Vénissieux #&gt; 4 Mme Huguette Chose 221 avenue de la Libération Marseille 11.5 Extraire des sous-chaînes par position La fonction str_sub permet d’extraire des sous-chaînes par position, en indiquant simplement les positions des premier et dernier caractères : str_sub(d$ville, 1, 3) #&gt; [1] &quot;Nou&quot; &quot;Mar&quot; &quot;Vén&quot; &quot;Mar&quot; 11.6 Détecter des motifs str_detect permet de détecter la présence d’un motif parmi les élements d’un vecteur. Par exemple, si on souhaite identifier toutes les adresses contenant “Libération” : str_detect(d$adresse, &quot;Libération&quot;) #&gt; [1] FALSE TRUE FALSE TRUE str_detect renvoie un vecteur de valeurs logiques et peut donc être utilisée, par exemple, avec le verbe filter de dplyr pour extraire des sous-populations. Une variante, str_count, compte le nombre d’occurrences d’une chaîne pour chaque élément d’un vecteur : str_count(d$ville, &quot;s&quot;) #&gt; [1] 0 1 2 1 Attention, les fonctions de stringr étant prévues pour fonctionner avec des expressions régulières, certains caractères n’auront pas le sens habituel dans la chaîne indiquant le motif à rechercher. Par exemple, le . ne sera pas un point mais le symbole représentant “n’importe quel caractère”. La section sur les modificateurs de motifs explique comment utiliser des chaîne “classiques” au lieu d’expressions régulières. On peut aussi utiliser str_subset pour ne garder d’un vecteur que les éléments correspondant au motif : str_subset(d$adresse, &quot;Libération&quot;) #&gt; [1] &quot;47 ave de la Libération&quot; &quot;221 avenue de la Libération&quot; 11.7 Extraire des motifs str_extract permet d’extraire les valeurs correspondant à un motif. Si on lui passe comme motif une chaîne de caractère, cela aura peu d’intérêt : str_extract(d$adresse, &quot;Libération&quot;) #&gt; [1] NA &quot;Libération&quot; NA &quot;Libération&quot; C’est tout de suite plus intéressant si on utilise des expressions régulières. Par exemple la commande suivante permet d’isoler les numéros de rue. str_extract(d$adresse, &quot;^\\\\d+&quot;) #&gt; [1] &quot;3&quot; &quot;47&quot; &quot;12&quot; &quot;221&quot; str_extract ne récupère que la première occurrence du motif. Si on veut toutes les extraire on peut utiliser str_extract_all. Ainsi, si on veut extraire l’ensemble des nombres présents dans les adresses : str_extract_all(d$adresse, &quot;\\\\d+&quot;) #&gt; [[1]] #&gt; [1] &quot;3&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;47&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;12&quot; &quot;17&quot; &quot;1961&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;221&quot; Si on veut faire de l’extraction de groupes dans des expressions régulières (identifiés avec des parenthèses), on pourra utiliser str_match. À noter que si on souhaite extraire des valeurs d’une colonne texte d’un tableau de données pour créer de nouvelles variables, on pourra utiliser la fonction extract de l’extension tidyr, décrite section 12.3.6. Par exemple : library(tidyr) d %&gt;% extract(adresse, &quot;type_rue&quot;, &quot;^\\\\d+ (.*?) &quot;, remove = FALSE) #&gt; # A tibble: 4 × 4 #&gt; nom adresse type_rue ville #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mr Félicien Machin 3 rue des Fleurs rue Nouméa #&gt; 2 Mme Raymonde Bidule 47 ave de la Libération ave Marseille #&gt; 3 M. Martial Truc 12 rue du 17 octobre 1961 rue Vénissieux #&gt; 4 Mme Huguette Chose 221 avenue de la Libération avenue Marseille 11.8 Remplacer des motifs La fonction str_replace permet de remplacer une chaîne ou un motif par une autre. Par exemple, on peut remplace les occurrence de “Mr” par “M.” dans les noms de notre tableau : str_replace(d$nom, &quot;Mr&quot;, &quot;M.&quot;) #&gt; [1] &quot;M. Félicien Machin&quot; &quot;Mme Raymonde Bidule&quot; &quot;M. Martial Truc&quot; #&gt; [4] &quot;Mme Huguette Chose&quot; La variante str_replace_all permet de spécifier plusieurs remplacements d’un coup : str_replace_all( d$adresse, c(&quot;avenue&quot; = &quot;Avenue&quot;, &quot;ave&quot; = &quot;Avenue&quot;, &quot;rue&quot; = &quot;Rue&quot;) ) #&gt; [1] &quot;3 Rue des Fleurs&quot; &quot;47 Avenue de la Libération&quot; #&gt; [3] &quot;12 Rue du 17 octobre 1961&quot; &quot;221 Avenue de la Libération&quot; 11.9 Modificateurs de motifs Par défaut, les motifs passés aux fonctions comme str_detect, str_extract ou str_replace sont des expressions régulières classiques. On peut spécifier qu’un motif n’est pas une expression régulière mais une chaîne de caractères normale en lui appliquant la fonction fixed. Par exemple, si on veut compter le nombre de points dans les noms de notre tableau, le paramétrage par défaut ne fonctionnera pas car dans une expression régulière le . est un symbole signifiant “n’importe quel caractère” : str_count(d$nom, &quot;.&quot;) #&gt; [1] 18 19 15 18 Il faut donc spécifier que notre point est bien un point avec fixed : str_count(d$nom, fixed(&quot;.&quot;)) #&gt; [1] 0 0 1 0 On peut aussi modifier le comportement des expressions régulières à l’aide de la fonction regex. On peut ainsi rendre les motifs insensibles à la casse avec ignore_case : str_detect(d$nom, &quot;mme&quot;) #&gt; [1] FALSE FALSE FALSE FALSE str_detect(d$nom, regex(&quot;mme&quot;, ignore_case = TRUE)) #&gt; [1] FALSE TRUE FALSE TRUE On peut également permettre aux regex d’être multilignes avec l’option multiline = TRUE, etc. 11.10 Ressources L’ouvrage R for Data Science, accessible en ligne, contient un chapitre entier sur les chaînes de caractères et les expressions régulières (en anglais). Le site officiel de stringr contient une liste des fonctions et les pages d’aide associées, ainsi qu’un article dédié aux expressions régulières. Pour des besoins plus pointus, on pourra aussi utiliser l’extension stringi sur laquelle est elle-même basée stringr. 11.11 Exercices Dans ces exercices on utilise un tableau d, généré par le code suivant : d &lt;- tibble( nom = c(&quot;M. rené Bézigue&quot;, &quot;Mme Paulette fouchin&quot;, &quot;Mme yvonne duluc&quot;, &quot;M. Jean-Yves Pernoud&quot;), naissance = c(&quot;18/04/1937 Vesoul&quot;, &quot;En 1947 à Grenoble (38)&quot;, &quot;Le 5 mars 1931 à Bar-le-Duc&quot;, &quot;Marseille, juin 1938&quot;), profession = c(&quot;Ouvrier agric&quot;, &quot;ouvrière qualifiée&quot;, &quot;Institutrice&quot;, &quot;Exploitant agric&quot;) ) nom naissance profession M. rené Bézigue 18/04/1937 Vesoul Ouvrier agric Mme Paulette fouchin En 1947 à Grenoble (38) ouvrière qualifiée Mme yvonne duluc Le 5 mars 1931 à Bar-le-Duc Institutrice M. Jean-Yves Pernoud Marseille, juin 1938 Exploitant agric Exercice 1 Capitalisez les noms des personnes avec str_to_title : #&gt; [1] &quot;M. René Bézigue&quot; &quot;Mme Paulette Fouchin&quot; &quot;Mme Yvonne Duluc&quot; #&gt; [4] &quot;M. Jean-Yves Pernoud&quot; str_to_title(d$nom) Exercice 2 Dans la variable profession, remplacer toutes les occurrences de l’abbréviation “agric” par “agricole” : #&gt; [1] &quot;Ouvrier agricole&quot; &quot;ouvrière qualifiée&quot; &quot;Institutrice&quot; #&gt; [4] &quot;Exploitant agricole&quot; str_replace(d$profession, &quot;agric&quot;, &quot;agricole&quot;) Exercice 3 À l’aide de str_detect, identifier les personnes de catégorie professionnelle “Ouvrier”. Indication : pensez au modificateur ignore_case. #&gt; [1] TRUE TRUE FALSE FALSE str_detect(d$profession, regex(&quot;Ouvr&quot;, ignore_case = TRUE)) Exercice 4 À l’aide de case_when et de str_detect, créer une nouvelle variable sexe identifiant le sexe de chaque personne en fonction de la présence de M. ou de Mme dans son nom. #&gt; # A tibble: 4 × 4 #&gt; nom naissance profession sexe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 M. rené Bézigue 18/04/1937 Vesoul Ouvrier agric Homme #&gt; 2 Mme Paulette fouchin En 1947 à Grenoble (38) ouvrière qualifiée Femme #&gt; 3 Mme yvonne duluc Le 5 mars 1931 à Bar-le-Duc Institutrice Femme #&gt; 4 M. Jean-Yves Pernoud Marseille, juin 1938 Exploitant agric Homme d %&gt;% mutate(sexe = case_when( str_detect(nom, fixed(&quot;Mme&quot;)) ~ &quot;Femme&quot;, str_detect(nom, fixed(&quot;M.&quot;)) ~ &quot;Homme&quot; ) ) Exercice 5 Extraire l’année de naissance de chaque individu avec str_extract. Vous pouvez utiliser le regex \"\\\\d\\\\d\\\\d\\\\d\" qui permet d’identifier les nombres de quatre chiffres. Vous devez obtenir le vecteur suivant : #&gt; [1] &quot;1937&quot; &quot;1947&quot; &quot;1931&quot; &quot;1938&quot; str_extract(d$naissance, &quot;\\\\d\\\\d\\\\d\\\\d&quot;) À l’aide de la fonction extract de l’extension tidyr et du regex précédent, créez une nouvelle variable annee dans le tableau, qui contient l’année de naissance (pour plus d’informations sur extract, voir la section 12.3.6). #&gt; # A tibble: 4 × 4 #&gt; nom naissance annee profession #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 M. rené Bézigue 18/04/1937 Vesoul 1937 Ouvrier agric #&gt; 2 Mme Paulette fouchin En 1947 à Grenoble (38) 1947 ouvrière qualifiée #&gt; 3 Mme yvonne duluc Le 5 mars 1931 à Bar-le-Duc 1931 Institutrice #&gt; 4 M. Jean-Yves Pernoud Marseille, juin 1938 1938 Exploitant agric library(tidyr) d %&gt;% extract( naissance, &quot;annee&quot;, &quot;(\\\\d\\\\d\\\\d\\\\d)&quot;, remove = FALSE ) Il s’agit en fait d’une version très simplifiée, la “véritable” expression permettant de tester si une adresse mail est valide fait plus de 80 lignes…↩︎ "],["12-tidyr.html", "Partie 12 Mettre en ordre avec tidyr 12.1 Tidy data 12.2 Trois règles pour des données bien rangées 12.3 Les verbes de tidyr 12.4 Ressources", " Partie 12 Mettre en ordre avec tidyr 12.1 Tidy data Comme indiqué dans la section 6.3, les extensions du tidyverse comme dplyr ou ggplot2 partent du principe que les données sont “bien rangées” sous forme de tidy data. Prenons un exemple avec les données suivantes, qui indique la population de trois pays pour quatre années différentes : country 1992 1997 2002 2007 Belgium 10045622 10199787 10311970 10392226 France 57374179 58623428 59925035 61083916 Germany 80597764 82011073 82350671 82400996 Imaginons qu’on souhaite représenter avec ggplot2 l’évolution de la population pour chaque pays sous forme de lignes : c’est impossible avec les données sous ce format. On a besoin d’arranger le tableau de la manière suivante : country annee population Belgium 1992 10045622 Belgium 1997 10199787 Belgium 2002 10311970 Belgium 2007 10392226 France 1992 57374179 France 1997 58623428 France 2002 59925035 France 2007 61083916 Germany 1992 80597764 Germany 1997 82011073 Germany 2002 82350671 Germany 2007 82400996 C’est seulement avec les données dans ce format qu’on peut réaliser le graphique : ggplot(d) + geom_line(aes(x = annee, y = population, color = country)) + scale_x_continuous(breaks = unique(d$annee)) C’est la même chose pour dplyr, par exemple si on voulait calculer la population minimale pour chaque pays avec summarise : d %&gt;% group_by(country) %&gt;% summarise(pop_min = min(population)) #&gt; # A tibble: 3 × 2 #&gt; country pop_min #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Belgium 10045622 #&gt; 2 France 57374179 #&gt; 3 Germany 80597764 12.2 Trois règles pour des données bien rangées Le concept de tidy data repose sur trois règles interdépendantes. Des données sont considérées comme tidy si : chaque ligne correspond à une observation chaque colonne correspond à une variable chaque valeur est présente dans une unique case de la table ou, de manière équivalente, des unités d’observations différentes sont présentes dans des tables différentes Ces règles ne sont pas forcément très intuitives. De plus, il y a une infinité de manières pour un tableau de données de ne pas être tidy. Prenons par exemple les règles 1 et 2 et le tableau de notre premier exemple : country 1992 1997 2002 2007 Belgium 10045622 10199787 10311970 10392226 France 57374179 58623428 59925035 61083916 Germany 80597764 82011073 82350671 82400996 Pourquoi ce tableau n’est pas tidy ? Parce que si on essaie d’identifier les variables mesurées dans le tableau, il y en a trois : le pays, l’année et la population. Or elles ne correspondent pas aux colonnes de la table. C’est le cas par contre pour la table transformée : country annee population Belgium 1992 10045622 Belgium 1997 10199787 Belgium 2002 10311970 Belgium 2007 10392226 France 1992 57374179 France 1997 58623428 France 2002 59925035 France 2007 61083916 Germany 1992 80597764 Germany 1997 82011073 Germany 2002 82350671 Germany 2007 82400996 On peut remarquer qu’en modifiant notre table pour satisfaire à la deuxième règle, on a aussi réglé la première : chaque ligne correspond désormais à une observation, en l’occurrence l’observation de trois pays à plusieurs moments dans le temps. Dans notre table d’origine, chaque ligne comportait en réalité quatre observations différentes. Ce point permet d’illustrer le fait que les règles sont interdépendantes. Autre exemple, généré depuis le jeu de données nycflights13, permettant cette fois d’illustrer la troisième règle : year month day dep_time carrier name 2013 1 1 517 UA United Air Lines Inc. 2013 1 1 533 UA United Air Lines Inc. 2013 1 1 542 AA American Airlines Inc. 2013 1 1 554 UA United Air Lines Inc. 2013 1 1 558 AA American Airlines Inc. 2013 1 1 558 UA United Air Lines Inc. 2013 1 1 558 UA United Air Lines Inc. 2013 1 1 559 AA American Airlines Inc. Dans ce tableau on a bien une observation par ligne (un vol), et une variable par colonne. Mais on a une “infraction” à la troisième règle, qui est que chaque valeur doit être présente dans une unique case : si on regarde la colonne name, on a en effet une duplication de l’information concernant le nom des compagnies aériennes. Notre tableau mêle en fait deux types d’observations différents : des observations sur les vols, et des observations sur les compagnies aériennes. Pour “arranger” ce tableau, il faut séparer les deux types d’observations en deux tables différentes : year month day dep_time carrier 2013 1 1 517 UA 2013 1 1 533 UA 2013 1 1 542 AA 2013 1 1 554 UA 2013 1 1 558 AA 2013 1 1 558 UA 2013 1 1 558 UA 2013 1 1 559 AA carrier name UA United Air Lines Inc. AA American Airlines Inc. On a désormais deux tables distinctes, l’information n’est pas dupliquée, et on peut facilement faire une jointure si on a besoin de récupérer l’information d’une table dans une autre. 12.3 Les verbes de tidyr L’objectif de tidyr est de fournir des fonctions pour arranger ses données et les convertir dans un format tidy. Ces fonctions prennent la forme de verbes qui viennent compléter ceux de dplyr et s’intègrent parfaitement dans les séries de pipes (%&gt;%), les pipelines, permettant d’enchaîner les opérations. 12.3.1 pivot_longer : transformer des colonnes en lignes Prenons le tableau d suivant, qui liste la population de 6 pays en 2002 et 2007 : country 2002 2007 Belgium 10311970 10392226 France 59925035 61083916 Germany 82350671 82400996 Italy 57926999 58147733 Spain 40152517 40448191 Switzerland 7361757 7554661 Dans ce tableau, une même variable (la population) est répartie sur plusieurs colonnes, chacune représentant une observation à un moment différent. On souhaite que la variable ne représente plus qu’une seule colonne, et que les observations soient réparties sur plusieurs lignes. Pour cela on va utiliser la fonction pivot_longer20 : d %&gt;% pivot_longer(c(`2002`, `2007`)) #&gt; # A tibble: 12 × 3 #&gt; country name value #&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Belgium 2002 10311970 #&gt; 2 Belgium 2007 10392226 #&gt; 3 France 2002 59925035 #&gt; 4 France 2007 61083916 #&gt; 5 Germany 2002 82350671 #&gt; 6 Germany 2007 82400996 #&gt; 7 Italy 2002 57926999 #&gt; 8 Italy 2007 58147733 #&gt; 9 Spain 2002 40152517 #&gt; 10 Spain 2007 40448191 #&gt; 11 Switzerland 2002 7361757 #&gt; 12 Switzerland 2007 7554661 La fonction pivot_longer prend comme premier argument la liste des colonnes à rassembler (ici on a mis 2002 et 2007 entre backticks (`2002`) pour indiquer à pivot_longer qu’il s’agit d’un nom de colonne et pas d’un nombre). Ces colonnes peuvent être spécifiées avec la même syntaxe que celle de la fonction select de dplyr. Par exemple, il est parfois plus rapide d’indiquer à pivot_longer les colonnes qu’on ne souhaite pas “rassembler”. On peut le faire avec la syntaxe suivante : d %&gt;% pivot_longer(-country) #&gt; # A tibble: 12 × 3 #&gt; country name value #&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Belgium 2002 10311970 #&gt; 2 Belgium 2007 10392226 #&gt; 3 France 2002 59925035 #&gt; 4 France 2007 61083916 #&gt; 5 Germany 2002 82350671 #&gt; 6 Germany 2007 82400996 #&gt; 7 Italy 2002 57926999 #&gt; 8 Italy 2007 58147733 #&gt; 9 Spain 2002 40152517 #&gt; 10 Spain 2007 40448191 #&gt; 11 Switzerland 2002 7361757 #&gt; 12 Switzerland 2007 7554661 Par défaut, les colonnes qui contiennent les noms des colonnes d’origine et leurs valeurs sont nommées name et value. Si cela ne convient pas, on peut indiquer les noms à utiliser via les arguments names_to et values_to : d %&gt;% pivot_longer( c(`2002`, `2007`), names_to = &quot;annee&quot;, values_to = &quot;population&quot; ) #&gt; # A tibble: 12 × 3 #&gt; country annee population #&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Belgium 2002 10311970 #&gt; 2 Belgium 2007 10392226 #&gt; 3 France 2002 59925035 #&gt; 4 France 2007 61083916 #&gt; 5 Germany 2002 82350671 #&gt; 6 Germany 2007 82400996 #&gt; 7 Italy 2002 57926999 #&gt; 8 Italy 2007 58147733 #&gt; 9 Spain 2002 40152517 #&gt; 10 Spain 2007 40448191 #&gt; 11 Switzerland 2002 7361757 #&gt; 12 Switzerland 2007 7554661 Au final, la nom de pivot_longer s’explique par le fait qu’on fait “pivoter” notre tableau de départ d’un format “large” (avec plus de colonnes) vers un format “long” (avec plus de lignes). 12.3.2 pivot_wider : transformer des lignes en colonnes La fonction pivot_wider est l’inverse de pivot_longer. Soit le tableau d suivant : country continent year variable value Belgium Europe 2002 lifeExp 78.320 Belgium Europe 2002 pop 10311970.000 Belgium Europe 2007 lifeExp 79.441 Belgium Europe 2007 pop 10392226.000 France Europe 2002 lifeExp 79.590 France Europe 2002 pop 59925035.000 France Europe 2007 lifeExp 80.657 France Europe 2007 pop 61083916.000 Ce tableau a le problème inverse du précédent : on a deux variables, lifeExp et pop qui, plutôt que d’être réparties en deux colonnes, sont réparties entre plusieurs lignes. On va donc utiliser pivot_wider pour répartir ces lignes dans deux colonnes différentes : d %&gt;% pivot_wider(names_from = variable, values_from = value) #&gt; # A tibble: 4 × 5 #&gt; country continent year lifeExp pop #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Belgium Europe 2002 78.3 10311970 #&gt; 2 Belgium Europe 2007 79.4 10392226 #&gt; 3 France Europe 2002 79.6 59925035 #&gt; 4 France Europe 2007 80.7 61083916 pivot_wider prend deux arguments principaux : names_from indique la colonne contenant les noms des nouvelles variables à créer values_from indique la colonne contenant les valeurs de ces variables Il peut arriver que certaines variables soient absentes pour certaines observations. Dans ce cas l’argument values_fill permet de spécifier la valeur à utiliser pour ces données manquantes (par défaut les valeurs absentes sont, logiquement, indiquées par des NA). Exemple avec le tableau d suivant : country continent year variable value Belgium Europe 2002 lifeExp 78.320 Belgium Europe 2002 pop 10311970.000 Belgium Europe 2007 lifeExp 79.441 Belgium Europe 2007 pop 10392226.000 France Europe 2002 lifeExp 79.590 France Europe 2002 pop 59925035.000 France Europe 2007 lifeExp 80.657 France Europe 2007 pop 61083916.000 France Europe 2002 density 94.000 d %&gt;% pivot_wider(names_from = variable, values_from = value) #&gt; # A tibble: 4 × 6 #&gt; country continent year lifeExp pop density #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Belgium Europe 2002 78.3 10311970 NA #&gt; 2 Belgium Europe 2007 79.4 10392226 NA #&gt; 3 France Europe 2002 79.6 59925035 94 #&gt; 4 France Europe 2007 80.7 61083916 NA d %&gt;% pivot_wider( names_from = variable, values_from = value, values_fill = list(value = 0) ) #&gt; # A tibble: 4 × 6 #&gt; country continent year lifeExp pop density #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Belgium Europe 2002 78.3 10311970 0 #&gt; 2 Belgium Europe 2007 79.4 10392226 0 #&gt; 3 France Europe 2002 79.6 59925035 94 #&gt; 4 France Europe 2007 80.7 61083916 0 Au final, la nom de pivot_wider s’explique par le fait qu’on fait “pivoter” notre tableau de départ d’un format “long” (avec plus de lignes) vers un format “large” (avec plus de colonnes). 12.3.3 separate : séparer une colonne en plusieurs colonnes Parfois on a plusieurs informations réunies en une seule colonne et on souhaite les séparer. Soit le tableau d’exemple caricatural suivant, nommé df : eleve note Félicien Machin 5/20 Raymonde Bidule 6/10 Martial Truc 87/100 separate permet de séparer la colonne note en deux nouvelles colonnes note et note_sur : df %&gt;% separate(note, c(&quot;note&quot;, &quot;note_sur&quot;)) #&gt; # A tibble: 3 × 3 #&gt; eleve note note_sur #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Félicien Machin 5 20 #&gt; 2 Raymonde Bidule 6 10 #&gt; 3 Martial Truc 87 100 separate prend deux arguments principaux, le nom de la colonne à séparer et un vecteur indiquant les noms des nouvelles variables à créer. Par défaut separate “sépare” au niveau des caractères non-alphanumérique (espace, symbole, etc.). On peut lui indiquer explicitement le caractère sur lequel séparer avec l’argument sep : df %&gt;% separate(eleve, c(&quot;prenom&quot;, &quot;nom&quot;), sep = &quot; &quot;) #&gt; # A tibble: 3 × 3 #&gt; prenom nom note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Félicien Machin 5/20 #&gt; 2 Raymonde Bidule 6/10 #&gt; 3 Martial Truc 87/100 12.3.4 separate_rows : séparer une colonne en plusieurs lignes separate_rows est également utile quand plusieurs informations différentes ont été réunies dans une seules colonne. Contrairement à separate, elle ne répartit les différentes valeurs dans plusieurs colonnes, mais dans plusieurs lignes. Prenons l’exemple suivant, ou la colonne notes contient plusieurs notes séparées par des virgules : eleve classe notes Félicien Machin 6e 5,16,11 Raymonde Bidule 5e 15 Martial Truc 6e 11,17 Si on applique separate_rows à la colonne notes, chaque note se retrouve dans une ligne différente (et les autres colonnes sont dupliquées) : separate_rows(df, notes) #&gt; # A tibble: 6 × 3 #&gt; eleve classe notes #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Félicien Machin 6e 5 #&gt; 2 Félicien Machin 6e 16 #&gt; 3 Félicien Machin 6e 11 #&gt; 4 Raymonde Bidule 5e 15 #&gt; 5 Martial Truc 6e 11 #&gt; 6 Martial Truc 6e 17 Par défaut separate_rows sépare les valeurs dès qu’elle trouve un caractère qui ne soit ni un chiffre ni une lettre, mais on peut spécifier le séparateur à l’aide de l’argument sep (qui accepte une chaîne de caractère ou même une expression régulière) : separate_rows(df, notes, sep = &quot;,&quot;) 12.3.5 unite : regrouper plusieurs colonnes en une seule unite est l’opération inverse de separate. Elle permet de regrouper plusieurs colonnes en une seule. Imaginons qu’on obtient le tableau d suivant : code_departement code_commune commune pop_tot 01 004 Ambérieu-en-Bugey 14233 01 007 Ambronay 2437 01 014 Arbent 3440 01 024 Attignat 3110 01 025 Bâgé-la-Ville 3130 01 027 Balan 2785 On souhaite reconstruire une colonne code_insee qui indique le code INSEE de la commune, et qui s’obtient en concaténant le code du département et celui de la commune. On peut utiliser unite pour cela : d %&gt;% unite(code_insee, code_departement, code_commune) #&gt; # A tibble: 6 × 3 #&gt; code_insee commune pop_tot #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 01_004 Ambérieu-en-Bugey 14233 #&gt; 2 01_007 Ambronay 2437 #&gt; 3 01_014 Arbent 3440 #&gt; 4 01_024 Attignat 3110 #&gt; 5 01_025 Bâgé-la-Ville 3130 #&gt; 6 01_027 Balan 2785 Le résultat n’est pas idéal : par défaut unite ajoute un caractère _ entre les deux valeurs concaténées, alors qu’on ne veut aucun séparateur. De plus, on souhaite conserver nos deux colonnes d’origine, qui peuvent nous être utiles. On peut résoudre ces deux problèmes à l’aide des arguments sep et remove : d %&gt;% unite( code_insee, code_departement, code_commune, sep = &quot;&quot;, remove = FALSE ) #&gt; # A tibble: 6 × 5 #&gt; code_insee code_departement code_commune commune pop_tot #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 01004 01 004 Ambérieu-en-Bugey 14233 #&gt; 2 01007 01 007 Ambronay 2437 #&gt; 3 01014 01 014 Arbent 3440 #&gt; 4 01024 01 024 Attignat 3110 #&gt; 5 01025 01 025 Bâgé-la-Ville 3130 #&gt; 6 01027 01 027 Balan 2785 12.3.6 extract : créer de nouvelles colonnes à partir d’une colonne de texte extract permet de créer de nouvelles colonnes à partir de sous-chaînes d’une colonne de texte existante, identifiées par des groupes dans une expression régulière. Par exemple, à partir du tableau suivant : eleve note Félicien Machin 5/20 Raymonde Bidule 6/10 Martial Truc 87/100 On peut extraire les noms et prénoms dans deux nouvelles colonnes avec : df %&gt;% extract( eleve, c(&quot;prenom&quot;, &quot;nom&quot;), &quot;^(.*) (.*)$&quot; ) #&gt; # A tibble: 3 × 3 #&gt; prenom nom note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Félicien Machin 5/20 #&gt; 2 Raymonde Bidule 6/10 #&gt; 3 Martial Truc 87/100 On passe donc à extract trois arguments : la colonne d’où on doit extraire les valeurs, un vecteur avec les noms des nouvelles colonnes à créer, et une expression régulière comportant autant de groupes (identifiés par des parenthèses) que de nouvelles colonnes. Par défaut la colonne d’origine n’est pas conservée dans la table résultat. On peut modifier ce comportement avec l’argument remove = FALSE. Ainsi, le code suivant extrait les initiales du prénom et du nom mais conserve la colonne d’origine : df %&gt;% extract( eleve, c(&quot;initiale_prenom&quot;, &quot;initiale_nom&quot;), &quot;^(.).* (.).*$&quot;, remove = FALSE ) #&gt; # A tibble: 3 × 4 #&gt; eleve initiale_prenom initiale_nom note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Félicien Machin F M 5/20 #&gt; 2 Raymonde Bidule R B 6/10 #&gt; 3 Martial Truc M T 87/100 12.3.7 complete : compléter des combinaisons de variables manquantes Imaginons qu’on ait le tableau de résultats suivants : eleve matiere note Alain Maths 16 Alain Français 9 Barnabé Maths 17 Chantal Français 11 Les élèves Barnabé et Chantal n’ont pas de notes dans toutes les matières. Supposons que c’est parce qu’ils étaient absents et que leur note est en fait un 0. Si on veut calculer les moyennes des élèves, on doit compléter ces notes manquantes. La fonction complete est prévue pour ce cas de figure : elle permet de compléter des combinaisons manquantes de valeurs de plusieurs colonnes. On peut l’utiliser de cette manière : df %&gt;% complete(eleve, matiere) #&gt; # A tibble: 6 × 3 #&gt; eleve matiere note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alain Français 9 #&gt; 2 Alain Maths 16 #&gt; 3 Barnabé Français NA #&gt; 4 Barnabé Maths 17 #&gt; 5 Chantal Français 11 #&gt; 6 Chantal Maths NA On voit que les combinaisons manquante “Barnabé - Français” et “Chantal - Maths” ont bien été ajoutées par complete. Par défaut les lignes insérées récupèrent des valeurs manquantes NA pour les colonnes restantes. On peut néanmoins choisir une autre valeur avec l’argument fill, qui prend la forme d’une liste nommée : df %&gt;% complete(eleve, matiere, fill = list(note = 0)) #&gt; # A tibble: 6 × 3 #&gt; eleve matiere note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alain Français 9 #&gt; 2 Alain Maths 16 #&gt; 3 Barnabé Français 0 #&gt; 4 Barnabé Maths 17 #&gt; 5 Chantal Français 11 #&gt; 6 Chantal Maths 0 Parfois on ne souhaite pas inclure toutes les colonnes dans le calcul des combinaisons de valeurs. Par exemple, supposons qu’on rajoute dans notre tableau une colonne avec les identifiants de chaque élève : id eleve matiere note 1001001 Alain Maths 16 1001001 Alain Français 9 1001002 Barnabé Maths 17 1001003 Chantal Français 11 Si on applique complete comme précédemment, le résultat n’est pas bon car il contient toutes les combinaisons de id, eleve et matiere. df %&gt;% complete(id, eleve, matiere) #&gt; # A tibble: 18 × 4 #&gt; id eleve matiere note #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1001001 Alain Français 9 #&gt; 2 1001001 Alain Maths 16 #&gt; 3 1001001 Barnabé Français NA #&gt; 4 1001001 Barnabé Maths NA #&gt; 5 1001001 Chantal Français NA #&gt; 6 1001001 Chantal Maths NA #&gt; 7 1001002 Alain Français NA #&gt; 8 1001002 Alain Maths NA #&gt; 9 1001002 Barnabé Français NA #&gt; 10 1001002 Barnabé Maths 17 #&gt; 11 1001002 Chantal Français NA #&gt; 12 1001002 Chantal Maths NA #&gt; 13 1001003 Alain Français NA #&gt; 14 1001003 Alain Maths NA #&gt; 15 1001003 Barnabé Français NA #&gt; 16 1001003 Barnabé Maths NA #&gt; 17 1001003 Chantal Français 11 #&gt; 18 1001003 Chantal Maths NA Dans ce cas, pour signifier à complete que id et eleve sont deux attributs d’un même individu et ne doivent pas être combinés entre eux, on doit les placer dans une fonction nesting : df %&gt;% complete(nesting(id, eleve), matiere) #&gt; # A tibble: 6 × 4 #&gt; id eleve matiere note #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1001001 Alain Français 9 #&gt; 2 1001001 Alain Maths 16 #&gt; 3 1001002 Barnabé Français NA #&gt; 4 1001002 Barnabé Maths 17 #&gt; 5 1001003 Chantal Français 11 #&gt; 6 1001003 Chantal Maths NA 12.4 Ressources Chaque jeu de données est différent, et le travail de remise en forme est souvent long et plus ou moins compliqué. On n’a donné ici que les exemples les plus simples, et c’est souvent en combinant différentes opérations qu’on finit par obtenir le résultat souhaité. Le livre R for data science, librement accessible en ligne, contient un chapitre complet sur la remise en forme des données. L’article Tidy data, publié en 2014 dans le Journal of Statistical Software, présente de manière détaillée le concept éponyme (mais il utilise des extensions désormais obsolètes qui ont depuis été remplacées par dplyr ettidyr). Le site de l’extension est accessible à l’adresse : https://tidyr.tidyverse.org/ et contient une liste des fonctions et les pages d’aide associées. pivot_longer et pivot_wider ont été introduites dans la version 1.0 de tidyr. Elles ont alors remplacé gather et spread.↩︎ "],["13-rmarkdown.html", "Partie 13 Diffuser et publier avec rmarkdown 13.1 Créer un nouveau document 13.2 Éléments d’un document R Markdown 13.3 Personnaliser le document généré 13.4 Options des blocs de code R 13.5 Rendu des tableaux 13.6 Modèles de documents 13.7 Ressources", " Partie 13 Diffuser et publier avec rmarkdown L’extension rmarkdown permet de générer des documents de manière dynamique en mélangeant texte mis en forme et résultats produits par du code R. Les documents générés peuvent être au format HTML, PDF, Word, et bien d’autres21. C’est donc un outil très pratique pour l’exportation, la communication et la diffusion de résultats d’analyse. Le présent document a lui-même été généré à partir de fichiers R Markdown22. rmarkdown ne fait pas partie du tidyverse, mais elle est installée et chargée par défaut par RStudio23. Voici un exemple de document R Markdown minimal : --- title: &quot;Test R Markdown&quot; --- *R Markdown* permet de mélanger : - du texte libre mis en forme - des blocs de code R Les blocs de code sont exécutés et leur résultat affiché, par exemple : ```{r} mean(mtcars$mpg) ``` ## Graphiques On peut également inclure des graphiques : ```{r} plot(mtcars$hp, mtcars$mpg) ``` Ce document peut être “compilé” sous différents formats. Lors de cette étape, le texte est mis en forme, les blocs de code sont exécutés, leur résultat ajouté au document, et le tout est transformé dans un des différents formats possibles. Voici le rendu du document précédent au format HTML : Rendu HTML Le rendu du même document au format PDF : Rendu PDF Et le rendu au format docx : Rendu docx Les avantages de ce système sont nombreux : le code et ses résultats ne sont pas séparés des commentaires qui leur sont associés le document final est reproductible le document peut être très facilement régénéré et mis à jour, par exemple si les données source ont été modifiées. 13.1 Créer un nouveau document Un document R Markdown est un simple fichier texte enregistré avec l’extension .Rmd. Sous RStudio, on peut créer un nouveau document en allant dans le menu File puis en choisissant New file puis R Markdown…. La boîte de dialogue suivante s’affiche : Création d’un document R Markdown On peut indiquer le titre, l’auteur du document ainsi que le format de sortie par défaut (il est possible de modifier facilement ces éléments par la suite). Plutôt qu’un document classique, on verra section 13.6 qu’on peut aussi choisir de créer une présentation sous forme de slides (entrée Presentation) ou de créer un document à partir d’un modèle (Entrée From Template). Un fichier comportant un contenu d’exemple s’affiche alors. Vous pouvez l’enregistrer où vous le souhaitez avec une extension .Rmd. 13.2 Éléments d’un document R Markdown Un document R Markdown est donc un fichier texte qui ressemble à quelque chose comme ça : --- title: &quot;Titre&quot; author: &quot;Prénom Nom&quot; date: &quot;10 avril 2017&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## Introduction Ceci est un document RMarkdown, qui mélange : - du texte balisé selon la syntaxe Markdown - des bouts de code R qui seront exécutés Le code R se présente de la manière suivante : ```{r} summary(cars) ``` ## Graphiques On peut aussi inclure des graphiques, par exemple : ```{r} plot(pressure) ``` On va décomposer les différents éléments constitutifs de ce document. 13.2.1 En-tête (préambule) La première partie du document est son en-tête. Il se situe en tout début de document, et est délimité par trois tirets (---) avant et après : --- title: &quot;Titre&quot; author: &quot;Prénom Nom&quot; date: &quot;10 avril 2017&quot; output: html_document --- Cet en-tête contient les métadonnées du document, comme son titre, son auteur, sa date, plus tout un tas d’options possibles qui vont permettre de configurer ou personnaliser l’ensemble du document et son rendu. Ici, par exemple, la ligne output: html_document indique que le document généré doit être au format HTML. 13.2.2 Texte du document Le corps du document est constitué de texte qui suit la syntaxe Markdown. Un fichier Markdown est un fichier texte contenant un balisage léger qui permet de définir des niveaux de titres ou de mettre en forme le texte. Par exemple, le texte suivant : Ceci est du texte avec *de l&#39;italique* et **du gras**. On peut définir des listes à puces : - premier élément - deuxième élément Génèrera le texte mis en forme suivant : Ceci est du texte avec de l’italique et du gras. On peut définir des listes à puces : premier élément deuxième élément On voit que des mots placés entre des astérisques sont mis en italique, des lignes qui commencent par un tiret sont transformés en liste à puce, etc. On peut définir des titres de différents niveaux en faisant débuter une ligne par un ou plusieurs # : # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 Quand des titres ont été définis, si vous cliquez sur l’icône Show document outline totalement à droite de la barre d’outils associée au fichier R Markdown, une table des matières générée automatiquement à partir des titres s’affiche et vous permet de naviguer facilement dans le document : Table des matières dynamique La syntaxe Markdown permet d’autres mises en forme, comme la possibilité d’insérer des liens ou des images. Par exemple, le code suivant : [Exemple de lien](https://example.com) Donnera le lien suivant : Exemple de lien Dans RStudio, le menu Help puis Markdown quick reference donne un aperçu plus complet de la syntaxe. 13.2.3 Blocs de code R En plus du texte libre au format Markdown, un document R Markdown contient, comme son nom l’indique, du code R. Celui-ci est inclus dans des blocs (chunks) délimités par la syntaxe suivante : ```{r} x &lt;- 1:5 ``` Comme cette suite de caractères n’est pas très simple à saisir, vous pouvez utiliser le menu Insert de RStudio et choisir R24, ou utiliser le raccourci clavier Ctrl+Alt+i. Menu d’insertion d’un bloc de code Dans RStudio les blocs de code R sont en général affichés avec une couleur de fond légèrement différente pour les distinguer du reste du document. Quand votre curseur se trouve dans un bloc, vous pouvez saisir le code R que vous souhaitez, l’exécuter, utiliser l’autocomplétion, exactement comme si vous vous trouviez dans un script R. Vous pouvez également exécuter l’ensemble du code contenu dans un bloc à l’aide du raccourci clavier Ctrl+Maj+Entrée. Dans RStudio, par défaut, les résultats d’un bloc de code (texte, tableau ou graphique) s’affichent directement dans la fenêtre d’édition du document, permettant de les visualiser facilement et de les conserver le temps de la session 25. Lorsque le document est “compilé” au format HTML, PDF ou docx, chaque bloc est exécuté tour à tour, et le résultat inclus dans le document final, qu’il s’agisse de texte, d’un tableau ou d’un graphique. Les blocs sont liés entre eux, dans le sens où les données importées ou calculées dans un bloc sont accessibles aux blocs suivants. On peut donc aussi voir un document R Markdown comme un script R dans lequel on aurait intercalé du texte libre au format Markdown. À noter qu’avant chaque compilation, une nouvelle session R est lancée, ne contenant aucun objet. Les premiers blocs de code d’un document sont donc souvent utilisés pour importer des données, exécuter des recodages, etc. 13.2.4 Compiler un document (Knit) On peut à tout moment compiler, ou plutôt “tricoter” (Knit), un document R Markdown pour obtenir et visualiser le document généré. Pour cela, il suffit de cliquer sur le bouton Knit et de choisir le format de sortie voulu : Menu Knit Vous pouvez aussi utiliser le raccourci Ctrl+Maj+K pour compiler le document dans le dernier format utilisé. Pour la génération du format PDF, vous devez avoir une installation fonctionnelle de LaTeX sur votre système. Si ça n’est pas le cas, l’extension tinytex de Yihui Xie vise à faciliter l’installation d’une distribution LaTeX minimale quel que soit le système d’exploitation de votre machine. Pour l’utiliser il vous faut d’abord installer l’extension avec install.packages(‘tinytex’), puis lancer la commande suivante dans la console (prévoir un téléchargement d’environ 200Mo) : tinytex::install_tinytex() Plus d’informations sur le site de tinytex. Un onglet R Markdown s’ouvre dans la même zone que l’onglet Console et indique la progression de la compilation, ainsi que les messages d’erreur éventuels. Si tout se passe bien, Le document devrait s’afficher soit dans une fenêtre Viewer de RStudio (pour la sortie HTML), soit dans le logiciel par défaut de votre ordinateur. 13.3 Personnaliser le document généré La personnalisation du document généré se fait en modifiant des options dans le préambule du document. RStudio propose néanmoins une petite interface graphique permettant de changer ces options plus facilement. Pour cela, cliquez sur l’icône en forme d’engrenage à droite du bouton Knit et choisissez Output Options… Options de sortie R Markdown Une boîte de dialogue s’affiche vous permettant de sélectionner le format de sortie souhaité et, selon le format, différentes options : Dialogue d’options de sortie R Markdown Pour le format HTML par exemple, l’onglet General vous permet de spécifier si vous voulez une table des matières, sa profondeur, les thèmes à appliquer pour le document et la coloration syntaxique des blocs R, etc. L’onglet Figures vous permet de changer les dimensions par défaut des graphiques générés. Une option très intéressante pour les fichiers HTML, accessible via l’onglet Advanced, est l’entrée Create standalone HTML document. Si elle est cochée (ce qui est le cas par défaut), le document HTML généré contiendra en un seul fichier le code HTML mais aussi les images et toutes les autres ressources nécessaires à son affichage. Ceci permet de générer des fichiers (parfois assez volumineux) que vous pouvez transférer très facilement à quelqu’un par mail ou en le mettant en ligne quelque part. Si la case n’est pas cochée, les images et autres ressources sont placées dans un dossier à part. Lorsque vous changez des options, RStudio va en fait modifier le préambule de votre document. Ainsi, si vous choisissez d’afficher une table des matières et de modifier le thème de coloration syntaxique, votre en-tête va devenir quelque chose comme : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes --- Vous pouvez modifier les options directement en éditant le préambule. À noter qu’il est possible de spécifier des options différentes selon les formats, par exemple : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes pdf_document: fig_caption: yes highlight: kate --- La liste complète des options possibles est présente sur le site de la documentation officielle (très complet et bien fait) et sur l’antisèche et le guide de référence, accessibles depuis RStudio via le menu Help puis Cheatsheets. 13.4 Options des blocs de code R Il est également possible de passer des options à chaque bloc de code R pour modifier son comportement. On rappelle qu’on bloc de code se présente de la manière suivante : ```{r} x &lt;- 1:5 ``` Les options d’un bloc de code sont à placer à l’intérieur des accolades {r}. 13.4.1 Nom du bloc La première possibilité est de donner un nom au bloc. Celui-ci est indiqué directement après le r : {r nom_du_bloc} Il n’est pas obligatoire de nommer un bloc, mais cela peut être utile en cas d’erreur à la compilation, pour identifier le bloc ayant causé le problème. Attention, on ne peut pas avoir deux blocs avec le même nom. 13.4.2 Options En plus d’un nom, on peut passer à un bloc une série d’options sous la forme option = valeur. Voici un exemple de bloc avec un nom et des options : ```{r mon_bloc, echo = FALSE, warning = TRUE} x &lt;- 1:5 ``` Et un exemple de bloc non nommé avec des options : ```{r echo = FALSE, warning = FALSE} x &lt;- 1:5 ``` Une des options la plus utile est l’option echo. Par défaut echo vaut TRUE, et le bloc de code R est inséré dans le document généré, de cette manière : x &lt;- 1:5 print(x) #&gt; [1] 1 2 3 4 5 Mais si on positionne l’option echo=FALSE, alors le code R n’est plus inséré dans le document, et seul le résultat est visible : #&gt; [1] 1 2 3 4 5 Voici une liste de quelques unes des options disponibles : Option Valeurs Description echo TRUE/FALSE Afficher ou non le code R dans le document eval TRUE/FALSE Exécuter ou non le code R à la compilation include TRUE/FALSE Inclure ou non le code R et ses résultats dans le document results “hide”/“asis”/“markup”/“hold” Type de résultats renvoyés par le bloc de code warning TRUE/FALSE Afficher ou non les avertissements générés par le bloc message TRUE/FALSE Afficher ou non les messages générés par le bloc Il existe de nombreuses autres options décrites notamment dans guide de référence R Markdown (PDF en anglais). 13.4.3 Modifier les options Il est possible de modifier les options manuellement en éditant l’en-tête du bloc de code, mais on peut aussi utiliser une petite interface graphique proposée par RStudio. Pour cela, il suffit de cliquer sur l’icône d’engrenage située à droite sur la ligne de l’en-tête de chaque bloc : Menu d’options de bloc de code Vous pouvez ensuite modifier les options les plus courantes, et cliquer sur Apply pour les appliquer. 13.4.4 Options globales On peut vouloir appliquer une option à l’ensemble des blocs d’un document. Par exemple, on peut souhaiter par défaut ne pas afficher le code R de chaque bloc dans le document final. On peut positionner une option globalement en utilisant la fonction knitr::opts_chunk$set(). Par exemple, insérer knitr::opts_chunk$set(echo = FALSE) dans un bloc de code positionnera l’option echo = FALSE par défaut pour tous les blocs suivants. En général, on place toutes ces modifications globales dans un bloc spécial nommé setup et qui est le premier bloc du document : ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` Par défaut RStudio exécute systématiquement le contenu du bloc setup avant d’exécuter celui d’un autre bloc. Contrairement aux autres blocs de code, quand on utilise dans RStudio le menu des paramètres du bloc setup pour modifier ses options, celles-ci modifient non pas les options de ce bloc mais les options globales, en mettant à jour l’appel de la fonction knitr::opts_chunk$set(). 13.4.5 Mise en cache des résultats Compiler un document R Markdown peut être long, car il faut à chaque fois exécuter l’ensemble des blocs de code R qui le constituent. Pour accélérer cette opération, R Markdown utilise un système de mise en cache : les résultats de chaque bloc sont enregistrés dans un fichier et à la prochaine compilation, si le code et les options du bloc n’ont pas été modifiés, c’est le contenu du fichier de cache qui est utilisé, ce qui évite d’exécuter le code R. On peut activer ou désactiver la mise en cache des résultats pour chaque bloc de code avec l’option cache = TRUE ou cache = FALSE, et on peut aussi désactiver totalement la mise en cache pour le document en ajoutant knitr::opts_chunk$set(cache = FALSE) dans le premier bloc setup. Ce système de cache peut poser problème par exemple si les données source changent : dans ce cas les résultats de certains blocs peuvent ne pas être mis à jour s’ils sont présents en cache. Dans ce cas, on peut vider le cache du document, ce qui forcera un recalcul de tous les blocs de code à la prochaine compilation. Pour cela, vous pouvez ouvrir le menu Knit et choisir Clear Knitr Cache… : Menu Knit 13.5 Rendu des tableaux 13.5.1 Tableaux croisés Par défaut, les tableaux issus de la fonction table sont affichés comme ils apparaissent dans la console de R, en texte brut : library(questionr) data(hdv2003) tab &lt;- lprop(table(hdv2003$qualif, hdv2003$sexe)) tab #&gt; #&gt; Homme Femme Total #&gt; Ouvrier specialise 47.3 52.7 100.0 #&gt; Ouvrier qualifie 78.4 21.6 100.0 #&gt; Technicien 76.7 23.3 100.0 #&gt; Profession intermediaire 55.0 45.0 100.0 #&gt; Cadre 55.8 44.2 100.0 #&gt; Employe 16.2 83.8 100.0 #&gt; Autre 36.2 63.8 100.0 #&gt; All 44.8 55.2 100.0 On peut améliorer leur présentation en utilisant la fonction kable de l’extension knitr. Celle-ci fournit un formatage adapté en fonction du format de sortie. On aura donc des tableaux “propres” que ce soit en HTML, PDF ou aux formats traitements de texte : library(knitr) kable(tab) Homme Femme Total Ouvrier specialise 47.29064 52.70936 100 Ouvrier qualifie 78.42466 21.57534 100 Technicien 76.74419 23.25581 100 Profession intermediaire 55.00000 45.00000 100 Cadre 55.76923 44.23077 100 Employe 16.16162 83.83838 100 Autre 36.20690 63.79310 100 All 44.82759 55.17241 100 Différents arguments permettent de modifier la sortie de kable. digits, par exemple, permet de spécifier le nombre de chiffres significatifs à afficher dans les colonnes de nombres : kable(tab, digits = 1) Homme Femme Total Ouvrier specialise 47.3 52.7 100 Ouvrier qualifie 78.4 21.6 100 Technicien 76.7 23.3 100 Profession intermediaire 55.0 45.0 100 Cadre 55.8 44.2 100 Employe 16.2 83.8 100 Autre 36.2 63.8 100 All 44.8 55.2 100 13.5.2 Tableaux de données et tris à plat En ce qui concerne les tableaux de données (tibble ou data frame), l’affichage HTML par défaut se contente d’un affichage texte comme dans la console, très peu lisible dès que le tableau dépasse une certaine taille. Une alternative est d’utiliser la fonction paged_table, qui affiche une représentation HTML paginée du tableau : Rendu d’une table par paged_table Une alternative est d’utiliser kable, comme précédemment pour les tableaux croisés, ou encore la fonction datatable de l’extension DT, qui propose encore davantage d’interactivité : Rendu d’une table par DT::datatable Dans tous les cas il est déconseillé d’afficher de cette manière un tableau de données de très grandes dimensions, car le fichier HTML résultant contiendrait l’ensemble des données et serait donc très volumineux. On peut définir un mode d’affichage par défaut pour tous les tableaux de données en modifiant les Output options du format HTML (onglet General, Print dataframes as), ou en modifiant manuellement l’option df_print de l’entrée html_document dans le préambule. À noter que les tableaux issus de la fonction freq de questionr s’affichent comme des tableaux de données (et non comme des tableaux croisés). 13.6 Modèles de documents On a vu ici la production de documents “classiques”, mais R Markdown permet de créer bien d’autres choses. Le site de documentation de l’extension propose une galerie des différentes sorties possibles. On peut ainsi créer des slides, des sites Web ou même des livres entiers, comme le présent document. 13.6.1 Slides Un usage intéressant est la création de diaporamas pour des présentations sous forme de slides. Le principe reste toujours le même : on mélange texte au format Markdown et code R, et R Markdown transforme le tout en présentations au format HTML ou PDF. En général les différents slides sont séparés au niveau de certains niveaux de titre. Certains modèles de slides sont inclus avec R Markdown, notamment : ioslides et Slidy pour des présentations HTML beamer pour des présentations en PDF via LaTeX Quand vous créez un nouveau document dans RStudio, ces modèles sont accessibles via l’entrée Presentation : Créer une présentation R Markdown D’autres extensions, qui doivent être installées séparément, permettent aussi des diaporamas dans des formats variés. On citera notamment : xaringan pour des présentations HTML basées sur remark.js revealjs pour des présentations HTML basées sur reveal.js rmdshower pour des diaporamas HTML basés sur shower Une fois l’extension installée, elle propose en général un template de départ lorsqu’on crée un nouveau document dans RStudio. Ceux-ci sont accessibles depuis l’entrée From Template. Créer une présentation à partir d’un template 13.6.2 Templates Il existe également différents templates permettant de changer le format et la présentation des documents générés. Une liste de ces formats et leur documentation associée est accessible depuis la page formats de la documentation. On notera notamment : le format Distill, adapté à des publications scientifiques ou techniques sur le Web le format Tufte Handouts qui permet de produire des documents PDF ou HTML dans un format proche de celui utilisé par Edward Tufte pour certaines de ses publications rticles, package qui propose des templates LaTeX pour plusieurs revues scientifiques Enfin, l’extension rmdformats propose plusieurs modèles HTML adaptés notamment pour des documents longs : Modèle readthedown Modèle downcute Modèle robobook Modèle material Là encore, la plupart du temps, ces modèles de documents proposent un template de départ lorsqu’on crée un nouveau document dans RStudio (entrée From Template) : Créer un document à partir d’un template 13.7 Ressources Les ressources suivantes sont toutes en anglais… L’ouvrage R for data science, accessible en ligne, contient un chapitre dédié à R Markdown. Le site officiel de l’extension contient une documentation très complète, tant pour les débutants que pour un usage avancé. Enfin, l’aide de RStudio (menu Help puis Cheatsheets) permet d’accéder à deux documents de synthèse : une “antisèche” synthétique (R Markdown Cheat Sheet) et un “guide de référence” plus complet (R Markdown Reference Guide). On peut citer les formats odt, rtf, Markdown, etc.↩︎ Plus précisément grâce à l’extension bookdown qui permet de générer des documents de type livre.↩︎ Si vous n’utilisez pas ce dernier, l’extension peut être installée à part avec install.packages(\"rmarkdown\") et chargée explicitement avec library(rmarkdown).↩︎ Il est possible d’inclure dans un document R Markdown des blocs de code d’autres langages↩︎ Ce comportement peut être modifié en cliquant sur l’icône d’engrenage de la barre d’outils et en choisissant Chunk Output in Console↩︎ "],["14-fonctions.html", "Partie 14 Écrire ses propres fonctions 14.1 Introduction et exemples 14.2 Arguments et résultat d’une fonction 14.3 Portée des variables 14.4 Les fonctions comme objets 14.5 Ressources 14.6 Exercices", " Partie 14 Écrire ses propres fonctions 14.1 Introduction et exemples 14.1.1 Structure d’une fonction Nous avons vu lors de l’introduction à R que le langage repose sur deux grands concepts : les objets et les fonctions. Pour reprendre une citation de John Chambers, en R, tout ce qui existe est un objet, et tout ce qui se passe est une fonction. Le principe d’une fonction est de prendre en entrée un ou plusieurs arguments (ou paramètres), d’effectuer un certain nombre d’actions et de renvoyer un résultat : Nous avons déjà rencontré et utilisé un grand nombre de fonctions, certaines assez simples (mean, max…) et d’autres beaucoup plus complexes (summary, mutate…). R, comme tout langage de programmation, offre la possibilité de créer et d’utiliser ses propres fonctions. Voici un exemple de fonction très simple, quoi que d’une utilité douteuse, puisqu’elle se contente d’ajouter 2 à un nombre : ajoute2 &lt;- function(x) { res &lt;- x + 2 return(res) } En exécutant ce code, on crée une nouvelle fonction nommée ajoute2, que l’on peut directement utiliser dans un script ou dans la console : ajoute2(3) #&gt; [1] 5 On va décomposer pas à pas la structure de cette première fonction. D’abord, une fonction est créée en utilisant l’instruction function. Celle-ci est suivie d’une paire de parenthèses et d’une paire d’accolades. function() { } Dans les parenthèses, on indique les arguments de la fonction, ceux qui devront lui être passés quand nous l’appellerons. Ici notre fonction ne prend qu’un seul argument, que nous avons décidé arbitrairement de nommer x. function(x) { } Les accolades comprennent une série d’instructions R qui constituent le corps de notre fonction. C’est ce code qui sera exécuté quand notre fonction est appelée. On peut utiliser dans le corps de la fonction les arguments qui lui sont passés. Ici, la première ligne utilise la valeur de l’argument x, lui ajoute 2 et stocke le résultat dans un nouvel objet res. function(x) { res &lt;- x + 2 } Pour qu’elle soit utile, notre fonction doit renvoyer le résultat qu’elle a calculé précédemment. Ceci se fait via l’instruction return à qui on passe la valeur à retourner. function(x) { res &lt;- x + 2 return(res) } Enfin, pour que notre fonction puisse être appelée et utilisée, nous devons lui donner un nom, ou plus précisément la stocker dans un objet. Ici on la stocke dans un objet nommé ajoute2. ajoute2 &lt;- function(x) { res &lt;- x + 2 return(res) } Les fonctions étant des objets comme les autres, elles suivent les mêmes contraintes pour leur nom : on a donc droit aux lettres, chiffres, point et tiret bas. Attention à ne pas donner à votre fonction le nom d’une fonction déjà existante : par exemple, si vous créez une fonction nommée table, la fonction du même nom de R base ne sera plus disponible (sauf à la préfixer avec base::table). Si vous “écrasez” par erreur une fonction existante, il vous suffit de relancer votre session R et de trouver un nouveau nom. Avec le code précédent, on a donc créé un nouvel objet ajoute2 de type function. Cette nouvelle fonction prend un seul argument x, calcule la valeur x + 2 et retourne ce résultat. On l’utilise en tapant son nom suivi de la valeur de son argument entre parenthèses, par exemple : ajoute2(41) #&gt; [1] 43 Ou encore : y &lt;- 5 z &lt;- ajoute2(y) z #&gt; [1] 7 À noter que comme x + 2 fonctionne si x est un vecteur, on peut aussi appeler notre fonction en lui passant un vecteur en argument. vec &lt;- 1:5 ajoute2(vec) #&gt; [1] 3 4 5 6 7 Si on récapitule, une fonction se définit donc de la manière suivante : Une fonction peut évidemment prendre plusieurs arguments. Dans ce cas on liste les arguments dans les parenthèses en les séparant par des virgules : somme &lt;- function(x, y) { return(x + y) } somme(3, 5) #&gt; [1] 8 Une fonction peut aussi n’accepter aucun argument, dans ce cas on laisse les parenthèses vides. miaule &lt;- function() { return(&quot;Miaou&quot;) } miaule() #&gt; [1] &quot;Miaou&quot; À noter que si on appelle une fonction avec un nombre d’arguments incorrect, cela génère une erreur. somme(1) #&gt; Error in somme(1): argument &quot;y&quot; is missing, with no default miaule(&quot;ouaf&quot;) #&gt; Error in miaule(&quot;ouaf&quot;): unused argument (&quot;ouaf&quot;) 14.1.2 Exemple de fonction Prenons un exemple un peu plus élaboré : la fonction table() retourne le tri à plat en effectifs d’une variable qualitative. On souhaite créer une fonction qui calcule plutôt le tri à plat en pourcentages. Voici une manière de le faire : prop_tab &lt;- function(v) { tri &lt;- table(v) effectif_total &lt;- length(v) tri &lt;- tri / effectif_total * 100 return(tri) } Notre fonction prend en entrée un argument nommé v, en l’occurrence un vecteur représentant une variable qualitative. On commence par faire le tri à plat de ce vecteur avec table, puis on calcule la répartition en pourcentages en divisant ce tri à plat par l’effectif total et en multipliant par 100. Testons avec un vecteur d’exemple : vec &lt;- c(&quot;rouge&quot;, &quot;vert&quot;, &quot;vert&quot;, &quot;bleu&quot;, &quot;rouge&quot;) prop_tab(vec) #&gt; v #&gt; bleu rouge vert #&gt; 20 40 40 Testons sur une variable du jeu de données hdv200326 : library(questionr) data(hdv2003) prop_tab(hdv2003$qualif) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.15 14.60 4.30 #&gt; Profession intermediaire Cadre Employe #&gt; 8.00 13.00 29.70 #&gt; Autre #&gt; 2.90 Ça fonctionne, mais avec une petite limite : par défaut table() ignore les NA. On peut modifier ce comportement en lui ajoutant un argument useNA = \"ifany\". prop_tab &lt;- function(v) { tri &lt;- table(v, useNA = &quot;ifany&quot;) effectif_total &lt;- length(v) tri &lt;- tri / effectif_total * 100 return(tri) } prop_tab(hdv2003$qualif) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.15 14.60 4.30 #&gt; Profession intermediaire Cadre Employe #&gt; 8.00 13.00 29.70 #&gt; Autre &lt;NA&gt; #&gt; 2.90 17.35 Quand on modifie une fonction existante, il faut exécuter à nouveau le code correspondant à sa définition pour la “mettre à jour”. Ici, si on ne le fait pas l’objet prop_tab contiendra toujours l’ancienne définition. Pour “mettre à jour” une fonction après avoir modifié son code, on peut soit sélectionner le code qui la définit et l’exécuter de la manière habituelle, soit, dans RStudio, se positionner dans le corps de la fonction et utiliser le raccourci clavier Ctrl + Alt + F. Autre amélioration possible : on pourrait vouloir modifier le nombre de décimales affichées pour les pourcentages, par exemple en les limitant à 1. Pour cela on ajoute une instruction round(). prop_tab &lt;- function(v) { tri &lt;- table(v, useNA = &quot;ifany&quot;) effectif_total &lt;- length(v) tri &lt;- tri / effectif_total * 100 tri &lt;- round(tri, 1) return(tri) } prop_tab(hdv2003$qualif) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.2 14.6 4.3 #&gt; Profession intermediaire Cadre Employe #&gt; 8.0 13.0 29.7 #&gt; Autre &lt;NA&gt; #&gt; 2.9 17.3 Ça fonctionne ! Cela dit, limiter à un chiffre après la virgule ne convient pas forcément dans tous les cas. L’idéal serait d’offrir la possibilité à la personne qui appelle la fonction de choisir elle-même la précision de l’affichage. Comment ? Tout simplement en ajoutant un deuxième argument à notre fonction, que nous nommerons decimales, et en utilisant cet argument à la place du 1 dans l’appel à round(). prop_tab &lt;- function(v, decimales) { tri &lt;- table(v, useNA = &quot;ifany&quot;) effectif_total &lt;- length(v) tri &lt;- tri / effectif_total * 100 tri &lt;- round(tri, decimales) return(tri) } Désormais, notre fonction s’utilise en lui indiquant deux arguments : prop_tab(hdv2003$qualif, 1) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.2 14.6 4.3 #&gt; Profession intermediaire Cadre Employe #&gt; 8.0 13.0 29.7 #&gt; Autre &lt;NA&gt; #&gt; 2.9 17.3 De la même manière, on pourrait vouloir laisser le choix à l’utilisateur d’afficher ou non les NA dans le tri à plat. C’est possible en ajoutant un troisième argument à notre fonction et en utilisant sa valeur dans le paramètre useNA de table(). prop_tab &lt;- function(v, decimales, useNA) { tri &lt;- table(v, useNA = useNA) effectif_total &lt;- length(v) tri &lt;- tri / effectif_total * 100 tri &lt;- round(tri, decimales) return(tri) } prop_tab(hdv2003$qualif, 1, &quot;no&quot;) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.2 14.6 4.3 #&gt; Profession intermediaire Cadre Employe #&gt; 8.0 13.0 29.7 #&gt; Autre #&gt; 2.9 14.1.3 Effets de bord et affichage de messages Parfois une fonction n’a pas pour objectif de renvoyer un résultat mais d’accomplir une action, comme générer un graphique, afficher un message, enregistrer un fichier… Dans ce cas la fonction peut ne pas inclure d’instruction return(). Les actions “visibles” dans notre session R accomplies par une fonction en-dehors du résultat renvoyé sont appelés des effets de bord. Par exemple la fonction suivante prend en argument un vecteur et génère un diagramme en barres du tri à plat de cette variable (en modifiant un peu la présentation au passage). my_barplot &lt;- function(var) { tri &lt;- table(var) barplot(tri, col = &quot;skyblue&quot;, border = NA) } my_barplot(hdv2003$clso) Un autre effet de bord très courant consiste à afficher des informations dans la console. Pour cela on peut utiliser print, qui affiche de manière aussi lisible que possible l’objet qu’on lui passe en argument : indicateurs &lt;- function(v) { print(mean(v)) print(sd(v)) } indicateurs(hdv2003$age) #&gt; [1] 48.157 #&gt; [1] 16.94181 Quand on souhaite seulement afficher une chaîne de caractère, on peut utiliser cat() qui fournit une sortie plus lisible que print : hello &lt;- function(nom) { cat(&quot;Bonjour,&quot;, nom, &quot;!&quot;) } hello(&quot;Pierre-Edmond&quot;) #&gt; Bonjour, Pierre-Edmond ! Enfin, on peut aussi utiliser message() qui, comme son nom l’indique, affiche un message dans la console, avec une mise en forme spécifique. En général on l’utilise plutôt pour afficher des informations relatives au déroulement de la fonction. Dans l’exemple suivant, on utilise la fonction runif() pour générer aléatoirement n nombres entre 0 et 1 et on affiche avec cat() la valeur du plus petit nombre généré. Comme l’exécution du runif() peut prendre du temps si n est grand, on affiche un message avec message() pour prévenir l’utilisateur. min_alea &lt;- function(n) { message(&quot;Génération de &quot;, n, &quot; nombres aléatoires...&quot;) v &lt;- runif(n) cat(&quot;Le plus petit nombre généré vaut&quot;, min(v)) } min_alea(50000) #&gt; Génération de 50000 nombres aléatoires... #&gt; Le plus petit nombre généré vaut 1.085363e-05 14.1.4 Utilité des fonctions On peut se demander dans quels cas il est utile de créer une fonction. Une règle courante considère que dès qu’on a répété le même code plus de deux fois, il est préférable d’en faire une fonction. Celles-ci ont en effet comme avantage d’éviter la duplication du code. Imaginons que nous avons récupéré un jeu de données avec toute une série de variables ayant les modalités \"1\" et \"2\" qui correspondent aux réponses \"Oui\" et \"Non\" à des questions. On crée un data frame fictif comportant quatre variables de ce type : df &lt;- data.frame( q1 = c(&quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;1&quot;), q2 = c(&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;), q3 = c(&quot;2&quot;, &quot;2&quot;, &quot;1&quot;, &quot;1&quot;), q4 = c(&quot;1&quot;, &quot;2&quot;, &quot;1&quot;, &quot;1&quot;) ) df #&gt; q1 q2 q3 q4 #&gt; 1 1 1 2 1 #&gt; 2 1 2 2 2 #&gt; 3 2 2 1 1 #&gt; 4 1 2 1 1 On a vu section 9.3 qu’on peut recoder l’une de ces variables à l’aide de la fonction fct_recode() de l’extension forcats : df$q1 &lt;- fct_recode(df$q1, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) On peut donc être tenté de dupliquer ce code autant de fois qu’on a de questions à recoder : df$q1 &lt;- fct_recode(df$q1, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) df$q2 &lt;- fct_recode(df$q2, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) df$q3 &lt;- fct_recode(df$q3, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) df$q4 &lt;- fct_recode(df$q4, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) Mais il est plus judicieux dans ce cas de créer une fonction pour ce recodage : recode_oui_non &lt;- function(var) { var_recodee &lt;- fct_recode(var, &quot;Oui&quot; = &quot;1&quot;, &quot;Non&quot; = &quot;2&quot; ) return(var_recodee) } En effet, il est alors très simple d’appliquer ce recodage à plusieurs variables : df$q1 &lt;- recode_oui_non(df$q1) df$q2 &lt;- recode_oui_non(df$q2) df$q3 &lt;- recode_oui_non(df$q3) df$q4 &lt;- recode_oui_non(df$q4) Autre avantage, si on réalise qu’on a commis une erreur et qu’en fait le code \"1\" correspondait à \"Non\" et le code \"2\" à \"Oui\", on n’a pas besoin de modifier tous les endroits où on a copié/collé notre recodage : on a juste à corriger la définition de la fonction. Les avantages de procéder ainsi sont donc multiples : créer une fonction évite la répétition du code et le rend moins long et plus lisible, surtout si on donne à notre fonction un nom explicite permettant de comprendre facilement ce qu’elle fait. créer une fonction évite les erreurs de copier/coller du code. une fonction permet de mettre à jour plus facilement son code : si on se rend compte d’une erreur ou si on souhaite améliorer son fonctionnement, on n’a qu’un seul endroit à modifier. enfin, créer des fonctions permet potentiellement de rendre son code réutilisable d’un script à l’autre ou même d’un projet à l’autre. Voire, à terme, de les regrouper dans un package pour soi-même ou pour diffusion à d’autres utilisateurs et utilisatrices de R. 14.2 Arguments et résultat d’une fonction 14.2.1 Définition des arguments Les arguments (ou paramètres) d’une fonction sont ce qu’on lui donne “en entrée”, et qui vont soit lui fournir des données, soit modifier son comportement. La liste des arguments acceptés par une fonction est indiquée entre les parenthèses de l’appel de function() : ma_fonction &lt;- function(arg1, arg2, arg3) { print(arg1) print(arg2) print(arg3) } Une fonction peut aussi ne pas accepter d’arguments, dans ce cas on la définit juste avec function(). Lors de l’appel de la fonction, on peut lui passer les arguments par position : ma_fonction(x, 12, TRUE) Dans ce cas, arg1 vaudra x, arg2 vaudra 12 et arg3 vaudra TRUE. On peut aussi passer les arguments par nom : ma_fonction(arg1 = x, arg2 = 12, arg3 = TRUE) Quand on passe les arguments par nom, on peut les indiquer dans l’ordre que l’on souhaite : ma_fonction(arg1 = x, arg3 = TRUE, arg2 = 12) Et on peut évidemment mélanger passage par position et passage par nom : ma_fonction(x, 12, arg3 = TRUE) Le plus souvent, les premiers arguments acceptés par une fonction sont les données sur lesquelles elle va travailler, tandis que les arguments suivants sont des paramètres qui vont modifier son comportement. Par exemple, median accepte comme premier argument x, un vecteur, puis un argument na.rm qui va changer sa manière de calculer la médiane des valeurs de x. En général on appelle la fonction en passant les paramètres correspondant aux données par position, et les autres en les nommant. C’est ainsi qu’on ne fait ni median(x = tailles, na.rm = TRUE) ni median(tailles, TRUE), mais plutôt median(tailles, na.rm = TRUE). En ce qui concerne le nom des arguments, en général ceux correspondant aux données transmises à une fonction peuvent avoir des noms relativement génériques (x, y, v pour un vecteur, data ou df pour un data.frame…). Les autres doivent par contre avoir des noms à la fois courts et explicites : par exemple plutôt decimales que nd ou nombre_de_decimales. 14.2.2 Valeurs par défaut Au moment de la définition de la fonction, on peut indiquer une valeur par défaut qui sera prise par l’argument si la personne qui utilise la fonction n’en fournit pas. Si on reprend la fonction prop_tab déjà définie plus haut : prop_tab &lt;- function(v, decimales, useNA) { tri &lt;- table(v, useNA = useNA) tri &lt;- tri / length(v) * 100 tri &lt;- round(tri, decimales) return(tri) } On peut indiquer une valeur par défaut aux arguments decimales et useNA de la manière suivante : prop_tab &lt;- function(v, decimales = 1, useNA = &quot;ifany&quot;) { tri &lt;- table(v, useNA = useNA) tri &lt;- tri / length(v) * 100 tri &lt;- round(tri, decimales) return(tri) } Si on appelle prop_tab en lui passant uniquement le vecteur v, on voit que decimales vaut bien 1 et useNA vaut bien `“ifany”: prop_tab(hdv2003$qualif) #&gt; v #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 10.2 14.6 4.3 #&gt; Profession intermediaire Cadre Employe #&gt; 8.0 13.0 29.7 #&gt; Autre &lt;NA&gt; #&gt; 2.9 17.3 14.2.3 Arguments obligatoires et arguments facultatifs Si un argument n’a pas de valeur par défaut, il est obligatoire : si l’utilisateur essaye d’appeler la fonction sans définir cet argument, cela génère une erreur. prop_tab &lt;- function(v, decimales, useNA) { tri &lt;- table(v, useNA = useNA) tri &lt;- tri / length(v) * 100 tri &lt;- round(tri, decimales) return(tri) } prop_tab(hdv2003$sexe) #&gt; Error in match.arg(useNA): argument &quot;useNA&quot; is missing, with no default Pour être tout à fait précis, l’erreur est générée uniquement lorsque l’argument sans valeur par défaut est utilisé dans la fonction. Si à l’inverse un argument a une valeur par défaut, il devient facultatif : on peut appeler la fonction sans le définir. prop_tab &lt;- function(v, decimales = 1, useNA = &quot;ifany&quot;) { tri &lt;- table(v, useNA = useNA) tri &lt;- tri / length(v) * 100 tri &lt;- round(tri, decimales) return(tri) } prop_tab(hdv2003$sexe) #&gt; v #&gt; Homme Femme #&gt; 45 55 Parfois un argument est facultatif mais on n’a pas forcément de valeur par défaut à lui attribuer. Dans ce cas on lui attribue en général par défaut la valeur NULL, et on utilise l’instruction if() dans la fonction pour tester s’il a été défini ou pas. Ce cas de figure est détaillé section 17.2.4. 14.2.4 L’argument ... Une fonction peut prendre un argument spécial nommé ... : ma_fonction &lt;- function(x, correct = TRUE, ...) { } Cet argument spécial “capture” tous les arguments présents et qui n’ont pas été définis avec la fonction. Par exemple, si on appelle la fonction précédente avec : ma_fonction(1:5, correct = FALSE, title = &quot;Titre&quot;, size = 12) Alors ... contiendra les arguments title et size et leurs valeurs. Si on veut accéder à la valeur de size dans …, on utilise list(…)$size. En général ... est utilisé pour passer ces arguments à d’autres fonctions. Reprenons notre fonction my_barplot définie précédemment : my_barplot &lt;- function(var) { tri &lt;- table(var) barplot(tri, col = &quot;skyblue&quot;, border = NA) } On pourrait permettre de personnaliser les couleurs des barres et de leurs bordures en ajoutant des arguments supplémentaires : my_barplot &lt;- function(var, col = &quot;skyblue&quot;, border = NA) { tri &lt;- table(var) barplot(tri, col = col, border = border) } Mais si on veut aussi permettre de personnaliser d’autres arguments de barplot comme main, xlab, xlim… il faudrait rajouter autant d’arguments supplémentaires à notre fonction, ce qui deviendrait vite ingérable. Une solution est de “capturer” tous les arguments supplémentaires avec ... et de les passer directement à barplot, de cette manière : my_barplot &lt;- function(var, ...) { tri &lt;- table(var) tri &lt;- sort(tri) barplot(tri, ...) } Ce qui permet d’appeler notre fonction avec tous les arguments possibles de barplot, par exemple : my_barplot( hdv2003$clso, col = &quot;yellowgreen&quot;, main = &quot;Croyez-vous en l&#39;existence des classes sociales ?&quot; ) 14.2.5 Résultat d’une fonction On l’a vu, l’objectif d’une fonction est en général de renvoyer un résultat. Lors de la définition d’une fonction, le résultat peut être retourné en utilisant la fonction return() : ajoute2 &lt;- function(x) { res &lt;- x + 2 return(res) } En réalité, l’utilisation de return() n’est pas obligatoire : une fonction retourne automatiquement le résultat de la dernière instruction qu’elle exécute. On aurait donc pu écrire : ajoute2 &lt;- function(x) { res &lt;- x + 2 res } Ou même, encore mieux et plus lisible : ajoute2 &lt;- function(x) { x + 2 } Dans la suite de ce document on utilisera, lorsque c’est possible, la syntaxe la plus “compacte” qui omet le return(). Un point important à noter : lorsque R rencontre une instruction return() dans une fonction, il interrompt immédiatement son exécution et “sort” de la fonction en renvoyant le résultat. Ainsi, dans la fonction suivante : ajoute2 &lt;- function(x) { return(x + 2) x * 5 } L’instruction x * 5 ne sera jamais exécutée car R “sort” de la fonction dès qu’il évalue le return() de la ligne précédente. Conséquence de ce comportement, on ne peut utiliser plusieurs return() pour renvoyer plusieurs résultats depuis une seule fonction. Est-ce à dire qu’une fonction R ne pourrait renvoyer qu’une seule valeur ? Non, car si elle ne peut retourner qu’un seul objet, celui-ci peut être complexe et comporter plusieurs valeurs. Par exemple, on a vu précédemment une fonction rudimentaire nommée indicateurs() qui affiche la moyenne et l’écart-type d’un vecteur numérique. indicateurs &lt;- function(v) { print(mean(v)) print(sd(v)) } Plutôt que de se contenter de les afficher dans la console, on pourrait vouloir retourner ces deux valeurs pour pouvoir les réutiliser par la suite. Pour cela, une première solution pourrait être de renvoyer un vecteur comportant ces deux valeurs. indicateurs &lt;- function(v) { moyenne &lt;- mean(v) ecart_type &lt;- sd(v) c(moyenne, ecart_type) } indicateurs(hdv2003$age) #&gt; [1] 48.15700 16.94181 Mais dans ce cas de figure il est recommandé de retourner plutôt une liste nommée27, de cette manière : indicateurs &lt;- function(v) { moyenne &lt;- mean(v) ecart_type &lt;- sd(v) list(moyenne = moyenne, ecart_type = ecart_type) } indicateurs(hdv2003$age) #&gt; $moyenne #&gt; [1] 48.157 #&gt; #&gt; $ecart_type #&gt; [1] 16.94181 On a du coup un affichage un peu plus lisible, et on peut accéder aux éléments du résultat via leur nom : res &lt;- indicateurs(hdv2003$age) res$moyenne #&gt; [1] 48.157 14.3 Portée des variables Un point délicat mais important quand on commence à créer ses propres fonctions concerne la portée des variables, c’est-à-dire la façon dont les objets créés dans une fonction et ceux existant en-dehors “cohabitent”. C’est une question assez complexe, mais seules quatre grandes règles sont réellement utiles au départ. 14.3.1 Une fonction peut accéder à un objet extérieur Si on fait appel dans une fonction à un objet qui n’existe pas et n’a pas été passé comme argument, on obtient une erreur. f &lt;- function() { obj } f() #&gt; Error in f(): objet &#39;obj&#39; introuvable Si on crée cet objet dans notre fonction avant de l’utiliser, on supprime évidemment l’erreur. f &lt;- function() { obj &lt;- 2 obj } f() #&gt; [1] 2 Mais on peut aussi accéder depuis une fonction à un objet qui existe dans notre environnement au moment où la fonction a été appelée. f &lt;- function() { obj } obj &lt;- 3 f() #&gt; [1] 3 Dans cet exemple, au moment de l’exécution de f(), comme obj n’existe pas au sein de la fonction (il n’a pas été passé comme argument ni défini dans le corps de la fonction), R va chercher dans l’environnement global, celui depuis lequel la fonction a été appelée. Comme il trouve un objet obj, il utilise sa valeur au moment de l’appel de la fonction. 14.3.2 Les arguments et les objets créés dans la fonction sont prioritaires Que se passe-t-il si un objet avec le même nom existe à la fois dans la fonction et dans notre environnement global ? Dans ce cas R privilégie l’objet créé dans la fonction. f &lt;- function() { obj &lt;- 10 obj } obj &lt;- 3 f() #&gt; [1] 10 Cette règle s’applique également pour les arguments passés à la fonction. f &lt;- function(obj) { obj } obj &lt;- 3 f(20) #&gt; [1] 20 14.3.3 Un objet créé dans une fonction n’existe que dans cette fonction Autre règle importante : un objet créé à l’intérieur d’une fonction n’est pas accessible à l’extérieur de celle-ci. f &lt;- function() { nouvel_objet &lt;- 15 nouvel_objet } f() #&gt; [1] 15 nouvel_objet #&gt; Error in eval(expr, envir, enclos): object &#39;nouvel_objet&#39; not found Ici, nouvel_objet existe tant qu’on est dans la fonction, mais il est détruit dès qu’on en sort et donc inaccessible dans notre environnement global. Les objets créés dans notre session et qui existent dans notre environnement (tel que visible dans l’onglet Environment de RStudio) sont appelés des objets globaux : ils existent et sont accessibles pour les fonctions appelées depuis cet environnement. Les objets créés lors de l’exécution d’une fonction sont à l’inverse des objets locaux : ils n’existent qu’à l’intérieur de la fonction et pour la durée de son exécution. Si deux objets du même nom coexistent, l’objet local est prioritaire par rapport à l’objet global. 14.3.4 On ne peut pas modifier un objet global dans une fonction Une conséquence importante de la troisième règle est qu’il n’est pas possible de modifier un objet de notre environnement global depuis une fonction28 : f &lt;- function() { obj &lt;- 10 message(&quot;Valeur dans la fonction : &quot;, obj) } obj &lt;- 3 f() #&gt; Valeur dans la fonction : 10 obj #&gt; [1] 3 Pour comprendre le résultat obtenu, on peut essayer de décomposer pas à pas : Au moment du obj &lt;- 3, R crée un objet global nommé obj avec la valeur 3. Quand on exécute f() et qu’on rencontre l’instruction obj &lt;- 10, R crée un nouvel objet nommé obj, local celui-ci, avec la valeur 10. À ce moment-là on a donc deux objets distincts portant le même nom, l’un global avec la valeur 3, l’autre local avec la valeur 10. Comme l’objet local est prioritaire, c’est lui qui est utilisé lors de l’affichage du message. Lorsqu’on sort de f(), l’objet local contenant la valeur 10 est détruit. Il ne reste plus que l’objet global avec la valeur 3. C’est donc lui qui est affiché lors du dernier appel à obj. Pour les mêmes raisons, dans l’exemple suivant, le recodage appliqué à la variable taille du tableau df passé en argument à la fonction recode_taille() n’est pas conservé en-dehors de la fonction. Ce recodage n’existe que dans un tableau d local à la fonction, et détruit dès qu’on en est sorti. df &lt;- data.frame(taille = c(155, 182), poids = c(65, 71)) recode_taille &lt;- function(d) { d$taille &lt;- d$taille / 100 } recode_taille(df) # Le recodage n&#39;est pas conservé df #&gt; taille poids #&gt; 1 155 65 #&gt; 2 182 71 Si on souhaite modifier un objet global, on doit le passer comme argument en entrée de notre fonction, et le renvoyer comme résultat en sortie. Pour que le recodage précédent soit bien répercuté dans notre tableau df, on doit faire : recode_taille &lt;- function(d) { d$taille &lt;- d$taille / 100 d } df &lt;- recode_taille(df) # Le recodage est bien conservé df #&gt; taille poids #&gt; 1 1.55 65 #&gt; 2 1.82 71 14.4 Les fonctions comme objets Quand on crée une fonction, on la “nomme” en la stockant dans un objet. Cet objet peut être utilisé comme n’importe quel autre objet dans R. On peut ainsi copier une fonction en l’attribuant à un nouvel objet : f &lt;- function(x) { x + 2 } g &lt;- f g(10) #&gt; [1] 12 On a déjà vu à de nombreuses reprises que quand on fournit juste un nom d’objet à R, celui-ci affiche son contenu dans la console. C’est aussi le cas pour les fonctions : dans ce cas c’est le code source de la fonction qui est affiché. f #&gt; function(x) { #&gt; x + 2 #&gt; } 14.4.1 Passer des fonctions comme argument Certaines fonctions sont prévues pour s’appliquer elles-mêmes à des fonctions. Par exemple, formals et body permettent d’afficher respectivement les arguments et le corps d’une fonction passée en argument. formals(f) #&gt; $x body(f) #&gt; { #&gt; x + 2 #&gt; } Il est donc possible de passer une fonction comme argument d’une autre fonction, comme dans body(f). On a déjà vu un exemple de ce type de fonctionnement avec la fonction tapply dans la section 4.2.2. Celle-ci prend trois arguments : un vecteur de valeurs, un facteur, et une fonction. Elle applique ensuite la fonction aux valeurs pour chaque niveau du facteur. Par exemple, si on a un data frame avec une liste de fruits et leur poids : df &lt;- data.frame( fruit = c(&quot;Pomme&quot;, &quot;Pomme&quot;, &quot;Citron&quot;, &quot;Citron&quot;), poids = c(147, 189, 76, 91) ) df #&gt; fruit poids #&gt; 1 Pomme 147 #&gt; 2 Pomme 189 #&gt; 3 Citron 76 #&gt; 4 Citron 91 On peut utiliser tapply pour calculer le poids moyen par type de fruit. tapply(df$poids, df$fruit, mean) #&gt; Citron Pomme #&gt; 83.5 168.0 Si on souhaite plutôt calculer le poids maximal, il suffit de passer à tapply la fonction max plutôt que la fonction mean. tapply(df$poids, df$fruit, max) #&gt; Citron Pomme #&gt; 91 189 Cette manière de transmettre une fonction à une autre fonction peut être un peu déroutante de prime abord, mais c’est une mécanique qu’on va retrouver très souvent dans les chapitres suivants. Si f est une fonction, il est important de bien faire la différence entre f et f() : f est la fonction en elle-même f() est le résultat de la fonction quand on l’exécute sans lui passer d’argument Quand on passe une fonction comme argument à une autre fonction, on utilise donc toujours la notation sans les parenthèses. 14.4.2 Fonctions anonymes Dans le cas où on souhaite calculer quelque chose pour lequel une fonction n’existe pas déjà, on peut créer une nouvelle fonction : poids_moyen_kg &lt;- function(poids) { mean(poids / 1000) } Et la passer en argument à tapply() : tapply(df$poids, df$fruit, poids_moyen_kg) #&gt; Citron Pomme #&gt; 0.0835 0.1680 Si on ne souhaite pas réutiliser cette fonction par la suite, on peut aussi définir cette fonction directement comme argument de tapply : tapply(df$poids, df$fruit, function(poids) { mean(poids/1000) }) #&gt; Citron Pomme #&gt; 0.0835 0.1680 Dans ce cas on a créé ce qu’on appelle une fonction anonyme, qui n’a pas de nom (elle n’a pas été stockée dans un objet), et qui n’existe que le temps de l’appel à tapply. 14.5 Ressources L’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre complet d’introduction sur les fonctions. L’ouvrage Advanced R (également en anglais) aborde de manière très approfondie les fonctions ainsi que la programmation fonctionnelle. Le manuel officiel Introduction to R (toujours en anglais) contient une partie sur l’écriture de ses propres fonctions. 14.6 Exercices 14.6.1 Introduction et exemples Exercice 1.1 Écrire une fonction nommée perimetre qui prend en entrée un argument nommé r et retourne le périmètre d’un cercle de rayon r, c’est-à-dire 2 * pi * r (pi est un objet R qui contient la valeur de \\(\\pi\\)). Vérifier avec l’appel suivant : perimetre(4) #&gt; [1] 25.13274 perimetre &lt;- function(r) { resultat &lt;- 2 * pi * r return(resultat) } Exercice 1.2 Écrire une fonction etendue qui prend en entrée un vecteur numérique et retourne la différence entre la valeur maximale et la valeur minimale de ce vecteur. Vérifier avec l’appel suivant : etendue(c(18, 35, 21, 40)) #&gt; [1] 22 etendue &lt;- function(v) { vmax &lt;- max(v) vmin &lt;- min(v) return(vmax - vmin) } Exercice 1.3 Écrire une fonction nommée alea qui tire un nombre au hasard entre 0 et 100. Cette fonction ne prend pas d’argument et son corps est constitué des étapes suivantes : tirer un nombre aléatoire entre 0 et 1 avec runif(1) multiplier ce nombre par 100 l’arrondir à l’entier le plus proche avec round retourner le résultat alea &lt;- function() { n &lt;- runif(1) n &lt;- n * 100 n &lt;- round(n) return(n) } Modifier cette fonction pour qu’elle accepte un argument max et qu’elle génère un nombre entier au hasard entre 0 et max. alea &lt;- function(max) { n &lt;- runif(1) n &lt;- n * max n &lt;- round(n) return(n) } Facultatif : Modifier à nouveau la fonction pour qu’elle accepte deux arguments min et max et qu’elle génère un nombre entier au hasard compris entre min et max. alea &lt;- function(min, max) { n &lt;- runif(1) n &lt;- n * (max - min) + min n &lt;- round(n) return(n) } Exercice 1.4 Écrire une fonction nommée meteo qui prend un argument nommé ville avec le corps suivant : out &lt;- readLines(paste0(&quot;https://v2.wttr.in/&quot;, ville, &quot;?A&quot;)) cat(out, sep = &quot;\\n&quot;) Tester la fonction avec par exemple meteo(\"Lyon\"). meteo &lt;- function(ville) { out &lt;- readLines(paste0(&quot;https://v2.wttr.in/&quot;, ville, &quot;?A&quot;)) cat(out, sep = &quot;\\n&quot;) } Exercice 1.5 Soit le code suivant, qui recode une variable du jeu de données hdv2003 en utilisant str_to_lower() puis fct_recode() : library(questionr) library(tidyverse) data(hdv2003) hdv2003$hard.rock &lt;- str_to_lower(hdv2003$hard.rock) hdv2003$hard.rock &lt;- fct_recode(hdv2003$hard.rock, &quot;o&quot; = &quot;oui&quot;, &quot;n&quot; = &quot;non&quot;) Transformer ce code en une fonction nommée recode_oui_non, et appliquer cette fonction à hard.rock, lecture.bd et cuisine. recode_oui_non &lt;- function(var) { var_rec &lt;- str_to_lower(var) var_rec &lt;- fct_recode(var_rec, &quot;o&quot; = &quot;Oui&quot;, &quot;n&quot; = &quot;Non&quot;) return(var_rec) } hdv2003$hard.rock &lt;- recode_oui_non(hdv2003$hard.rock) hdv2003$lecture.bd &lt;- recode_oui_non(hdv2003$lecture.bd) hdv2003$cuisine &lt;- recode_oui_non(hdv2003$cuisine) 14.6.2 Arguments et résultat Exercice 2.1 Observer le code de la fonction suivante pour comprendre à quoi correspondent chacun de ses trois arguments, puis réordonner et renommer ces arguments de manière plus pertinente : moyenne_arrondie &lt;- function(d, vecteur_contenant_les_donnees, supprimer_les_na) { res &lt;- mean(vecteur_contenant_les_donnees, na.rm = supprimer_les_na) res &lt;- round(res, d) return(res) } moyenne_arrondie &lt;- function(v, decimales, na.rm) { res &lt;- mean(v, na.rm = na.rm) res &lt;- round(res, decimales) return(res) } Donner aux arguments une valeur par défaut. moyenne_arrondie &lt;- function(v, decimales = 2, na.rm = TRUE) { res &lt;- mean(v, na.rm = na.rm) res &lt;- round(res, decimales) return(res) } Simplifier la fonction en utilisant la syntaxe plus compacte qui ne fait pas appel à return(). moyenne_arrondie &lt;- function(v, decimales = 2, na.rm = TRUE) { res &lt;- mean(v, na.rm = na.rm) round(res, decimales) } Exercice 2.2 Simplifier la fonction suivante pour que son corps ne fasse plus qu’une seule ligne : centrer_reduire &lt;- function(x) { res &lt;- x - mean(x) res &lt;- res / sd(x) return(res) } centrer_reduire &lt;- function(x) { (x - mean(x)) / sd(x) } Exercice 2.3 Le code suivant permet de déterminer la lettre initiale et la longueur d’un mot. initiale &lt;- str_sub(mot, 1, 1) longueur &lt;- nchar(mot) Utiliser ce code pour créer une fonction caracteristiques_mot() qui prend un argument mot et retourne à la fois son initiale et sa longueur. caracteristiques_mot(&quot;Bidonnage&quot;) #&gt; $initiale #&gt; [1] &quot;B&quot; #&gt; #&gt; $longueur #&gt; [1] 9 caracteristiques_mot &lt;- function(mot) { initiale &lt;- str_sub(mot, 1, 1) longueur &lt;- nchar(mot) list(initiale = initiale, longueur = longueur) } Facultatif : modifier la fonction pour qu’elle retourne un vecteur plutôt qu’une liste, et l’appliquer sur un mot de votre choix. Que constatez-vous ? Comme les vecteurs atomiques ne peuvent contenir que des données du même type, le nombre correspondant à longueur a été converti en chaîne de caractères. 14.6.3 Portée des variables Exercice 3.1 En lisant les codes suivants, essayer de prévoir quelle va être la valeur affichée par la dernière ligne. Vérifier en exécutant le code : f &lt;- function() { x &lt;- 3 x } f() f &lt;- function() { x } x &lt;- 5 f() f &lt;- function(x) { x } x &lt;- 5 f(30) f &lt;- function(x = 100) { x } x &lt;- 5 f() f &lt;- function(x = 100) { x &lt;- 150 x } x &lt;- 5 f(30) f &lt;- function() { x &lt;- 5 } x &lt;- 1000 f() x Exercice 3.2 Dans le code suivant, on a essayé de créer une fonction qui modifie un tableau de données passé en argument pour ne conserver que les lignes correspondant aux pommes. Est-ce que ça fonctionne ? df &lt;- data.frame( fruit = c(&quot;Pomme&quot;, &quot;Pomme&quot;, &quot;Citron&quot;, &quot;Citron&quot;), poids = c(147, 189, 76, 91) ) filtre_pommes &lt;- function(d) { d &lt;- dplyr::filter(d, fruit == &quot;Pomme&quot;) } filtre_pommes(df) df Modifier le code pour obtenir le résultat souhaité. filtre_pommes &lt;- function(d) { dplyr::filter(d, fruit == &quot;Pomme&quot;) } df &lt;- filtre_pommes(df) df 14.6.4 Les fonctions comme objets Exercice 4.1 Écrire une fonction nommée bonjour qui ne prend aucun argument et affiche juste le texte “Bonjour !” dans la console. bonjour &lt;- function() { cat(&quot;Bonjour !&quot;) } Exécuter dans la console les deux commandes suivantes tour à tour : bonjour() bonjour Comprenez-vous la différence entre les deux ? Copier la fonction dans un nouvel objet nommé salut. Exécuter la nouvelle fonction ainsi créée. salut &lt;- bonjour salut() Exercice 4.2 Construire une fonction etendue() qui prend en entrée un vecteur numérique et retourne la différence entre la valeur maximale et la valeur minimale de ce vecteur (vous pouvez récupérer le code de l’exercice 1.2). etendue &lt;- function(v) { max(v) - min(v) } À l’aide de tapply(), appliquez la fonction etendue() à la variable age pour chaque valeur de qualif dans le jeu de données hdv2003. #&gt; Ouvrier specialise Ouvrier qualifie Technicien #&gt; 74 68 62 #&gt; Profession intermediaire Cadre Employe #&gt; 62 63 72 #&gt; Autre #&gt; 78 library(questionr) data(hdv2003) tapply(hdv2003$age, hdv2003$qualif, etendue) Réécrire le code précédent en utilisant une fonction anonyme (ie en définissant la fonction directement dans le tapply). tapply(hdv2003$age, hdv2003$qualif, function(v) { max(v) - min(v) }) Exercice 4.3 Exécutez le code suivant. Comprenez-vous les résultats obtenus ? f &lt;- function(y) { y * 4 } body(f) f(5) body(f) &lt;- quote(y + 2) body(f) f(5) Intuitivement, comprenez-vous à quoi sert la fonction quote ? Le jeu de données hdv2003 fait partie de l’extension questionr, il est décrit section A.3.2.2.↩︎ Les listes seront abordées un peu plus en détail dans la partie 16.2.↩︎ En réalité c’est possible avec l’opérateur &lt;&lt;-, mais c’est fortement déconseillé dans la très grande majorité des cas.↩︎ "],["15-dplyr-avance.html", "Partie 15 dplyr avancé 15.1 Appliquer ses propres fonctions 15.2 across() : appliquer des fonctions à plusieurs colonnes 15.3 Fonctions anonymes et syntaxes abrégées 15.4 rowwise() et c_across() : appliquer une transformation ligne par ligne 15.5 Ressources 15.6 Exercices", " Partie 15 dplyr avancé L’extension dplyr a déjà été présentée dans la partie 10. On va voir ici comment aller un peu plus loin dans l’utilisation du package, notamment en utilisant nos propres fonctions et en appliquant des transformations à des ensembles de colonnes. On commence par charger les extensions du tidyverse ainsi que les jeux de données hdv2003 et rp2012 de l’extension questionr. library(tidyverse) library(questionr) data(hdv2003) data(rp2012) 15.1 Appliquer ses propres fonctions 15.1.1 Exemple avec mutate Soit le jeu de données fictif suivant, dont chaque ligne représente un individu pour lequel on dispose de sa PCS, celle de ses parents, son âge et celui de ses enfants. df &lt;- tribble( ~id, ~pcs, ~pcs_pere, ~pcs_mere, ~age, ~`age enf1`, ~`age enf2`, ~`age enf3`, 1, &quot;5&quot;, &quot;5&quot;, &quot;6&quot;, 25, 2, NA, NA, 2, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;, 45, 12, 8, 2, 3, &quot;4&quot;, &quot;2&quot;, &quot;5&quot;, 29, 7, NA, NA, 4, &quot;2&quot;, &quot;1&quot;, &quot;4&quot;, 32, 6, 3, NA, 5, &quot;1&quot;, &quot;4&quot;, &quot;3&quot;, 65, 39, 36, 28, 6, &quot;6&quot;, &quot;6&quot;, &quot;6&quot;, 51, 18, 12, NA, 7, &quot;5&quot;, &quot;4&quot;, &quot;6&quot;, 37, 8, 4, 1, 8, &quot;3&quot;, &quot;3&quot;, &quot;1&quot;, 42, 16, 10, 5 ) df #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 5 5 6 25 2 NA NA #&gt; 2 2 3 3 2 45 12 8 2 #&gt; 3 3 4 2 5 29 7 NA NA #&gt; 4 4 2 1 4 32 6 3 NA #&gt; 5 5 1 4 3 65 39 36 28 #&gt; 6 6 6 6 6 51 18 12 NA #&gt; 7 7 5 4 6 37 8 4 1 #&gt; 8 8 3 3 1 42 16 10 5 Dans ce tableau les PCS sont indiquées sous forme de codes : il serait plus lisible de les avoir sous forme d’intitulés de catégorie socio-professionnelle. On a vu section 9.3.2 qu’on peut effectuer ce recodage avec la fonction fct_recode() de l’extension forcats. df %&gt;% mutate( pcs = fct_recode(pcs, &quot;Agriculteur&quot; = &quot;1&quot;, &quot;Indépendant&quot; = &quot;2&quot;, &quot;Cadre&quot; = &quot;3&quot;, &quot;Intermédiaire&quot; = &quot;4&quot;, &quot;Employé&quot; = &quot;5&quot;, &quot;Ouvrier&quot; = &quot;6&quot; ) ) Plutôt que d’intégrer le code du recodage directement dans le mutate(), on peut l’extraire en créant une fonction. recode_pcs &lt;- function(v) { fct_recode(v, &quot;Agriculteur&quot; = &quot;1&quot;, &quot;Indépendant&quot; = &quot;2&quot;, &quot;Cadre&quot; = &quot;3&quot;, &quot;Intermédiaire&quot; = &quot;4&quot;, &quot;Employé&quot; = &quot;5&quot;, &quot;Ouvrier&quot; = &quot;6&quot; ) } On peut dès lors simplifier notre mutate en appelant notre nouvelle fonction. df %&gt;% mutate(pcs = recode_pcs(pcs)) Premier avantage : on gagne en lisibilité. On a déplacé le code d’une opération spécifique dans une fonction avec un nom “parlant”, ce qui permet de savoir facilement à quoi elle sert. Et on a simplifié notre mutate qui est désormais plus lisible parce qu’il fait apparaître la logique de nos opérations (on veut recoder les PCS) sans en inclure les détails. Le deuxième avantage évident, comme pour toute fonction, est qu’on peut la réutiliser pour appliquer ce recodage à plusieurs variables. Ainsi, si on veut recoder de la même manière pcs et pcs_mere, il suffit de faire : df %&gt;% mutate( pcs = recode_pcs(pcs), pcs_mere = recode_pcs(pcs_mere) ) Le code est plus court, plus lisible, on évite les erreurs de copier/coller, et si on souhaite modifier le recodage on n’a à intervenir qu’à un seul endroit en modifiant notre fonction. 15.1.2 Exemple avec summarise Autre exemple, cette fois sur le jeu de données rp2012. Imaginons qu’on souhaite calculer, pour chaque région, le pourcentage de communes dont le nom se termine par une série de caractères donnée : par exemple, le pourcentage de communes dont le nom se termine par “ac”. Comme il ne s’agit pas forcément d’une question triviale, on va décomposer le problème et rappeler (comme vu section 11.6) que la fonction str_detect() de l’extension stringr permet de détecter quels éléments d’un vecteur de chaînes de caractères correspondent à une expression régulière. Ainsi, si on veut détecter si un nom de commune (variable rp2012$commune) se termine par \"ac\", on utilisera : str_detect(rp2012$commune, &quot;ac$&quot;) Le symbole $ dans l’expression régulière “ac$” représente la fin de la chaîne de caractères. Il permet de s’assurer qu’on ne détecte que les noms de communes se terminant par “ac” (comme “Figeac”), et pas ceux contenant “ac” à un autre endroit (comme “Arcachon”). Si on veut compter le nombre de communes pour lesquelles on a détecté une terminaison en “ac”, on peut utiliser un idiome courant en R et appliquer la fonction sum() au résultat précédent : les TRUE du résultat du str_detect sont alors convertis en 1, les FALSE en 0, et le sum() renverra donc le nombre de TRUE. sum(str_detect(rp2012$commune, &quot;ac$&quot;)) #&gt; [1] 122 Si on souhaite convertir ce résultat en pourcentage, il faut qu’on divise par le nombre total de communes, et qu’on multiplie par 100. sum(str_detect(rp2012$commune, &quot;ac$&quot;)) / length(rp2012$commune) * 100 #&gt; [1] 2.359768 On crée une fonction nommée prop_suffixe qui a pour objectif d’effectuer ce calcul. Elle prend en entrée deux arguments : un vecteur de chaînes de caractères et un suffixe à détecter, et retourne le pourcentage d’éléments du vecteur se terminant par le suffixe. On rajoute nous-même le “$” à la fin du suffixe en question pour faciliter l’usage de la fonction. Le résultat final est le suivant : prop_suffixe &lt;- function(v, suffixe) { # On ajoute $ à la fin du suffixe pour capturer uniquement en fin de chaîne suffixe &lt;- paste0(suffixe, &quot;$&quot;) # Détection du suffixe nb_detect &lt;- sum(str_detect(v, suffixe)) # On retourne le pourcentage nb_detect / length(v) * 100 } On peut utiliser notre fonction de la manière suivante : prop_suffixe(rp2012$commune, &quot;ac&quot;) #&gt; [1] 2.359768 On a donc dans notre jeu de données 2.36% de communes dont le nom se termine par “ac”29. Si maintenant on souhaite calculer ce pourcentage pour toutes les régions françaises, il suffit d’appeler notre fonction dans un summarise : rp2012 %&gt;% group_by(region) %&gt;% summarise(prop_ac = prop_suffixe(commune, &quot;ac&quot;)) %&gt;% arrange(desc(prop_ac)) #&gt; # A tibble: 26 × 2 #&gt; region prop_ac #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Limousin 19.6 #&gt; 2 Aquitaine 12.2 #&gt; 3 Auvergne 8.62 #&gt; 4 Poitou-Charentes 5.88 #&gt; 5 Bretagne 4.68 #&gt; 6 Midi-Pyrénées 3.91 #&gt; 7 Languedoc-Roussillon 3.89 #&gt; 8 Pays de la Loire 2.18 #&gt; 9 Franche-Comté 1.16 #&gt; 10 Rhône-Alpes 1.03 #&gt; # … with 16 more rows L’avantage d’avoir créé une fonction pour effectuer cette opération et qu’on peut du coup très facilement faire le même calcul en faisant varier le suffixe recherché. rp2012 %&gt;% group_by(region) %&gt;% summarise(prop_ac = prop_suffixe(commune, &quot;ieu&quot;)) %&gt;% arrange(desc(prop_ac)) #&gt; # A tibble: 26 × 2 #&gt; region prop_ac #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Rhône-Alpes 3.42 #&gt; 2 Midi-Pyrénées 1.30 #&gt; 3 Bourgogne 0.917 #&gt; 4 Pays de la Loire 0.485 #&gt; 5 Aquitaine 0.358 #&gt; 6 Alsace 0 #&gt; 7 Auvergne 0 #&gt; 8 Basse-Normandie 0 #&gt; 9 Bretagne 0 #&gt; 10 Centre 0 #&gt; # … with 16 more rows En créant une fonction plutôt qu’en mettant notre code directement dans le summarise on a un script plus lisible, plus facile à maintenir, et des fonctionnalités facilement réutilisables. 15.1.3 Exemple avec rename_with On a vu section 10.2.3 que dplyr propose la fonction rename() pour renommer des colonnes d’un tableau de données. On peut l’utiliser par exemple pour remplacer un espace par un _ dans le nom d’une variable de df. df %&gt;% rename(&quot;age_enf1&quot; = &quot;age enf1&quot;) Supposons maintenant qu’on souhaite appliquer la même transformation à l’ensemble des variables de df. Une solution pour cela est d’utiliser la fonction rename_with(), toujours fournie par dplyr, qui prend en argument non pas une correspondance \"nouveau nom\" = \"ancien nom\" mais une fonction qui sera appliquée à l’ensemble des noms de colonnes. Par exemple, si on souhaite convertir tous les noms de colonnes en majuscules, on peut passer comme argument la fonction str_to_upper() de stringr. df %&gt;% rename_with(str_to_upper) #&gt; # A tibble: 8 × 8 #&gt; ID PCS PCS_PERE PCS_MERE AGE `AGE ENF1` `AGE ENF2` `AGE ENF3` #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 5 5 6 25 2 NA NA #&gt; 2 2 3 3 2 45 12 8 2 #&gt; 3 3 4 2 5 29 7 NA NA #&gt; 4 4 2 1 4 32 6 3 NA #&gt; 5 5 1 4 3 65 39 36 28 #&gt; 6 6 6 6 6 51 18 12 NA #&gt; 7 7 5 4 6 37 8 4 1 #&gt; 8 8 3 3 1 42 16 10 5 Pour remplacer les espaces par des _, on va d’abord créer une fonction ad hoc qui utilise str_replace_all. remplace_espaces &lt;- function(v) { str_replace_all(v, &quot; &quot;, &quot;_&quot;) } Dès lors, on peut appliquer cette fonction à l’ensemble de nos noms de variables : df %&gt;% rename_with(remplace_espaces) #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age age_enf1 age_enf2 age_enf3 #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 5 5 6 25 2 NA NA #&gt; 2 2 3 3 2 45 12 8 2 #&gt; 3 3 4 2 5 29 7 NA NA #&gt; 4 4 2 1 4 32 6 3 NA #&gt; 5 5 1 4 3 65 39 36 28 #&gt; 6 6 6 6 6 51 18 12 NA #&gt; 7 7 5 4 6 37 8 4 1 #&gt; 8 8 3 3 1 42 16 10 5 Certain.es lectrices et lecteurs attentives auront peut-être noté que le même résultat peut être obtenu en utilisant remplace_espaces() avec la fonction names(). names(df) &lt;- remplace_espaces(names(df)) L’avantage de rename_with() c’est qu’elle peut s’intégrer dans un pipeline de dplyr, et, comme nous allons le voir un peu plus loin, permet si nécessaire de n’appliquer cette transformation qu’à certaines colonnes seulement. 15.2 across() : appliquer des fonctions à plusieurs colonnes 15.2.1 Appliquer une fonction à plusieurs colonnes On a défini précédemment une fonction qui recode les modalités d’une variable PCS et on a vu comment appliquer ce recodage à deux variables de df. recode_pcs &lt;- function(v) { fct_recode(v, &quot;Agriculteur&quot; = &quot;1&quot;, &quot;Indépendant&quot; = &quot;2&quot;, &quot;Cadre&quot; = &quot;3&quot;, &quot;Intermédiaire&quot; = &quot;4&quot;, &quot;Employé&quot; = &quot;5&quot;, &quot;Ouvrier&quot; = &quot;6&quot; ) } df %&gt;% mutate( pcs = recode_pcs(pcs), pcs_mere = recode_pcs(pcs_mere) ) Supposons qu’on souhaite appliquer ce recodage à toutes les variables PCS de notre tableau. On pourrait évidemment créer autant de lignes que nécessaires dans notre mutate, mais on peut aussi utiliser la fonction across() de dplyr, qui facilite justement ce type d’opérations. across() prend deux arguments principaux : la définition d’un ensemble de colonnes de notre tableau de données une ou plusieurs fonctions à appliquer aux colonnes sélectionnées Il existe de nombreuses manières de définir les colonnes qu’on souhaite transformer : celles-ci sont en fait les mêmes que celles offertes par des verbes de dplyr comme select(). Une première possibilité est d’utiliser c() en lui passant les noms des variables (on notera qu’on n’est pas obligés de mettre ces noms entre guillemets). df %&gt;% mutate( across( c(pcs, pcs_mere), recode_pcs ) ) #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 Employé 5 Ouvrier 25 2 NA NA #&gt; 2 2 Cadre 3 Indépenda… 45 12 8 2 #&gt; 3 3 Intermédiaire 2 Employé 29 7 NA NA #&gt; 4 4 Indépendant 1 Intermédi… 32 6 3 NA #&gt; 5 5 Agriculteur 4 Cadre 65 39 36 28 #&gt; 6 6 Ouvrier 6 Ouvrier 51 18 12 NA #&gt; 7 7 Employé 4 Ouvrier 37 8 4 1 #&gt; 8 8 Cadre 3 Agriculte… 42 16 10 5 Une autre possibilité est d’utiliser :, qui permet de définir une plage de colonnes en lui indiquant la colonne de début et la colonne de fin. Ainsi dans l’exemple suivant notre recodage est appliqué à toutes les colonnes situées entre pcs et pcs_mere (incluses). df %&gt;% mutate( across( pcs:pcs_pere, recode_pcs ) ) #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 Employé Employé 6 25 2 NA NA #&gt; 2 2 Cadre Cadre 2 45 12 8 2 #&gt; 3 3 Intermédiaire Indépenda… 5 29 7 NA NA #&gt; 4 4 Indépendant Agriculte… 4 32 6 3 NA #&gt; 5 5 Agriculteur Intermédi… 3 65 39 36 28 #&gt; 6 6 Ouvrier Ouvrier 6 51 18 12 NA #&gt; 7 7 Employé Intermédi… 6 37 8 4 1 #&gt; 8 8 Cadre Cadre 1 42 16 10 5 On peut aussi sélectionner les variables via leurs noms. On peut ainsi choisir les variables qui commencent par une certaine chaîne de caractères via la fonction starts_with(), celles qui se terminent ou qui contiennent certains caractères avec ends_with() et contains(). df %&gt;% mutate( across( starts_with(&quot;pcs&quot;), recode_pcs ) ) #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 Employé Employé Ouvrier 25 2 NA NA #&gt; 2 2 Cadre Cadre Indépend… 45 12 8 2 #&gt; 3 3 Intermédiaire Indépend… Employé 29 7 NA NA #&gt; 4 4 Indépendant Agricult… Interméd… 32 6 3 NA #&gt; 5 5 Agriculteur Interméd… Cadre 65 39 36 28 #&gt; 6 6 Ouvrier Ouvrier Ouvrier 51 18 12 NA #&gt; 7 7 Employé Interméd… Ouvrier 37 8 4 1 #&gt; 8 8 Cadre Cadre Agricult… 42 16 10 5 across() fonctionne dans un mutate, mais aussi dans un summarise. Dans l’exemple suivant, on calcule la moyenne de toutes les variables qui contiennent “enf”. df %&gt;% summarise( across( contains(&quot;enf&quot;), mean ) ) #&gt; # A tibble: 1 × 3 #&gt; `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 13.5 NA NA De manière similaire, la fonction num_range() permet de sélectionner des colonnes ayant un préfixe commun suivi d’un indicateur numérique, comme x1, x2… Par exemple la syntaxe suivante sélectionnerait toutes les colonnes de Q01 à Q12 : across(num_range(&quot;Q&quot;, 1:12, width = 2)) On peut également sélectionner des colonnes via une condition avec la fonction where(). Celle-ci prend elle-même en argument une fonction qui doit renvoyer TRUE ou FALSE, et ne conserve que les colonnes qui correspondent à des TRUE. Dans l’exemple suivant, on applique la fonction mean seulement aux colonnes de df pour lesquelles la fonction is.numeric renvoie TRUE. df %&gt;% summarise( across( where(is.numeric), mean ) ) #&gt; # A tibble: 1 × 5 #&gt; id age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4.5 40.8 13.5 NA NA Pour des conditions plus complexes, on doit parfois définir soi-même la fonction passée à where(). Dans l’exemple suivant on calcule la moyenne uniquement pour les variables de df qui sont numériques et n’ont pas de valeurs manquantes. no_na &lt;- function(v) { is.numeric(v) &amp;&amp; sum(is.na(v)) == 0 } df %&gt;% summarise( across( where(no_na), mean ) ) #&gt; # A tibble: 1 × 3 #&gt; id age `age enf1` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4.5 40.8 13.5 Il est même possible, pour les cas les plus complexes, de combiner plusieurs sélections avec les opérateurs &amp;, | et !. L’exemple suivant applique la fonction mean() à toutes les colonnes numériques de df, sauf à la colonne id. df %&gt;% summarise( across( where(is.numeric) &amp; !id, mean ) ) #&gt; # A tibble: 1 × 4 #&gt; age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 40.8 13.5 NA NA Enfin, la fonction spéciale everything() permet de sélectionner la totalité des colonnes d’un tableau. Dans l’exemple suivant, on applique n_distinct() pour afficher le nombre de valeurs distinctes de toutes les variables de df. df %&gt;% summarise( across( everything(), n_distinct ) ) #&gt; # A tibble: 1 × 8 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 8 6 6 6 8 8 7 5 Ces différentes manières de sélectionner un ensemble de colonnes sont appelées tidy selection. Il y a encore d’autres possibilités de sélection, pour avoir un aperçu complet on pourra se référer à la page de documentation de la fonction select(). Une erreur de syntaxe fréquente est de mettre la sélection des colonnes dans l’appel à across(), mais pas la fonction qu’on souhaite appliquer. Ainsi le code suivant génèrera une erreur : mutate(across(pcs:pcs_mere), recode_pcs) Il faut bien penser à passer la fonction comme argument du across(), donc à l’intérieur de ses parenthèses. mutate(across(pcs:pcs_mere, recode_pcs)) 15.2.2 Passer des arguments supplémentaires à la fonction appliquée Par défaut, si on passe des arguments supplémentaires à across(), ils seront automatiquement transmis comme arguments à la fonction appliquée. Dans l’exemple vu précédemment, on appliquait mean() à toutes les variables d’âge de df. Or comme certaines colonnes ont des valeurs manquantes, leur résultat vaut NA. df %&gt;% summarise( across( starts_with(&quot;age&quot;), mean ) ) Si on préfère que mean() soit appelée avec l’argument na.rm = TRUE, on pourrait définir explicitement une fonction à part qui utilise cet argument : mean_sans_na &lt;- function(x) { max(x, na.rm = TRUE) } df %&gt;% summarise( across( starts_with(&quot;age&quot;), mean_sans_na ) ) Mais on peut faire plus simple, car tout argument supplémentaire passé à across() est transmis directement à la fonction appelée. Il est donc possible de faire : df %&gt;% summarise( across( starts_with(&quot;age&quot;), max, na.rm = TRUE ) ) #&gt; # A tibble: 1 × 4 #&gt; age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 65 39 36 28 15.2.3 Noms des colonnes créées par un mutate Par défaut, lorsqu’on utilise across() dans un mutate, les nouvelles colonnes portent le même nom que les colonnes d’origine, ce qui signifie que ces dernières sont “écrasées” par les nouvelles valeurs. Ainsi dans l’exemple suivant, les valeurs d’origine des colonnes PCS ont été écrasées par le résultat du recodage. df %&gt;% mutate( across( starts_with(&quot;pcs&quot;), recode_pcs ) ) Si on préfère créer de nouvelles colonnes, on doit indiquer la manière de les nommer en utilisant l’argument .names de across(). Celui prend comme valeur une chaîne de caractère dans laquelle le motif {.col} sera remplacé par le nom de la colonne d’origine. Ainsi, si on souhaite plutôt que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe _rec, on peut utiliser : df %&gt;% mutate( across( starts_with(&quot;pcs&quot;), recode_pcs, .names = &quot;{.col}_rec&quot; ) ) #&gt; # A tibble: 8 × 11 #&gt; id pcs pcs_pere pcs_mere age `age enf1` `age enf2` `age enf3` pcs_rec #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 1 5 5 6 25 2 NA NA Employé #&gt; 2 2 3 3 2 45 12 8 2 Cadre #&gt; 3 3 4 2 5 29 7 NA NA Interméd… #&gt; 4 4 2 1 4 32 6 3 NA Indépend… #&gt; 5 5 1 4 3 65 39 36 28 Agricult… #&gt; 6 6 6 6 6 51 18 12 NA Ouvrier #&gt; 7 7 5 4 6 37 8 4 1 Employé #&gt; 8 8 3 3 1 42 16 10 5 Cadre #&gt; # … with 2 more variables: pcs_pere_rec &lt;fct&gt;, pcs_mere_rec &lt;fct&gt; 15.2.4 Appliquer plusieurs fonctions à plusieurs colonnes across() offre également la possibilité d’appliquer plusieurs fonctions à un ensemble de colonnes. Dans ce cas, plutôt que de lui passer une seule fonction comme deuxième argument, on lui passe une liste nommée de fonctions. Le code suivant calcule le minimum et le maximum pour les variables d’âge de df. df %&gt;% summarise( across( starts_with(&quot;age&quot;), list(minimum = min, maximum = max) ) ) #&gt; # A tibble: 1 × 8 #&gt; age_minimum age_maximum `age enf1_minimum` `age enf1_maximum` `age enf2_minim… #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 25 65 2 39 NA #&gt; # … with 3 more variables: age enf2_maximum &lt;dbl&gt;, age enf3_minimum &lt;dbl&gt;, #&gt; # age enf3_maximum &lt;dbl&gt; Par défaut les nouvelles variables sont nommées sous la forme {nom_variable}_{nom_fonction}, mais on peut personnaliser cette règle en ajoutant un argument .names à across(). Cet argument est une chaîne de caractères dans laquelle {.col} sera remplacé par le nom de la colonne courante, et {.fn} par le nom de la fonction. df %&gt;% summarise( across( starts_with(&quot;age&quot;), list(minimum = min, maximum = max), .names = &quot;{.fn}_{.col}&quot; ) ) #&gt; # A tibble: 1 × 8 #&gt; minimum_age maximum_age `minimum_age enf1` `maximum_age enf1` `minimum_age en… #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 25 65 2 39 NA #&gt; # … with 3 more variables: maximum_age enf2 &lt;dbl&gt;, minimum_age enf3 &lt;dbl&gt;, #&gt; # maximum_age enf3 &lt;dbl&gt; 15.2.5 Renommer plusieurs colonnes avec une fonction On a vu précédemment qu’on peut utiliser rename_with() pour renommer les colonnes d’un tableau de données à l’aide d’une fonction. remplace_espaces &lt;- function(v) { str_replace_all(v, &quot; &quot;, &quot;_&quot;) } df %&gt;% rename_with(remplace_espaces) Par défaut, rename_with() applique la fonction de renommage à l’ensemble des colonnes du tableau. Il est cependant possible de lui indiquer de ne renommer que certaines de ces colonnes. Pour cela, on peut lui ajouter un argument supplémentaire nommé .cols, dont la syntaxe est exactement la même que pour across() ou select(). Par exemple, le code suivant convertit en majuscule uniquement les noms des colonnes id et poids. df %&gt;% rename_with(str_to_upper, .cols = starts_with(&quot;pcs&quot;)) #&gt; # A tibble: 8 × 8 #&gt; id PCS PCS_PERE PCS_MERE age `age enf1` `age enf2` `age enf3` #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 5 5 6 25 2 NA NA #&gt; 2 2 3 3 2 45 12 8 2 #&gt; 3 3 4 2 5 29 7 NA NA #&gt; 4 4 2 1 4 32 6 3 NA #&gt; 5 5 1 4 3 65 39 36 28 #&gt; 6 6 6 6 6 51 18 12 NA #&gt; 7 7 5 4 6 37 8 4 1 #&gt; 8 8 3 3 1 42 16 10 5 Et le code suivant remplace les espaces par des _ uniquement pour les colonnes dont le nom contient “enf”. df %&gt;% rename_with(remplace_espaces, .cols = contains(&quot;enf&quot;)) #&gt; # A tibble: 8 × 8 #&gt; id pcs pcs_pere pcs_mere age age_enf1 age_enf2 age_enf3 #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 5 5 6 25 2 NA NA #&gt; 2 2 3 3 2 45 12 8 2 #&gt; 3 3 4 2 5 29 7 NA NA #&gt; 4 4 2 1 4 32 6 3 NA #&gt; 5 5 1 4 3 65 39 36 28 #&gt; 6 6 6 6 6 51 18 12 NA #&gt; 7 7 5 4 6 37 8 4 1 #&gt; 8 8 3 3 1 42 16 10 5 15.3 Fonctions anonymes et syntaxes abrégées Dans les sections précédentes, nous avons rencontré plusieurs fonctions, comme rename_with() ou across(), qui prennent une fonction en argument. Par exemple, dans l’utilisation suivante de rename_with(), on avait créé une fonction remplace_points(). remplace_espaces &lt;- function(v) { str_replace_all(v, &quot; &quot;, &quot;_&quot;) } df %&gt;% rename_with(remplace_espaces) Le fait de créer une fonction à part pour une opération d’une seule ligne ne se justifie pas forcément, surtout si on n’utilise pas cette fonction ailleurs dans notre code. Dans, ce cas, on peut définir notre fonction directement dans l’appel à rename_with() en utilisant une fonction anonyme, déjà introduites section 14.4.2. df %&gt;% rename_with(function(v) { str_replace_all(v, &quot; &quot;, &quot;_&quot;) }) Cette notation est assez pratique et souvent utilisée pour les fonctions à usage unique, ne serait-ce que pour s’économiser le fait de devoir lui trouver un nom pertinent. La syntaxe étant un peu lourde, il existe deux alternatives permettant une définition plus “compacte”. La première alternative est propre aux packages du tidyverse (notamment dplyr et purrr), et ne fonctionnera pas pour les fonctions n’appartenant pas à ces packages. Il s’agit d’utiliser une syntaxe de type “formule” : le corps de la formule contient les instructions de la fonction, et les arguments sont nommés .x (ou .) s’il n’y en a qu’un, .x et .y s’il y en a deux, et ..1, ..2, etc. s’ils sont plus nombreux. La deuxième alternative est une syntaxe apparue avec la version 4.1 de R, qui permet de remplacer function(...) par le raccourci \\(...). Ainsi les définitions suivantes sont équivalents : # Fonctionne partout et tout le temps function(v) { v + 2 } # Fonctionne uniquement dans les fonctions du tidyverse ~ { .x + 2 } # Fonctionne uniquement à partir de R 4.1 \\(v) { v + 2 } De même que les définitions suivantes : function(v1, v2) { res &lt;- v1 / v2 round(res, 1) } ~ { res &lt;- .x / .y round(res, 1) } \\(v1, v2) { res &lt;- v1 / v2 round(res, 1) } Quand la fonction anonyme est constituée d’une seule instruction, on peut supprimer les accolades dans sa définition. function(x) x + 2 ~ .x + 2 \\(x) x + 2 On pourra du coup, si on le souhaite, utiliser ces syntaxes compactes dans notre rename_with() pour définir notre fonction anonyme. df %&gt;% rename_with(~ str_replace_all(.x, &quot; &quot;, &quot;_&quot;) ) df %&gt;% rename_with( \\(x) str_replace_all(x, &quot; &quot;, &quot;_&quot;) ) Cette syntaxe peut être utilisée partout où on peut passer une fonction comme argument et donc définir des fonctions anonymes. Dans cet exemple déjà vu précédemment, on passe la fonction no_na comme argument de where(). no_na &lt;- function(v) { is.numeric(v) &amp;&amp; sum(is.na(v)) == 0 } df %&gt;% summarise( across( where(no_na), mean ) ) On peut donc remplacer la fonction no_na par une fonction anonyme définie directement dans le where(). df %&gt;% summarise( across( where(function(v) { is.numeric(v) &amp;&amp; sum(is.na(v)) == 0 }), mean ) ) Et du coup utiliser une des deux syntaxes “compactes”. df %&gt;% summarise( across( where(~ is.numeric(.x) &amp;&amp; sum(is.na(.x)) == 0), mean ) ) df %&gt;% summarise( across( where(\\(v) is.numeric(v) &amp;&amp; sum(is.na(v)) == 0), mean ) ) 15.4 rowwise() et c_across() : appliquer une transformation ligne par ligne Soit le tableau de données suivant, qui contient des évaluations de restaurants sur quatre critères différents30 : restos &lt;- tribble( ~nom, ~cuisine, ~decor, ~accueil, ~prix, &quot;La bonne fourchette&quot;, 4, 2, 5, 4, &quot;La choucroute de l&#39;amer&quot;, 3, 3, 2, 3, &quot;L&#39;Hair de rien&quot;, 1, 4, 4, 3, &quot;La blanquette de Vaulx&quot;, 5, 4, 4, 5, ) restos #&gt; # A tibble: 4 × 5 #&gt; nom cuisine decor accueil prix #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 #&gt; 3 L&#39;Hair de rien 1 4 4 3 #&gt; 4 La blanquette de Vaulx 5 4 4 5 Imaginons qu’on souhaite faire la moyenne, pour chaque restaurant, des critères decor et accueil. On pourrait être tentés d’utiliser mean() de la manière suivante : restos %&gt;% mutate( decor_accueil = mean(c(decor, accueil)) ) #&gt; # A tibble: 4 × 6 #&gt; nom cuisine decor accueil prix decor_accueil #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 3.5 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 3.5 #&gt; 3 L&#39;Hair de rien 1 4 4 3 3.5 #&gt; 4 La blanquette de Vaulx 5 4 4 5 3.5 Si on regarde le résultat, on constate qu’il ne correspond pas à ce que l’on souhaite puisque toutes les valeurs sont les mêmes. Que s’est-il passé ? En fait le mutate s’est appliqué sur la totalité du tableau. Ceci signifie que dans mean(c(decor, accueil)), les objets decor et accueil correspondent à la totalité des valeurs de chaque variable. On a donc concaténé ces deux vecteurs et calculé la moyenne, qui est du coup la même pour chaque ligne. La valeur obtenue correspond aux résultat de : mean(c(restos$decor, restos$accueil)) #&gt; [1] 3.5 Ce que nous souhaitons ici, c’est calculer la moyenne non pas pour l’ensemble du tableau mais pour chaque ligne. Pour cela, on va utiliser la fonction rowwise() : celle-ci est équivalente à un group_by() qui créerait autant de groupes qu’il y a de lignes dans notre tableau. restos %&gt;% rowwise() #&gt; # A tibble: 4 × 5 #&gt; # Rowwise: #&gt; nom cuisine decor accueil prix #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 #&gt; 3 L&#39;Hair de rien 1 4 4 3 #&gt; 4 La blanquette de Vaulx 5 4 4 5 Quant notre tableau est groupé via un rowwise(), les opérations s’effectuent sur un tableau constitué uniquement de la ligne courante. Si on calcule la moyenne précédente, on obtient désormais le bon résultat. restos %&gt;% rowwise() %&gt;% mutate(decor_accueil = mean(c(decor, accueil))) #&gt; # A tibble: 4 × 6 #&gt; # Rowwise: #&gt; nom cuisine decor accueil prix decor_accueil #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 3.5 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 2.5 #&gt; 3 L&#39;Hair de rien 1 4 4 3 4 #&gt; 4 La blanquette de Vaulx 5 4 4 5 4 Supposons qu’on souhaite désormais calculer la moyenne de l’ensemble des critères. On peut évidemment reprendre le code précédent en saisissant toutes les variables concernées. restos %&gt;% rowwise() %&gt;% mutate(moyenne = mean(c(decor, accueil, cuisine, prix))) #&gt; # A tibble: 4 × 6 #&gt; # Rowwise: #&gt; nom cuisine decor accueil prix moyenne #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 3.75 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 2.75 #&gt; 3 L&#39;Hair de rien 1 4 4 3 3 #&gt; 4 La blanquette de Vaulx 5 4 4 5 4.5 Lister les variables de cette manière peut vite devenir pénible si le nombre de variables est important. C’est pourquoi dplyr propose la fonction c_across() : celle-ci permet de sélectionner des colonnes de la même manière que select() ou across(), et retourne un vecteur constitué des valeurs concaténées de ces colonnes. L’exemple suivant calcule la moyenne de toutes les colonnes comprises entre decor et prix, en utilisant l’opérateur :. restos %&gt;% rowwise() %&gt;% mutate( moyenne = mean(c_across(decor:prix)) ) #&gt; # A tibble: 4 × 6 #&gt; # Rowwise: #&gt; nom cuisine decor accueil prix moyenne #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 3.67 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 2.67 #&gt; 3 L&#39;Hair de rien 1 4 4 3 3.67 #&gt; 4 La blanquette de Vaulx 5 4 4 5 4.33 Comme pour across() ou select(), on peut utiliser la fonction where() pour calculer la moyenne sur toutes les colonnes numériques. restos %&gt;% rowwise() %&gt;% mutate( moyenne = mean( c_across(where(is.numeric)) ) ) #&gt; # A tibble: 4 × 6 #&gt; # Rowwise: #&gt; nom cuisine decor accueil prix moyenne #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 4 2 5 4 3.75 #&gt; 2 La choucroute de l&#39;amer 3 3 2 3 2.75 #&gt; 3 L&#39;Hair de rien 1 4 4 3 3 #&gt; 4 La blanquette de Vaulx 5 4 4 5 4.5 L’utilisation de rowwise() et c_across() est intéressante principalement quand il n’existe pas de fonction vectorisée pour la transformation qu’on souhaite appliquer. Quand elle existe, il est en général plus simple et plus rapide de l’utiliser. Par exemple, pour trouver la valeur la plus élevée par restaurant, on pourrait être tenté d’utiliser le code suivant : restos %&gt;% rowwise() %&gt;% summarise(note_max = max(c(decor, accueil))) #&gt; # A tibble: 4 × 1 #&gt; note_max #&gt; &lt;dbl&gt; #&gt; 1 5 #&gt; 2 3 #&gt; 3 4 #&gt; 4 4 Il est cependant plus lisible et plus efficace d’utiliser la fonction pmax, qui a justement pour objectif de parcourir des vecteurs en parallèle et de ne conserver que la plus grande valeur. restos %&gt;% summarise(note_max = pmax(decor, accueil)) #&gt; # A tibble: 4 × 1 #&gt; note_max #&gt; &lt;dbl&gt; #&gt; 1 5 #&gt; 2 3 #&gt; 3 4 #&gt; 4 4 Une des limites de pmax cependant est qu’on ne peut pas l’utiliser avec c_across(), et qu’on ne peut donc pas faire de sélection des colonnes : on est obligés de saisir leurs noms. restos %&gt;% summarise(note_max = pmax(cuisine, decor, accueil, prix)) #&gt; # A tibble: 4 × 1 #&gt; note_max #&gt; &lt;dbl&gt; #&gt; 1 5 #&gt; 2 3 #&gt; 3 4 #&gt; 4 5 Dans certains cas, notamment lorsque les colonnes sont nombreuses ou qu’on ne les a pas identifiées à l’avance, on pourra donc utiliser rowwise() et c_across() même quand des alternatives vectorisées existent. restos %&gt;% rowwise() %&gt;% summarise( note_max = max( c_across(where(is.numeric)) ) ) #&gt; # A tibble: 4 × 1 #&gt; note_max #&gt; &lt;dbl&gt; #&gt; 1 5 #&gt; 2 3 #&gt; 3 4 #&gt; 4 5 15.5 Ressources La page d’aide de la fonction select (en anglais) liste toutes les possibilités offertes pour spécifier des ensembles de colonnes d’un tableau de données. La vignette Column-wise operations de dplyr (en anglais) présente en détail l’utilisation et les fonctionnalités de across(). La vignette Row-wise operations de dplyr (toujours en anglais) présente de manière approfondie l’utilisation de rowwise() et c_across() pour opérer individuellement sur les lignes d’un tableau de données. 15.6 Exercices Pour certains des exercices qui suivent on utilisera le jeu de données starwars de dplyr. On peut le charger avec les instructions suivantes : library(dplyr) data(starwars) Le jeu de données contient les caractéristiques de 87 personnages présents dans les films : espèce, âge, planète d’origine, etc. 15.6.1 Appliquer ses propres fonctions Exercice 1.1 Créer une fonction imc qui prend en argument un vecteur taille (en cm) et un vecteur poids (en kg) et retourne les valeurs correspondantes de l’indice de masse corporelle, qui se calcule en divisant le poids en kilos par la taille en mètres au carré. imc &lt;- function(tailles, poids) { tailles_m &lt;- tailles / 100 poids / tailles_m ^ 2 } Utiliser cette fonction pour ajouter une nouvelle variable imc au tableau starwars. starwars %&gt;% mutate(imc = imc(height, mass)) À l’aide de group_by() et summarise(), utiliser à nouveau cette fonction pour calculer l’IMC moyen selon les valeurs de la variable species. starwars %&gt;% group_by(species) %&gt;% summarise( imc = mean(imc(height, mass), na.rm = TRUE) ) Exercice 1.2 Toujours dans le jeu de données starwars, à l’aide d’un group_by() et d’un summarise(), calculer pour chaque valeur de la variable sex la valeur de l’étendue de la variable height du jeu de données starwars, c’est-à-dire la différence entre sa valeur maximale et sa valeur minimale. starwars %&gt;% group_by(sex) %&gt;% summarise( etendue_taille = max(height, na.rm = TRUE) - min(height, na.rm = TRUE) ) En partant du code précédent, créer une fonction etendue qui prend en argument un vecteur et retourne la différence entre sa valeur maximale et sa valeur minimale. En utilisant cette fonction, calculer pour chaque valeur de sex la valeur de l’étendue des variables height et mass. etendue &lt;- function(v) { max(v, na.rm = TRUE) - min(v, na.rm = TRUE) } starwars %&gt;% group_by(sex) %&gt;% summarise( etendue_taille = etendue(height), etendue_poids = etendue(mass) ) Exercice 1.3 On a vu que la fonction suivante permet de calculer le pourcentage des éléments d’un vecteur de chaînes de caractères se terminant par un suffixe passé en argument. prop_suffixe &lt;- function(v, suffixe) { # On ajoute $ à la fin du suffixe pour capturer uniquement en fin de chaîne suffixe &lt;- paste0(suffixe, &quot;$&quot;) # Détection du suffixe nb_detect &lt;- sum(str_detect(v, suffixe)) # On retourne le pourcentage nb_detect / length(v) * 100 } Modifier cette fonction en une fonction prop_prefixe qui retourne le pourcentage d’éléments commençant par un préfixe passé en argument. Indication : pour détecter si une chaîne commence par \"ker\", on utilise l’expression régulière \"^ker\". prop_prefixe &lt;- function(v, prefixe) { # On ajoute $ à la fin du prefixe pour capturer uniquement en début de chaîne prefixe &lt;- paste0(&quot;^&quot;, prefixe) # Détection du motif nb_detect &lt;- sum(str_detect(v, prefixe)) # On retourne le pourcentage nb_detect / length(v) * 100 } Utiliser prop_prefixe dans un summarise appliqué à rp2012 pour calculer le pourcentage de communes commençant par “Saint” selon le département. Ordonner les résultats par pourcentage décroissant. rp2012 %&gt;% group_by(departement) %&gt;% summarise( prop_saint = prop_prefixe(commune, &quot;Saint&quot;) ) %&gt;% arrange(desc(prop_saint)) Créer une fonction tab_prefixe qui prend un seul argument prefixe et renvoie le tableau obtenu à la question précédente pour le préfixe passé en argument. Tester avec tab_prefixe(\"Plou\") et tab_prefixe(\"Sch\") tab_prefixe &lt;- function(prefixe) { rp2012 %&gt;% group_by(departement) %&gt;% summarise( prop = prop_prefixe(commune, prefixe) ) %&gt;% arrange(desc(prop)) } Exercice 1.4 Le vecteur suivant donne, pour chacun des neuf principaux films de la saga Star Wars, la date à laquelle ils se déroulent dans l’univers de la saga. c( &quot;I&quot; = -32, &quot;II&quot; = -22, &quot;III&quot; = -19, &quot;IV&quot; = 0, &quot;V&quot; = 3, &quot;VI&quot; = 4, &quot;VII&quot; = 34, &quot;VIII&quot; = 34, &quot;IX&quot; = 35 ) Dans le jeu de données starwars, la variable birth_year indique l’année de naissance du personnage en “années avant l’an zéro” (une valeur de 19 signifie donc une année de naissance de -19). Créer une fonction age_film qui prend en entrée un vecteur d’années de naissance au même format que birth_year ainsi que l’identifiant d’un film, et calcule les âges à la date du film. Vérifier avec : age_film(starwars$birth_year, &quot;IV&quot;) #&gt; [1] 19.0 112.0 33.0 41.9 19.0 52.0 47.0 NA 24.0 57.0 41.9 64.0 #&gt; [13] 200.0 29.0 44.0 600.0 21.0 NA 896.0 82.0 31.5 15.0 53.0 31.0 #&gt; [25] 37.0 41.0 48.0 NA 8.0 NA 92.0 NA 91.0 52.0 NA NA #&gt; [37] NA NA NA 62.0 72.0 54.0 NA 48.0 NA NA NA 72.0 #&gt; [49] 92.0 NA NA NA NA NA 22.0 NA NA NA 82.0 NA #&gt; [61] 58.0 40.0 NA 102.0 67.0 66.0 NA NA NA NA NA NA #&gt; [73] NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [85] NA NA 46.0 age_film &lt;- function(annees, film) { annees_films &lt;- c( &quot;I&quot; = -32, &quot;II&quot; = -22, &quot;III&quot; = -19, &quot;IV&quot; = 0, &quot;V&quot; = 3, &quot;VI&quot; = 4, &quot;VII&quot; = 34, &quot;VIII&quot; = 34, &quot;IX&quot; = 35 ) annees_naissance &lt;- -annees annee_ref &lt;- annees_films[film] annee_ref - annees_naissance } Utiliser la fonction pour ajouter deux nouvelles variables au tableau starwars : age_iv qui correspond à l’âge (potentiel) au moment du film IV, et age_ix qui correspond à l’âge au moment du film IX. starwars %&gt;% mutate( age_iv = age_film(birth_year, &quot;IV&quot;), age_ix = age_film(birth_year, &quot;IX&quot;), ) 15.6.2 across() Exercice 2.1 Reprendre la fonction etendue de l’exercice 1.2 : etendue &lt;- function(v) { max(v, na.rm = TRUE) - min(v, na.rm = TRUE) } Dans le jeu de données starwars, calculer l’étendue des variables height et mass pour chaque valeur de sex à l’aide de group_by(), summarise() et across(). starwars %&gt;% group_by(sex) %&gt;% summarise( across( c(height, mass), etendue ) ) Toujours à l’aide d’across(), appliquer etendue à toutes les variables numériques, toujours pour chaque valeur de sex. starwars %&gt;% group_by(sex) %&gt;% summarise( across( where(is.numeric), etendue ) ) En utilisant &amp; et !, appliquer etendue à toutes les variables numériques sauf à celles qui finissent par “year”. starwars %&gt;% group_by(sex) %&gt;% summarise( across( where(is.numeric) &amp; !ends_with(&quot;year&quot;), etendue ) ) Exercice 2.2 Dans le jeu de données starwars, appliquer en un seul summarise les fonctions min et max aux variables height et mass. starwars %&gt;% summarise( across( c(height, mass), list(min = min, max = max) ) ) Si vous ne l’avez pas déjà fait à la question précédente, modifier le code pour que le calcul des valeurs minimales et maximales ne prennent pas en compte les valeurs manquantes. funs &lt;- list( min = function(v) { min(v, na.rm = TRUE) }, max = function(v) { max(v, na.rm = TRUE) } ) starwars %&gt;% summarise( across( c(height, mass), funs ) ) # Autre possibilité : les arguments supplémentaires passés à across() sont # transmis aux fonctions appliquées starwars %&gt;% summarise( across( c(height, mass), list(min = min, max = max), na.rm = TRUE ) ) Exercice 2.3 Dans le jeu de données hdv2003, utiliser across() pour transformer les modalités “Oui” et “Non” en TRUE et FALSE pour toutes les variables de hard.rock à sport. detecte_oui &lt;- function(v) { v == &quot;Oui&quot; } hdv2003 %&gt;% mutate( across( hard.rock:sport, detecte_oui ) ) Ajouter un argument .names à across() pour que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe \"_true\". detecte_oui &lt;- function(v) { v == &quot;Oui&quot; } hdv2003 %&gt;% mutate( across( hard.rock:sport, detecte_oui, .names = &quot;{.col}_true&quot; ) ) 15.6.3 Fonctions anonymes et notations abrégées Exercice 3.1 Soit le code suivant, qui renomme les colonnes du tableau starwars de type liste en leur ajoutant le préfixe “liste_”. ajoute_prefixe_liste &lt;- function(nom) { paste0(&quot;liste_&quot;, nom) } starwars %&gt;% rename_with(ajoute_prefixe_liste, .cols = where(is.list)) Réécrire ce code avec une fonction anonyme en utilisant les trois notations : classique (avec function()) formule (du tidyverse) compacte (à partir de R 4.1) # Classique starwars %&gt;% rename_with( function(nom) { paste0(&quot;liste_&quot;, nom) }, .cols = where(is.list) ) # Formule starwars %&gt;% rename_with( ~ paste0(&quot;liste_&quot;, .x), .cols = where(is.list) ) # Compacte starwars %&gt;% rename_with( \\(nom) paste0(&quot;liste_&quot;, nom), .cols = where(is.list) ) Exercice 3.2 Le code suivant indique, pour chaque région du jeu de données rp2012, le nom de la commune ayant la valeur maximale pour les variables dipl_aucun et dipl_sup. nom_commune_max &lt;- function(valeurs, communes) { communes[valeurs == max(valeurs)] } rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), nom_commune_max, commune ) ) #&gt; # A tibble: 26 × 3 #&gt; region dipl_aucun dipl_sup #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Alsace Bischwiller Strasbourg #&gt; 2 Aquitaine Les Églisottes-et-Chalaures Bordeaux #&gt; 3 Auvergne Aigueperse Chamalières #&gt; 4 Basse-Normandie Périers Saint-Contest #&gt; 5 Bourgogne Saint-Florentin Fontaine-lès-Dijon #&gt; 6 Bretagne La Guerche-de-Bretagne Saint-Grégoire #&gt; 7 Centre Gièvres Olivet #&gt; 8 Champagne-Ardenne Pargny-sur-Saulx Taissy #&gt; 9 Corse Ghisonaccia Ville-di-Pietrabugno #&gt; 10 Franche-Comté Saint-Loup-sur-Semouse Pirey #&gt; # … with 16 more rows Réécrire ce code en utilisant une fonction anonyme, avec la syntaxe de votre choix (classique, formule ou compacte). # Classique rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), function(valeurs, communes) { communes[valeurs == max(valeurs)] }, commune ) ) # Formule rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), ~ .y[.x == max(.x)], commune ) ) # Compacte rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), \\(valeurs, communes) communes[valeurs == max(valeurs)], commune ) ) À l’aide d’une fonction anonyme supplémentaire, modifier le code pour qu’il retourne également, pour les mêmes variables, le nom des communes avec les valeurs minimales. # Formule rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), list( max = ~ .y[.x == max(.x)], min = ~ .y[.x == min(.x)] ), commune ) ) # Compacte rp2012 %&gt;% group_by(region) %&gt;% summarise( across( c(dipl_aucun, dipl_sup), list( max = \\(valeurs, communes) communes[valeurs == max(valeurs)], min = \\(valeurs, communes) communes[valeurs == min(valeurs)] ), commune ) ) %&gt;% View() 15.6.4 rowwise() et c_across() Exercice 4.1 On repart du code final de l’exercice 2.3, qui recodait une série de variables de hdv2003 en valeurs TRUE/FALSE dans de nouvelles variables avec le suffixe \"_true\". detecte_oui &lt;- function(v) { v == &quot;Oui&quot; } hdv2003 &lt;- hdv2003 %&gt;% mutate( across( hard.rock:sport, detecte_oui, .names = &quot;{.col}_true&quot; ) ) Calculer le plus simplement possible une nouvelle variable total qui contient, pour chaque ligne, le nombre de valeurs TRUE des deux variables cinema_true et sport_true (si une ligne contient TRUE pour ces deux variables, total doit valoir 2, etc.) hdv2003 %&gt;% mutate(total = cuisine_true + sport_true) Recalculer la variable total pour qu’elle contienne le nombre de TRUE par ligne pour les variables bricol_true, cinema_true et sport_true. hdv2003 %&gt;% rowwise() %&gt;% mutate(total = sum(cuisine_true, sport_true, bricol_true)) Recalculer la variable total pour qu’elle contienne le nombre de TRUE par ligne pour toutes les variables se terminant par \"_true\". hdv2003 %&gt;% rowwise() %&gt;% mutate(total = sum(c_across(ends_with(&quot;_true&quot;)))) Reprendre le code précédent pour qu’il puisse s’appliquer directement sur les variables hard.rock…sport, sans passer par le recodage en TRUE/FALSE. count_oui &lt;- function(v) { sum(v == &quot;Oui&quot;) } hdv2003 %&gt;% rowwise() %&gt;% mutate( total = count_oui(c_across(hard.rock:sport)) ) Exercice 4.2 Dans le jeu de données starwars, la colonne films contient la liste des films dans lesquels apparaissent les différents personnages. Cette colonne a une forme un peu particulière puisqu’il s’agit d’une “colonne-liste” : les éléments de cette colonne sont eux-mêmes des listes. head(starwars$films, 3) #&gt; [[1]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Revenge of the Sith&quot; #&gt; [3] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; [5] &quot;The Force Awakens&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Attack of the Clones&quot; #&gt; [3] &quot;The Phantom Menace&quot; &quot;Revenge of the Sith&quot; #&gt; [5] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Attack of the Clones&quot; #&gt; [3] &quot;The Phantom Menace&quot; &quot;Revenge of the Sith&quot; #&gt; [5] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; [7] &quot;The Force Awakens&quot; On essaye de calculer le nombre de films pour chaque personnage avec le code suivant. Est-ce que ça fonctionne ? Pourquoi ? starwars %&gt;% mutate(n_films = length(films)) Trouver une manière d’obtenir le résultat attendu. starwars %&gt;% rowwise() %&gt;% mutate(n_films = length(films)) Attention, le jeu de données ne comporte que les communes de plus de 2000 habitants.↩︎ Un nom de salon de coiffure s’est glissé dans cette liste de restaurants. Saurez-vous le retrouver ?↩︎ "],["16-structures-donnees.html", "Partie 16 Structures de données 16.1 Vecteurs atomiques 16.2 Listes 16.3 Tableaux de données (data frame et tibble) 16.4 Ressources 16.5 Exercices", " Partie 16 Structures de données R propose de nombreuses structures de données différentes, et les extensions peuvent en implémenter de nouvelles. Cette section introduit trois structures parmi les plus utilisées : les vecteurs atomiques, les listes et les tableaux de données. Certaines ont déjà été abordées et utilisées précédemment, mais connaître leurs spécificités et savoir les manipuler est utile voire indispensable, notamment lorsqu’on veut créer ses propres fonctions. 16.1 Vecteurs atomiques Les vecteurs atomiques sont des structures qui regroupent ensemble plusieurs éléments constitués d’une seule valeur, avec deux contraintes : ces valeurs doivent toutes être du même type. Les vecteurs atomiques ont déjà été introduits section 9.1. 16.1.1 Création d’un vecteur On peut construire un vecteur manuellement avec la fonction c(). x &lt;- c(1, 3, 8) Si on souhaite générer un vecteur de valeurs entières successives, on peut utiliser l’opérateur : ou la fonction seq_len(). 2:8 #&gt; [1] 2 3 4 5 6 7 8 seq_len(5) #&gt; [1] 1 2 3 4 5 La fonction seq() permet de générer des séquences régulière plus complexes. seq(0.5, 2.5, by = 0.5) #&gt; [1] 0.5 1.0 1.5 2.0 2.5 seq(0, 4, length.out = 6) #&gt; [1] 0.0 0.8 1.6 2.4 3.2 4.0 Une autre variante de seq(), nommée seq_along(), permet de générer un vecteur d’entiers correspondant à la longueur d’un objet passé en argument : x &lt;- c(&quot;Pomme&quot;, &quot;Poire&quot;) seq_along(x) #&gt; [1] 1 2 y &lt;- runif(10) seq_along(y) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Enfin, la fonction rep() permet de répéter un élément ou un vecteur. rep(&quot;Pomme&quot;, 6) #&gt; [1] &quot;Pomme&quot; &quot;Pomme&quot; &quot;Pomme&quot; &quot;Pomme&quot; &quot;Pomme&quot; &quot;Pomme&quot; rep(1:4, 2) #&gt; [1] 1 2 3 4 1 2 3 4 Si on souhaite connaître le nombre d’éléments d’un vecteur, on peut utiliser la fonction length(). v &lt;- rep(1:4, 2) length(v) #&gt; [1] 8 Il peut parfois être utile de créer des vecteurs “vides”. Dans ce cas on peut les initialiser avec les fonctions vector(), character() ou numeric(). Par défaut ces fonctions renvoient un vecteur sans élément, mais on peut aussi leur indiquer en argument le nombre d’éléments souhaités (qui seront alors initialisés avec une valeur par défaut). numeric() #&gt; numeric(0) character(2) #&gt; [1] &quot;&quot; &quot;&quot; 16.1.2 Vecteurs nommés Les éléments d’un vecteur peuvent être nommés. Ces noms peuvent êtré définis au moment de la création du vecteur. x &lt;- c(e1 = 1, e2 = 3, e3 = 8) x #&gt; e1 e2 e3 #&gt; 1 3 8 On peut utiliser names() pour récupérer les noms des éléments d’un vecteur. names(x) #&gt; [1] &quot;e1&quot; &quot;e2&quot; &quot;e3&quot; On peut aussi utiliser names() pour créer ou modifier les noms d’un vecteur existant. names(x) &lt;- c(&quot;brouette&quot;, &quot;moto&quot;, &quot;igloo&quot;) x #&gt; brouette moto igloo #&gt; 1 3 8 16.1.3 Types de vecteurs On peut déterminer le type d’un vecteur avec l’instruction typeof. x &lt;- c(1, 3, 8) typeof(x) #&gt; [1] &quot;double&quot; y &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) typeof(y) #&gt; [1] &quot;character&quot; z &lt;- c(TRUE, FALSE, FALSE) typeof(z) #&gt; [1] &quot;logical&quot; Parmi les principaux types de données on notera31 : les chaînes de caractères (character) les nombres flottants (double) les nombres entiers (integer) les valeurs logiques (logical) À noter que par défaut les nombres sont considérés comme des nombres flottants (des nombres décimaux avec une virgule) : pour les définir explicitement comme nombres entiers on peut leur ajouter le suffixe L. x &lt;- c(1L, 3L, 8L) typeof(x) #&gt; [1] &quot;integer&quot; On peut tester le type d’un vecteur avec les fonctions is.character, is.double, is.logical… Autre fonction utile, is.numeric teste si un vecteur est de type double ou integer. x &lt;- c(1, 3, 8) is.numeric(x) #&gt; [1] TRUE x &gt; 2 #&gt; [1] FALSE TRUE TRUE is.logical(x &gt; 2) #&gt; [1] TRUE y &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) is.character(y) #&gt; [1] TRUE Petite spécificité, les facteurs (voir section 9.3.1) ne sont pas considérés par R comme des character, même s’ils comportent des chaînes de caractères. Pour tester si un vecteur est de type facteur, on utilise is.factor(). fac &lt;- factor(c(&quot;rouge&quot;, &quot;vert&quot;, &quot;rouge&quot;)) is.character(fac) #&gt; [1] FALSE is.factor(fac) #&gt; [1] TRUE Tous les éléments d’un vecteur doivent être du même type. Si ça n’est pas le cas, les éléments seront convertis au type le plus “général” présent dans le vecteur, sachant que les character sont plus généraux que les numeric, qui sont eux-mêmes plus généraux que les logical. Dans l’exemple suivant, le nombre 1 est transformé en chaîne de caractère \"1\". c(1, &quot;foo&quot;) #&gt; [1] &quot;1&quot; &quot;foo&quot; Si on mélange nombres et valeurs logiques, les TRUE sont convertis en 1 et les FALSE en 0. c(TRUE, 2, FALSE) #&gt; [1] 1 2 0 Si la valeur NA, comme on l’a vu, permet d’indiquer une valeur manquante (Not Available), il existe en réalité plusieurs types de NA, même si cette distinction est la plupart du temps transparente pour l’utilisateur. On a ainsi notamment des valeurs NA_integer_, NA_character_, NA_real_. La conversion automatique d’un type en un autre est à l’origine d’un idiome courant en R. Quand on applique une fonction qui attend un vecteur de nombres à un vecteur de valeurs logiques, celles-ci sont automatiquement converties, les TRUE devenant 1 et les FALSE devenant 0. Du coup, si on applique sum() à un vecteur de valeurs logiques, le résultat est égal au nombre de valeurs TRUE. sum(c(TRUE, FALSE, TRUE)) #&gt; [1] 2 On peut donc appliquer sum() à un test, et on obtiendra le nombre de valeurs pour lesquelles le test est vrai. x &lt;- c(1, 5, 8, 12, 14) sum(x &gt; 10) #&gt; [1] 2 Ceci fournit un raccourci très pratique. Dans l’exemple suivant, on tire 1000 nombres au hasard entre 0 et 1 et on calcule le nombre de valeurs obtenues qui sont inférieures à 0.5. x &lt;- runif(1000) sum(x &lt; 0.5) #&gt; [1] 491 Autre raccourci moins utilisé, appliquer mean() au résultat d’un test donne la proportion de valeurs pour lesquelles le test est vrai. x &lt;- c(1, 5, 8, 12, 14) mean(x &gt; 10) #&gt; [1] 0.4 x &lt;- runif(1000) mean(x &lt; 0.5) #&gt; [1] 0.49 On peut convertir un vecteur d’un type à un autre avec les fonctions as.character(), as.numeric() et as.logical(). Si une valeur ne peut pas être convertie, elle est remplacée par un NA, et R affiche un avertissement. as.character(1:3) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; as.logical(c(0, 2, 4)) #&gt; [1] FALSE TRUE TRUE as.numeric(c(&quot;foo&quot;, &quot;23&quot;)) #&gt; Warning: NAs introduits lors de la conversion automatique #&gt; [1] NA 23 16.1.4 Sélection d’éléments On a vu section 9.1 que l’opérateur [] peut être utilisé pour sélectionner des éléments d’un vecteur. Cet opérateur peut comporter : des nombres (qui sélectionnent par position) des chaînes de caractères (qui sélectionnent par nom) un test ou des valeurs logiques (qui sélectionnent les éléments correspondant à TRUE) x &lt;- c(e1 = 1, e2 = 2, e3 = 8, e4 = 12) x[c(1, 4)] #&gt; e1 e4 #&gt; 1 12 x[c(&quot;e2&quot;, &quot;e4&quot;)] #&gt; e2 e4 #&gt; 2 12 x[x &lt; 10] #&gt; e1 e2 e3 #&gt; 1 2 8 Si on fournit à [] un ou plusieurs nombres négatifs, les valeurs correspondantes seront supprimées plutôt que sélectionnées. x[-1] #&gt; e2 e3 e4 #&gt; 2 8 12 x[c(-2, -4)] #&gt; e1 e3 #&gt; 1 8 Si on souhaite afficher les premières ou dernières valeurs d’un vecteur, les fonctions head() et tail() peuvent être utiles. head(x, 2) #&gt; e1 e2 #&gt; 1 2 tail(x, 1) #&gt; e4 #&gt; 12 16.1.5 Modification Utilisé conjointement avec l’opérateur d’assignation &lt;-, l’opérateur [] permet de remplacer des éléments. x &lt;- c(e1 = 1, e2 = 2, e3 = 8, e4 = 12) x[1] &lt;- -1000 x #&gt; e1 e2 e3 e4 #&gt; -1000 2 8 12 x[&quot;e2&quot;] &lt;- 0 x #&gt; e1 e2 e3 e4 #&gt; -1000 0 8 12 x[x &gt; 10] &lt;- NA x #&gt; e1 e2 e3 e4 #&gt; -1000 0 8 NA Utilisé sans arguments, [] se contente de renvoyer le vecteur entier. Mais couplé à une assignation, il remplace chacun des éléments du vecteur plutôt que le vecteur lui-même. x[] &lt;- 3 x #&gt; e1 e2 e3 e4 #&gt; 3 3 3 3 16.2 Listes Les listes sont une généralisation des vecteurs : elles regroupent également plusieurs éléments ensemble, mais ceux-ci peuvent être de n’importe quel type, y compris des objets complexes. Une liste peut donc contenir des vecteurs, des listes, des tableaux de données, des fonctions, des graphiques ggplot2 stockés dans un objet, etc. 16.2.1 Création On construit une liste avec la fonction list. list(1, &quot;foo&quot;, c(&quot;Pomme&quot;, &quot;Citron&quot;)) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;foo&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; La manière dont R affiche le contenu d’une liste dans la console diffère de celle des vecteurs. Dans le cas d’une liste ses éléments sont affichés les uns en dessous des autres, et séparés par leur indice numérique entre une paire de crochets. Dans l’affichage ci-dessus, il faut bien distinguer les [[1]], [[2]] et [[3]], qui correspondent au numéro de l’élément de la liste, et les [1] qui font partie de l’affichage du contenu de ces éléments. Comme pour les vecteurs, on peut nommer les éléments à la création de la liste. liste &lt;- list(nombre = 1, char = &quot;foo&quot;, vecteur = c(&quot;Pomme&quot;, &quot;Citron&quot;)) liste #&gt; $nombre #&gt; [1] 1 #&gt; #&gt; $char #&gt; [1] &quot;foo&quot; #&gt; #&gt; $vecteur #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; Dans ce cas l’affichage de la liste dans la console montre ces noms plutôt que les indices numériques des éléments. Comme pour les vecteurs atomiques, on peut utiliser names() pour afficher ou modifier les noms des éléments. names(liste) #&gt; [1] &quot;nombre&quot; &quot;char&quot; &quot;vecteur&quot; L’affichage peut vite devenir illisible quand la liste est plus complexe. liste &lt;- list( l2 = list(x = 1:10, y = c(&quot;Pomme&quot;, &quot;Citron&quot;)), df = data.frame(v1 = 2:5, v2 = LETTERS[2:5]), y = runif(10) ) liste #&gt; $l2 #&gt; $l2$x #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $l2$y #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; #&gt; #&gt; #&gt; $df #&gt; v1 v2 #&gt; 1 2 B #&gt; 2 3 C #&gt; 3 4 D #&gt; 4 5 E #&gt; #&gt; $y #&gt; [1] 0.32472487 0.36336259 0.04744591 0.67934294 0.23261455 0.99240863 #&gt; [7] 0.89464324 0.22002331 0.58594936 0.41784867 Dans ce cas la fonction str peut être utile pour afficher de manière plus compacte la structure de la liste. Dans cet exemple elle permet de voir un peu plus clairement que x et y sont des éléments d’une sous-liste l2. str(liste) #&gt; List of 3 #&gt; $ l2:List of 2 #&gt; ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #&gt; ..$ y: chr [1:2] &quot;Pomme&quot; &quot;Citron&quot; #&gt; $ df:&#39;data.frame&#39;: 4 obs. of 2 variables: #&gt; ..$ v1: int [1:4] 2 3 4 5 #&gt; ..$ v2: chr [1:4] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; #&gt; $ y : num [1:10] 0.3247 0.3634 0.0474 0.6793 0.2326 ... 16.2.2 Ajout d’éléments Attention, si on souhaite ajouter un nouvel élément à une liste, il ne faut pas utiliser à nouveau list(), car dans ce cas notre liste de départ est insérée comme une “sous-liste”. liste &lt;- list(e1 = 1:3, e2 = &quot;Chihuhua&quot;) liste2 &lt;- list(liste, nouveau = 100) str(liste2) #&gt; List of 2 #&gt; $ :List of 2 #&gt; ..$ e1: int [1:3] 1 2 3 #&gt; ..$ e2: chr &quot;Chihuhua&quot; #&gt; $ nouveau: num 100 Il faut à la place utiliser c(), comme pour les vecteurs. liste3 &lt;- c(liste, nouveau = 100) str(liste3) #&gt; List of 3 #&gt; $ e1 : int [1:3] 1 2 3 #&gt; $ e2 : chr &quot;Chihuhua&quot; #&gt; $ nouveau: num 100 c() permet aussi de “concaténer” deux listes existantes en une seule. liste1 &lt;- list(a = 1, b = 2) liste2 &lt;- list(x = 3, y = 4) c(liste1, liste2) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 2 #&gt; #&gt; $x #&gt; [1] 3 #&gt; #&gt; $y #&gt; [1] 4 16.2.3 Sélection d’éléments Il y a deux opérateurs différents qui permettent de sélectionner les éléments d’une liste : les crochets simples [] et les crochets doubles [[]]. La différence entre ces deux opérateurs est souvent source de confusion. Partons de la liste suivante : liste &lt;- list(1:5, &quot;foo&quot;, c(&quot;Pomme&quot;, &quot;Citron&quot;)) liste #&gt; [[1]] #&gt; [1] 1 2 3 4 5 #&gt; #&gt; [[2]] #&gt; [1] &quot;foo&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; Si on utilise les crochets simples pour sélectionner le premier élément de cette liste, on obtient le résultat suivant : liste[1] #&gt; [[1]] #&gt; [1] 1 2 3 4 5 On notera que le résultat est une liste à un seul élément. Si on utilise les crochets doubles : liste[[1]] #&gt; [1] 1 2 3 4 5 On obtient cette fois-ci non pas une liste composée du premier élément, mais le contenu de ce premier élément. La différence est importante, mais pas toujours facile à retenir. On peut utiliser deux petites astuces mnémotechniques : si une liste est un train composé de plusieurs wagons, [1] retourne le premier wagon du train, tandis que [[1]] renvoie le contenu du premier wagon. une alternative est de considérer que [[]] va chercher “plus profondément” que []. Un autre point important est que si on passe plusieurs éléments à [[]], la sélection se fait d’une manière récursive peu intuitive et source d’erreurs. Il est donc conseillé de toujours utiliser [[]] avec un seul argument, et d’utiliser [] si on souhaite sélectionner plusieurs éléments d’une liste. liste[c(1, 2)] #&gt; [[1]] #&gt; [1] 1 2 3 4 5 #&gt; #&gt; [[2]] #&gt; [1] &quot;foo&quot; En résumé : si on souhaite récupérer uniquement le contenu d’un élément d’une liste, on utilise [[]] avec un seul argument. si on souhaite récupérer une nouvelle liste en sélectionnant des éléments de notre liste actuelle, on utilise [] avec un ou plusieurs arguments. Comme pour les vecteurs, on peut utiliser des nombres négatifs avec [] pour exclure des éléments plutôt que les sélectionner, et on peut également utiliser les fonctions head() et tail(). Si la liste est nommée, on peut sélectionner des éléments par noms avec les deux opérateurs. liste &lt;- list(nombre = 1, char = &quot;foo&quot;, vecteur = c(&quot;Pomme&quot;, &quot;Citron&quot;)) liste[c(&quot;nombre&quot;, &quot;char&quot;)] #&gt; $nombre #&gt; [1] 1 #&gt; #&gt; $char #&gt; [1] &quot;foo&quot; liste[[&quot;vecteur&quot;]] #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; On peut aussi utiliser l’opérateur $, qui équivaut à [[]] : liste$vecteur #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; 16.2.4 Modification Comme pour les vecteurs, on peut utiliser l’opérateur [] et l’opérateur d’assignation &lt;- pour modifier des éléments d’une liste. liste &lt;- list(nombre = 1:5, char = &quot;foo&quot;, vecteur = c(&quot;Pomme&quot;, &quot;Citron&quot;)) liste[1] &lt;- &quot;first&quot; liste #&gt; $nombre #&gt; [1] &quot;first&quot; #&gt; #&gt; $char #&gt; [1] &quot;foo&quot; #&gt; #&gt; $vecteur #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; liste[c(1, 3)] &lt;- 0 liste #&gt; $nombre #&gt; [1] 0 #&gt; #&gt; $char #&gt; [1] &quot;foo&quot; #&gt; #&gt; $vecteur #&gt; [1] 0 Attention à ne pas utiliser les crochets doubles pour modifier des éléments d’une liste car ceux-ci peuvent avoir un comportement inattendu si on veut modifier plusieurs éléments d’un coup. Enfin, si on souhaite supprimer un ou plusieurs éléments d’une liste, il faut leur attribuer la valeur NULL32. liste &lt;- list(nombre = 1:5, char = &quot;foo&quot;, vecteur = c(&quot;Pomme&quot;, &quot;Citron&quot;)) liste$char &lt;- NULL liste #&gt; $nombre #&gt; [1] 1 2 3 4 5 #&gt; #&gt; $vecteur #&gt; [1] &quot;Pomme&quot; &quot;Citron&quot; 16.2.5 Utilisation En tant que généralisation des vecteurs atomiques, les listes sont utiles dès qu’on souhaite regrouper des éléments complexes ou hétérogènes. On les utilisera par exemple pour retourner plusieurs résultats depuis une fonction. indicateurs &lt;- function(x) { list( moyenne = mean(x), variance = var(x) ) } x &lt;- 1:10 res &lt;- indicateurs(x) res$moyenne #&gt; [1] 5.5 res$variance #&gt; [1] 9.166667 On utilise également les listes pour stocker des objets complexes et leur appliquer des fonctions. Ce fonctionnement sera abordé en détail dans la section 18, mais en guise de petit aperçu, l’exemple fictif suivant récupère les noms de tous les fichiers CSV du répertoire courant et les importe tous dans une liste à l’aide de purrr::map() et de read_csv(). files &lt;- list.files(pattern = &quot;*.csv&quot;) dfs &lt;- purrr::map(files, read_csv) On pourra ensuite utiliser cette liste de tableaux pour leur appliquer des transformations ou les fusionner. 16.3 Tableaux de données (data frame et tibble) On a déjà utilisé les tableaux de données à de nombreux reprises en manipulant des data frames ou des tibbles. Les seconds sont une variante des premiers, les différences entre les deux ayant été abordées section 6.4. Un tableau de données est en réalité une liste nommée de vecteurs atomiques avec une contrainte spécifique : ces vecteurs doivent tous être de même longueur, ce qui garantit le format “tabulaire” des données. 16.3.1 Création Un tableau de données est le plus souvent créé en important des données depuis un fichier au format CSV, tableur ou autre. On peut cependant créer un data frame manuellement via la fonction data.frame() : df &lt;- data.frame( fruit = c(&quot;Pomme&quot;, &quot;Pomme&quot;, &quot;Citron&quot;), poids = c(154, 167, 92), couleur = c(&quot;vert&quot;, &quot;vert&quot;, &quot;jaune&quot;) ) On peut aussi créer un tibble manuellement avec la fonction tibble(). La syntaxe est la même que celle de data.frame(), mais avec un comportement un peu différent : notamment, les noms comportant des espaces ou des caractères spéciaux sont conservés tels quels. La fonction tribble() permet de créer un tibble manuellement avec une syntaxe “par ligne” qui peut être un peu plus lisible. df_trib &lt;- tribble( ~fruit, ~poids, ~couleur, &quot;Pomme&quot;, 154, &quot;vert&quot;, &quot;Pomme&quot;, 167, &quot;vert&quot;, &quot;Citron&quot;, 92, &quot;jaune&quot; ) On peut convertir un data frame en tibble avec la fonction as_tibble(). df_tib &lt;- as_tibble(df) df_tib #&gt; # A tibble: 3 × 3 #&gt; fruit poids couleur #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Pomme 154 vert #&gt; 2 Pomme 167 vert #&gt; 3 Citron 92 jaune 16.3.2 Noms de colonnes et de lignes On peut lister et modifier les noms des colonnes d’un tableau avec les fonctions names() ou colnames() (qui sont équivalentes). names(df) #&gt; [1] &quot;fruit&quot; &quot;poids&quot; &quot;couleur&quot; colnames(df) #&gt; [1] &quot;fruit&quot; &quot;poids&quot; &quot;couleur&quot; On peut attribuer des noms aux lignes d’un data frame à l’aide de la fonction rownames(). Attention cependant, les noms de ligne ne sont (volontairement) pas pris en charge par les tibbles. rownames(df) &lt;- c(&quot;fruit1&quot;, &quot;fruit2&quot;, &quot;fruit3&quot;) rownames(df) #&gt; [1] &quot;fruit1&quot; &quot;fruit2&quot; &quot;fruit3&quot; rownames(df_tib) &lt;- c(&quot;fruit1&quot;, &quot;fruit2&quot;, &quot;fruit3&quot;) #&gt; Warning: Setting row names on a tibble is deprecated. Si on souhaite conserver des noms de ligne en passant d’un data frame à un tibble, il faut les stocker dans une nouvelle colonne, soit en la créant manuellement soit avec la fonction rownames_to_column() (qui a l’avantage de placer la nouvelle colonne en première position du tableau). rownames_to_column(df, &quot;name&quot;) #&gt; name fruit poids couleur #&gt; 1 fruit1 Pomme 154 vert #&gt; 2 fruit2 Pomme 167 vert #&gt; 3 fruit3 Citron 92 jaune 16.3.3 Sélection de lignes et de colonnes On a déjà vu dans les parties précédentes plusieurs manières de sélectionner des éléments dans un tableau de données. Ainsi, on peut sélectionner une colonne via l’opérateur $. df$fruit #&gt; [1] &quot;Pomme&quot; &quot;Pomme&quot; &quot;Citron&quot; Comme un tableau de données est en réalité une liste de colonnes, on peut aussi utiliser l’opérateur [[]] pour sélectionner l’une de ses colonnes, par position ou par nom33. df[[&quot;fruit&quot;]] #&gt; [1] &quot;Pomme&quot; &quot;Pomme&quot; &quot;Citron&quot; df[[2]] #&gt; [1] 154 167 92 On peut utiliser head() et tail() avec un tableau de données : dans ce cas ces fonctions retourneront les premières ou dernières lignes du tableau. head(df, 2) #&gt; fruit poids couleur #&gt; fruit1 Pomme 154 vert #&gt; fruit2 Pomme 167 vert tail(df, 1) #&gt; fruit poids couleur #&gt; fruit3 Citron 92 jaune On peut également utiliser l’opérateur [,] pour sélectionner à la fois des lignes et des colonnes, en lui passant deux arguments séparés par une virgule : d’abord la sélection des lignes puis celle des colonnes. Dans les deux cas on peut sélectionner par position, nom ou condition. Si on laisse un argument vide, on sélectionne l’intégralité des lignes ou des colonnes. # Lignes 1 et 3 et colonne &quot;poids&quot; df[c(1, 3), &quot;poids&quot;] #&gt; [1] 154 92 # Toutes les lignes et colonnes &quot;poids&quot; et &quot;fruit&quot; df[, c(&quot;poids&quot;, &quot;fruit&quot;)] #&gt; poids fruit #&gt; fruit1 154 Pomme #&gt; fruit2 167 Pomme #&gt; fruit3 92 Citron # Lignes pour lesquelles poids &gt; 150, et toutes les colonnes df[df$poids &gt; 150, ] #&gt; fruit poids couleur #&gt; fruit1 Pomme 154 vert #&gt; fruit2 Pomme 167 vert library(stringr) # Colonnes dont le nom contient un &quot;o&quot;, et toutes les lignes df[, str_detect(names(df), &quot;o&quot;)] #&gt; poids couleur #&gt; fruit1 154 vert #&gt; fruit2 167 vert #&gt; fruit3 92 jaune Attention, le comportement de [,] est différent entre les tibbles et les data frame lorsqu’on ne sélectionne qu’une seule colonne. Dans le cas d’un data frame, le résultat est un vecteur, dans le cas d’un tibble le résultat est un tableau à une colonne. df[, &quot;fruit&quot;] #&gt; [1] &quot;Pomme&quot; &quot;Pomme&quot; &quot;Citron&quot; df_tib[, &quot;fruit&quot;] #&gt; # A tibble: 3 × 1 #&gt; fruit #&gt; &lt;chr&gt; #&gt; 1 Pomme #&gt; 2 Pomme #&gt; 3 Citron Cette différence peut parfois être source d’erreurs, notamment quand on développe une fonction qui prend un tableau de données en argument. 16.3.4 Modification On peut utiliser [[]] et [,] avec l’opérateur d’assignation &lt;- pour modifier tout ou partie d’un tableau de données. # Création d&#39;une nouvelle colonne poids_kg df[[&quot;poids_kg&quot;]] &lt;- df$poids / 1000 df #&gt; fruit poids couleur poids_kg #&gt; fruit1 Pomme 154 vert 0.154 #&gt; fruit2 Pomme 167 vert 0.167 #&gt; fruit3 Citron 92 jaune 0.092 # Remplacement de la valeur de la colonne &quot;fruit&quot; pour les lignes # pour lesquelles &quot;fruit&quot; vaut &quot;Citron&quot; df[df$fruit == &quot;Citron&quot;, &quot;fruit&quot;] &lt;- &quot;Agrume&quot; df #&gt; fruit poids couleur poids_kg #&gt; fruit1 Pomme 154 vert 0.154 #&gt; fruit2 Pomme 167 vert 0.167 #&gt; fruit3 Agrume 92 jaune 0.092 Pour conclure, on peut noter que l’utilisation des opérateurs [[]] et [,] sur un tableau de données peut sembler redondante et moins pratique que l’utilisation des verbes de dplyr comme select() ou filter(). Ils peuvent cependant être utiles lorsqu’on souhaite éviter les complications liées à l’utilisation du tidyverse à l’intérieur de fonctions, comme indiqué section 19. Ils peuvent également être plus rapides, et il est important de les connaître car on les rencontrera très fréquemment dans du code R sur le Web ou dans des packages. 16.4 Ressources L’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre sur les vecteurs atomiques et les listes, et un chapitre dédié aux tibbles. Pour aller encore plus loin, l’ouvrage Advanced R (également en anglais) aborde de manière approfondie les structures de données et les opérateurs de sélection [], [[]] et $. 16.5 Exercices 16.5.1 Vecteurs atomiques Exercice 1.1 À l’aide de seq(), créer un vecteur v contenant tous les nombres pairs entre 10 et 20. v &lt;- seq(10, 20, by = 2) Sélectionner les 3 premières valeurs de v. v[1:3] head(v, 3) Sélectionner toutes les valeurs de v strictement inférieures à 15. v[v &lt; 15] Créer une fonction derniere() qui prend en paramètre un vecteur et retourne son dernier élément (la fonction doit pouvoir s’appliquer à n’importe quel vecteur, quelle que soit sa longueur). derniere(v) #&gt; [1] 20 derniere &lt;- function(v) { v[length(v)] } # Ou bien derniere &lt;- function(v) { tail(v, 1) } Créer une fonction sauf_derniere() qui prend en paramètre un vecteur et retourne ce vecteur sans son dernier élément. sauf_derniere(v) #&gt; [1] 10 12 14 16 18 sauf_derniere &lt;- function(v) { v[-length(v)] } # Ou bien sauf_derniere &lt;- function(v) { head(v, -1) } Exercice 1.2 Soit le vecteur vn suivant : vn &lt;- c(val1 = 10, val2 = 0, val3 = 14) Sélectionner les valeurs nommées “val1” et “val3”. vn[c(&quot;val1&quot;, &quot;val3&quot;)] Créer une fonction select_noms() qui prend en argument un vecteur v et un ou plusieurs noms, et retourne uniquement les éléments de v correspondant à ces noms. select_noms(vn, c(&quot;val2&quot;, &quot;val3&quot;)) #&gt; val2 val3 #&gt; 0 14 select_noms &lt;- function(v, noms) { v[noms] } Facultatif : créer une fonction sauf_nom() qui prend en argument un vecteur v et un nom, et retourne tous les éléments de v sauf celui correspondant à ce nom. sauf_nom(vn, &quot;val2&quot;) #&gt; val1 val3 #&gt; 10 14 sauf_nom &lt;- function(v, nom) { v[names(v) != nom] } Facultatif : comparer les résultats des deux instructions suivantes. vn[&quot;val1&quot;] vn[[&quot;val1&quot;]] Exercice 1.3 Soit les vecteurs x et y suivants : x &lt;- c(1, NA, 3, 4, NA) y &lt;- c(10, 20, 30, 40, 50) À l’aide de l’opérateur [], sélectionner uniquement les valeurs NA de x. x[is.na(x)] De la même manière, sélectionner les valeurs de y correspondant aux valeurs NA de x (c’est-à-dire les valeurs 20 et 50). y[is.na(x)] En utilisant les deux instructions précédentes et l’opérateur d’assignation &lt;-, remplacer les valeurs manquantes de x par les valeurs correspondantes de y. x[is.na(x)] &lt;- y[is.na(x)] Exercice 1.4 Créer une fonction problemes_conversion qui : prend en argument un vecteur v le convertit en vecteur numérique retourne les valeurs de v qui n’ont pas été converties correctement, c’est-à-dire celles qui ne valaient pas NA dans v mais valent NA après la conversion. Vérifier avec : x &lt;- c(&quot;igloo&quot;, &quot;20&quot;, NA, &quot;3.5&quot;, &quot;4,8&quot;) problemes_conversion(x) #&gt; Warning in problemes_conversion(x): NAs introduits lors de la conversion #&gt; automatique #&gt; [1] &quot;igloo&quot; &quot;4,8&quot; problemes_conversion &lt;- function(v) { conv &lt;- as.numeric(v) v[!is.na(v) &amp; is.na(conv)] } 16.5.2 Listes Exercice 2.1 Créer une liste liste ayant la structure suivante : #&gt; List of 3 #&gt; $ : num 1 #&gt; $ : chr &quot;oui&quot; #&gt; $ : int [1:3] 10 11 12 liste &lt;- list(1, &quot;oui&quot;, 10:12) Donner les noms suivants aux éléments de la liste : num, reponse et vec. names(liste) &lt;- c(&quot;num&quot;, &quot;reponse&quot;, &quot;vec&quot;) Ajouter un élément nommé chat et ayant pour valeur “Ronron” à la fin de liste. liste &lt;- c(liste, chat = &quot;Ronron&quot;) Modifier l’élément chat pour lui donner la valeur “Ronpchi”. liste$chat &lt;- &quot;Ronpchi&quot; # Ou bien liste[&quot;chat&quot;] &lt;- &quot;Ronpchi&quot; Supprimer l’élément vec de liste. liste$vec &lt;- NULL # Ou bien liste[&quot;vec&quot;] &lt;- NULL Exercice 2.2 Créer une fonction nommée extremes qui prend en argument un vecteur et retourne une liste nommée comportant sa valeur minimale et sa valeur maximale. extremes &lt;- function(x) { list(min = min(x), max = max(x)) } Appliquer cette fonction à un vecteur de votre choix et utiliser le résultat pour calculer l’étendue (soit la différence entre la valeur maximale et la valeur minimale). v &lt;- runif(10) res &lt;- extremes(v) res$max - res$min Exercice 2.3 Soit la liste suivante : liste &lt;- list(1:3, runif(5), &quot;youpi&quot;) Sélectionner la sous liste composée des éléments 1 et 3 de liste. liste[c(1, 3)] Sélectionner la sous-liste composée du premier élément de liste. liste[1] Sélectionner le contenu du premier élément de liste. liste[[1]] En enchaînant deux opérations de sélection, sélectionner le deuxième élément du premier élément de liste. liste[[1]][2] Exercice 2.4 Créer une fonction description_liste qui prend en argument une liste et retourne : son premier élément son dernier élément le nombre d’éléments qu’elle contient Vérifier avec : liste &lt;- list(1:3, runif(5), &quot;youpi&quot;) description_liste(liste) #&gt; $premier_element #&gt; [1] 1 2 3 #&gt; #&gt; $dernier_element #&gt; [1] &quot;youpi&quot; #&gt; #&gt; $nb_elements #&gt; [1] 3 description_liste &lt;- function(liste) { list( premier_element = liste[[1]], dernier_element = liste[[length(liste)]], nb_elements = length(liste) ) } 16.5.3 Tableaux de données Exercice 3.1 Créer le tableau df suivant : df &lt;- tribble( ~fruit, ~poids, ~couleur, &quot;Pomme&quot;, 154, &quot;vert&quot;, &quot;Pomme&quot;, 167, &quot;vert&quot;, &quot;Citron&quot;, 92, &quot;jaune&quot; ) À l’aide de l’opérateur $, sélectionner la colonne fruit de df. df$fruit Faire de même avec l’opérateur [[]]. df[[&quot;fruit&quot;]] À l’aide de l’opérateur [[]] et de la fonction str_to_upper() de stringr, transformer la colonne fruit en passant ses valeurs en majuscules. library(stringr) df[[&quot;fruit&quot;]] &lt;- str_to_upper(df[[&quot;fruit&quot;]]) Créer une fonction colonne_maj qui prend en argument un tableau de données d et un nom de colonne colonne, et retourne le tableau avec la colonne correspondante convertie en majuscules. Vérifier avec : colonne_maj(df, &quot;couleur&quot;) #&gt; # A tibble: 3 × 3 #&gt; fruit poids couleur #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Pomme 154 VERT #&gt; 2 Pomme 167 VERT #&gt; 3 Citron 92 JAUNE colonne_maj &lt;- function(d, colonne) { d[[colonne]] &lt;- str_to_upper(d[[colonne]]) d } Exercice 3.2 Créer le tableau df suivant : df &lt;- tribble( ~fruit, ~poids, ~couleur, &quot;Pomme&quot;, 154, &quot;vert&quot;, &quot;Pomme&quot;, 167, &quot;vert&quot;, &quot;Citron&quot;, 92, &quot;jaune&quot; ) À l’aide de l’opérateur [,], sélectionner : les citrons les pommes et les colonnes fruit et couleur la première colonne des lignes ayant un poids inférieur à 100 df[df$fruit == &quot;Citron&quot;,] df[df$fruit == &quot;Pomme&quot;, c(&quot;fruit&quot;, &quot;couleur&quot;)] df[df$poids &lt; 100, 1] Créer une fonction filtre_valeur() qui prend un seul argument nommé valeur et retourne les lignes de df pour lesquelles la colonne fruit vaut valeur. Vérifier avec : filtre_valeur(&quot;Pomme&quot;) #&gt; # A tibble: 2 × 3 #&gt; fruit poids couleur #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Pomme 154 vert #&gt; 2 Pomme 167 vert filtre_valeur &lt;- function(valeur) { df[df$fruit == valeur,] } Modifier la fonction pour qu’elle accepte également un argument d contenant le tableau à filtrer. Vérifier avec : filtre_valeur(df, &quot;Pomme&quot;) #&gt; # A tibble: 2 × 3 #&gt; fruit poids couleur #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Pomme 154 vert #&gt; 2 Pomme 167 vert filtre_valeur &lt;- function(d, valeur) { d[d$fruit == valeur,] } Modifier à nouveau la fonction pour qu’elle accepte aussi un argument colonne qui contient le nom de la colonne à utiliser pour filtrer les lignes. Vérifier avec : filtre_valeur(df, colonne = &quot;couleur&quot;, valeur = &quot;jaune&quot;) #&gt; # A tibble: 1 × 3 #&gt; fruit poids couleur #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Citron 92 jaune filtre_valeur &lt;- function(d, colonne, valeur) { d[d[colonne] == valeur,] } Vérifier que cette fonction marche aussi sur un autre jeu de données : library(questionr) data(hdv2003) filtre_valeur(hdv2003, &quot;sexe&quot;, &quot;Femme&quot;) Exercice 3.3 Reprendre le tableau df des exercices précédents : df &lt;- tribble( ~fruit, ~poids, ~couleur, &quot;Pomme&quot;, 154, &quot;vert&quot;, &quot;Pomme&quot;, 167, &quot;vert&quot;, &quot;Citron&quot;, 92, &quot;jaune&quot; ) À l’aide de l’opérateur [,], effectuer les opérations suivantes : Créer une nouvelle colonne id avec les valeurs 1, 2, 3 Remplacer la valeur “jaune” de la variable couleur par “jaune citron” Créer une nouvelle colonne poids_rec qui vaut “léger” si poids est inférieur à 100, et “lourd” sinon df[, &quot;id&quot;] &lt;- 1:3 df[df$couleur == &quot;jaune&quot;, &quot;couleur&quot;] &lt;- &quot;jaune citron&quot; df[df$poids &lt; 100, &quot;poids_rec&quot;] &lt;- &quot;léger&quot; df[df$poids &gt;= 100, &quot;poids_rec&quot;] &lt;- &quot;lourd&quot; # Ou bien : df[, &quot;poids_rec&quot;] &lt;- if_else(df$poids &lt; 100, &quot;léger&quot;, &quot;lourd&quot;) Facultatif : effectuer les mêmes opérations en utilisant les verbes de dplyr. df &lt;- df %&gt;% mutate(id = 1:3) df &lt;- df %&gt;% mutate( couleur = if_else(couleur == &quot;jaune&quot;, &quot;jaune_citron&quot;, couleur) ) # Ou bien : library(forcats) df &lt;- df %&gt;% mutate( couleur = fct_recode(couleur, &quot;jaune_citron&quot; = &quot;jaune&quot;) ) df &lt;- df %&gt;% mutate( poids_rec = if_else(poids &lt; 100, &quot;léger&quot;, &quot;lourd&quot;) ) Il en existe d’autres, comme complex ou raw, mais qui sont moins fréquemment utilisés.↩︎ Si on veut ajouter un élément NULL à une liste, il faut utiliser les crochets simples avec la syntaxe liste[\"foo\"] &lt;- list(NULL).↩︎ Attention, comme pour les listes, à ne pas utiliser [[]] avec un argument de longueur supérieur à 1, car cela mène soit à des erreurs soit à des résultats contre-intuitifs.↩︎ "],["17-if-boucles.html", "Partie 17 Exécution conditionnelle et boucles 17.1 if et else : exécuter du code sous certaines conditions 17.2 Contrôle de l’exécution et gestion des erreurs 17.3 for et while : répéter des instructions dans une boucle 17.4 Ressources 17.5 Exercices", " Partie 17 Exécution conditionnelle et boucles Nous avons vu précédemment comment écrire nos propres fonctions. Cette section présente des éléments du langage qui permettent de programmer des actions un peu plus complexes : exécuter du code de manière conditionnelle selon le résultat d’un test, et répéter des opérations avec des boucles. Les notions décrites dans cette partie s’appliquent pour le développement de fonctions, mais peuvent aussi être mises en œuvre à tout moment dans un script. On commence par charger les jeux de données d’exemple utilisés par la suite : library(questionr) data(hdv2003) data(rp2012) 17.1 if et else : exécuter du code sous certaines conditions 17.1.1 if L’instruction if permet de n’exécuter du code que si une condition est remplie. if est suivie d’une condition (entre parenthèses) puis d’un bloc de code (entre accolades). Ce bloc de code n’est exécuté que si la condition est vraie. Par exemple, dans le code suivant, le message Bonjour ! ne sera affiché que si la valeur de l’objet prenom vaut \"Pierre-Edmond\" : prenom &lt;- &quot;Pierre-Edmond&quot; if (prenom == &quot;Pierre-Edmond&quot;) { message(&quot;Bonjour !&quot;) } #&gt; Bonjour ! On peut utiliser ce code pour créer une passionnante fonction qui a pour objectif de ne dire bonjour qu’aux personnes qui s’appellent Pierre-Edmond : bonjour_pierre_edmond &lt;- function(prenom) { if (prenom == &quot;Pierre-Edmond&quot;) { message(&quot;Bonjour !&quot;) } } bonjour_pierre_edmond(&quot;Pierre-Edmond&quot;) #&gt; Bonjour ! bonjour_pierre_edmond(&quot;Valérie-Charlotte&quot;) Une autre utilisation possible (et un peu plus utile) dans le cadre d’une fonction est de n’exécuter certaines instructions que si la valeur d’un argument vaut une valeur donnée. Dans l’exemple suivant, on n’applique la fonction round() que si l’argument arrondir vaut TRUE. moyenne &lt;- function(x, arrondir = TRUE) { res &lt;- mean(x) if (arrondir == TRUE) { res &lt;- round(res) } res } v &lt;- c(1.4, 2.3, 8.9) moyenne(v) #&gt; [1] 4 moyenne(v, arrondir = FALSE) #&gt; [1] 4.2 On notera que le test x == TRUE est en fait redondant, car son résultat est le même que la valeur de x : si x vaut TRUE, x == TRUE vaut TRUE si x vaut FALSE, x == TRUE vaut FALSE On remplacera donc en général if (x == TRUE) par if (x). De la même manière, on pourra remplacer if (x == FALSE) par if (!x). Dans notre fonction moyenne ci-dessus, on peut donc remplacer : if (arrondir == TRUE) { res &lt;- round(res) } Par : if (arrondir) { res &lt;- round(res) } À noter également que quand le bloc de code qui suit une instruction if ne comporte qu’une seule instruction, on peut omettre les accolades qui l’entourent. Les syntaxe suivantes sont donc équivalentes : if (arrondir) { res &lt;- round(res) } if (arrondir) res &lt;- round(res) 17.1.2 if / else On utilise souvent if en le faisant suivre par une instruction else. else précède un autre bloc de code R qui ne s’exécute que si la condition donnée au if est fausse : On peut ainsi utiliser if / else pour une nouvelle fonction fort utile qui nous évitera bien des désagréments météorologiques. conseil_vestimentaire &lt;- function(temperature) { if (temperature &gt; 15) { message(&quot;La polaire n&#39;est pas forcément nécessaire.&quot;) } else { message(&quot;Vous devriez prendre une petite laine.&quot;) } } conseil_vestimentaire(-5) #&gt; Vous devriez prendre une petite laine. Plus utile, on peut l’utiliser pour effectuer deux actions différentes en fonction de la valeur d’un argument. La fonction suivante génère deux graphiques différents selon le type du vecteur passé en argument : graph_var &lt;- function(x) { if (is.character(x)) { barplot(table(x)) } else { hist(x) } } graph_var(c(&quot;Pomme&quot;, &quot;Pomme&quot;, &quot;Citron&quot;)) graph_var(c(1, 5, 10, 3, 1, 4)) 17.1.3 “if” / “else if” / “else” Une possibilité complémentaire est d’ajouter des blocs else if qui permettent d’ajouter des conditions supplémentaires. Dès qu’une condition est vraie, le bloc de code correspondant est exécuté. Le dernier bloc else est exécuté si aucune des conditions n’est vraie. On peut donc améliorer encore notre fonction graph_var() pour tester plusieurs types explicitement et afficher un message si aucun type géré n’a été reconnu. graph_var &lt;- function(x) { if (is.character(x)) { barplot(table(x)) } else if (is.numeric(x)) { hist(x) } else { message(&quot;Le type de x n&#39;est pas géré par la fonction&quot;) } } graph_var(c(TRUE, FALSE, TRUE)) #&gt; Le type de x n&#39;est pas géré par la fonction Attention, seul le bloc de la première condition vraie est exécuté, l’ordre des conditions est donc important. Dans l’exemple suivant, le second bloc n’est jamais exécuté et donc le second message jamais affiché. test_x &lt;- function(x) { if (x &lt; 100) { message(&quot;x est inférieur à 100&quot;) } else if (x &lt; 10) { message(&quot;x est inférieur à 10&quot;) } } test_x(5) #&gt; x est inférieur à 100 Il est donc important d’ordonner les conditions de la plus spécifique à la plus générale. 17.1.4 Construction de conditions complexes On peut combiner plusieurs tests avec les opérateurs logiques classiques : &amp;&amp; est l’opérateur “et”, qui est vrai si les deux conditions qu’il réunit sont vraies || est l’opérateur “ou”, qui est vrai si au moins l’une des deux conditions qu’il réunit sont vraies ! est l’opérateur “not”, qui teste si la condition qu’il précède est fausse Ainsi, si on veut qu’une variable temperature soit comprise entre 15 et 25, on écrira : verifie_temperature &lt;- function(temperature) { if (temperature &gt;= 15 &amp;&amp; temperature &lt;= 25) { message(&quot;Température ok&quot;) } } verifie_temperature(20) Si on souhaite tester que temperature est inférieure à 15 ou supérieure à 25 : verifie_temperature &lt;- function(temperature) { if (temperature &lt; 15 || temperature &gt; 25) { message(&quot;Température pas glop&quot;) } } verifie_temperature(10) Si on veut tester si temperature vaut NULL, on peut utiliser is.null(). verifie_temperature &lt;- function(temperature = NULL) { if (is.null(temperature)) { message(&quot;Merci d&#39;indiquer une température&quot;) } } verifie_temperature() Mais si à l’inverse on veut tester si temperature n’est pas NULL, on inverse le test précédent en utilisant !. verifie_temperature &lt;- function(temperature = NULL) { if (!is.null(temperature)) { message(&quot;Merci d&#39;avoir indiqué une température&quot;) } } verifie_temperature(15) On pourra noter qu’il existe deux types d’opérateurs “et” et “ou” dans R : Les opérateurs simples &amp; et | sont des opérateurs vectorisés. Ils peuvent s’appliquer à des vecteurs et retourneront un vecteur de TRUE et FALSE. Les opérateurs doubles &amp;&amp; et || ne peuvent retourner qu’une seule valeur, et si on leur fournit des vecteurs ils n’utiliseront que la première valeur de chacun d’entre eux. x &lt;- 1:5 x &gt; 0 &amp; x &lt;= 2 #&gt; [1] TRUE TRUE FALSE FALSE FALSE x &gt; 0 &amp;&amp; x &lt;= 2 #&gt; [1] TRUE Quand on passe un test à un if, celui-ci est censé retourner une unique valeur TRUE ou FALSE. Une erreur fréquente, notamment quand on est dans une fonction, est de passer à if une condition appliquée à un vecteur. Dans ce cas R a la bonne idée d’afficher un avertissement, et il n’utilise alors que la première valeur du vecteur pour déterminer si le bloc de code doit être exécuté ou non. superieur_a_5 &lt;- function(x) { if (x &gt;= 5) { message(&quot;&gt;=5&quot;) } } superieur_a_5(1:10) #&gt; Warning in if (x &gt;= 5) {: la condition a une longueur &gt; 1 et seul le premier #&gt; élément est utilisé À retenir : quand on utilise l’instruction if, la condition qui lui est passée entre parenthèses ne doit renvoyer qu’une seule valeur TRUE ou FALSE. Si on utilise une condition complexe, on utilisera donc plutôt les opérateurs doubles &amp;&amp; et ||. 17.1.5 Différence entre if / else et ifelse Une source fréquente de confusion concerne la différence entre les instructions if / else et la fonction ifelse() de R base (ou son équivalent if_else() de dplyr, voir section 9.4.1). Les deux sont pourtant très différentes : if / else s’utilisent quand on teste une seule condition et qu’on veut exécuter des blocs de code différents selon son résultat ifelse et if_else appliquent un test à tous les éléments d’un vecteur et retournent un vecteur dont les éléments dépendent du résultat de chaque test Premier cas de figure : un objet x contient une seule valeur et on veut afficher un message différent selon si celle-ci est inférieure ou supérieure à 10. Dans ce cas on utilise if / else. x &lt;- 5 if (x &gt;= 10) { message(&quot;&gt;=10&quot;) } else { message(&quot;&lt;10&quot;) } #&gt; &lt;10 Deuxième cas de figure : x est un vecteur et on souhaite recoder chacune de ses valeurs selon le même critère que ci-dessus. Dans ce cas on utilise ifelse ou if_else. x &lt;- 5:15 x_rec &lt;- ifelse(x &gt;= 10, &quot;&gt;=10&quot;, &quot;&lt;10&quot;) x_rec #&gt; [1] &quot;&lt;10&quot; &quot;&lt;10&quot; &quot;&lt;10&quot; &quot;&lt;10&quot; &quot;&lt;10&quot; &quot;&gt;=10&quot; &quot;&gt;=10&quot; &quot;&gt;=10&quot; &quot;&gt;=10&quot; &quot;&gt;=10&quot; #&gt; [11] &quot;&gt;=10&quot; 17.2 Contrôle de l’exécution et gestion des erreurs L’instruction if est souvent utilisée dans des fonctions pour valider les valeurs passées en arguments, ou plus généralement pour contrôler que l’exécution du code se déroule comme prévu. 17.2.1 Utilisation de return pour sortir de la fonction On peut utiliser un return pour interrompre l’exécution de la fonction et retourner un résultat. On a en effet vu section 14.2.5 que dès que R rencontre un return dans une fonction, il interrompt immédiatement l’exécution de celle-ci. La fonction suivante retourne la longueur du mot le plus long dans un vecteur de chaînes de caractères. longueur_max &lt;- function(x) { max(nchar(x)) } longueur_max(c(&quot;Pomme&quot;, &quot;Pamplemousse&quot;)) #&gt; [1] 12 Cette fonction n’a pas trop de sens si on lui passe en entrée un vecteur qui n’est pas un vecteur de chaînes de caractères. On peut donc rajouter un test qui, si x n’est pas de type character, retourne directement la valeur NA. longueur_max &lt;- function(x) { if (!is.character(x)) { return(NA) } max(nchar(x)) } longueur_max(1:5) #&gt; [1] NA 17.2.2 warning La fonction warning fonctionne comme message mais permet d’afficher un avertissement. Celui-ci est présenté un peu différemment dans la console de manière à attirer l’attention, et il indique quelle fonction a déclenché l’avertissement, ce qui peut être utile pour retrouver l’origine du problème. Dans la fonction précédente, on peut ajouter un avertissement dans le cas où le vecteur passé en argument n’est pas de type character. longueur_max &lt;- function(x) { if (!is.character(x)) { warning(&quot;x n&#39;est pas de type character, le résultat vaut NA.&quot;) return(NA) } max(nchar(x)) } longueur_max(1:5) #&gt; Warning in longueur_max(1:5): x n&#39;est pas de type character, le résultat vaut #&gt; NA. #&gt; [1] NA 17.2.3 stop et stopifnot stop fonctionne comme warning mais déclenche une erreur qui interrompt totalement l’exécution du code. Quand R le rencontre dans une fonction, il sort immédiatement de la fonction, ne retourne aucun résultat, et il interrompt également toutes les autres instructions en attente d’exécution. On peut ainsi considérer, toujours dans la fonction longueur_max, que le fait de ne pas fournir en argument un vecteur de type character est suffisamment “grave” pour interrompre l’exécution en cours et forcer la personne qui utilise la fonction à régler le problème. longueur_max &lt;- function(x) { if (!is.character(x)) { stop(&quot;x doit être de type character.&quot;) } max(nchar(x)) } longueur_max(1:5) #&gt; Error in longueur_max(1:5): x doit être de type character. Savoir si un problème doit être traité comme un avertissement ou comme une erreur relève du choix de la personne qui développe la fonction : chaque cas est particulier. stopifnot est une syntaxe alternative plus compacte qui combine test et message d’erreur. On lui passe en premier argument une condition, et en deuxième argument un message à afficher si la condition est fausse. On peut donc réécrire notre fonction longueur_max ci-dessus de la manière suivante : longueur_max &lt;- function(x) { stopifnot(is.character(x)) max(nchar(x)) } longueur_max(1:5) #&gt; Error in longueur_max(1:5): is.character(x) n&#39;est pas TRUE Si on souhaite un message d’erreur personnalisé il faut le passer comme nom de la condition. longueur_max &lt;- function(x) { stopifnot( &quot;x doit être de type character&quot; = is.character(x) ) max(nchar(x)) } longueur_max(1:5) #&gt; Error in longueur_max(1:5): x doit être de type character 17.2.4 Tester la présence d’un argument facultatif On a vu section 14.2.3 que pour rendre un argument de fonction “facultatif”, on doit lui attribuer une valeur par défaut. Parfois cependant, on n’a pas de valeur par défaut évidente à lui attribuer directement : dans ce cas on lui attribue la valeur NULL et on utilise un if() dans la fonction pour déterminer s’il a été défini ou non par l’utilisateur. Par exemple, soit une fonction qui génère un graphique avec un argument titre qui permet de définir son titre. histo &lt;- function(x, titre) { hist(x, main = titre) } Si l’utilisateur ne donne pas de titre, on souhaite ajouter un titre qui indique la valeur de la moyenne de la variable représentée. Dans ce cas on attribue à titre la valeur par défaut NULL, et on vérifie dans le corps de la fonction que l’utilisateur n’a pas fourni de valeur avec if (is.null(titre)). On peut alors calculer la valeur “par défaut” souhaitée : histo &lt;- function(x, titre = NULL) { if (is.null(titre)) { titre &lt;- paste(&quot;Moyenne :&quot;, mean(x)) } hist(x, main = titre) } x &lt;- c(1, 15, 8, 10, 12, 18, 8, 4) histo(x) histo(x, titre = &quot;Quel bel histogramme&quot;) 17.3 for et while : répéter des instructions dans une boucle Les boucles permettent de répéter du code plusieurs fois, soit en fonction d’une condition soit selon les éléments d’un vecteur34. 17.3.1 for Le premier type de boucle est défini par l’instruction for. Sa structure est la suivante : Le principe est le suivant : on fournit à for entre parenthèses une expression du type item in vecteur, puis un bloc de code entre accolades. for va exécuter le bloc de codes pour chacune des valeurs de vecteur, et affectera tour à tour à item la valeur courante de vecteur. Prenons tout de suite un exemple pour mieux comprendre. for (item in 1:5) { print(item) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 Ici notre vecteur “source” est constitué des entiers de 1 à 5. for va donc exécuter l’instruction print(item) 5 fois, en remplaçant la première fois item par 1, la seconde fois par 2, etc. On peut itérer sur différents types d’objets, et le nom item peut être remplacé par ce que l’on souhaite : for (prenom in c(&quot;Pierre-Edmond&quot;, &quot;Valérie-Charlotte&quot;)) { message(&quot;Bonjour &quot;, prenom, &quot; !&quot;) } #&gt; Bonjour Pierre-Edmond ! #&gt; Bonjour Valérie-Charlotte ! Exemple un peu plus complexe, la fonction suivante prend en entrée un tableau de données et un vecteur de noms de variables, et affiche le résultat de summary pour chacune de ces variables. summaries &lt;- function(d, vars) { for (var in vars) { message(&quot;--- &quot;, var, &quot; ---&quot;) print(summary(d[, var])) } } summaries(hdv2003, c(&quot;sexe&quot;, &quot;age&quot;, &quot;heures.tv&quot;)) #&gt; --- sexe --- #&gt; Homme Femme #&gt; 899 1101 #&gt; --- age --- #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 18.00 35.00 48.00 48.16 60.00 97.00 #&gt; --- heures.tv --- #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 0.000 1.000 2.000 2.247 3.000 12.000 5 Un “pattern” relativement fréquent est de vouloir itérer sur les éléments d’un vecteur par leur position. Il est du coup assez naturel d’utiliser quelque chose comme for (i in 1:length(x)). Il est cependant préférable dans ces cas-là d’utiliser la fonction dédiée seq_along(x)35. x &lt;- c(&quot;rouge&quot;, &quot;vert&quot;, &quot;bleu&quot;) 1:length(x) #&gt; [1] 1 2 3 seq_along(x) #&gt; [1] 1 2 3 Dans l’exemple suivant, la fonction affiche_dimensions prend en entrée une liste de tableaux de données et affiche leur nombre de lignes et de colonnes. affiche_dimensions &lt;- function(dfs) { for (i in seq_along(dfs)) { name &lt;- names(dfs)[[i]] df &lt;- dfs[[i]] message(&quot;Dimensions de &quot;, name, &quot; : &quot;, nrow(df), &quot;x&quot;, ncol(df)) } } l &lt;- list( hdv = hdv2003, rp = rp2012 ) affiche_dimensions(l) #&gt; Dimensions de hdv : 2000x20 #&gt; Dimensions de rp : 5170x60 À noter que quand on sort d’une boucle for, l’objet utilisé pour itérer sur les valeurs du vecteur existe toujours, et contient la dernière valeur qu’il a prise. for (i in 1:3) { print(&quot;a&quot;) } #&gt; [1] &quot;a&quot; #&gt; [1] &quot;a&quot; #&gt; [1] &quot;a&quot; print(i) #&gt; [1] 3 17.3.2 while while prend en argument une condition et est suivi d’un bloc de code entre accolades. Elle exécute le bloc tant que la condition est vraie : Par exemple, la fonction suivante simule un tirage à pile ou face à l’aide de la fonction sample(). La simulation de tirage s’exécute et affiche le résultat tant qu’on obtient “Pile” (et interrompt la boucle au premier “Face”) : resultat &lt;- &quot;&quot; while (resultat != &quot;Face&quot;) { resultat &lt;- sample(c(&quot;Pile&quot;, &quot;Face&quot;), size = 1) print(resultat) } [1] &quot;Pile&quot; [1] &quot;Pile&quot; [1] &quot;Face&quot; Le déroulement de la boucle est le suivant : la première instruction initialise la valeur de la variable resultat avec une chaîne vide à la première entrée dans le while, resultat vaut \"\", elle est donc différente de \"Face\" et le bloc de code est donc exécuté à la fin de cette exécution, resultat vaut soit \"Pile\" soit \"Face\". On entre alors une deuxième fois dans le while. Si resultat vaut \"Pile\", la condition du while n’est pas vraie, on n’exécute donc pas le bloc de code et on sort de la boucle. Si resultat vaut \"Face\", la condition est vraie, on exécute le bloc de code et on rentre ensuite une troisième fois dans le while, etc. 17.3.3 next et break Les instructions next et break permettent de modifier les itérations d’une boucle for ou while. next permet de sortir de l’itération courante et de passer directement à l’itération suivante sans exécuter le reste du code. Reprenons la fonction summaries, vue plus haut, qui affiche le résumé de plusieurs variables d’un tableau de données. summaries &lt;- function(d, vars) { for (var in vars) { message(&quot;--- &quot;, var, &quot; ---&quot;) print(summary(d[, var])) } } summaries(hdv2003, c(&quot;sexe&quot;, &quot;age&quot;)) #&gt; --- sexe --- #&gt; Homme Femme #&gt; 899 1101 #&gt; --- age --- #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 18.00 35.00 48.00 48.16 60.00 97.00 Si on passe à la fonction un nom de colonne qui n’existe pas, on obtient une erreur et les autres variables ne sont pas affichées. summaries(hdv2003, c(&quot;sexe&quot;, &quot;igloo&quot;, &quot;age&quot;)) #&gt; --- sexe --- #&gt; Homme Femme #&gt; 899 1101 #&gt; --- igloo --- #&gt; Error in `[.data.frame`(d, , var): colonnes non définies sélectionnées On pourrait dans ce cas vouloir afficher les résultats pour les “bonnes” colonnes, et ignorer les autres. C’est possible si on ajoute une instruction next quand la valeur courante de var ne fait pas partie des noms de colonnes (on pourrait aussi ajouter un warning() juste avant le next pour informer l’utilisateur). summaries &lt;- function(d, vars) { for (var in vars) { if (!(var %in% names(d))) { next } message(&quot;--- &quot;, var, &quot; ---&quot;) print(summary(d[, var])) } } summaries(hdv2003, c(&quot;sexe&quot;, &quot;igloo&quot;, &quot;age&quot;)) #&gt; --- sexe --- #&gt; Homme Femme #&gt; 899 1101 #&gt; --- age --- #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 18.00 35.00 48.00 48.16 60.00 97.00 L’instruction break est un peu plus radicale : non seulement elle sort de l’itération courante sans exécuter la suite du code, mais elle interrompt carrément la boucle toute entière et n’exécute pas les itérations restantes. Dans l’exemple précédent, si on remplace next par break, on voit bien qu’on sort de la boucle et que seule la première itération est totalement exécutée. summaries &lt;- function(d, vars) { for (var in vars) { if (!(var %in% names(d))) { break } message(&quot;--- &quot;, var, &quot; ---&quot;) print(summary(d[, var])) } } summaries(hdv2003, c(&quot;sexe&quot;, &quot;igloo&quot;, &quot;age&quot;)) #&gt; --- sexe --- #&gt; Homme Femme #&gt; 899 1101 17.3.4 Quand (ne pas) utiliser des boucles Le mécanisme des boucles, assez intuitif, peut être utilisé pour beaucoup d’opérations. Il y a cependant sous R des alternatives souvent plus rapides, qu’il est préférable de privilégier. Avant tout, de nombreuses fonctions R sont “vectorisées” et s’appliquent directement à tous les éléments d’un vecteur. Dans le cas où une fonction vectorisée existe déjà, elle propose en général une syntaxe plus compacte et une exécution (beaucoup) plus rapide. Pour prendre un exemple caricatural, si on souhaite ajouter 10 à chaque élément d’un vecteur on évitera absolument de faire : for (i in seq_along(x)) { x[i] &lt;- x[i] + 10 } Et on se contentera d’un beaucoup plus simple x + 10. Autre exemple, si on souhaite remplacer dans tous les éléments d’un vecteur de chaînes de caractères le caractère “X” par le caractère “o”, on pourrait être tenter de faire une boucle du type : mots &lt;- c(&quot;brXuette&quot;, &quot;mXtX&quot;, &quot;iglXX&quot;) for (i in seq_along(mots)) { mots[i] &lt;- str_replace_all(mots[i], &quot;X&quot;, &quot;o&quot;) } Or c’est tout à fait inutile car str_replace_all() étant vectorisée, on peut l’appliquer directement à un vecteur sans utiliser de boucle. mots &lt;- str_replace_all(mots, &quot;X&quot;, &quot;o&quot;) Dernier exemple, la boucle suivante remplace les valeurs manquantes d’un vecteur par les valeurs correspondantes d’un deuxième vecteur. x &lt;- c(1, NA, 4, 110, NA) y &lt;- c(20, 30, 40, 50, 60) for (i in seq_along(x)) { if (is.na(x[i])) { x[i] &lt;- y[i] } } Cette boucle sera avantageusement remplacée par une utilisation plus compacte et plus rapide de l’opérateur []. x[is.na(x)] &lt;- y[is.na(x)] En dehors des questions de performance, une boucle peut aussi être moins lisible que certaines alternatives. Soit la fonction suivante, qui prend en entrée un vecteur de mots et retourne le nombre total de voyelles qu’il contient. library(stringr) n_voyelles &lt;- function(mots) { nb &lt;- str_count(mots, &quot;[aeiou]&quot;) sum(nb) } n_voyelles(c(&quot;le&quot;, &quot;chat&quot;, &quot;roupille&quot;)) #&gt; [1] 6 Supposons qu’on souhaite appliquer cette fonction à une série de vecteurs de mots contenus dans une liste. On pourrait utiliser une boucle for parcourant cette liste, appliquant la fonction, et ajoutant le résultat à un vecteur numérique vide préalablement créé avec numeric(). phrases &lt;- list( c(&quot;le&quot;, &quot;chat&quot;, &quot;roupille&quot;), c(&quot;l&#39;autre&quot;, &quot;chat&quot;, &quot;roupille&quot;, &quot;aussi&quot;) ) res &lt;- numeric() for (i in seq_along(phrases)) { res[i] &lt;- n_voyelles(phrases[[i]]) } res #&gt; [1] 6 11 On verra cependant dans la section 18 que des fonctions permettent de faire ce genre de choses de manière beaucoup plus simple et plus lisible. Ici par exemple on obtiendrait le même résultat avec un simple : phrases %&gt;% map_int(n_voyelles) #&gt; [1] 6 11 Au final, entre les fonctions vectorisées existantes et les possibilités fournies par purrr, il est assez rare de devoir utiliser une boucle directement dans R. Pour autant, il ne faut pas non plus tomber dans l’excès inverse et considérer que tout usage de for ou while doit être évité : ces fonctions sont parfaitement justifiées dans certains cas de figure, et si vous trouvez une solution qui fonctionne de manière efficace avec une boucle for, il n’est pas forcément utile de chercher à la remplacer. 17.4 Ressources L’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre sur les boucles for, et un chapitre sur les blocs if / else. L’ouvrage Advanced R (également en anglais) aborde de manière approfondie les tests et les boucles. Sur le blog de ThinkR, un article détaillé sur l’utilisation des boucles et les alternatives possibles. Sur le blog de Florian Privé, un billet approfondi sur les raisons pour lesquelles les boucles peuvent être lentes et sur les cas où il est préférable de ne pas les utiliser. 17.5 Exercices 17.5.1 if et else Exercice 1.1 Écrire une fonction gel qui prend un argument nommé temperature et effectue les actions suivantes : si temperature est négative, affiche le message “ça gèle” avec la fonction message() sinon, affiche le message “ça gèle pas” avec la fonction message() gel &lt;- function(temperature) { if (temperature &lt;= 0) { message(&quot;ça gèle&quot;) } else { message(&quot;ça gèle pas&quot;) } } Exercice 1.2 Écrire une fonction meteo qui prend un argument nommé temperature et effectue les actions suivantes : si temperature est inférieure à 0, affiche le message “ça caille” avec la fonction message() si temperature est comprise entre 0 et 15, affiche le message “fais pas chaud” si temperature est comprise entre 15 et 30, affiche le message “on est pas mal” si temperature est supérieure à 30, affiche le message “tous à Miribel” meteo &lt;- function(temperature) { if (temperature &lt; 0) { message(&quot;ça caille&quot;) } else if (temperature &lt; 15) { message(&quot;fais pas chaud&quot;) } else if (temperature &lt; 30) { message(&quot;on est pas mal&quot;) } else { message(&quot;tous à Miribel&quot;) } } # Ou bien meteo &lt;- function(temperature) { if (temperature &lt; 0) { message(&quot;ça caille&quot;) } if (temperature &gt;= 0 &amp;&amp; temperature &lt; 15) { message(&quot;fais pas chaud&quot;) } if (temperature &gt;= 15 &amp;&amp; temperature &lt; 30) { message(&quot;on est pas mal&quot;) } if (temperature &gt;= 30) { message(&quot;tous à Mriribel&quot;) } } Exercice 1.3 Écrire une fonction avertissement qui prend deux arguments pluie et parapluie et qui effectue les opérations suivantes : si pluie vaut TRUE et parapluie vaut FALSE, affiche “mouillé” avec la fonction message() si pluie vaut TRUE et parapluie vaut TRUE, affiche “bien vu” si pluie vaut FALSE, affiche “RAS” avertissement &lt;- function(pluie, parapluie) { if (pluie &amp;&amp; !parapluie) { message(&quot;mouillé&quot;) } if (pluie &amp;&amp; parapluie) { message(&quot;bien vu&quot;) } if (!pluie) { message(&quot;RAS&quot;) } } 17.5.2 Contrôle de l’exécution Exercice 2.1 Créer une fonction moyenne_arrondie, qui prend en argument un vecteur x et un argument facultatif decimales. La fonction doit effectuer les opérations suivantes : calculer la moyenne du vecteur si decimales est défini, arrondir la moyenne au nombre de décimales correspondant avec la fonction round() retourner le résultat moyenne_arrondie &lt;- function(x, decimales = NULL) { moyenne &lt;- mean(x) if (!is.null(decimales)) { moyenne &lt;- round(moyenne, decimales) } moyenne } Exercice 2.2 Créer une fonction etendue qui retourne la différence entre la plus grande et la plus petite valeur d’un vecteur. etendue &lt;- function(x) { max(x) - min(x) } Modifier la fonction pour qu’elle retourne NA si le vecteur passé en argument n’est pas numérique. etendue &lt;- function(x) { if (!is.numeric(x)) { return(NA) } max(x) - min(x) } Modifier à nouveau la fonction pour qu’elle affiche un avertissement avant de renvoyer la valeur NA. etendue &lt;- function(x) { if (!is.numeric(x)) { warning(&quot;x doit être numérique&quot;) return(NA) } max(x) - min(x) } Exercice 2.3 Créer une fonction proportion qui prend en argument un vecteur et retourne les valeurs de ce vecteur divisée par leur somme. proportion &lt;- function(x) { x / sum(x) } Essayer d’exécuter proportion(c(-2, 1, 1)). Pourquoi obtient-on ce résultat ? Comme la somme des éléments du vecteur vaut 0, lorsqu’on divise chaque élément par cette valeur on obtient l’infini (Inf), soit négatif soit positif selon le signe de l’élément divisé. Modifier la fonction pour qu’elle retourne un message d’erreur si la somme des éléments du vecteur vaut 0. proportion &lt;- function(x) { if (sum(x) == 0) { stop(&quot;la somme des éléments de x vaut zéro&quot;) } x / sum(x) } 17.5.3 Boucles Exercice 3.1 Charger le jeu de données hdv2003 de l’extension questionr avec : library(questionr) data(hdv2003) À l’aide d’une boucle for, parcourir les noms des variables de hdv2003. Si la variable en question est numérique, faire l’histogramme de la variable avec la fonction hist(). for (name in names(hdv2003)) { variable &lt;- hdv2003[, name] if (is.numeric(variable)) { hist(variable) } } Ajouter le nom de la variable comme titre du graphique en utilisant l’argument main de hist(). for (name in names(hdv2003)) { variable &lt;- hdv2003[, name] if (is.numeric(variable)) { hist(variable, main = name) } } Exercice 3.2 La fonction readline() permet de lire une chaîne de caractère saisie au clavier de la manière suivante : reponse &lt;- readline(&quot;Quelle est votre réponse ?&quot;) Écrire le code qui effectue les opérations suivantes : Afficher le message “Quel est le plus grand sociologue de tous les temps ?” et demander la réponse à l’utilisateur Si la réponse saisie est “Tonton Michel”, afficher “Bingo !” Sinon, afficher “Nope” reponse &lt;- readline(&quot;Quel est le plus grand sociologue de tous les temps ?&quot;) if (reponse == &quot;Tonton Michel&quot;) { message(&quot;Bingo !&quot;) } else { message(&quot;Nope !&quot;) } À l’aide d’une boucle while(), modifier le code précédent pour que la question soit répétée jusqu’à ce que l’utilisateur saisisse “Tonton Michel”. reponse &lt;- &quot;&quot; while (reponse != &quot;Tonton Michel&quot;) { reponse &lt;- readline(&quot;Quel est le plus grand sociologue de tous les temps ?&quot;) if (reponse == &quot;Tonton Michel&quot;) { message(&quot;Bingo !&quot;) } else { message(&quot;Nope !&quot;) } } Exercice 3.3 À l’aide d’une boucle for, écrire une fonction somme_positifs qui prend en argument un vecteur et retourne la somme de tous les nombres positifs qu’il contient. somme_positifs &lt;- function(x) { somme &lt;- 0 for (item in x) { if (item &gt; 0) { somme &lt;- somme + item } } somme } Réécrire cette fonction pour qu’elle retourne le même résultat mais sans utiliser de boucle. somme_positifs &lt;- function(x) { sum(x[x &gt; 0]) } Exercice 3.4 En utilisant une boucle for, créer une fonction somme_premiers_positifs qui prend en argument un vecteur et retourne la somme de tous les nombres positifs qu’il contient en partant du début du vecteur et en s’arrêtant au premier élément négatif (on pourra recopier et modifier la première fonction somme_positifs de l’exercice précédent). somme_premiers_positifs &lt;- function(x) { somme &lt;- 0 for (item in x) { if (item &lt; 0) { break } somme &lt;- somme + item } somme } Facultatif : réécrire la fonction pour qu’elle retourne le même résultat sans utiliser de boucle for. somme_premiers_positifs &lt;- function(x) { negatifs &lt;- which(x &lt; 0) if (length(negatifs) == 0) { return(sum(x)) } premier_negatif &lt;- min(negatifs) sum(head(x, premier_negatif - 1)) } Exercice 3.5 Soit la fonction pile_ou_face suivante, qui simule un jet de pièce : pile_ou_face &lt;- function() { alea &lt;- runif(1) if (alea &lt; 0.5) { result &lt;- &quot;pile&quot; } else { result &lt;- &quot;face&quot; } result } Modifier cette fonction en utilisant une boucle for pour qu’elle accepte un argument n et retourne un vecteur comprenant le résultat de n tirages. pile_ou_face(4) #&gt; [1] &quot;pile&quot; &quot;face&quot; &quot;pile&quot; &quot;face&quot; pile_ou_face &lt;- function(n) { tirages &lt;- character() for (i in seq_len(n)) { alea &lt;- runif(1) if (alea &lt; 0.5) { tirages &lt;- c(tirages, &quot;pile&quot;) } else { tirages &lt;- c(tirages, &quot;face&quot;) } } tirages } Réécrire la fonction pour qu’elle retourne le même résultat sans utiliser de boucle for. pile_ou_face &lt;- function(n) { alea &lt;- runif(n) result &lt;- ifelse(alea &lt; 0.5, &quot;pile&quot;, &quot;face&quot;) result } # Ou bien, encore plus simple pile_ou_face &lt;- function(n) { sample(c(&quot;pile&quot;, &quot;face&quot;), size = n, replace = TRUE) } En complément, on verra également dans la section 18 d’autres fonctions tirées de l’extension purrr qui permettent d’appliquer une fonction en itérant sur les éléments de plusieurs objets.↩︎ L’intérêt de seq_along(x) est notamment qu’elle n’essaie pas d’exécuter le bloc de code si jamais x est de longueur nulle. Cf. des explications supplémentaires dans Advanced R.↩︎ "],["18-purrr.html", "Partie 18 Itérer avec purrr 18.1 Exemple d’application 18.2 map et ses variantes 18.3 Itérer sur les colonnes d’un tableau de données 18.4 modify 18.5 imap 18.6 walk 18.7 map2 et pmap : itérer sur plusieurs vecteurs en parallèle 18.8 Répéter une opération 18.9 Quand (ne pas) utiliser map 18.10 purrr vs *apply 18.11 Ressources 18.12 Exercices", " Partie 18 Itérer avec purrr purrr est une extension du tidyverse qui fournit des outils pour travailler avec les vecteurs et les fonctions, et notamment pour itérer sur les éléments de vecteurs ou de listes en leur appliquant une fonction. Dans cette section on aura besoin des extensions du tidyverse (dont purrr fait partie), que nous chargeons donc immédiatement, de même que les jeux de données rp2012 et hdv2003 de questionr. library(tidyverse) library(questionr) data(hdv2003) data(rp2012) 18.1 Exemple d’application Pour mieux appréhender de quoi il s’agit, on part du vecteur suivant, qui contient des extraits (fictifs ?) de discours politiques. discours &lt;- c( &quot;nous privilégierons une intergouvernementalisation sans agir anticonstitutionnellement&quot;, &quot;le souffle de la nation est le vent qui agite les drapeaux de nos libertés&quot;, &quot;nous devons faire preuve de plus de pédagogie pour cette réforme&quot;, &quot;mon compte twitter a été piraté&quot; ) On souhaite calculer la longueur de chaque extrait, en nombre de mots. On commence par découper grossièrement chaque extrait en mots en utilisant la fonction str_split() de stringr36. mots &lt;- str_split(discours, &quot; &quot;) str(mots) #&gt; List of 4 #&gt; $ : chr [1:7] &quot;nous&quot; &quot;privilégierons&quot; &quot;une&quot; &quot;intergouvernementalisation&quot; ... #&gt; $ : chr [1:15] &quot;le&quot; &quot;souffle&quot; &quot;de&quot; &quot;la&quot; ... #&gt; $ : chr [1:11] &quot;nous&quot; &quot;devons&quot; &quot;faire&quot; &quot;preuve&quot; ... #&gt; $ : chr [1:6] &quot;mon&quot; &quot;compte&quot; &quot;twitter&quot; &quot;a&quot; ... L’objet mots est une liste de vecteurs de chaînes de caractères qui contiennent les mots des différents extraits. Calculer le nombre de mots de chaque extrait revient à calculer la longueur de chaque élément de mots. Pour cela on pourrait vouloir utiliser la fonction length() directement : length(mots) #&gt; [1] 4 Ceci ne fonctionne pas, car length() nous retourne le nombre d’éléments de mots, pas celui de chacun de ses éléments : ce qu’on veut, ça n’est pas length(mots) mais length(mots[[1]]), length(mots[[2]]), etc. On a vu section 17.3.4 qu’on peut pour cela utiliser une boucle for, par exemple de la manière suivante. resultat &lt;- list() for (item in mots) { resultat &lt;- c(resultat, length(item)) } resultat #&gt; [[1]] #&gt; [1] 7 #&gt; #&gt; [[2]] #&gt; [1] 15 #&gt; #&gt; [[3]] #&gt; [1] 11 #&gt; #&gt; [[4]] #&gt; [1] 6 Ça fonctionne, mais la syntaxe est un peu “lourde”. La fonction map() de purrr propose exactement cette fonctionnalité. Elle prend deux arguments principaux : un vecteur ou une liste une fonction et elle retourne une liste contenant le résultat de la fonction appliquée à chaque élément du vecteur ou de la liste. En utilisant map() on peut remplacer notre boucle for par un simple : map(mots, length) #&gt; [[1]] #&gt; [1] 7 #&gt; #&gt; [[2]] #&gt; [1] 15 #&gt; #&gt; [[3]] #&gt; [1] 11 #&gt; #&gt; [[4]] #&gt; [1] 6 map va itérer sur les éléments de mots, leur appliquer tour à tour la fonction length passée en argument, et regrouper les résultats dans une liste. À noter qu’on peut évidemment utiliser le pipe. mots %&gt;% map(length) #&gt; [[1]] #&gt; [1] 7 #&gt; #&gt; [[2]] #&gt; [1] 15 #&gt; #&gt; [[3]] #&gt; [1] 11 #&gt; #&gt; [[4]] #&gt; [1] 6 Ici notre résultat est une liste. Or il pourrait être simplifié sous forme de vecteur atomique, puisque tous ses éléments sont des nombres. Si on souhaitait obtenir un vecteur numérique avec une boucle for, il faut soit convertir le résultat de la boucle précédente en vecteur atomique (avec unlist() ou purrr::flatten_int()), soit modifier cette boucle pour qu’elle génère plutôt un vecteur numérique : resultat &lt;- numeric(length(discours)) for (i in seq_along(mots)) { resultat[i] &lt;- length(mots[[i]]) } resultat #&gt; [1] 7 15 11 6 Mais purrr propose des variantes de la fonction map qui permettent justement de s’assurer du type de résultat obtenu. Ainsi, map_dbl() renverra toujours un vecteur de nombres flottants, et map_int() un vecteur de nombres entiers. En remplacement de la boucle for ci-dessus, on peut donc utiliser : mots %&gt;% map_int(length) #&gt; [1] 7 15 11 6 18.2 map et ses variantes 18.2.1 Modes d’appel de map L’objectif de map est donc d’appliquer une fonction à l’ensemble des éléments d’un vecteur ou d’une liste. On a vu qu’on pouvait l’utiliser pour appliquer la fonction length à chacun des vecteurs contenus par la liste mots. En utilisant map_int on s’assure de récupérer un simple vecteur numérique, plus facile à utiliser par la suite si on souhaite par exemple calculer une moyenne. mots %&gt;% map_int(length) #&gt; [1] 7 15 11 6 Si on souhaitait plutôt extraire le dernier mot de chaque vecteur, on pourrait créer une fonction spécifique et l’appliquer avec map(). dernier_mot &lt;- function(v) { tail(v, 1) } mots %&gt;% map(dernier_mot) #&gt; [[1]] #&gt; [1] &quot;anticonstitutionnellement&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;libertés&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;réforme&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;piraté&quot; Comme notre résultat est une liste de chaînes de caractères simples, on peut forcer le résultat à être plutôt un vecteur de type character en utilisant map_chr() : mots %&gt;% map_chr(dernier_mot) #&gt; [1] &quot;anticonstitutionnellement&quot; &quot;libertés&quot; #&gt; [3] &quot;réforme&quot; &quot;piraté&quot; Comme notre fonction est très courte, on peut aussi préférer utiliser une fonction anonyme, introduites section 14.4.2. mots %&gt;% map_chr(function(v) { tail(v, 1) }) #&gt; [1] &quot;anticonstitutionnellement&quot; &quot;libertés&quot; #&gt; [3] &quot;réforme&quot; &quot;piraté&quot; On peut aussi utiliser la notation abrégée sous forme de formule, propre aux fonctions du tidyverse, présentée section 15.3. mots %&gt;% map_chr(~ tail(.x, 1) ) #&gt; [1] &quot;anticonstitutionnellement&quot; &quot;libertés&quot; #&gt; [3] &quot;réforme&quot; &quot;piraté&quot; On peut également utiliser la notation compacte pour les fonctions anonymes disponible sous R à partir de la version 4.1. mots %&gt;% map_chr(\\(v) tail(v, 1)) #&gt; [1] &quot;anticonstitutionnellement&quot; &quot;libertés&quot; #&gt; [3] &quot;réforme&quot; &quot;piraté&quot; Enfin, si on fournit des arguments supplémentaires à map, ils sont passés comme argument à la fonction qu’il applique, on peut donc également utiliser la notation suivante : mots %&gt;% map_chr(tail, 1) #&gt; [1] &quot;anticonstitutionnellement&quot; &quot;libertés&quot; #&gt; [3] &quot;réforme&quot; &quot;piraté&quot; Dans ce qui suit on utilisera de préférence la notation “formule”, mais toutes les versions ci-dessus sont équivalentes et donnent le même résultat. Petite astuce à noter, si on transmet à map() autre chose qu’une fonction, elle utilisera cette information pour extraire des éléments. Ainsi, v %&gt;% map(1) extraiera le premier élément de chaque élément du vecteur v, v %&gt;% map(“foo”) extraiera les éléments nommés “foo”, etc. 18.2.2 Variantes de map On a vu que map propose plusieurs variantes qui permettent de contrôler le type de résultat qu’elle retourne : map() retourne une liste map_int() retourne un vecteur atomique d’entiers map_dbl() retourne un vecteur atomique de nombres flottants map_chr() retourne un vecteur atomique de chaînes de caractères map_lgl() retourne un vecteur atomique de TRUE / FALSE Attention, ces variantes sont très strictes : si la fonction appelée retourne un résultat qui n’est pas compatible avec le résultat attendu, elle génère une erreur. C’est le cas si dans le code précédent on essaie de récupérer chaque dernier mot sous forme d’un vecteur de nombres : mots %&gt;% map_dbl(tail, 1) #&gt; Error: Can&#39;t coerce element 1 from a character to a double Pour pouvoir utiliser ces variantes et obtenir un vecteur atomique, chaque résultat retourné par la fonction appliquée doit être de longueur 1. Ainsi, si on souhaitait extraire plutôt la liste des mots contenant un “f”, certains résultats ne contiennent aucun élément, et d’autres en contiennent deux : mots %&gt;% map(~ str_subset(.x, &quot;f&quot;) ) #&gt; [[1]] #&gt; character(0) #&gt; #&gt; [[2]] #&gt; [1] &quot;souffle&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;faire&quot; &quot;réforme&quot; #&gt; #&gt; [[4]] #&gt; character(0) Dans ce cas on ne peut pas utiliser map_chr() : si on essaie on obtient un message d’erreur nous indiquant que certains résultats de str_subset() ne sont pas au bon format. mots %&gt;% map_chr(~ str_subset(.x, &quot;f&quot;) ) #&gt; Error: Result 1 must be a single string, not a character vector of length 0 Dans ce cas, on doit donc utiliser map() et conserver le résultat sous forme de liste, qui elle peut contenir des éléments de longueurs différentes. mots %&gt;% map(~ str_subset(.x, &quot;f&quot;) ) #&gt; [[1]] #&gt; character(0) #&gt; #&gt; [[2]] #&gt; [1] &quot;souffle&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;faire&quot; &quot;réforme&quot; #&gt; #&gt; [[4]] #&gt; character(0) On notera qu’on peut tout à fait enchaîner les map() si on veut effectuer des opérations supplémentaires. mots %&gt;% map(~ str_subset(.x, &quot;f&quot;) ) %&gt;% map_int(length) #&gt; [1] 0 1 2 0 18.2.3 map_dfr() et map_dfc() La page suivante contient les données du jeu de données rp2012 sous la forme de fichiers CSV, avec un fichier par département : https://github.com/juba/tidyverse/tree/main/resources/data/rp2012 À partir de cette page, on peut télécharger les fichiers CSV en utilisant des adresses de la forme : https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_01.csv En remplaçant “01” par le code du département souhaité. On peut créer une fonction genere_url() qui, à partir d’une liste de codes de départements, retourne les adresses des fichiers correspondant. genere_url &lt;- function(codes) { paste0( &quot;https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_&quot;, codes, &quot;.csv&quot; ) } genere_url(c(&quot;42&quot;, &quot;69&quot;)) #&gt; [1] &quot;https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_42.csv&quot; #&gt; [2] &quot;https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_69.csv&quot; Grâce à la fonction read_csv(), on peut charger directement dans notre session R un fichier en indiquant son URL. data69 &lt;- read_csv(genere_url(&quot;69&quot;)) Comment faire si l’on souhaite charger les fichiers de plusieurs départements ? La fonction read_csv() n’accepte qu’une seule URL à la fois, elle n’est pas vectorisée. Dans ce cas on peut utiliser map() pour l’appliquer tour à tour à plusieurs URL. departements &lt;- c(&quot;38&quot;, &quot;42&quot;, &quot;69&quot;) urls &lt;- genere_url(departements) dfs &lt;- urls %&gt;% map(read_csv) Le résultat dfs est une liste de trois tableaux de données. Chacun de ces éléments est un tibble : d’abord celui du fichier CSV des données de l’Isère, puis celui de la Loire, et enfin celui du Rhône. On peut itérer sur cette liste dfs pour appliquer une fonction à chacun de ces tableaux. # Affichage des dimensions de chaque tableau dfs %&gt;% map(dim) #&gt; [[1]] #&gt; [1] 129 36 #&gt; #&gt; [[2]] #&gt; [1] 56 36 #&gt; #&gt; [[3]] #&gt; [1] 119 36 # Calcul de la moyenne de la variable dipl_aucun dfs %&gt;% map_dbl(~ mean(.x$dipl_aucun)) #&gt; [1] 16.03841 18.14102 14.73050 # Calcul du coefficient associé à la variable dipl_sup dans # la régression linéaire de cadres en fonction de dipl_sup dfs %&gt;% map_dbl(~ { reg &lt;- lm(cadres ~ dipl_sup, data = .x) reg$coefficients[&quot;dipl_sup&quot;] }) #&gt; [1] 1.007805 1.154655 1.065431 Si on souhaite réunir ces trois tibbles en un seul, on peut utiliser la fonction bind_rows() de dplyr. departements &lt;- c(&quot;38&quot;, &quot;42&quot;, &quot;69&quot;) urls &lt;- genere_url(departements) df &lt;- urls %&gt;% map(read_csv) %&gt;% bind_rows() Mais on peut aussi utiliser une autre variante de map(), nommée map_dfr(), qui considère les résultats obtenus par l’application de la fonction comme les lignes d’un tableau de données qu’elle va automatiquement rassembler en un seul tableau, de la même manière qu’avec un bind_rows(). df &lt;- urls %&gt;% map_dfr(read_csv) df #&gt; # A tibble: 304 × 36 #&gt; code_insee commune code_region region departement log_rp log_proprio log_loc #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 38001 Les Abr… 82 Rhône… Isère 1432 814 588 #&gt; 2 38006 Allevard 82 Rhône… Isère 1684 1033 610 #&gt; 3 38012 Aoste 82 Rhône… Isère 1083 733 331 #&gt; 4 38013 Apprieu 82 Rhône… Isère 1197 1007 172 #&gt; 5 38022 Les Ave… 82 Rhône… Isère 2320 1596 679 #&gt; 6 38034 Beaurep… 82 Rhône… Isère 1985 1080 861 #&gt; 7 38039 Bernin 82 Rhône… Isère 1117 922 172 #&gt; 8 38045 Biviers 82 Rhône… Isère 942 801 131 #&gt; 9 38052 Le Bour… 82 Rhône… Isère 1363 843 476 #&gt; 10 38053 Bourgoi… 82 Rhône… Isère 12129 4924 6913 #&gt; # … with 294 more rows, and 28 more variables: log_hlm &lt;dbl&gt;, log_sec &lt;dbl&gt;, #&gt; # log_maison &lt;dbl&gt;, log_appart &lt;dbl&gt;, age_0_14 &lt;dbl&gt;, age_15_29 &lt;dbl&gt;, #&gt; # age_75p &lt;dbl&gt;, femmes &lt;dbl&gt;, chom &lt;dbl&gt;, agric &lt;dbl&gt;, indep &lt;dbl&gt;, #&gt; # cadres &lt;dbl&gt;, interm &lt;dbl&gt;, empl &lt;dbl&gt;, ouvr &lt;dbl&gt;, etud &lt;dbl&gt;, #&gt; # dipl_aucun &lt;dbl&gt;, dipl_bepc &lt;dbl&gt;, dipl_capbep &lt;dbl&gt;, dipl_bac &lt;dbl&gt;, #&gt; # dipl_bac2 &lt;dbl&gt;, dipl_sup &lt;dbl&gt;, resid_sec &lt;dbl&gt;, proprio &lt;dbl&gt;, #&gt; # locataire &lt;dbl&gt;, hlm &lt;dbl&gt;, maison &lt;dbl&gt;, appart &lt;dbl&gt; Les deux lignes de code ci-dessus partent donc d’une liste d’identifiants de départements, génèrent les URL des fichiers CSV correspondant, les importent dans R et assemblent le résultat en un seul tableau. Plutôt efficace ! Une fonction utile en complément de map_dfr() est la fonction list.files(), qui peut lister les fichiers ayant une certaine extension dans un dossier spécifique. Par exemple, l’instruction suivante liste tous les fichiers se terminant par .csv du sous-dossier data. fichiers &lt;- list.files(&quot;data&quot;, &quot;*.csv&quot;, full.names = TRUE) On peut dès lors utiliser map_dfr() et read_csv() pour lire tous ces fichiers en une seule fois et les concaténer en un seul tableau de données. d &lt;- fichiers %&gt;% map_dfr(read_csv) Il existe également une variante map_dfc() qui considère les résultats comme des colonnes d’un tableau de données et les rassemble en un seul tableau comme le ferait la fonction bind_cols() de dplyr. 18.3 Itérer sur les colonnes d’un tableau de données On a vu section 16.3 que les tableaux de données (data frame ou tibble) sont en fait des listes dont les éléments sont les colonnes du tableau. Si on applique map() à un tableau, celle-ci itérera donc sur ses colonnes. Par exemple, on peut appliquer n_distinct au jeu de données starwars et obtenir le nombre de valeurs distinctes de chacune de ses colonnes. starwars %&gt;% map_int(n_distinct) #&gt; name height mass hair_color skin_color eye_color birth_year #&gt; 87 46 39 13 31 15 37 #&gt; sex gender homeworld species films vehicles starships #&gt; 5 3 49 38 24 11 17 Le résultat est équivalent à celui qu’on obtient en faisant un summarise() sur l’ensemble des colonnes, comme vu section 15.2, sauf que map_int() retourne un vecteur numérique tandis que summarise() renvoie un tibble à une ligne. starwars %&gt;% summarise( across(everything(), n_distinct) ) #&gt; # A tibble: 1 × 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 87 46 39 13 31 15 37 5 3 #&gt; # … with 5 more variables: homeworld &lt;int&gt;, species &lt;int&gt;, films &lt;int&gt;, #&gt; # vehicles &lt;int&gt;, starships &lt;int&gt; De la même manière, si on veut connaître le nombre de valeurs manquantes pour chaque variable : starwars %&gt;% map_int(~ sum(is.na(.x)) ) #&gt; name height mass hair_color skin_color eye_color birth_year #&gt; 0 6 28 5 0 0 44 #&gt; sex gender homeworld species films vehicles starships #&gt; 4 4 10 4 0 0 0 Contrairement à across(), on ne peut pas spécifier directement une sélection de colonnes à map(). On peut par contre utiliser des fonctions comme keep() ou discard() qui “filtrent” les éléments d’une liste via une fonction qui renvoie TRUE ou FALSE. On peut par exemple utiliser discard() après map() pour ne conserver que les colonnes ayant au moins une valeur NA. starwars %&gt;% map_int(~ sum(is.na(.x)) ) %&gt;% discard(~ .x == 0 ) #&gt; height mass hair_color birth_year sex gender homeworld #&gt; 6 28 5 44 4 4 10 #&gt; species #&gt; 4 Ou bien utiliser keep() pour n’appliquer mean() qu’aux variables numériques. starwars %&gt;% keep(is.numeric) %&gt;% map_dbl(mean, na.rm = TRUE) #&gt; height mass birth_year #&gt; 174.35802 97.31186 87.56512 18.4 modify modify() est une variante de map() qui a pour particularité de renvoyer un résultat du même type que la liste ou le vecteur donné en entrée. Ainsi, si on l’applique à un vecteur de chaînes de caractères, le résultat sera aussi un vecteur de chaînes de caractères même si la fonction appliquée retourne un résultat numérique. v &lt;- c(&quot;brouette&quot;, &quot;moto&quot;, &quot;igloo&quot;) v %&gt;% modify(length) #&gt; [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; Si on l’applique à une liste, le résultat sera aussi une liste. v &lt;- list(&quot;brouette&quot;, &quot;moto&quot;, &quot;igloo&quot;) v %&gt;% modify(length) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 1 #&gt; #&gt; [[3]] #&gt; [1] 1 L’objectif de modify() est de permettre de “modifier” une liste ou un vecteur en lui appliquant une fonction tout en étant sûr qu’on ne va pas modifier son type. L’intérêt principal de modify() est qu’elle propose deux variantes, modify_if() et modify_at(), qui sélectionnent les éléments respectivement via une fonction et via leur nom ou leur position, et qui n’appliquent la fonction de transformation qu’aux éléments sélectionnés. Cela peut être particulièrement utile quand on l’applique à un tableau de données. Par exemple le code suivant transforme uniquement les colonnes de type factor de hdv2003 en character, et laisse les autres inchangées. hdv2003 %&gt;% modify_if(is.factor, as.character) On notera qu’on obtient le même résultat avec le code suivant qui utilise across() de dplyr. hdv2003 %&gt;% mutate( across( where(is.factor), as.character ) ) 18.5 imap Imaginons que nous avons récupéré les données suivantes, qui représentent des évaluations obtenues par quatre restaurants, sous la forme d’une liste. restos &lt;- list( &quot;La bonne fourchette&quot; = c(3, 3, 2, 5, 2, 3, 2, 4, 1, 3), &quot;La choucroute de l&#39;amer&quot; = c(4, 1, 2, 4, 2, 5, 2), &quot;L&#39;Hair de rien&quot; = c(1, 5, 5, 1, 5, 3, 1, 5, 2), &quot;La blanquette de Vaulx&quot; = c(4, 1, 3, 1, 3, 3, 1, 4, 2, 5) ) À partir de cette liste, on souhaite créer un tableau de données comportant la moyenne et l’écart-type des notes de chaque restaurant. Comme on l’a vu précédemment, cela peut se faire avec l’aide de map_dfr(). restos %&gt;% map_dfr(~ tibble(moyenne = mean(.x), ecart_type = sd(.x)) ) #&gt; # A tibble: 4 × 2 #&gt; moyenne ecart_type #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2.8 1.14 #&gt; 2 2.86 1.46 #&gt; 3 3.11 1.90 #&gt; 4 2.7 1.42 On obtient le tableau souhaité, mais il manque une information : le nom du restaurant correspondant à chaque ligne. Cette information est incluse dans les noms des éléments de la liste restos, or la fonction passée à map_dfr n’y a pas accès, elle n’a accès qu’à leurs valeurs. C’est pour ce type de cas de figure que purrr propose la famille de fonctions imap(). Celle-ci fonctionne de la même manière que map(), sauf que la fonction appliquée prend deux arguments : d’abord la valeur de l’élément courant, puis son nom. Dans l’exemple suivant, on applique imap() à une liste simple et on affiche un message avec le nom et la valeur de chaque élément. l &lt;- list(nom1 = 1, nom2 = 3) l2 &lt;- l %&gt;% imap(function(valeur, nom) { message(&quot;La valeur de &quot;, nom, &quot; est &quot;, valeur) }) #&gt; La valeur de nom1 est 1 #&gt; La valeur de nom2 est 3 On peut évidemment utiliser la notation “formule” de purrr, il faut juste se souvenir que dans ce cas .x correspond à la valeur, et .y au nom. l2 &lt;- l %&gt;% imap(~ { message(&quot;La valeur de &quot;, .y, &quot; est &quot;, .x) }) #&gt; La valeur de nom1 est 1 #&gt; La valeur de nom2 est 3 Tout comme map() proposait les variantes map_int(), map_chr() ou map_dfr(), on peut également utiliser imap_dbl(), imap_chr() et autres imap_dfc() pour forcer le type de résultat retourné. Pour reprendre notre exemple de départ, on peut donc, en utilisant imap, récupérer le nom de l’élément courant de la liste restos et l’utiliser pour rajouter le nom du restaurant dans notre tibble de résultats. On peut le faire avec une fonction anonyme “classique” : restos %&gt;% imap_dfr(function(notes, nom) { tibble(resto = nom, moyenne = mean(notes), ecart_type = sd(notes)) }) #&gt; # A tibble: 4 × 3 #&gt; resto moyenne ecart_type #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 2.8 1.14 #&gt; 2 La choucroute de l&#39;amer 2.86 1.46 #&gt; 3 L&#39;Hair de rien 3.11 1.90 #&gt; 4 La blanquette de Vaulx 2.7 1.42 On peut aussi utiliser la notation compacte de type formule, en se souvenant à nouveau que .x correspond à la valeur de l’élément courant, et .y à son nom. restos %&gt;% imap_dfr(~ { tibble(resto = .y, moyenne = mean(.x), ecart_type = sd(.x)) }) #&gt; # A tibble: 4 × 3 #&gt; resto moyenne ecart_type #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 La bonne fourchette 2.8 1.14 #&gt; 2 La choucroute de l&#39;amer 2.86 1.46 #&gt; 3 L&#39;Hair de rien 3.11 1.90 #&gt; 4 La blanquette de Vaulx 2.7 1.42 Si on utilise imap() sur une liste ou un vecteur qui n’a pas de noms, le deuxième argument passé à la fonction appliquée sera l’indice de l’élément courant : 1 pour le premier, 2 pour le deuxième, etc. 18.6 walk walk() est une variante de map() qui a pour particularité de ne pas retourner de résultat. On l’utilise lorsqu’on souhaite parcourir un vecteur ou une liste et appliquer à ses éléments une fonction dont on ne souhaite conserver que les “effets de bord” : afficher un message, générer un graphique, enregistrer un fichier… Par exemple, le code suivant génère quatre diagrammes en barre indiquant la répartition des notes des différents restaurants vus dans la section précédente. walk(restos, ~ barplot(table(.x)) ) Comme pour map(), la variante iwalk() permet d’itérer à la fois sur les valeurs et sur les noms des éléments du vecteur ou de la liste. Ceci permet par exemple d’afficher le nom du restaurant comme titre de chaque graphique. iwalk(restos, ~ barplot(table(.x), main = .y) ) Au final, on notera que l’utilisation de walk(), comme elle ne retourne pas de résultats, est très proche de celle d’une boucle for. 18.7 map2 et pmap : itérer sur plusieurs vecteurs en parallèle Supposons qu’un.e collègue, qui travaille avec nous sur le jeu de données rp2012, nous a envoyé une liste de variables dont elle voudrait connaître les corrélations. Cette liste a été saisie dans un tableur sur deux colonnes, chaque ligne indiquant deux variables pour lesquelles elle souhaite qu’on effectue ce calcul. Après importation dans R on obtient le tableau de données suivant. correlations &lt;- tribble( ~var1, ~var2, &quot;dipl_sup&quot;, &quot;dipl_aucun&quot;, &quot;dipl_sup&quot;, &quot;cadres&quot;, &quot;hlm&quot;, &quot;cadres&quot;, &quot;hlm&quot;, &quot;ouvr&quot;, &quot;proprio&quot;, &quot;hlm&quot; ) correlations #&gt; # A tibble: 5 × 2 #&gt; var1 var2 #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 dipl_sup dipl_aucun #&gt; 2 dipl_sup cadres #&gt; 3 hlm cadres #&gt; 4 hlm ouvr #&gt; 5 proprio hlm Pour pouvoir calculer les corrélations souhaitées, on doit itérer sur les deux vecteurs var1 et var2 en parallèle, et calculer la corrélation entre la colonne de rp2012 correspondant à la valeur courante de var1 et celle correspondant à la valeur courante de var2. C’est précisément ce que fait la fonction map2(). Celle-ci prend trois arguments en entrée : deux listes ou vecteurs qui seront itérés en parallèle une fonction qui accepte deux arguments : ceux-ci prendront tour à tour les deux valeurs courantes des deux listes ou vecteurs itérés On peut donc utiliser map2 pour itérer parallèlement sur les deux colonnes var1 et var2 de notre tableau correlations, et calculer la corrélation des deux colonnes correspondantes de rp2012. map2( correlations$var1, correlations$var2, ~ cor(rp2012[[.x]], rp2012[[.y]]) ) #&gt; [[1]] #&gt; [1] -0.5337366 #&gt; #&gt; [[2]] #&gt; [1] 0.9371629 #&gt; #&gt; [[3]] #&gt; [1] -0.1452185 #&gt; #&gt; [[4]] #&gt; [1] 0.2526703 #&gt; #&gt; [[5]] #&gt; [1] -0.7878005 map2() propose les mêmes variantes map2_int(), mapr2_chr(), etc. que map(). On peut donc utiliser map2_dbl() pour récupérer un vecteur numérique plutôt qu’une liste, et l’utiliser par exemple pour rajouter une colonne à notre tableau de départ. correlations$corr &lt;- map2_dbl( correlations$var1, correlations$var2, ~ cor(rp2012[[.x]], rp2012[[.y]]) ) correlations #&gt; # A tibble: 5 × 3 #&gt; var1 var2 corr #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 dipl_sup dipl_aucun -0.534 #&gt; 2 dipl_sup cadres 0.937 #&gt; 3 hlm cadres -0.145 #&gt; 4 hlm ouvr 0.253 #&gt; 5 proprio hlm -0.788 Si on souhaite uniquement capturer les effets de bord sans récupérer les résultats de la fonctions appliquée, on peut aussi utiliser la variante walk2(). Supposons maintenant que notre collègue nous a envoyé, toujours sous la même forme, une liste de variables dont elle souhaite obtenir un nuage de points, mais en fournissant également un titre à ajouter au graphique. On obtient le tableau suivant : nuages &lt;- tribble( ~var1, ~var2, ~titre, &quot;dipl_sup&quot;, &quot;dipl_aucun&quot;, &quot;Diplômés du supérieur x sans diplôme&quot;, &quot;dipl_sup&quot;, &quot;cadres&quot;, &quot;Pourcentage de cadres x diplômés du supérieur&quot;, &quot;hlm&quot;, &quot;cadres&quot;, &quot;Pas facile de trouver un titre&quot;, &quot;proprio&quot;, &quot;cadres&quot;, &quot;Oui non vraiment c&#39;est pas simple&quot; ) nuages #&gt; # A tibble: 4 × 3 #&gt; var1 var2 titre #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 dipl_sup dipl_aucun Diplômés du supérieur x sans diplôme #&gt; 2 dipl_sup cadres Pourcentage de cadres x diplômés du supérieur #&gt; 3 hlm cadres Pas facile de trouver un titre #&gt; 4 proprio cadres Oui non vraiment c&#39;est pas simple On est dans une situation similaire à la précédente, sauf que cette fois on doit itérer sur trois vecteurs en parallèle. On va donc utiliser la fonction pmap() qui permet d’itérer sur autant de listes ou vecteurs que l’on souhaite. Plus précisément, comme on souhaite générer des graphiques on va utiliser la variante pwalk() qui ne retourne pas de résultat. pmap() et pwalk() prennent deux arguments principaux : les vecteurs et listes sur lesquels itérer, eux-mêmes regroupés dans une liste une fonction acceptant autant d’arguments que de vecteur ou listes sur lesquels on itère Dans notre exemple on aurait donc un appel de la forme suivante. pwalk( list(nuages$var1, nuages$var2, nuages$titre), function(var1, var2, titre) { plot( rp2012[[var1]], rp2012[[var2]], xlab = var1, ylab = var2, main = titre ) } ) Petite précision, si la liste est nommée, il faut que les noms des arguments de la fonction correspondent aux noms de la liste. pwalk( list(v1 = nuages$var1, v2 = nuages$var2, titre = nuages$titre), function(v1, v2, titre) { plot( rp2012[[v1]], rp2012[[v2]], xlab = v1, ylab = v2, main = titre ) } ) À noter que comme nuages est un tableau de données, donc une liste dont les éléments sont ses colonnes, on obtient le même résultat avec : pwalk( nuages, function(var1, var2, titre) { plot( rp2012[[var1]], rp2012[[var2]], xlab = var1, ylab = var2, main = titre ) } ) On peut utiliser la syntaxe “formule” pour la fonction anonyme, dans ce cas les arguments sont accessibles avec la notation ..1, ..2, etc. On notera que dans ce cas la syntaxe “formule” est sans doute moins lisible que la syntaxe classique avec function() qui permet de nommer les paramètres. pwalk( nuages, ~ { plot( rp2012[[..1]], rp2012[[..2]], xlab = ..1, ylab = ..2, main = ..3 ) } ) Comme pour map() et map2(), pmap() propose aussi les variantes pmap_int(), pmap_chr(), etc. 18.8 Répéter une opération Les fonctions de purrr peuvent être utilisées quand on souhaite juste répéter une opération un certain nombre de fois, à la place d’une boucle for. Par exemple si on souhaite générer 10 vecteurs de 100 nombre aléatoires, on pourra remplacer la boucle suivante : res &lt;- list() for (i in 1:10) { res &lt;- c(res, rnorm(100)) } Par un appel à map() : res &lt;- map(1:10, ~ rnorm(100)) Ce qui donne un code un peu plus compact et plus lisible. De la même manière, si on s’intéresse juste aux effets de bord, on pourra éventuellement remplacer une boucle for par un appel à walk(). 18.9 Quand (ne pas) utiliser map Une fois qu’on a compris la logique de map() et de ses variantes, on peut être tenté.es de l’appliquer un peu systématiquement. Il faut cependant garder en tête que son usage n’est pas toujours conseillé notamment dans les cas où il existe déjà une fonction vectorisée qui permet d’obtenir le même résultat. Ainsi cela n’aurait pas de sens de faire : v &lt;- 1:5 map_dbl(v, ~ .x + 10) #&gt; [1] 11 12 13 14 15 Quand on peut simplement faire : v + 10 #&gt; [1] 11 12 13 14 15 Pour prendre un exemple un peu moins caricatural, de nombreuses fonctions de stringr sont vectorisées, il n’est donc pas utile de faire : textes &lt;- c(&quot;fantastique&quot;, &quot;effectivement&quot;, &quot;igloo&quot;) map_int(textes, ~ str_count(.x, &quot;f&quot;)) #&gt; [1] 1 2 0 Quand on peut faire simplement : str_count(textes, &quot;f&quot;) #&gt; [1] 1 2 0 Par contre map() est utile quand on souhaite appliquer une fonction qui n’est pas vectorisée à plusieurs valeurs, comme c’est le cas par exemple avec read_csv(), qui ne permet pas de charger plusieurs fichiers d’un coup : fichiers &lt;- c(&quot;fichier1.csv&quot;, &quot;fichier2.csv&quot;) l &lt;- fichiers %&gt;% map(read_csv) Ou quand on veut itérer sur un argument non vectorisé, par exemple ici sur l’argument pattern de str_count() : voyelle &lt;- c(a = &quot;a&quot;, e = &quot;e&quot;, i = &quot;i&quot;) textes &lt;- c(&quot;brouette&quot;, &quot;moto&quot;, &quot;igloo&quot;) voyelle %&gt;% map(~ str_count(textes, pattern = .x)) #&gt; $a #&gt; [1] 0 0 0 #&gt; #&gt; $e #&gt; [1] 2 0 0 #&gt; #&gt; $i #&gt; [1] 0 0 1 On l’utilise également quand on veut appliquer une fonction non pas à une liste, mais aux éléments qu’elle contient : l &lt;- list(1:3, c(2, 5)) l %&gt;% map_int(length) #&gt; [1] 3 2 À noter qu’en termes de performance, map() n’est pas forcément plus rapide qu’une boucle for, puisque dans les deux cas on itère sur un ensemble de valeurs. Par contre une fonction vectorisée existante sera toujours (beaucoup) plus rapide. 18.10 purrr vs *apply Les fonctions de purrr ont des équivalents dans R “de base”, ce sont notamment les fonctions de la famille apply : lapply, sapply, mapply… L’avantage de map() et des autres fonctions fournies par purrr et qu’elles sont plus explicites : on a des fonctions différentes selon qu’on veut seulement appliquer une fonction (map()), générer des effets de bord (walk), modifier une liste sans changer son type (modify()), etc. purrr propose également de nombreuses fonctions utiles qui facilite le travail avec les vecteurs et listes. Mais un des avantages principaux des fonctions de la famille map() est qu’elles sont consistantes et cohérentes dans le type de résultat qu’elles retournent : on est certain que map() ou imap() retourneront une liste, que map_chr() ou map2_chr() retourneront un vecteur de chaînes de caractères, etc. Là encore, il n’est pas question de dire qu’il ne faut pas utiliser les fonctions *apply. Si vous en avez l’habitude et qu’elles fonctionnent pour vous, il n’y a pas spécialement de raison de changer. Mais si vous n’avez pas l’habitude de ce type d’opérations ou si vous préférez une syntaxe plus cohérente et plus facile à retenir, les fonctions de purrr peuvent être intéressantes. Si vous souhaitez en savoir plus, l’ouvrage en ligne R for data science contient une comparaison plus détaillée des deux familles de fonctions. 18.11 Ressources Au-delà de celles présentées ici, purrr propose de nombreuses autres fonctions facilitant la manipulation et les itérations sur les listes et les vecteurs. On peut en trouver la liste complète et la documentation associée (en anglais) sur le site de l’extension. La section Iteration de l’ouvrage en ligne R for data science (en anglais) propose une présentation de plusieurs fonctions de purrr. RStudio propose une antisèche (en anglais, format PDF) qui résume les différentes fonctions de purrr. Sur le blog en français de Lise Vaudor, on trouvera un billet Itérer des fonctions avec purrr et une suite practice makes purrr-fect. 18.12 Exercices 18.12.1 map et ses variantes Exercice 1.1 La liste suivante rassemble les notes obtenues par un élève dans différentes matières. notes &lt;- list( maths = c(12, 15, 8, 10), anglais = c(18, 11, 9), sport = c(5, 13), musique = 14 ) En utilisant map(), calculer une liste indiquant la moyenne dans chaque matière. notes %&gt;% map(mean) En utilisant une variante de map(), simplifier le résultat pour obtenir un vecteur numérique. notes %&gt;% map_dbl(mean) On a rajouté à la liste les notes obtenues en technologie, parmi lesquelles une note est manquante. notes &lt;- list( maths = c(12, 15, 8, 10), anglais = c(18, 11, 9), sport = c(5, 13), musique = 14, techno = c(12, NA) ) Calculer à nouveau un vecteur numérique des moyennes par matière, mais sans tenir compte de la valeur manquante. notes %&gt;% map_dbl(~ mean(.x, na.rm = TRUE) ) # Ou bien notes %&gt;% map_dbl(mean, na.rm = TRUE) Calculer une liste qui contient pour chaque matière le nombre de notes, leur moyenne et leur écart-type. # On peut aussi utiliser list() plutôt que c() notes %&gt;% map(~ c( nb_notes = length(.x), moyenne = mean(.x, na.rm = TRUE), ecart_type = sd(.x, na.rm = TRUE) ) ) Exercice 1.2 La liste suivante comporte les parcours biographiques de 5 personnes sous la forme de vecteurs indiquant leurs communes de résidence successives. parcours &lt;- list( c(&quot;Lyon&quot;, &quot;Flixevile&quot;, &quot;Saint-Dié-en-Pouilly&quot;), c(&quot;Sainte-Gabelle-sur-Sarthe&quot;), c(&quot;Décines&quot;, &quot;Meyzieu&quot;, &quot;Demptezieu&quot;), c(&quot;Meyzieu&quot;, &quot;Lyon&quot;, &quot;Paris&quot;, &quot;Flixevile&quot;, &quot;Lyon&quot;), c(&quot;La Bâtie-Divisin&quot;, &quot;Versailles&quot;) ) À l’aide de map(), calculer une nouvelle liste comportant le nombre de villes de résidence pour chaque parcours. parcours %&gt;% map(length) Utiliser une variante de map() pour simplifier le résultat et obtenir un vecteur numérique plutôt qu’une liste. parcours %&gt;% map_int(length) Déterminer pour chaque parcours le nombre de fois où la personne a résidé à Lyon. parcours %&gt;% map_int(~ sum(.x == &quot;Lyon&quot;)) L’équipe chargée de l’enquête vient de repérer une erreur de saisie : “Flixevile” s’écrit en réalité “Flixeville”. Utiliser map() pour corriger la liste parcours. parcours &lt;- parcours %&gt;% map(~ ifelse(.x == &quot;Flixevile&quot;, &quot;Flixeville&quot;, .x)) # Ou bien parcours &lt;- parcours %&gt;% map(~ str_replace(.x, &quot;Flixevile&quot;, &quot;Flixeville&quot;)) Exercice 1.3 Le vecteur suivant contient les adresses de deux fichiers CSV contenant les données de rp2012 pour les départements de l’Ain et du Rhône : urls &lt;- c( &quot;https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_01.csv&quot;, &quot;https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2012/rp2012_69.csv&quot; ) Utiliser map() pour charger ces deux tableaux de données dans une liste nommée dfs. dfs &lt;- urls %&gt;% map(read_csv) Utiliser map_dfr() pour charger ces deux tableaux de données et les regrouper en une seule table d. Que constatez-vous ? # Génère une erreur ! d &lt;- urls %&gt;% map_dfr(read_csv) À l’aide de map(), afficher la variable code_insee des deux tableaux de dfs. D’où vient le problème ? # Une variable a été importée en character, l&#39;autre en numérique dfs %&gt;% map(~ .x$code_insee) Trouver une solution pour corriger le problème. # En convertissant manuellement code_insee en character d &lt;- urls %&gt;% map_dfr(~{ tab &lt;- read_csv(.x) tab$code_insee &lt;- as.character(tab$code_insee) tab }) # Ou bien en utilisant l&#39;option col_types de read_csv d &lt;- urls %&gt;% map_dfr(read_csv, col_types = c(&quot;code_insee&quot; = &quot;character&quot;)) 18.12.2 modify et itération sur les colonnes d’un tableau Exercice 2.1 Soit le tableau de données d suivant : d &lt;- tribble( ~prenom, ~nom, ~age, ~taille, &quot;pierre-edmond&quot;, &quot;rateau&quot;, 19, 151, &quot;YVONNE&quot;, &quot;de la grappinière&quot;, 73, 182, &quot;charlotte-adélaïde&quot;, &quot;QUIGNON&quot;, 27, NA ) Utliser typeof() et map() pour afficher le type de toutes les colonnes de d. d %&gt;% map(typeof) En utilisant keep() et map(), calculer la moyenne de toutes les variables numériques de d. d %&gt;% keep(is.numeric) %&gt;% map(mean, na.rm = TRUE) En utilisant modify_if(), appliquer str_to_title() à toutes les colonnes de type character pour corriger la capitalisation des noms et prénoms. d &lt;- d %&gt;% modify_if(is.character, str_to_title) À l’aide de la fonction discard(), supprimer de d les colonnes qui comportent des NA. d %&gt;% discard(~ sum(is.na(.x)) &gt; 0) # Ou bien d %&gt;% discard(~ any(is.na(.x))) 18.12.3 imap et walk Exercice 3.1 On reprend la liste de notes vue dans un exercice précédent. notes &lt;- list( maths = c(12, 15, 8, 10), anglais = c(18, 11, 9), sport = c(5, 13), musique = 14, techno = c(12, NA) ) Sans utiliser de boucle for, afficher avec la fonction message() les valeurs de chaque moyenne tour à tour de manière à obtenir le résultat suivant : #&gt; 11.25 #&gt; 12.6666666666667 #&gt; 9 #&gt; 14 #&gt; 12 notes %&gt;% walk(~ message(mean(.x, na.rm = TRUE))) De la même manière afficher pour chaque matière les messages suivants : #&gt; Votre moyenne en maths est 11.25 #&gt; Votre moyenne en anglais est 12.6666666666667 #&gt; Votre moyenne en sport est 9 #&gt; Votre moyenne en musique est 14 #&gt; Votre moyenne en techno est 12 notes %&gt;% iwalk(function(notes, matiere) { message(&quot;Votre moyenne en &quot;, matiere, &quot; est &quot;, mean(notes, na.rm = TRUE)) }) Construire un tableau de données avec une matière par ligne et deux colonnes contenant le nom de la matière et la valeur de la moyenne. #&gt; # A tibble: 5 × 2 #&gt; matiere moyenne #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 maths 11.2 #&gt; 2 anglais 12.7 #&gt; 3 sport 9 #&gt; 4 musique 14 #&gt; 5 techno 12 notes %&gt;% imap_dfr(function(notes, matiere) { tibble( matiere = matiere, moyenne = mean(notes, na.rm = TRUE) ) }) Exercice 3.2 Lors de la présentation des boucles for, on a vu la fonction suivante qui affiche les dimensions de chaque tableau de données contenu dans une liste. affiche_dimensions &lt;- function(dfs) { for (i in seq_along(dfs)) { name &lt;- names(dfs)[[i]] df &lt;- dfs[[i]] message(&quot;Dimensions de &quot;, name, &quot; : &quot;, nrow(df), &quot;x&quot;, ncol(df)) } } l &lt;- list( hdv = hdv2003, rp = rp2012 ) affiche_dimensions(l) #&gt; Dimensions de hdv : 2000x20 #&gt; Dimensions de rp : 5170x60 Réécrire affiche_dimensions() en utilisant iwalk(). affiche_dimensions &lt;- function(dfs) { iwalk(dfs, function(df, name) { message(&quot;Dimensions de &quot;, name, &quot; : &quot;, nrow(df), &quot;x&quot;, ncol(df)) }) } Exercice 3.3 Lors de la présentation des boucles, on a vu la fonction summaries suivante, qui prend en paramètre un tableau de données et une liste de noms de colonnes, et applique la fonction summary() à ces colonnes. summaries &lt;- function(d, vars) { for (var in vars) { message(&quot;--- &quot;, var, &quot; ---&quot;) print(summary(d[, var])) } } summaries(hdv2003, c(&quot;sexe&quot;, &quot;age&quot;)) Réécrire la fonction sans utiliser de boucle for. summaries &lt;- function(d, vars) { vars %&gt;% walk(~{ message(&quot;--- &quot;, .x, &quot; ---&quot;) print(summary(d[, .x])) }) } Modifier cette nouvelle fonction en utilisant keep() ou discard(), pour qu’elle fonctionne sans erreur même si l’une des variables passées en arguments n’existe pas. summaries(hdv2003, c(&quot;sexe&quot;, &quot;igloo&quot;, &quot;age&quot;)) #&gt; --- sexe --- #&gt; sexe #&gt; Homme: 899 #&gt; Femme:1101 #&gt; --- age --- #&gt; age #&gt; Min. :18.00 #&gt; 1st Qu.:35.00 #&gt; Median :48.00 #&gt; Mean :48.16 #&gt; 3rd Qu.:60.00 #&gt; Max. :97.00 summaries &lt;- function(d, vars) { vars %&gt;% keep(~ .x %in% names(d) ) %&gt;% walk(~{ message(&quot;--- &quot;, .x, &quot; ---&quot;) print(summary(d[, .x])) }) } 18.12.4 map2 et pmap Exercice 4.1 Soit le tableau de données suivant, qui indique des couples de variables du jeu de données hdv2003. croisements &lt;- tribble( ~v1, ~v2, &quot;qualif&quot;, &quot;clso&quot;, &quot;qualif&quot;, &quot;cinema&quot;, &quot;sexe&quot;, &quot;clso&quot;, &quot;sexe&quot;, &quot;cinema&quot; ) croisements #&gt; # A tibble: 4 × 2 #&gt; v1 v2 #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 qualif clso #&gt; 2 qualif cinema #&gt; 3 sexe clso #&gt; 4 sexe cinema À l’aide de map2(), calculer une liste qui contient les tableaux croisés des quatre couples de variables de croisements. map2(croisements$v1, croisements$v2, ~table(hdv2003[[.x]], hdv2003[[.y]]) ) Modifier le code précédent pour obtenir une liste comportant, pour chaque couple de variables : les noms des deux variables croisées le résultat du test du \\(\\chi^2\\) appliqué aux deux variables khi2 &lt;- map2(croisements$v1, croisements$v2, ~list( variables = paste(.x, .y), chisq = chisq.test(hdv2003[[.x]], hdv2003[[.y]]) ) ) Facultatif : filtrer la liste obtenue à l’étape précédente pour ne conserver que les éléments dont la p-value du test du \\(\\chi^2\\) est inférieure à 0.001. khi2 &lt;- map2(croisements$v1, croisements$v2, ~list( variables = paste(.x, .y), chisq = chisq.test(hdv2003[[.x]], hdv2003[[.y]]) ) ) %&gt;% keep(~ .x$chisq$p.value &lt; 0.001) Exercice 4.2 Pour rappel, on peut simuler un tirage au sort de type “pile ou face” avec la fonction sample() de la manière suivante : sample( c(&quot;pile&quot;, &quot;face&quot;), size = 10, replace = TRUE, prob = c(0.5, 0.5) ) #&gt; [1] &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;pile&quot; &quot;pile&quot; &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;pile&quot; &quot;pile&quot; Le tableau de données suivant définit trois types de tirages aléatoires différents. elements contient les éléments parmi lesquels on tire, probas les probabilités de chaque élément d’être tiré, et n le nombre de tirages. tirages &lt;- tribble( ~elements, ~probas, ~n, c(&quot;pile&quot;, &quot;face&quot;), c(0.5, 0.5), 1000, c(&quot;rouge&quot;, &quot;noire&quot;), c(0.1, 0.9), 500, 1:6, rep(1/6, 6), 800 ) À l’aide de pmap() et de sample(), créer une liste contenant les résultats des simumations de ces trois séries de tirages. resultats &lt;- tirages %&gt;% pmap( function(elements, probas, n) { sample(elements, size = n, replace = TRUE, prob = probas) } ) Représenter avec barplot() les résultats obtenus. resultats %&gt;% walk(~barplot(table(.x))) 18.12.5 Répéter une opération Exercice 5.1 La fonction suivante simule le lancer de n dés à 6 faces. lancer_des &lt;- function(n) { sample(1:6, size = n, replace = TRUE) } lancer_des(3) #&gt; [1] 5 5 1 On souhaite utiliser cette fonction pour générer 10 lancers de 4 dés. On essaie avec le code suivant : map(1:10, lancer_des, 4) Est-ce que cela fonctionne ? Pourquoi ? Ça ne fonctionne pas car lancer_des() est appelée à chaque itération avec deux arguments : la valeur courante de l’itérateur, et 4. Ainsi dans sa première itération, map() exécute lancer_des(1, 4), ce qui génère un message d’erreur puisque lancer_des() n’accepte qu’un argument. Trouver une solution en corrigeant le code. map(1:10, ~lancer_des(4)) Exercice 5.2 Comme vu précédemment, la fonction suivante permet de simuler 20 lancers de pièces et de stocker le résultat dans un vecteur de chaînes de caractères. sample(c(&quot;pile&quot;, &quot;face&quot;), size = 20, replace = TRUE) #&gt; [1] &quot;pile&quot; &quot;pile&quot; &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;pile&quot; &quot;face&quot; &quot;pile&quot; #&gt; [11] &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;pile&quot; &quot;pile&quot; &quot;pile&quot; &quot;face&quot; &quot;face&quot; &quot;face&quot; &quot;pile&quot; À l’aide de map() et de ce code, créer une liste nommée sims contenant le résultat de 100 simulations de 20 lancers. sims &lt;- map( 1:100, ~ sample(c(&quot;pile&quot;, &quot;face&quot;), size = 20, replace = TRUE) ) Toujours à l’aide de map(), calculer le nombre de “pile” obtenus pour chaque simulation de sims. n_piles &lt;- sims %&gt;% map_int(~ sum(.x == &quot;pile&quot;)) Déterminer le nombre minimal et le nombre maximal de “pile” obtenus parmi toutes les simulations de sims. range(n_piles) Facultatif : à l’aide de la fonction head_while(), déterminer pour chaque simulation de sims le nombre de “pile” consécutifs obtenus avant le premier “face”. sims %&gt;% map_int( ~ length(head_while(.x, ~ .x == &quot;pile&quot;)) ) Facultatif : la fonction rle() permet de calculer les run length encoding d’un vecteur. rle(c(&quot;pile&quot;, &quot;face&quot;, &quot;face&quot;, &quot;face&quot;, &quot;pile&quot;, &quot;pile&quot;)) #&gt; Run Length Encoding #&gt; lengths: int [1:3] 1 3 2 #&gt; values : chr [1:3] &quot;pile&quot; &quot;face&quot; &quot;pile&quot; À l’aide de cette fonction et de map_int(), calculer pour chaque simulation la longueur de la plus grande série consécutive de “pile”. sims %&gt;% map_int(~{ r &lt;- rle(.x) longueurs_pile &lt;- r$lengths[r$values == &quot;pile&quot;] max(longueurs_pile) }) Pour une application sérieuse on utilisera des fonctions spécifiques de “tokenization” d’extensions dédiées à l’analyse textuelle, comme quanteda.↩︎ "],["19-programmer-tidyverse.html", "Partie 19 Programmer avec le tidyverse 19.1 Spécificités du tidyverse 19.2 Programmer avec dplyr et tidyr 19.3 Programmer avec ggplot2 19.4 Aide-mémoire 19.5 Ressources 19.6 Exercices", " Partie 19 Programmer avec le tidyverse Dans les parties précédentes, nous avons vu comment créer et utiliser nos propres fonctions. Cependant, un lecteur.trice attentif.ve aura remarqué que nous avons rigoureusement évité d’utiliser des fonctions du tidyverse, notamment de dplyr, de tidyr et de ggplot2, dans les fonctions que nous avons créées jusqu’ici. Nous allons voir dans cette section les spécificités liées à certaines fonctions du tidyverse et les manières de les utiliser pour programmer et les inclure dans nos propres fonctions. On commence avant toute chose par charger le tidyverse et le jeu de données starwars de dplyr. library(tidyverse) data(starwars) Les notions et fonctions abordées dans cette partie sont propres aux extensions du tidyverse. Elles ne sont en général pas utilisables ailleurs dans R. 19.1 Spécificités du tidyverse Les extensions du tidyverse fournissent une syntaxe lisible et agréable à utiliser lorsqu’on les utilise de manière interactive. Par exemple, si on veut filtrer les lignes et les colonnes d’un tableau de données en base R, on utilise quelque chose comme : starwars[starwars$species == &quot;Droid&quot; &amp; starwars$eye_color == &quot;red&quot;, c(&quot;height&quot;, &quot;mass&quot;)] Tandis qu’avec dplyr on peut faire : starwars %&gt;% filter(species == &quot;Droid&quot; &amp; eye_color == &quot;red&quot;) %&gt;% select(height, mass) L’avantage de dplyr est double : dans filter, on sait qu’on travaille à l’intérieur du tableau de données, on indique donc juste species et pas starwars$species dans select, on peut indiquer les noms de colonnes en omettant les guillemets Cette simplification pour une utilisation interactive, la plus fréquente, entraîne cependant une complexification lorsqu’on souhaite utiliser ces fonctions pour programmer, notamment quand on veut les utiliser à l’intérieur d’autres fonctions. 19.1.1 data masking On part du tableau de données d’exemple suivant37. restos &lt;- tibble( nom = c(&quot;Chez Jojo&quot;, &quot;Vertige des sens&quot;, &quot;Le Crousse&quot;, &quot;Le bouchon coréen&quot;, &quot;Le lampad&#39;hair&quot;), style = c(&quot;tradi&quot;, &quot;gastro&quot;, &quot;tradi&quot;, &quot;gastro&quot;, &quot;coiffure&quot;), ville = c(&quot;Ecully&quot;, &quot;Lyon&quot;, &quot;Lyon&quot;, &quot;Lyon&quot;, &quot;Ecully&quot;), evaluation = c(4.6, 3.2, 3.3, 4.1, 1.2), places = c(28, 32, 94, 18, 8), note = c(&quot;Pas mal&quot;, &quot;Cher&quot;, &quot;Ambiance jeune&quot;, &quot;Original&quot;, &quot;Euh ?&quot;) ) restos #&gt; # A tibble: 5 × 6 #&gt; nom style ville evaluation places note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance jeune #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? Avec dplyr, on peut sélectionner une colonne du tableau avec : restos %&gt;% select(note) #&gt; # A tibble: 5 × 1 #&gt; note #&gt; &lt;chr&gt; #&gt; 1 Pas mal #&gt; 2 Cher #&gt; 3 Ambiance jeune #&gt; 4 Original #&gt; 5 Euh ? Dans cette expression, note ne se réfère pas à un objet note de notre environnement, mais à une variable du tableau de données restos. Que se passe-t-il si on passe à select non pas une colonne du tableau mais bien un objet de notre environnement ? x &lt;- &quot;note&quot; restos %&gt;% select(x) #&gt; # A tibble: 5 × 1 #&gt; note #&gt; &lt;chr&gt; #&gt; 1 Pas mal #&gt; 2 Cher #&gt; 3 Ambiance jeune #&gt; 4 Original #&gt; 5 Euh ? Ça fonctionne aussi : en l’absence de colonne nommée x, select va aller chercher le x de notre environnement et utiliser sa valeur pour sélectionner la colonne par nom. Mais que se passe-t-il s’il existe à la fois une colonne du tableau et un objet de notre environnement du même nom ? note &lt;- &quot;nom&quot; restos %&gt;% select(note) #&gt; # A tibble: 5 × 1 #&gt; note #&gt; &lt;chr&gt; #&gt; 1 Pas mal #&gt; 2 Cher #&gt; 3 Ambiance jeune #&gt; 4 Original #&gt; 5 Euh ? Dans ce cas, c’est la colonne du tableau qui a la priorité. On dit que dplyr fait du data masking : les objets de notre environnement sont “masqués” par les colonnes du même nom de notre tableau de données. On retrouve ce data masking dans d’autres fonctions comme filter(), mutate() ou summarise(), mais aussi dans la sélection des variables avec aes() pour les fonctions de ggplot2. Dans certains cas de figure, on peut vouloir outrepasser ce data masking. Par exemple, dans le cas suivant, la nouvelle colonne note_michelin n’est pas créée à partir des nouvelles données de l’objet note, mais à partir de celles de la colonne note. note &lt;- c(12, 14, 9, 15, NA) restos %&gt;% mutate(note_michelin = note) #&gt; # A tibble: 5 × 7 #&gt; nom style ville evaluation places note note_michelin #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal Pas mal #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher Cher #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance je… Ambiance jeu… #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original Original #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? Euh ? “Il suffit de changer le nom de l’objet note pour qu’il ne corresponde à aucune colonne !”, s’exclamera la lectrice ou le lecteur attentif.ve. Mais, outre que cela peut être source d’erreur, il est des cas où on ne connaît pas le nom des colonnes du tableau, par exemple quand l’opération se déroule dans une fonction et que le tableau est passé en paramètre : filtre_nom &lt;- function(df, valeurs) { df %&gt;% filter(nom %in% valeurs) } Rien ne nous assure dans ce cas que le tableau df ne contient pas déjà une colonne nommée valeurs qui “masquerait” l’objet valeurs passé en argument… Pour pallier à ce problème, à chaque fois qu’on est dans un environnement où du data masking se produit, on peut utiliser deux “pronoms” spécifiques nommés .data et .env : .data$var ou .data[[\"var\"]] pointe vers l’objet var correspondant à une colonne du tableau de données .env$var ou .env[[\"var\"]] pointe vers l’objet var correspondant à un objet de notre environnement Avec ces deux outils, on peut donc explicitement choisir d’où viennent les données qu’on utilise. note &lt;- c(12, 14, 9, 15, NA) restos %&gt;% mutate(note_michelin = .env$note) #&gt; # A tibble: 5 × 7 #&gt; nom style ville evaluation places note note_michelin #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal 12 #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher 14 #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance je… 9 #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original 15 #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? NA restos %&gt;% mutate(note = str_to_upper(.data$note)) #&gt; # A tibble: 5 × 6 #&gt; nom style ville evaluation places note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 PAS MAL #&gt; 2 Vertige des sens gastro Lyon 3.2 32 CHER #&gt; 3 Le Crousse tradi Lyon 3.3 94 AMBIANCE JEUNE #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 ORIGINAL #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 EUH ? En utilisant .env, on peut donc s’assurer que notre fonction filtre_nom() ci-dessus va bien prendre les valeurs dans notre environnement, donc dans l’argument passé à la fonction, et pas dans une éventuelle colonne qui porterait le même nom. filtre_nom &lt;- function(df, valeurs) { df %&gt;% filter(nom %in% .env$valeurs) } filtre_nom(restos, c(&quot;Chez Jojo&quot;, &quot;Le Crousse&quot;)) #&gt; # A tibble: 2 × 6 #&gt; nom style ville evaluation places note #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal #&gt; 2 Le Crousse tradi Lyon 3.3 94 Ambiance jeune 19.1.2 tidy selection Une autre spécificité de certaines fonctions du tidyverse réside dans le mode de sélection des colonnes basé sur un “mini-langage” permettant des expressions comme : c(height, mass) q1:q10 where(is.numeric) &amp; !contains(id) Cette méthode de sélection de colonnes est appelée tidy selection et on la retrouve dans plusieurs fonctions de dplyr et tidyr, comme select(), across(), c_across(), pull(), pivot_longer(), etc. La tidy selection est implémentée par le package tidyselect et on peut retrouver les différentes possibilités de ce mini-langage dans la vignette Selection language. On notera que la tidy selection fait appel au data masking, tout en y ajoutant des fonctions spécifiques. 19.1.3 Utilisation dans des fonctions Une difficulté liée au data masking survient quand les colonnes du tableau ne sont pas saisies directement mais proviennent d’un argument de fonction. Soit la fonction suivante qui prend en entrée un tableau de données et une colonne et retourne le résultat d’un summmarise. summarise_min &lt;- function(df, col) { df %&gt;% summarise(min = min(col)) } On voudrait pouvoir appeler cette fonction de la même manière qu’on utilise summarise, mais cela ne fonctionne pas : summarise_min(restos, evaluation) #&gt; Error: Problem with `summarise()` column `min`. #&gt; ℹ `min = min(col)`. #&gt; ✖ objet &#39;evaluation&#39; introuvable Le message d’erreur nous dit que l’objet evaluation est introuvable. La raison n’est pas triviale, elle repose sur plusieurs mécanismes assez complexes liés à l’évaluation des expressions dans R, mais on pourrait résumer en disant que les fonctions du tidyverse utilisent leur propre mécanisme d’évaluation qui tient compte notamment du data masking. Or, quand on utilise l’argument col dans le summarise de notre fonction, c’est l’évaluation “normale” de R qui est utilisée : le data masking n’étant pas pris en compte, l’objet evaluation est recherché dans notre environnement plutôt que dans notre tableau, ce qui génère une erreur puisqu’aucun objet de ce nom n’existe en-dehors du tableau. Comme la tidy selection fait appel au data masking, elle génère le même type d’erreur : select_col &lt;- function(df, col) { df %&gt;% select(col) } select_col(restos, evaluation) #&gt; Error: objet &#39;evaluation&#39; introuvable C’est pourquoi les packages du tidyverse fournissent un opérateur permettant de “forcer” l’évaluation d’expressions selon la manière qu’elles attendent. Cet opérateur prend la forme de double accolades {{ }} et se nomme curly curly. Pour résoudre le problème de notre fonction summarise_min(), on peut donc simplement faire passer notre argument col dans l’opérateur curly curly : summarise_min &lt;- function(df, col) { df %&gt;% summarise(min = min({{ col }})) } summarise_min(restos, evaluation) #&gt; # A tibble: 1 × 1 #&gt; min #&gt; &lt;dbl&gt; #&gt; 1 1.2 À noter que curly curly permet de passer en argument toute expression qui serait acceptée directement par les fonctions appelées. On peut donc combiner plusieurs colonnes, effectuer des opérations, etc. summarise_min(restos, evaluation * 4) #&gt; # A tibble: 1 × 1 #&gt; min #&gt; &lt;dbl&gt; #&gt; 1 4.8 Et on peut même utiliser les pronoms .data et .env : evaluation &lt;- 0:5 summarise_min(restos, .env$evaluation) #&gt; # A tibble: 1 × 1 #&gt; min #&gt; &lt;int&gt; #&gt; 1 0 19.2 Programmer avec dplyr et tidyr 19.2.1 Utiliser une colonne passée en argument Une opération courante quand on utilise les fonctions de dplyr ou tidyr dans une fonction est de prendre en argument une colonne à laquelle on souhaite accéder. Dans ce cas on doit utiliser l’opérateur curly curly et entourer les utilisations de l’argument contenant la colonne par une paire d’accolades. On a déjà vu un exemple précédemment avec summarise(). resume &lt;- function(df, col) { df %&gt;% summarise( moyenne = mean({{ col }}), min = min({{ col }}), max = max({{ col }}) ) } resume(restos, evaluation) #&gt; # A tibble: 1 × 3 #&gt; moyenne min max #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3.28 1.2 4.6 C’est le cas dans toutes les fonctions qui font du data masking, comme group_by() : resume_groupe &lt;- function(df, col_group, col_var) { df %&gt;% group_by({{ col_group }}) %&gt;% summarise( moyenne = mean({{col_var}}), min = min({{ col_var }}), max = max({{ col_var }}) ) } resume_groupe(restos, style, evaluation) #&gt; # A tibble: 3 × 4 #&gt; style moyenne min max #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 coiffure 1.2 1.2 1.2 #&gt; 2 gastro 3.65 3.2 4.1 #&gt; 3 tradi 3.95 3.3 4.6 19.2.2 Utiliser une sélection de colonnes passée en argument Dans la section précédente, on a utilisé à chaque fois une seule colonne. Si on souhaite grouper ou appliquer une fonction sur une série de colonnes, il faut alors utiliser across(). resume_groupe &lt;- function(df, cols_group, cols_var) { df %&gt;% group_by( across({{ cols_group }}) ) %&gt;% summarise( across( {{ cols_var }}, mean ) ) } On peut du coup utiliser tous les modes de sélection de colonnes permises par la tidy selection. resume_groupe(restos, c(style, ville), where(is.numeric)) #&gt; `summarise()` has grouped output by &#39;style&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 4 × 4 #&gt; # Groups: style [3] #&gt; style ville evaluation places #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 coiffure Ecully 1.2 8 #&gt; 2 gastro Lyon 3.65 25 #&gt; 3 tradi Ecully 4.6 28 #&gt; 4 tradi Lyon 3.3 94 De la même manière, si on utilise un argument de fonction pour sélectionner des variables avec select(), on doit l’entourer avec l’opérateur curly curly, et on peut dès lors utiliser toutes les possibilités de la tidy selection. select_cols &lt;- function(df, cols) { df %&gt;% select({{ cols }}) } restos %&gt;% select_cols(where(is.character) &amp; !c(nom, note)) #&gt; # A tibble: 5 × 2 #&gt; style ville #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 tradi Ecully #&gt; 2 gastro Lyon #&gt; 3 tradi Lyon #&gt; 4 gastro Lyon #&gt; 5 coiffure Ecully 19.2.3 Nommer de nouvelles colonnes à partir d’un argument On a vu comment utiliser des colonnes passées en argument pour accéder à leur contenu. On peut aussi vouloir passer en argument des noms de colonnes qu’on souhaite créer, par exemple avec un mutate() ou un summarise(). On pourrait essayer directement de la manière suivante, mais cela ne fonctionne pas car dans ce cas la colonne créée s’appelle “col_new”, et pas la valeur de l’argument col_new. calcule_pourcentage &lt;- function(df, col_new, col_var) { df %&gt;% mutate( col_new = {{ col_var }} / sum({{ col_var }}) * 100 ) } calcule_pourcentage(restos, prop_places, places) #&gt; # A tibble: 5 × 7 #&gt; nom style ville evaluation places note col_new #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal 15.6 #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher 17.8 #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance jeune 52.2 #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original 10 #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? 4.44 Dans ce cas de figure, la syntaxe à utiliser est un peu plus complexe : on remplace l’opérateur = du mutate() par l’opérateur := (appelé walrus operator) on place à gauche du := une chaîne de caractères dans laquelle notre argument contenant le nom de la nouvelle variable est entouré d’une paire d’accolades. Voici ce que ça donne pour l’exemple ci-dessus : calcule_pourcentage &lt;- function(df, col_new, col_var) { df %&gt;% mutate( &quot;{{col_new}}&quot; := {{ col_var }} / sum({{ col_var }}) * 100 ) } calcule_pourcentage(restos, prop_places, places) #&gt; # A tibble: 5 × 7 #&gt; nom style ville evaluation places note prop_places #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal 15.6 #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher 17.8 #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance jeune 52.2 #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original 10 #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? 4.44 Cette syntaxe est un peu complexe de prime abord, mais elle à l’avantage d’être souple : en particulier, on peut placer le texte que l’on souhaite dans la chaîne de caractères en plus des noms de variables entre double accolades. Cela permet par exemple de générer le nom d’une nouvelle variable automatiquement à partir de l’ancienne. calcule_pourcentage &lt;- function(df, col_var) { df %&gt;% mutate( &quot;prop_{{col_var}}&quot; := {{ col_var }} / sum({{ col_var }}) * 100 ) } calcule_pourcentage(restos, places) #&gt; # A tibble: 5 × 7 #&gt; nom style ville evaluation places note prop_places #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Chez Jojo tradi Ecully 4.6 28 Pas mal 15.6 #&gt; 2 Vertige des sens gastro Lyon 3.2 32 Cher 17.8 #&gt; 3 Le Crousse tradi Lyon 3.3 94 Ambiance jeune 52.2 #&gt; 4 Le bouchon coréen gastro Lyon 4.1 18 Original 10 #&gt; 5 Le lampad&#39;hair coiffure Ecully 1.2 8 Euh ? 4.44 Ou de personnaliser les noms de colonnes dans un summarise(). resume &lt;- function(df, col) { df %&gt;% summarise( &quot;{{col}}_moyenne&quot; := mean({{ col }}), &quot;{{col}}_min&quot; := min({{ col }}), &quot;{{col}}_max&quot; := max({{ col }}) ) } resume(restos, places) #&gt; # A tibble: 1 × 3 #&gt; places_moyenne places_min places_max #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 36 8 94 19.2.4 Désambiguïser data et env Lorsqu’on utilise des fonctions de dplyr ou tidyr dans d’autres fonctions, il peut être utile de préciser, quand on accède à un objet dont on connaît le nom (c’est-à-dire dont le nom n’est pas passé en argument), si c’est un objet de type “data” (une colonne du tableau de données dans lequel on travaille) ou de type “env” (un objet de l’environnement dans lequel on travaille). Dans la fonction suivante, on calcule la moyenne d’une colonne numérique de restos selon les valeurs de la colonne ville, et on ne conserve que les villes pour lesquelles cette moyenne est supérieure à un certain seuil. stat_par_ville &lt;- function(col_var, seuil = NULL) { res &lt;- restos %&gt;% group_by(.data$ville) %&gt;% summarise(moyenne = mean({{col_var}})) %&gt;% filter(moyenne &gt; .env$seuil) } stat_par_ville(evaluation, seuil = 0) stat_par_ville(evaluation, seuil = 3) On veut que l’objet ville du group_by soit toujours la colonne du tableau restos nommée ville, on peut donc s’assurer que c’est bien le cas en l’explicitant avec .data$ville. À l’inverse, on veut que la valeur seuil du filter soit celle de l’argument du même nom, donc d’un objet de l’environnement. On peut s’en assurer en indiquant .env$seuil. Cette explicitation ne paraît pas forcément utile à première vue, mais elle peut éviter des problèmes à terme, notamment si on ajoute de nouvelles colonnes à un tableau de données et qu’on finit par avoir des objets “data” et des objets “env” avec le même nom. 19.2.5 Quand les arguments sont des chaînes de caractères Jusqu’ici, on a passé les arguments de fonction sous la forme d’expressions ou de symboles. resume(restos, places) summarise_min(restos, evaluation * 4) Mais il arrive que des noms de colonnes soient passés plutôt sous forme de chaînes de caractères. resume(restos, &quot;places&quot;) summarise_min(restos, &quot;evaluation&quot;) On ne peut pas dans ce cas utiliser l’opérateur curly curly, par contre on peut utiliser le pronom .data pour accéder aux colonnes à partir de leur nom. summarise_min &lt;- function(df, col) { df %&gt;% summarise(min = min(.data[[col]])) } summarise_min(restos, &quot;evaluation&quot;) #&gt; # A tibble: 1 × 1 #&gt; min #&gt; &lt;dbl&gt; #&gt; 1 1.2 Si dans l’exemple précédent on souhaite personnaliser le nom de la colonne créée en utilisant la valeur de notre paramètre evaluation, on place le nom de notre objet dans une chaîne de caractère en l’entourant d’accolades simples, et on utilise le walrus operator :=. summarise_min &lt;- function(df, col) { df %&gt;% summarise(&quot;min_{col}&quot; := min(.data[[col]])) } summarise_min(restos, &quot;evaluation&quot;) #&gt; # A tibble: 1 × 1 #&gt; min_evaluation #&gt; &lt;dbl&gt; #&gt; 1 1.2 Quand on veut plutôt sélectionner des colonnes avec select() ou across() et qu’on récupère les noms de ces colonnes dans un vecteur de chaînes de caractères, on doit utiliser les fonctions all_of() ou any_of(). evaluation_par_groupe &lt;- function(cols_group) { restos %&gt;% group_by( across(all_of(cols_group)) ) %&gt;% summarise(evaluation = mean(.data$evaluation)) } evaluation_par_groupe(&quot;ville&quot;) #&gt; # A tibble: 2 × 2 #&gt; ville evaluation #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Ecully 2.9 #&gt; 2 Lyon 3.53 evaluation_par_groupe(c(&quot;ville&quot;, &quot;style&quot;)) #&gt; `summarise()` has grouped output by &#39;ville&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 4 × 3 #&gt; # Groups: ville [2] #&gt; ville style evaluation #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Ecully coiffure 1.2 #&gt; 2 Ecully tradi 4.6 #&gt; 3 Lyon gastro 3.65 #&gt; 4 Lyon tradi 3.3 La différence entre all_of() et any_of() est que all_of() produira une erreur si l’une des variables n’est pas trouvée. select_all_cols &lt;- function(cols) { restos %&gt;% select(all_of(cols)) } select_all_cols(c(&quot;ville&quot;, &quot;evaluation&quot;, &quot;igloo&quot;)) #&gt; Error: Can&#39;t subset columns that don&#39;t exist. #&gt; ✖ Column `igloo` doesn&#39;t exist. Tandis qu’any_off() renverra uniquement les colonnes existantes, sans générer d’erreur. select_any_cols &lt;- function(cols) { restos %&gt;% select(any_of(cols)) } select_any_cols(c(&quot;ville&quot;, &quot;evaluation&quot;, &quot;igloo&quot;)) #&gt; # A tibble: 5 × 2 #&gt; ville evaluation #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Ecully 4.6 #&gt; 2 Lyon 3.2 #&gt; 3 Lyon 3.3 #&gt; 4 Lyon 4.1 #&gt; 5 Ecully 1.2 19.3 Programmer avec ggplot2 19.3.1 Sélection de colonnes avec aes() Les règles pour sélectionner des colonnes dans un graphique ggplot2 à partir d’arguments passés à une fonction sont les mêmes que celles vues précédemment pour dplyr et tidyr : si les noms sont passés sous forme de symboles ou d’expressions, on utilise l’opérateur curly curly ({{ }}) bar_graph &lt;- function(df, col) { ggplot(df) + geom_bar(aes(x = {{ col }}), fill = &quot;skyblue&quot;) } bar_graph(restos, ville) si les noms sont passés sous forme de chaînes de caractères, on utilise le pronom .data bar_graph &lt;- function(df, col) { ggplot(df) + geom_bar(aes(x = .data[[col]]), fill = &quot;skyblue&quot;) } bar_graph(restos, &quot;ville&quot;) 19.3.2 Faceting Quand on utilise facet_wrap() ou facet_grid(), si la variable de faceting est donnée sous forme d’un symbole, on utilise vars() en conjonction avec l’opérateur curly curly. facet_points &lt;- function(facet) { ggplot(restos) + geom_point(aes(x = .data$evaluation, y = .data$places)) + facet_wrap(vars({{ facet }})) } facet_points(ville) Si la variable de faceting est donnée sous forme d’une chaîne de caractères , on utilise vars() en conjonction avec le pronom .data. facet_points &lt;- function(facet) { ggplot(restos) + geom_point(aes(x = .data$evaluation, y = .data$places)) + facet_wrap(vars(.data[[facet]])) } facet_points(&quot;ville&quot;) Si on utilise facet_grid(), la fonction doit accepter deux variables de faceting comme arguments. Celles-ci peuvent ensuite être passées à facet_grid() via ses paramètres rows et cols. facet_points &lt;- function(facet_row, facet_col) { ggplot(restos) + geom_point(aes(x = .data$evaluation, y = .data$places)) + facet_grid( rows = vars({{ facet_row }}), cols = vars({{ facet_col }}) ) } facet_points(ville, style) 19.4 Aide-mémoire On essaie de récapituler ici les points importants pour pouvoir les retrouver facilement. Premier point important : les spécificités vues ici ne s’appliquent que quand on veut utiliser certaines fonctions du tidyverse (dplyr, tidyr, ggplot2) à l’intérieur d’autres fonctions. Plus spécifiquement, elles sont à prendre en compte quand on souhaite passer en argument d’une fonction des noms de colonnes qui seront utilisées par des fonctions du tidyverse. Elles ne s’appliquent pas si on passe en arguments d’autres paramètres comme le tableau de données qu’on souhaite utiliser, des valeurs numériques ou des chaînes de caractères qu’on souhaite récupérer telles quelles, etc. Dans le cas où deux objets du même nom pourraient exister à la fois comme colonne de notre tableau de données (objet data) et comme objet de notre environnement (objet env), on peut expliciter lequel on souhaite utiliser avec les pronoms .data$var et .env$var Si un argument est une colonne passée sous la forme d’un symbole (var), on doit l’encadrer de l’opérateur curly curly. summarise_col &lt;- function(df, col) { df %&gt;% summarise(moyenne = mean({{ col }}, na.rm = TRUE)) } summarise_col(starwars, height) Si un argument est un nom de colonne passé sous la forme d’une chaîne de caractères (\"var\"), on y accède avec le pronom .data : summarise_col &lt;- function(df, col_name) { df %&gt;% summarise(moyenne = mean(.data[[col_name]], na.rm = TRUE)) } summarise_col(starwars, &quot;height&quot;) Si on utilise la tidy selection dans un select(), un across() ou une autre fonction, on l’encadre de l’opérateur curly curly : select_cols &lt;- function(df, cols) { df %&gt;% select({{ cols }}) } select_cols(starwars, !where(is.list)) Si on indique les noms de plusieurs colonnes sous la forme d’un vecteur de chaînes de caractères pour utilisation dans un select(), un across() ou une autre fonction acceptant la tidy selection, on utilise all_of() ou any_of() : select_cols &lt;- function(df, col_names) { df %&gt;% select(all_of(col_names)) } select_cols(starwars, c(&quot;height&quot;, &quot;mass&quot;)) Si on souhaite créer une nouvelle colonne à partir de la valeur d’un argument, on l’utilise sous la forme d’une chaîne de caractères avec l’opérateur walrus :=. Si l’argument est un symbole on l’entoure avec {{ }}, si c’est une chaîne de caractères on l’entoure avec {} : add_mean_by_species &lt;- function(col_var) { starwars %&gt;% group_by(species) %&gt;% mutate(&quot;moyenne_{{col_var}}&quot; := mean({{ col_var}})) } add_mean_by_species(height) Le schéma suivant récapitule les points précédents : 19.5 Ressources Pour plus de détails sur la programmation avec les fonctions de dplyr, on pourra se reporter à la vignette Programming with dplyr. Pour l’utilisation de ggplot2 dans des fonctions, on trouvera plus de détails dans la vignette Using ggplot2 in packages. Les mécanismes d’évaluation et de métaprogrammation propres aux packages du tidyverse sont implémentés en grande partie dans le package rlang. Enfin, pour une présentation approfondie des possibilités de métaprogrammation dans R en général, on pourra consulter le chapitre Metaprogramming de l’ouvrage en ligne Advanced R. 19.6 Exercices 19.6.1 dplyr et tidyr Exercice 1.1 Créer une fonction my_table qui prend en arguments un tableau de données df et une variable var et qui renvoie le résultat de count() sur cette variable. Vérifier avec : my_table(starwars, gender) #&gt; # A tibble: 3 × 2 #&gt; gender n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 feminine 17 #&gt; 2 masculine 66 #&gt; 3 &lt;NA&gt; 4 my_table &lt;- function(df, var) { df %&gt;% count({{ var }}) } Modifier my_table pour qu’elle accepte trois arguments df, var1 et var2, et qu’elle retourne le résultat du count appliqué à var1 et à var2. my_table(starwars, gender, sex) #&gt; # A tibble: 6 × 3 #&gt; gender sex n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 feminine female 16 #&gt; 2 feminine none 1 #&gt; 3 masculine hermaphroditic 1 #&gt; 4 masculine male 60 #&gt; 5 masculine none 5 #&gt; 6 &lt;NA&gt; &lt;NA&gt; 4 my_table &lt;- function(df, var1, var2) { df %&gt;% count({{ var1 }}, {{ var2 }}) } Modifier my_table pour qu’elle accepte deux arguments df et vars, et qu’elle applique le count à toutes les variables indiquées dans vars en utilisant la tidy selection. my_table(starwars, c(gender, sex)) #&gt; # A tibble: 6 × 3 #&gt; gender sex n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 feminine female 16 #&gt; 2 feminine none 1 #&gt; 3 masculine hermaphroditic 1 #&gt; 4 masculine male 60 #&gt; 5 masculine none 5 #&gt; 6 &lt;NA&gt; &lt;NA&gt; 4 my_table &lt;- function(df, vars) { df %&gt;% count(across({{ vars }})) } Exercice 1.2 Le code suivant ajoute une nouvelle colonne diff_height au tableau starwars, qui contient la différence entre la valeur de height et sa moyenne selon les valeurs de species. starwars %&gt;% group_by(species) %&gt;% mutate(diff_height = height - mean(height, na.rm = TRUE)) En utilisant ce code, créer une fonction diff_mean_height qui accepte un seul argument by et qui ajoute à starwars une colonne diff_height calculée de la même manière, mais en appliquant le group_by au by passé en paramètre. diff_mean_height &lt;- function(by) { starwars %&gt;% group_by({{ by }}) %&gt;% mutate(diff_height = height - mean(height, na.rm = TRUE)) } Modifier la fonction précédente en une nouvelle fonction diff_mean, qui prend deux arguments by et var, et qui applique la même transformation non pas à height mais à la variable passée dans var. diff_mean &lt;- function(by, var) { starwars %&gt;% group_by({{ by }}) %&gt;% mutate(diff_mean = {{ var }} - mean({{ var }}, na.rm = TRUE)) } Modifier la fonction pour que le nom de la colonne ajoutée ne soit pas diff_mean mais le nom de la variable passée dans var suivi du suffixe \"_diff_mean\". diff_mean &lt;- function(by, var) { starwars %&gt;% group_by({{ by }}) %&gt;% mutate(&quot;{{var}}_diff_mean&quot; := {{ var }} - mean({{ var }}, na.rm = TRUE)) } Modifier à nouveau diff_mean pour pouvoir passer à by plusieurs variables en utilisant la tidy selection. diff_mean &lt;- function(by, var) { starwars %&gt;% group_by(across({{ by }})) %&gt;% mutate(&quot;{{var}}_diff_mean&quot; := {{ var }} - mean({{ var }}, na.rm = TRUE)) } Exercice 1.3 La fonction unnest() de tidyr permet de transformer une colonne contenant des valeurs de type liste en colonne “normale” en dupliquant les lignes autant de fois qu’il y a d’éléments dans chaque liste : starwars %&gt;% unnest(films) %&gt;% select(name, films) #&gt; # A tibble: 173 × 2 #&gt; name films #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker The Empire Strikes Back #&gt; 2 Luke Skywalker Revenge of the Sith #&gt; 3 Luke Skywalker Return of the Jedi #&gt; 4 Luke Skywalker A New Hope #&gt; 5 Luke Skywalker The Force Awakens #&gt; 6 C-3PO The Empire Strikes Back #&gt; 7 C-3PO Attack of the Clones #&gt; 8 C-3PO The Phantom Menace #&gt; 9 C-3PO Revenge of the Sith #&gt; 10 C-3PO Return of the Jedi #&gt; # … with 163 more rows Créer une fonction freq_liste() qui prend en entrée un argument var et retourne grâce à count le tri à plat de toutes les valeurs de la variable correspondant à var dans starwars, même si cette variable contient des listes. freq_liste(films) #&gt; # A tibble: 7 × 2 #&gt; films n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 A New Hope 18 #&gt; 2 Attack of the Clones 40 #&gt; 3 Return of the Jedi 20 #&gt; 4 Revenge of the Sith 34 #&gt; 5 The Empire Strikes Back 16 #&gt; 6 The Force Awakens 11 #&gt; 7 The Phantom Menace 34 freq_liste &lt;- function(var) { starwars %&gt;% unnest({{ var }}) %&gt;% count({{ var }}) } 19.6.2 Noms de colonnes en chaînes de caractères Exercice 2.1 La fonction readline() permet de lire une chaîne de caractères entrée au clavier par l’utilisateur : v &lt;- readline(&quot;Votre choix : &quot;) Créer une fonction affiche_planete qui affiche le message “Nom de la planète”, lit la réponse de l’utilisateur, et affiche à l’aide d’un filter() les lignes du tableau starwars pour lesquelles la variable homeworld correspond au nom saisi. affiche_planete &lt;- function() { var &lt;- readline(&quot;Nom de la planète : &quot;) starwars %&gt;% filter(homeworld == var) } Créer une fonction affiche_barplot qui affiche le message “Nom de la variable”, lit la réponse de l’utilisateur, et affiche avec ggplot2 le diagramme en barres de la variable correspondante du tableau starwars. affiche_barplot &lt;- function() { var &lt;- readline(&quot;Nom de la variable : &quot;) ggplot(starwars) + geom_bar(aes(x = .data[[var]])) } Créer une fonction affiche_colonnes qui affiche le message “Noms des variables séparés par des virgules”, lit la réponse de l’utilisateur, et affiche uniquement les colonnes saisies du tableau starwars. Conseil : pour récupérer un vecteur de colonnes à partir de la saisie de l’utilisateur, on pourra utiliser les fonctions str_split() et str_trim() de stringr. affiche_colonnes &lt;- function() { vars &lt;- readline(&quot;Noms des variables séparés par des virgules : &quot;) vars &lt;- str_split(vars, &quot;,&quot;)[[1]] vars &lt;- str_trim(vars) starwars %&gt;% select(all_of(vars)) } 19.6.3 Ambiguïté data / env Exercice 3.1 Créer une fonction filter_height() qui accepte un argument nommé height, et qui retourne les lignes de starwars pour lesquelles les valeurs de la variable height sont supérieures à celles de l’argument height. Créer cette fonction sans utiliser dplyr mais avec l’opérateur [,]. filter_height(200) #&gt; # A tibble: 16 × 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Darth … 202 136 none white yellow 41.9 male mascu… #&gt; 2 Chewba… 228 112 brown unknown blue 200 male mascu… #&gt; 3 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; 4 Roos T… 224 82 none grey orange NA male mascu… #&gt; 5 Rugor … 206 NA none green orange NA male mascu… #&gt; 6 Yarael… 264 NA none white yellow NA male mascu… #&gt; 7 Lama Su 229 88 none grey black NA male mascu… #&gt; 8 Taun We 213 NA none grey black NA fema… femin… #&gt; 9 Grievo… 216 159 none brown, whi… green, y… NA male mascu… #&gt; 10 Tarfful 234 136 brown brown blue NA male mascu… #&gt; 11 Tion M… 206 80 none grey black NA male mascu… #&gt; 12 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; 13 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; 14 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; 15 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; 16 &lt;NA&gt; NA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; #&gt; # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; filter_height &lt;- function(height) { starwars[starwars$height &gt; height, ] } Améliorer la fonction pour qu’elle ne retourne pas les lignes pour lesquelles la variable correspondant à height_var vaut NA. filter_height(200) #&gt; # A tibble: 10 × 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Darth … 202 136 none white yellow 41.9 male mascu… #&gt; 2 Chewba… 228 112 brown unknown blue 200 male mascu… #&gt; 3 Roos T… 224 82 none grey orange NA male mascu… #&gt; 4 Rugor … 206 NA none green orange NA male mascu… #&gt; 5 Yarael… 264 NA none white yellow NA male mascu… #&gt; 6 Lama Su 229 88 none grey black NA male mascu… #&gt; 7 Taun We 213 NA none grey black NA fema… femin… #&gt; 8 Grievo… 216 159 none brown, whi… green, y… NA male mascu… #&gt; 9 Tarfful 234 136 brown brown blue NA male mascu… #&gt; 10 Tion M… 206 80 none grey black NA male mascu… #&gt; # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; filter_height &lt;- function(height) { starwars[starwars$height &gt; height &amp; !is.na(starwars$height), ] } Écrire la même fonction, cette fois en utilisant filter() à la place de [,]. filter_height &lt;- function(height) { starwars %&gt;% filter(.data$height &gt; .env$height) } Quels sont les avantages et inconvénients des deux méthodes ? La fonction utilisant filter() est plus compacte et plus lisible, et elle gère les NA de la manière attendue sans condition supplémentaire. La fonction utilisant [,] évite l’ambiguïté liée à la présence simultanée d’un argument height et d’une colonne height. 19.6.4 ggplot2 Exercice 4.1 Créer une fonction graph_bar qui prend en argument un tableau de données df et une variable var et qui retourne le diagramme en barre de la variable correspondante généré avec ggplot2. graph_bar(starwars, gender) graph_bar &lt;- function(df, var) { ggplot(df) + geom_bar(aes(x = {{ var }})) } Modifier la fonction graph_bar pour qu’elle accepte un troisième argument nommé facet_var et qu’elle retourne le diagramme en barre de var pour chaque valeur de facet_var. graph_bar(starwars, sex, gender) graph_bar &lt;- function(df, var, facet_var) { ggplot(df) + geom_bar(aes(x = {{ var }})) + facet_wrap(vars({{ facet_var }})) } Exercice 4.2 Créer une fonction graph_points qui prend en arguments un tableau de données et deux variables, et affiche le nuage de points de ces deux variables généré avec ggplot2. graph_points(starwars, height, mass) #&gt; Warning: Removed 28 rows containing missing values (geom_point). graph_points &lt;- function(df, var_x, var_y) { ggplot(df) + geom_point(aes(x = {{var_x}}, y = {{var_y}})) } Ajouter un quatrième argument color à la fonction graph_points(), qui permet de spécifier la couleur des points (la même couleur pour tous). graph_points(starwars, height, mass, color = &quot;red&quot;) #&gt; Warning: Removed 28 rows containing missing values (geom_point). graph_points &lt;- function(df, var_x, var_y, color) { ggplot(df) + geom_point(aes(x = {{var_x}}, y = {{var_y}}), color = color) } Modifier graph_points() pour que l’argument color corresponde non pas à une couleur fixe mais à une variable dont les valeurs déterminent la couleur des points. graph_points(starwars, height, mass, color = sex) #&gt; Warning: Removed 28 rows containing missing values (geom_point). graph_points &lt;- function(df, var_x, var_y, color) { ggplot(df) + geom_point(aes(x = {{var_x}}, y = {{var_y}}, color = {{color}})) } Facultatif : modifier graph_points() pour que l’argument color puisse accepter aussi bien une variable qu’une couleur fixe. Indication : en s’aidant du résultat de la fonction suivante, on pourra tester si la valeur passée à color est bien une colonne du tableau de données. f &lt;- function(x) { deparse(substitute(x)) } f(igloo) #&gt; [1] &quot;igloo&quot; graph_points &lt;- function(df, var_x, var_y, color) { color_value &lt;- deparse(substitute(color)) g &lt;- ggplot(df) if (color_value %in% names(df)) { g &lt;- g + geom_point(aes(x = {{var_x}}, y = {{var_y}}, color = {{color}})) } else { g &lt;- g + geom_point(aes(x = {{var_x}}, y = {{var_y}}), color = color) } g } Effectivement, un salon de coiffure s’est à nouveau glissé dans ce jeu de données.↩︎ "],["20-debuggage-performance.html", "Partie 20 Débuggage et performance 20.1 Débugguer une fonction 20.2 benchmarking : mesurer et comparer les temps d’exécution 20.3 Quelques conseils d’optimisation 20.4 Ressources", " Partie 20 Débuggage et performance 20.1 Débugguer une fonction Lorsqu’on commence à écrire des fonctions un peu complexes, avec des if, des for, et autres joyeusetés, arrive forcément un moment où ça ne fonctionne pas comme on le souhaiterait et où on ne comprend pas pourquoi. Bref, il y a un bug. Trouver la cause d’un bug n’est pas toujours évident, mais il existe plusieurs méthodes et outils permettant de faciliter un peu les choses. On commence par charger les extensions et les jeux de données dont on aura besoin par la suite. library(tidyverse) library(questionr) data(hdv2003) data(starwars) 20.1.1 print() L’outil le plus simple, rudimentaire et parfois décrié mais qui reste efficace, est de rajouter un print() dans le code de notre fonction pour examiner le contenu d’un objet à un moment donné. Prenons un exemple. La fonction suivante prend en argument un tableau de données df et un nom de variable var, et retourne la moyenne et l’écart-type de cette variable. indicateurs &lt;- function(df, var) { valeurs &lt;- df[, var] if (!is.numeric(valeurs)) return(NA) list( moyenne = mean(valeurs, na.rm = TRUE), sd = sd(valeurs, na.rm = TRUE) ) } On teste notre fonction sur une variable du jeu de données hdv2003. Tout semble fonctionner. indicateurs(hdv2003, &quot;age&quot;) #&gt; $moyenne #&gt; [1] 48.157 #&gt; #&gt; $sd #&gt; [1] 16.94181 On teste à nouveau, cette fois sur une variable du jeu de données starwars de dplyr. indicateurs(starwars, &quot;height&quot;) #&gt; [1] NA Sapristi, on obtient NA en résultat alors que notre variable height est bien numérique : on devrait donc obtenir la moyenne et l’écart-type. Comment expliquer ce résultat ? Comme on n’a pas d’explication immédiate juste en relisant le code de notre fonction, on va ajouter temporairement une instruction print() qui va afficher le contenu de valeurs juste après qu’elle soit calculée. indicateurs &lt;- function(df, var) { valeurs &lt;- df[, var] print(valeurs) if (!is.numeric(valeurs)) return(NA) list( moyenne = mean(valeurs, na.rm = TRUE), sd = sd(valeurs, na.rm = TRUE) ) } On lance cette fonction modifiée sur starwars : indicateurs(starwars, &quot;height&quot;) #&gt; # A tibble: 87 × 1 #&gt; height #&gt; &lt;int&gt; #&gt; 1 172 #&gt; 2 167 #&gt; 3 96 #&gt; 4 202 #&gt; 5 150 #&gt; 6 178 #&gt; 7 165 #&gt; 8 97 #&gt; 9 183 #&gt; 10 182 #&gt; # … with 77 more rows #&gt; [1] NA Le print() nous indique que valeurs n’est pas un vecteur mais un tableau de données à une seule colonne. Or dans ce cas, le test is.numeric, qui est sensé s’appliquer à un vecteur atomique, renvoie FALSE. is.numeric(starwars[, &quot;height&quot;]) #&gt; [1] FALSE C’est donc la raison pour laquelle on obtient NA comme résultat. Certes, mais alors pourquoi cela fonctionne-t-il dans notre exemple avec hdv2003 ? indicateurs(hdv2003, &quot;age&quot;) #&gt; [1] 28 23 59 34 71 35 60 47 20 28 65 47 63 67 76 49 62 20 70 39 30 30 37 79 20 #&gt; [26] 74 31 35 35 30 54 29 49 59 41 41 53 19 77 56 54 35 40 62 68 77 39 57 43 34 #&gt; [51] 60 41 54 23 26 23 74 60 23 57 55 71 39 56 54 27 40 42 44 41 30 48 59 46 33 #&gt; [76] 70 67 75 22 51 41 53 70 79 31 34 72 59 63 77 48 25 62 23 66 90 43 32 54 19 #&gt; [101] 61 57 54 31 33 86 84 74 49 47 25 52 71 56 58 66 70 51 54 73 35 64 51 68 42 #&gt; [126] 49 55 49 60 71 75 36 78 19 23 81 41 58 37 49 55 51 58 29 47 78 31 55 42 35 #&gt; [151] 50 78 56 40 35 46 50 69 73 32 38 18 43 62 35 28 51 65 47 66 48 27 71 38 61 #&gt; [176] 39 69 79 57 64 59 47 24 54 50 32 60 57 50 23 48 49 70 27 52 19 54 45 64 71 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] #&gt; $moyenne #&gt; [1] 48.157 #&gt; #&gt; $sd #&gt; [1] 16.94181 Ah ! Dans ce cas là valeurs est bien un vecteur, et on obtient donc le résultat attendu. Pourquoi cette différence ? On est en fait tombé sur une différence de comportement entre les data frames et les tibbles, mentionnée section 16.3.3 : lorsqu’on sélectionne une seule colonne avec l’opérateur [,], un data frame retourne un vecteur tandis qu’un tibble retourne un tableau à une colonne. Or, ici, hdv2003 est un data frame, et starwars un tibble. Comment résoudre ce problème ? Il y a différentes manières, mais la plus simple est sans doute de remplacer [,] par [[]], qui lui a le même comportement dans les deux cas. On peut donc modifier notre fonction (en n’oubliant pas d’enlever le print()) et vérifier que ça fonctionne désormais. indicateurs &lt;- function(df, var) { valeurs &lt;- df[[var]] if (!is.numeric(valeurs)) return(NA) list( moyenne = mean(valeurs, na.rm = TRUE), sd = sd(valeurs, na.rm = TRUE) ) } indicateurs(hdv2003, &quot;age&quot;) #&gt; $moyenne #&gt; [1] 48.157 #&gt; #&gt; $sd #&gt; [1] 16.94181 indicateurs(starwars, &quot;height&quot;) #&gt; $moyenne #&gt; [1] 174.358 #&gt; #&gt; $sd #&gt; [1] 34.77043 Quand on ajoute des print() pour essayer d’identifier un problème, il faut bien penser à les supprimer une fois ce problème résolu, sinon on risque de se retrouver avec des messages “parasites” dans la console. 20.1.2 Localiser une erreur print() peut aussi être utile pour savoir à quel moment une erreur se produit, notamment lorsqu’on utilise une boucle. Dans l’exemple suivant, on crée une fonction min_freq_values() qui prend en argument un tableau de données df et un effectif n_min et retourne une liste des modalités de variables qui apparaissent dans au moins n_min lignes de df (on utilise ici une boucle for, mais on aurait aussi pu utiliser map()). min_freq_values &lt;- function(df, n_min) { res &lt;- list() for (col in names(df)) { # Tri à plat des valeurs de la colonne freq &lt;- table(df[[col]]) # On conserve les modalités avec effectif &gt;= n freq &lt;- freq[freq &gt;= n_min] # On ajoute la colonne au résultat s&#39;il y a au moins une modalité if (length(freq) &gt; 0) res[[col]] &lt;- freq } res } Si on applique min_freq_values() à hdv2003 avec une valeur de n à 1500, on obtient toutes les modalités correspondant à au moins 1500 observations. min_freq_values(hdv2003, 1500) #&gt; $hard.rock #&gt; Non #&gt; 1986 #&gt; #&gt; $lecture.bd #&gt; Non #&gt; 1953 #&gt; #&gt; $peche.chasse #&gt; Non #&gt; 1776 Essayons maintenant d’appliquer min_freq_values() au jeu de données starwars de dplyr. min_freq_values(starwars, 50) #&gt; Error in table(df[[col]]): tous les arguments doivent avoir la même longueur On obtient un message quelque peu sybillin : apparemment une erreur se produit au moment de faire le tri à plat des valeurs avec table(). Mais comme ce tri à plat s’effectue dans une boucle, on ne sait pas quelle variable de starwars est à l’origine du problème. On va donc rajouter un print(col) comme première instruction de la boucle for. min_freq_values &lt;- function(df, n_min) { res &lt;- list() for (col in names(df)) { print(col) # Tri à plat des valeurs de la colonne freq &lt;- table(df[[col]]) # On conserve les modalités avec effectif &gt;= n freq &lt;- freq[freq &gt;= n_min] # On ajoute la colonne au résultat s&#39;il y a au moins une modalité if (length(freq) &gt; 0) res[[col]] &lt;- freq } res } min_freq_values(starwars, 50) #&gt; [1] &quot;name&quot; #&gt; [1] &quot;height&quot; #&gt; [1] &quot;mass&quot; #&gt; [1] &quot;hair_color&quot; #&gt; [1] &quot;skin_color&quot; #&gt; [1] &quot;eye_color&quot; #&gt; [1] &quot;birth_year&quot; #&gt; [1] &quot;sex&quot; #&gt; [1] &quot;gender&quot; #&gt; [1] &quot;homeworld&quot; #&gt; [1] &quot;species&quot; #&gt; [1] &quot;films&quot; #&gt; Error in table(df[[col]]): tous les arguments doivent avoir la même longueur Ce print(col) nous permet de voir que tout se passe bien pour les premières variables du tableau, et que l’erreur survient au moment de traiter la variable films. On regarde donc à quoi ressemble cette variable. head(starwars$films, 3) #&gt; [[1]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Revenge of the Sith&quot; #&gt; [3] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; [5] &quot;The Force Awakens&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Attack of the Clones&quot; #&gt; [3] &quot;The Phantom Menace&quot; &quot;Revenge of the Sith&quot; #&gt; [5] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;The Empire Strikes Back&quot; &quot;Attack of the Clones&quot; #&gt; [3] &quot;The Phantom Menace&quot; &quot;Revenge of the Sith&quot; #&gt; [5] &quot;Return of the Jedi&quot; &quot;A New Hope&quot; #&gt; [7] &quot;The Force Awakens&quot; Damn, cette variable n’est pas un vecteur atomique mais une liste ! Un tableau de données peut en effet contenir ce que l’on appelle des colonnes-listes. Comme ça n’est pas courant, on ne l’avait clairement pas prévu au moment de la création de la fonction. On a désormais identifié le problème, on peut donc le corriger par exemple en ignorant les colonnes de type liste. Pour cela on utilise is.list() et l’instruction next. min_freq_values &lt;- function(df, n_min) { res &lt;- list() for (col in names(df)) { # On passe à la colonne suivante si la colonne est une colonne-liste if (is.list(df[[col]])) next # Tri à plat des valeurs de la colonne freq &lt;- table(df[[col]]) # On conserve les modalités avec effectif &gt;= n freq &lt;- freq[freq &gt;= n_min] # On ajoute la colonne au résultat s&#39;il y a au moins une modalité if (length(freq) &gt; 0) res[[col]] &lt;- freq } res } min_freq_values(starwars, 50) #&gt; $sex #&gt; male #&gt; 60 #&gt; #&gt; $gender #&gt; masculine #&gt; 66 Ça fonctionne ! Et cela nous permet de repérer au passage une “légère” sur-représentation des personnages masculins… 20.1.3 browser() Il existe des alternatives à print() plus efficaces pour identifier et résoudre des bugs. La plus utilisée est la fonction browser() : celle-ci peut s’insérer à n’importe quel endroit du code, et lorsqu’elle est rencontrée par R celui-ci s’interrompt et affiche une invite de commande permettant notamment d’inspecter des objets. On reprend l’exemple précédent en remplaçant le print(col) que nous avions inséré pour débugguer la fonction min_freq_values par un appel à browser(). min_freq_values &lt;- function(df, n_min) { res &lt;- list() for (col in names(df)) { browser() # Tri à plat des valeurs de la colonne freq &lt;- table(df[[col]]) # On conserve les modalités avec effectif &gt;= n freq &lt;- freq[freq &gt;= n_min] # On ajoute la colonne au résultat s&#39;il y a au moins une modalité if (length(freq) &gt; 0) res[[col]] &lt;- freq } res } min_freq_values(starwars, 50) Lorsqu’on lance ce code, R s’interrompt et affiche l’invite de commande suivant : Called from: min_freq_values(starwars, 50) Browse[1]&gt; Cette invite de commande offre plusieurs possibilités. La première est d’indiquer du code R qui sera exécuté dans le contexte au moment de l’interruption : si on indique un nom d’objet, on pourra donc afficher sa valeur. Ainsi, si on tape col, R nous affiche la valeur actuelle de col, donc au moment de la première itération de la boucle. Browse[1]&gt; col [1] &quot;name&quot; On peut également fournir des commandes spécifiques : si on tape n, R va passer à l’instruction suivante puis s’interrompre à nouveau38. Browse[1]&gt; n debug à #6 : freq &lt;- table(df[[col]]) Si on tape c, R va relancer l’exécution jusqu’à la fin, ou jusqu’à la prochaine rencontre d’un browser(). Dans notre cas, cela signifie qu’on va continuer jusqu’au browser() de la deuxième itération de la boucle. Browse[2]&gt; c Called from: min_freq_values(starwars, 50) Browse[1]&gt; col [1] &quot;height&quot; Si on souhaite sortir de cette invite de commande et tout interrompre, il suffit de taper Q. browser() est donc un peu plus complexe à utiliser que des print() ajoutés manuellement, mais c’est aussi un outil plus souple et plus puissant. Cette section n’offre qu’un petit aperçu des possibilités de débuggage. R propose d’autres fonctionnalités, et les environnements de développement comme RStudio ou Visual Studio Code proposent également leurs propres outils. Pour plus d’informations on pourra se reporter aux ressources en fin de chapitre. 20.2 benchmarking : mesurer et comparer les temps d’exécution Lorsqu’on commence à créer ses propres fonctions et de manière générale à écrire du code de plus en plus complexe ou à travailler sur des données de plus en plus volumineuses, on peut arriver sur des problèmes de performance : les temps d’exécution deviennent longs et on aimerait essayer de les optimiser. Il est alors parfois utile de faire du benchmarking, c’est-à-dire comparer plusieurs manières différentes de faire la même chose en mesurant leurs différences de vitesse d’exécution. L’intruction la plus simple pour cela est sans doute system.time(). Celle-ci prend en argument une expression R, et affiche en retour le temps d’exécution en secondes. system.time(runif(1000000)) #&gt; utilisateur système écoulé #&gt; 0.031 0.000 0.031 L’expression peut comporter plusieurs instructions, dans ce cas on les entoure d’accolades. system.time({ v &lt;- runif(1000000) moy &lt;- mean(v) }) #&gt; utilisateur système écoulé #&gt; 0.031 0.000 0.030 system.time() est cependant très limitée : on ne peut exécuter qu’une expression à la fois, on ne peut donc pas en comparer plusieurs directement, et surtout le temps d’exécution peut varier assez sensiblement selon l’utilisation du processeur de la machine au moment où on lance la commande. Il existe donc en complément plusieurs extensions dédiées au benchmarking. On va utiliser ici l’extension bench, installable avec : install.packages(&quot;bench&quot;) bench propose une fonction principale, nommée mark(), qu’on peut donc appeler directement avec bench::mark()39. On passe à cette fonction plusieurs expressions, et bench::mark() va effectuer les actions suivante : elle vérifie que les expressions retournent bien le même résultat (si on souhaite comparer des expressions qui renvoient des résultats différents, il faut ajouter l’argument check = FALSE) elle lance chacune de ces expressions plusieurs fois et mesure à chaque fois leur temps d’exécution elle affiche un résumé de ces temps d’exécution en indiquant notamment leur minimum et leur médiane Exécuter chaque expression plusieurs fois permet de prendre en compte les fluctuations liées à l’activité du processeur de la machine. Par défaut, bench::mark() exécute chaque instruction au minimum une fois et au moins suffisamment de fois pour atteindre 0,5s d’exécution (ces valeurs peuvent être modifiées via les paramètres min_iterations et min_time). Dans l’exemple suivant, on crée deux fonctions qui font la même chose : ajouter 10 à tous les éléments d’un vecteur passé en argument. Dans la première fonction plus10_for on utilise une boucle for qui ajoute 10 à tous les éléments l’un après l’autre (ce qu’il ne faut évidemment pas faire !), tandis que la deuxième fonction plus10_vec utilise la forme vectorisée x + 10. plus10_for &lt;- function(x) { for (i in seq_along(x)) { x[i] &lt;- x[i] + 10 } x } plus10_vec &lt;- function(x) { x + 10 } On lance un benchmark avec bench::mark() et on stocke le résultat dans un objet. x &lt;- 1:10000 bnch &lt;- bench::mark( plus10_for(x), plus10_vec(x) ) On affiche les résultats obtenus : bnch #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; #&gt; 1 plus10_for(x) 676.3µs 720.8µs 1398. 102KB 4.12 #&gt; 2 plus10_vec(x) 20.7µs 59.7µs 18234. 117KB 40.1 La colonne la plus importante est sans doute la colonne median, qui affiche le temps médian d’exécution des deux expressions. Attention, l’unité de temps n’est pas forcément la même, ici l’exécution de plus10_for est affichée en millisecondes (“ms”), tandis que celle de plus10_vec l’est en microsecondes (“µs”) donc avec une unité mille fois plus petite. Si on préfère, on peut afficher les performances relatives des deux fonctions avec : summary(bnch, relative = TRUE) #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 plus10_for(x) 32.7 12.1 1 1 1 #&gt; 2 plus10_vec(x) 1 1 13.0 1.15 9.73 Ces résultats nous permettent de voir que la version vec est très nettement plus rapide que la version for ! Ce qui confirme le fait qu’il faut toujours prioriser l’utilisation de fonctions vectorisées lorsqu’elles existent. On prend un second exemple : on souhaite mesurer si l’utilisation de map est plus rapide ou non qu’une boucle for pour une tâche équivalente. Pour cela on commence par créer artificiellement une liste de 200 tableaux de données en dupliquant 100 fois une liste composée des tableaux rp2012 et hdv2003. dfs &lt;- list(rp2012, hdv2003) dfs &lt;- rep(dfs, 100) Puis on lance un benchmark sur une boucle for et un map qui retournent chacun les nombres de ligne des 200 tableaux. Cette-fois on ne crée pas de fonctions : on passe le code directement à bench::mark(), avec des noms permettant de les identifier plus facilement dans les résultats. bench::mark( boucle_for = { res &lt;- list() for (df in dfs) { res &lt;- c(res, nrow(df)) } res }, map = map(dfs, ~ nrow(.x) ) ) #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; #&gt; 1 boucle_for 3.31ms 3.48ms 286. 199.32KB 6.40 #&gt; 2 map 841.91µs 915.81µs 1094. 6.81KB 10.7 La lecture du résultat indique que le map est environ 4 fois plus rapide que la boucle for. Attention cependant en lisant ces résultats : dans la comparaison précédente les temps d’exécution étant en millisecondes, même une différence du type “4 fois plus rapide” peut être quasiment imperceptible. Dans l’exemple suivant on compare de la même manière for et map, mais cette fois en effectuant une action plus coûteuse en temps de calcul (on génère des vecteurs de nombres aléatoires). bench::mark( boucle_for = { res &lt;- numeric() for (i in 1:100) { res &lt;- c(res, mean(runif(50000))) } res }, map = map_dbl(1:100, ~ mean(runif(50000))), check = FALSE ) #&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled. #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; #&gt; 1 boucle_for 221ms 252ms 3.97 38.5MB 3.97 #&gt; 2 map 226ms 228ms 4.25 38.4MB 4.25 Dans ce cas la différence entre for et map devient négligeable par rapport aux temps de calcul des opérations effectuées dans les boucles : au final les temps d’exécution sont presque identiques. 20.3 Quelques conseils d’optimisation 20.3.1 Privilégier les fonctions vectorisées On l’a déjà dit, redit et reredit, une des forces de R est de proposer un grand nombre de fonctions vectorisées, c’est-à-dire prévues et optimisées pour s’appliquer à tous les éléments d’un vecteur. Quand une fonction vectorisée existe, il est donc toujours préférable de l’utiliser plutôt qu’une boucle ou un map. v &lt;- rep(c(&quot;Pomme&quot;, &quot;Poire&quot;, &quot;Fraise&quot;), 100) bench::mark( boucle = { map_int(v, str_count, &quot;m&quot;) }, vec = str_count(v, &quot;m&quot;) ) #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; #&gt; 1 boucle 3.54ms 3.93ms 239. 20.96KB 6.41 #&gt; 2 vec 74.3µs 78.3µs 9386. 1.22KB 2.04 20.3.2 Mettre le minimum d’opérations dans les boucles Si vous utilisez une boucle, toute opération qu’elle contient, comme elle va être répétée, peut devenir rapidement très coûteuse. Il ne faut donc y mettre que les opérations réellement nécessaires. La fonction suivante prend en entrée un tableau de données d et une chaîne de caractères chr, et retourne un vecteur nommé indiquant le nombre de fois ou cette valeur apparaît dans chaque colonne du tableau. On a décidé de convertir en minuscules à la fois la valeur de chr et l’ensemble des colonnes du tableau pour que le comptage ne prenne pas en compte les différences de majuscules/minuscules. nb_chaine1 &lt;- function(d, chr) { res &lt;- numeric() for (var in names(d)) { # Conversion des colonnes de d et de chr en minuscules d &lt;- d %&gt;% modify(str_to_lower) chr &lt;- str_to_lower(chr) # Comptage des occurrences de chr dans la colonne var res[[var]] &lt;- sum(d[[var]] == chr, na.rm = TRUE) } res } d &lt;- hdv2003[, c(&quot;hard.rock&quot;, &quot;qualif&quot;, &quot;clso&quot;, &quot;bricol&quot;)] nb_chaine1(d, &quot;oui&quot;) #&gt; hard.rock qualif clso bricol #&gt; 14 0 936 853 Ça fonctionne, mais si on regarde un peu plus attentivement le code de la fonction on peut vite se rendre compte d’un problème : les conversions en minuscules sont faites à l’intérieur de la boucle, et sont donc répétées pour chaque colonne de d. Or ceci n’est absolument pas nécessaire puisque cette conversion ne dépend pas des colonnes et qu’elle peut être faite une seule et unique fois en début de fonction. On décide donc de sortir les conversion en minuscules de la boucle. nb_chaine2 &lt;- function(d, chr) { res &lt;- numeric() # Conversion des colonnes de d et de chr en minuscules d &lt;- d %&gt;% modify(str_to_lower) chr &lt;- str_to_lower(chr) for (var in names(d)) { # Comptage des occurrences de chr dans la colonne var res[[var]] &lt;- sum(d[[var]] == chr, na.rm = TRUE) } res } nb_chaine2(d, &quot;oui&quot;) #&gt; hard.rock qualif clso bricol #&gt; 14 0 936 853 Le résultat des deux fonctions est identique. On compare leur temps d’exécution à l’aide de bench::mark(). bench::mark( nb_chaine1(d, &quot;oui&quot;), nb_chaine2(d, &quot;oui&quot;), ) #&gt; # A tibble: 2 × 6 #&gt; expression min median `itr/sec` mem_alloc `gc/sec` #&gt; &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; #&gt; 1 nb_chaine1(d, &quot;oui&quot;) 7.05ms 7.64ms 128. 345KB 4.21 #&gt; 2 nb_chaine2(d, &quot;oui&quot;) 1.96ms 2.12ms 442. 157KB 2.03 Ce qui permet de constater que la deuxième version est quatre fois plus rapide (et elle sera d’autant plus rapide que le nombre de colonnes du tableau sera grand). 20.3.3 Choisir un format de fichier adapté Si on travaille sur des fichiers de données volumineux, les temps de chargement et de sauvegarde des données peuvent devenir importants. Il existe différents formats de fichiers qui pourront être plus ou moins efficaces et pratiques selon l’utilisation qu’on en fait : le format CSV est pratique pour échanger des données d’un système à un autre, mais ces fichiers sont assez volumineux et les temps de lecture / écriture assez longs. À noter que si read_csv() de readr est plus rapide que read.csv() de R base, il existe des alternatives encore plus rapides comme fread() de data.table ou les fonctions de l’extension vroom. pour un usage interne à R, les formats Rdata (utilisé par load() et save()) et RDS (utilisé par readRDS() et saveRDS()) ont des temps de lecture plus rapides et conservent les informations sur les types de données. Avec ces formats on peut faire varier le niveau de compression des données et donc jouer sur le rapport entre espace disque utilisé et temps d’accès. pour des données vraiment volumineuses, les formats parquet (du package arrow) ou fst proposent des temps de lecture et d’écriture très rapides. Il n’est malheureusement pas toujours simple de s’y retrouver d’autant que les formats et les performances peuvent évoluer assez rapidement. À titre indicatif, le billet (en anglais) a shallow benchmark of R data frame export/import methods propose un comparatif entre les performances de différents formats de fichiers. Attention cependant, il date de 2019 et les performances des fonctions testées ont pu évoluer depuis. 20.3.4 Repérer les opérations coûteuses avec du profiling Quand on commence à écrire du code un peu long, il n’est pas toujours évident de savoir quelles sont les opérations qui sont les plus coûteuses en termes de performance. Il peut alors être utile d’utiliser un outil de profiling, qui consiste justement à exécuter du code tout en mesurant les temps d’exécution de chaque instruction, ce qui permet ensuite de visualiser et repérer les opérations qui prennent le plus de temps et qui seraient donc les plus intéressantes à optimiser (si c’est possible). L’extension profvis fournit un outil de profiling sous R pratique et utile. On passe des instructions ou un script entier à la fonction profvis(), et celle-ci fournit une visualisation interactive des différentes opérations, de leur temps d’exécution, de leur utilisation de la mémoire… Exemple de visualisation générée par profvis() L’utilisation de profvis() dépasse le cadre de ce document, mais on pourra trouver des explications (en anglais) dans la partie profiling d’Advanced R. 20.3.5 Mettre en cache les résultats intermédiaires Selon la taille des données et le type d’opérations réalisées, les temps de calculs même optimisés peuvent demeurer longs. Dans ce cas il peut être intéressant de “mettre en cache” des résultats intermédiaires dans des fichiers pour pouvoir les charger directement sans avoir à tout recalculer. Par exemple, si on travaille sur un corpus de données textuelles, on peut enregistrer dans un fichier RDS ou Rdata le résultat de toutes les opérations de prétraitement du corpus pour n’avoir qu’à charger ces fichiers si on souhaite effectuer de nouvelles analyses. L’idéal cependant est d’utiliser une extension comme targets, présentée section 21, qui gère automatiquement les dépendances entre les étapes d’un projet et la mise en cache des résultats, et permet ainsi d’optimiser les temps de traitement. 20.3.6 Utiliser d’autres extensions Enfin, si ce document est basé sur les extensions du tidyverse, qui offrent une syntaxe cohérente et plus facile d’accès, il existe d’autres extensions notamment dans le domaine de la manipulation des données qui permettent des opérations plus rapides. C’est notamment le cas de l’extension data.table, qui utilise une syntaxe moins accessible que celle de dplyr, mais propose des performances en général assez nettement supérieures. On trouvera la documentation détaillée de data.table (en anglais) sur le site de l’extension. 20.4 Ressources L’ouvrage Advanced R (en anglais) consacre un chapitre entier au debuggage, un autre à la mesure de la performance, et un dernier à différentes techniques d’optimisation du code. Le site de RStudio propose une page entière détaillant ses fonctionnalités de debugging (en anglais). Pour les utilisateurs de Visual Studio Code, on pourra se référer à l’extension VSCode-R-Debugger. Si on a un objet n dont on souhaite afficher le contenu, on doit faire print(n).↩︎ L’avantage d’utiliser bench::mark() est qu’on n’a pas besoin d’ajouter un library(bench) dans notre script.↩︎ "],["21-targets.html", "Partie 21 Organiser un projet avec targets 21.1 Définition du pipeline 21.2 Exécution du pipeline 21.3 Modification du pipeline 21.4 RMarkdown 21.5 Gestion des données en cache 21.6 Avantages et limites 21.7 Ressources", " Partie 21 Organiser un projet avec targets targets est une extension développée par Will Landau qui permet d’organiser un projet sous la forme d’un pipeline de traitements, composé de différentes étapes, et gérant automatiquement les dépendances entre celles-ci40. Cette organisation a plusieurs avantages : elle permet une description de toutes les étapes du pipeline dans un fichier dédié, et force à séparer ces différentes étapes dans des fonctions à part, ce qui facilite la lisibilité et la maintenance du projet elle facilite la reproductibilité des traitements, car elle garantit que toutes les étapes ont bien été effectuées dans le bon ordre et dans un nouvel environnement elle optimise les temps de calcul, car en cas de modification seules les étapes qui le nécessitent sont relancées L’utilisation de targets dans des petits projets peut être vue comme une complexité supplémentaire pas toujours très utile, mais elle peut être très bénéfique pour des projets plus complexes ou comportant des temps de calculs importants à certaines étapes. targets fait partie de l’initiative rOpenSci. 21.1 Définition du pipeline 21.1.1 Projet d’exemple On part d’un projet très simple : à partir du fichier national des prénoms donnés à la naissance, diffusé par l’INSEE, on souhaite produire un document indiquant les prénoms ayant les évolutions les plus fortes (à la hausse ou à la baisse) entre 2019 et 2020. Le dossier de notre projet s’organise de la manière suivante : data/ └── nat2020.csv R/ ├── fonctions_recode.R └── fonctions_calculs.R _targets.R À noter que targets n’impose aucune structure de projet particulière en-dehors de la présence du fichier _targets.R. On aurait donc pu avoir une organisation tout à fait différente. Le fichier data/nat2020.csv contient les données brutes téléchargées depuis le site de l’INSEE. Le fichier R/fonctions_recode.R contient deux fonctions de traitement et de remise en forme des données. # On conserve uniquement 2019 et 2020 et on # filtre les lignes des prénoms rares regroupés filter_data &lt;- function(df) { df %&gt;% filter(annais %in% c(&quot;2019&quot;, &quot;2020&quot;)) %&gt;% filter(preusuel != &quot;_PRENOMS_RARES&quot;) } # Passage d&#39;un format avec les années en ligne à un # format avec les années en colonnes pivot_2019_2020 &lt;- function(df) { df %&gt;% tidyr::pivot_wider(names_from = annais, values_from = nombre) %&gt;% relocate(`2020`, .after = `2019`) } Le fichier R/fonctions_calculs.R contient une seule fonction qui calcule les variables d’évolution 2019-2020. # Calcul des indicateurs d&#39;évolution en effectifs et pourcentages # pour les prénoms dont la fréquence est &gt; à min_n calcule_evo &lt;- function(df, min_n = 200) { df %&gt;% filter(`2020` &gt; min_n | `2019` &gt; min_n) %&gt;% mutate( evo = (`2020` - `2019`), `evo%` = round(evo / `2019` * 100, 2) ) %&gt;% drop_na(evo) } 21.1.2 _targets.R C’est dans le fichier _targets.R, situé à la racine du dossier, qu’on va définir le pipeline constitué de toutes les étapes de notre traitement : chargement et manipulation des données, calculs, génération de rapports, etc. Ces étapes sont également appelées cibles (targets). La syntaxe présentée ici est celle proposée par l’extension tarchetypes, qui est un peu plus facile à prendre en main et plus lisible que la syntaxe native de targets. Le fichier _targets.R commence par charger à la fois targets et tarchetypes. # Packages nécessaires pour ce script library(targets) library(tarchetypes) On va ensuite utiliser source() pour charger le contenu des deux fichiers R/fonctions_recode.R et R/fonctions_calculs.R, et pouvoir utiliser par la suite les fonctions qu’ils définissent. # Chargement des fonctions source(&quot;R/fonctions_recode.R&quot;) source(&quot;R/fonctions_calculs.R&quot;) On définit ensuite des options globales pour le pipeline. L’option packages de tar_option_set(), permet de spécifier une liste d’extensions à charger systématiquement avant le lancement de chaque étape. Ici on s’assure que l’extension tidyverse est bien chargée et disponible, et on positionne l’option tidyverse.quiet à TRUE pour supprimer le message qu’elle affiche systématiquement au chargement. # Options pour les différentes étapes options(tidyverse.quiet = TRUE) tar_option_set(packages = &quot;tidyverse&quot;) Vient enfin la définition du pipeline proprement dit. Celle-ci se fait via la fonction tar_plan() de tarchetypes. tar_plan( ) La première opération que l’on souhaite effectuer est de charger les données contenues dans data/nat2020.csv. Pour cela on va d’abord créer une première étape qui consiste à référencer notre fichier CSV à l’aide de la fonction tar_file(). tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;) ) Cette première étape définit une cible (target), nommée csv_file, qui pointe vers notre fichier CSV. On ajoute une seconde étape qui charge les données à l’aide de read_csv2(). tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;), donnees_brutes = read_csv2(csv_file), ) Cette nouvelle étape définit une deuxième cible nommée donnees_brutes. Cette cible correspond au nom d’une étape, mais aussi à un objet : dans ce qui suit, donnees_brutes correspond au tableau de données résultat du read_csv2(). On va utiliser cet objet donnees_brutes dans une troisième étape nommée donnees qui lui applique les deux fonctions de filtrage et transformation définies dans R/fonctions_recode.R. tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;), donnees_brutes = read_csv2(csv_file), # Mise en forme des données donnees = donnees_brutes %&gt;% filter_data() %&gt;% pivot_2019_2020() ) Ici aussi, donnees est à la fois le nom d’une cible et un objet contenant nos données retravaillées. On utilise cet objet dans une étape supplémentaire qui utilise la fonction de R/fonctions_calculs.R pour calculer les variables d’évolution. tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;), donnees_brutes = read_csv2(csv_file), # Mise en forme des données donnees = donnees_brutes %&gt;% filter_data() %&gt;% pivot_2019_2020(), # Calcul indicateurs donnees_evo = donnees %&gt;% calcule_evo(min_n = 1000) ) On notera que les cibles doivent toutes avoir des noms différents. Si on exécute plusieurs étapes de transformation ou de calcul sur un tableau de données, on devra donner un nom distinct à ces cibles et aux objets qui correspondent. Au final, notre fichier _targets.R est donc le suivant : # Packages nécessaires pour ce script library(targets) library(tarchetypes) # Chargement des fonctions source(&quot;R/fonctions_recode.R&quot;) source(&quot;R/fonctions_calculs.R&quot;) # Options pour les différentes étapes options(tidyverse.quiet = TRUE) tar_option_set(packages = &quot;tidyverse&quot;) # Définition du pipeline tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;), donnees_brutes = read_csv2(csv_file), # Mise en forme des données donnees = donnees_brutes %&gt;% filter_data() %&gt;% pivot_2019_2020(), # Calcul indicateurs donnees_evo = donnees %&gt;% calcule_evo(min_n = 1000) ) targets offre aussi la possibilité de définir notre pipeline directement dans un fichier RMarkdown, ce qui peut permettre notamment de mieux le documenter. Pour plus d’information on pourra se référer au chapitre Target Markdown du manuel en ligne. 21.2 Exécution du pipeline Une fois notre pipeline défini, targets fournit des outils permettant de visualiser sa structure et son état, notamment la fonction tar_visnetwork(). tar_visnetwork() Les différentes cibles apparaissent sous forme de cercles, et les fonctions qui leur sont appliquées sous forme de triangles. Les flèches indiquent que targets a automatiquement créé un réseau de dépendances entre cibles et fonctions : ainsi la cible donnees dépend des fonctions filter_data, pivot_2019_2020 et de la cible donnees_brutes, qui elle-même dépend de la cible csv_file. La couleur des différents éléments montrent que ceux-ci sont à l’état outdated : ils ne sont pas à jour. On va donc exécuter notre pipeline, en utilisant la fonction tar_make(). tar_make() #&gt; • start target csv_file #&gt; • built target csv_file #&gt; • start target donnees_brutes #&gt; ℹ Using &quot;&#39;,&#39;&quot; as decimal and &quot;&#39;.&#39;&quot; as grouping mark. Use `read_delim()` for more control. #&gt; Rows: 667364 Columns: 4 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;;&quot; #&gt; chr (2): preusuel, annais #&gt; dbl (2): sexe, nombre #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; • built target donnees_brutes #&gt; • start target donnees #&gt; • built target donnees #&gt; • start target donnees_evo #&gt; • built target donnees_evo #&gt; • end pipeline Lorsqu’on utilise tar_make(), targets lance une nouvelle session R (pour éviter tout problème ou conflit lié à l’état de notre session actuelle), charge les extensions définies via tar_option_set(), et exécute les cibles définies avec tar_plan(). On visualise le nouvel état de notre pipeline, et on voit que toutes les cibles sont passées à l’état up to date. tar_visnetwork() À chaque étape, targets crée et stocke dans un cache chacun des objets correspondants aux différentes cibles (donnees_brutes, donnees, etc.). On peut charger à tout moment ces objets dans notre session avec la fonction tar_load()41. tar_load(donnees_evo) donnees_evo #&gt; # A tibble: 128 × 6 #&gt; sexe preusuel `2019` `2020` evo `evo%` #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 AARON 2443 2312 -131 -5.36 #&gt; 2 1 ADAM 3670 3386 -284 -7.74 #&gt; 3 1 ALEXANDRE 1154 1039 -115 -9.97 #&gt; 4 1 AMIR 1588 1360 -228 -14.4 #&gt; 5 1 ANTOINE 1786 1455 -331 -18.5 #&gt; 6 1 ARTHUR 4008 3800 -208 -5.19 #&gt; 7 1 AUGUSTIN 1546 1379 -167 -10.8 #&gt; 8 1 AXEL 1809 1683 -126 -6.97 #&gt; 9 1 AYDEN 1524 1786 262 17.2 #&gt; 10 1 BAPTISTE 1403 1202 -201 -14.3 #&gt; # … with 118 more rows On peut aussi utiliser tar_read(), qui lit et retourne les résultats d’une des cibles, permettant de les stocker dans un nouvel objet. evo &lt;- tar_read(donnees_evo) 21.3 Modification du pipeline Essayons de lancer à nouveau notre pipeline : tar_make() #&gt; ✔ skip target csv_file #&gt; ✔ skip target donnees_brutes #&gt; ✔ skip target donnees #&gt; ✔ skip target donnees_evo #&gt; ✔ skip pipeline On voit que toutes les cibles ont été “skippées” : quand on lance tar_make(), seules les cibles qui sont à l’état outdated sont recalculées. Les résultats des autres sont conservés tels quels. On va maintenant modifier légèrement notre fichier R/fonctions_calculs.R : plutôt que d’arrondir les évolutions en pourcentages à deux décimale, on n’en conserve plus qu’une. # Calcul des indicateurs d&#39;évolution en effectifs et pourcentages # pour les prénoms dont la fréquence est &gt; à min_n calcule_evo &lt;- function(df, min_n = 200) { df %&gt;% filter(`2020` &gt; min_n | `2019` &gt; min_n) %&gt;% mutate( evo = (`2020` - `2019`), `evo%` = round(evo / `2019` * 100, 1) ) %&gt;% drop_na(evo) } On visualise à nouveau l’état de notre pipeline : tar_visnetwork() Grâce à sa gestion interne des dépendances entre les cibles, targets a vu que la fonction calcule_evo a été modifiée (elle est passée en statut outdated), et comme la cible donnees_evo dépend de cette fonction, celle-ci a également été placée en outdated. On peut obtenir directement une liste des cibles qui ne sont plus à jour à l’aide de la fonction tar_outdated() : tar_outdated() #&gt; [1] &quot;donnees_evo&quot; On relance notre pipeline : tar_make() #&gt; ✔ skip target csv_file #&gt; ✔ skip target donnees_brutes #&gt; ✔ skip target donnees #&gt; • start target donnees_evo #&gt; • built target donnees_evo #&gt; • end pipeline On voit que les cibles csv_file, donnees_brutes et donnees ont été “skippées” : targets est allé prendre directement leurs valeurs déjà stockées en cache. Par contre donnees_evo a bien été recalculée. On peut vérifier que notre pipeline est désormais entièrement à jour : tar_visnetwork() À noter que targets gère aussi les modifications des fichiers externes. Ainsi, si on modifie le contenu de nat2020.csv, la cible csv_file passerait en outdated, tout comme l’ensemble des autres cibles puisqu’elles dépendent directement ou indirectement de celle-ci. Dans ce cas, un tar_make() aurait pour effet de recalculer l’intégralité du pipeline. 21.4 RMarkdown Imaginons maintenant qu’on souhaite générer un rapport à partir d’un document RMarkdown en utilisant les données d’évolution calculées par notre pipeline. On crée donc un nouveau fichier evolution.Rmd dans un dossier reports. data/ └── nat2020.csv R/ ├── fonctions_recode.R └── fonctions_calculs.R reports/ └── evolution.Rmd _targets.R Quand on utilise un document RMarkdown dans un pipeline, on doit accéder aux données en utilisant les fonctions tar_read() ou tar_load() : ceci permet de s’assurer qu’on récupère les données “à jour”, et cela permet aussi à targets de déterminer un lien de dépendance entre le document et les données. Comme on souhaite utiliser les données de donnees_evo, on devra donc utiliser quelque chose comme : d &lt;- tar_read(donnees_evo) Au final, le contenu de notre fichier RMarkdown est le suivant : --- title: &quot;Évolutions des prénoms 2019-2020&quot; date: &quot;`r Sys.Date()`&quot; output: html_document: df_print: paged --- ```{r setup, include = FALSE} knitr::opts_chunk$set(echo = FALSE) d &lt;- tar_read(donnees_evo) ``` ## Plus fortes hausses ```{r} d %&gt;% arrange(desc(`evo%`)) %&gt;% head(10) ``` ## Plus fortes baisses ```{r} d %&gt;% arrange(`evo%`) %&gt;% head(10) ``` Pour ajouter ce rapport à notre pipeline, on crée une nouvelle cible dans le tar_plan() de _targets.R. Comme il s’agit d’un document RMarkdown, on utilise la fonction tar_render(). # Packages nécessaires pour ce script library(targets) library(tarchetypes) # Chargement des fonctions source(&quot;R/fonctions_recode.R&quot;) source(&quot;R/fonctions_calculs.R&quot;) # Options pour les différentes étapes options(tidyverse.quiet = TRUE) tar_option_set(packages = &quot;tidyverse&quot;) # Définition du pipeline tar_plan( # Chargement du fichier CSV tar_file(csv_file, &quot;data/nat2020.csv&quot;), donnees_brutes = read_csv2(csv_file), # Mise en forme des données donnees = donnees_brutes %&gt;% filter_data() %&gt;% pivot_2019_2020(), # Calcul indicateurs donnees_evo = donnees %&gt;% calcule_evo(min_n = 1000), # Génération rapport tar_render(report_evo, &quot;reports/evolution.Rmd&quot;) ) Visualisons notre pipeline modifié : tar_visnetwork() On voit que notre nouvelle cible report_evo a bien été prise en compte, qu’elle dépend bien de donnees_evo et qu’elle est à l’état outdated. Si on exécute notre pipeline : tar_make() #&gt; ✔ skip target csv_file #&gt; ✔ skip target donnees_brutes #&gt; ✔ skip target donnees #&gt; ✔ skip target donnees_evo #&gt; • start target report_evo #&gt; • built target report_evo #&gt; • end pipeline La cible report_evo a bien été calculée, et on devrait retrouver notre rapport compilé au format HTML dans le dossier reports. 21.5 Gestion des données en cache targets garde une copie des objets correspondant aux cibles du pipeline dans un cache, en fait sous forme de fichiers placés dans un sous-dossier _targets. On a vu qu’on peut récupérer ces objets dans notre session via les fonctions tar_read() et tar_load(). targets propose également plusieurs fonctions pour gérer les données et métadonnées en cache : tar_destroy() supprime la totalite du répertoire _targets. Elle permet donc de “repartir de zéro”, sans aucun cache et avec toutes les cibles à recalculer. tar_delete(donnees) supprime l’objet donnees du cache et place l’état de la cible correspondante à outdated. Elle permet de forcer le recalcul d’une cible et de celles qui en dépendent. À noter qu’on peut sélectionner plusieurs cibles en utilisant la syntaxe de la tidy selection. tar_prune() permet de supprimer les cibles qui ne sont plus présentes dans le pipeline. Elle permet donc de “faire le ménage” quand on a supprimé des étapes dans _targets.R. 21.6 Avantages et limites 21.6.1 Avantages On peut voir dans cette introduction rapide que l’utilisation de targets présente de nombreux avantages : le fichier _targets.R fournit une description détaillée des étapes du projet. Cela facilite les choses quand on revient dessus après un certain temps et qu’on n’a plus tous les détails en tête, ou si on le partage avec quelqu’un. chaque cible du pipeline est définie via des fonctions, ce qui garantit une séparation et une encapsulation des différentes étapes. l’utilisation de tar_make() garantit que toutes les cibles du pipeline sont recalculées dans le bon ordre : pas de risque de lancer un script sur des données qui ne seraient pas complètement à jour parce qu’on a oublié de relancer certains recodages par exemple. tar_make() s’exécute toujours dans un environnement vide, ce qui élimine les problèmes liés à l’état de notre session en cours et garantit la reproductibilité des résultats. comme targets conserve une copie des résultats des cibles en cache, pas besoin de tout recalculer quand on relance le projet, on peut récupérer directement les résultats et savoir si ils sont à jour. tar_make() ne recalcule que les cibles qui le nécessitent, les temps de calcul et d’exécution sont optimisés. Parmi les inconvénients liés à l’utilisation de targets, on notera que le débuggage est un peu plus complexe, même si l’extension fournit plusieurs outils pour faciliter le travail. 21.6.2 Interactivité et développement du pipeline Une des limitations de targets est que le pipeline ne permet pas l’utilisation de fonctions “interactives”. Par exemple, on pourrait ajouter une étape affichant un graphique dans tar_plan() : graphique = ggplot(donnees_evo) + geom_histogram(aes(x = evo)) Ceci fonctionne, mais ne provoque pas l’affichage du graphique. Il faut faire un tar_read(graphique) pour pouvoir le visualiser. De la même manière, on ne peut pas utiliser d’interfaces interactives comme celles vues pour faciliter les recodages de variables (par exemple section 9.3.2.1). Il est donc souvent pratique de commencer à développer des transformations, calculs ou analyses de façon “interactive”, via un script classique dans lequel on importe les données nécessaires via tar_read(). Une fois qu’on obtient le résultat souhaité, on transforme ce code en une ou plusieurs fonctions et on les intègre au pipeline de targets. On notera que les documents RMarkdown s’utilisent très bien avec targets : du moment qu’on charge les données avec tar_read() ou tar_load(), ils permettent à la fois une utilisation “interactive” pendant leur écriture, et une intégration directe dans un pipeline avec tar_render() sans avoir besoin de les modifier. 21.7 Ressources Nous n’avons vu ici qu’un petit aperçu des fonctionnalités de targets, qui est une extension extrêmement riche. Celle-ci propose de nombreuses autres possibilités, comme la parallélisation des calculs, la gestion des versions de paquets via renv, la création programmatique de cibles… Le package bénéficie d’une excellente documentation en anglais. On pourra donc se référer aux sites officiels de targets et tarchetypes, mais surtout à l’ouvrage en ligne The targets R Package User Manual, très clair et très complet. Le groupe des utilisateurs de R de Lille a récemment accueilli une intervention (toujours en anglais) de Will Landau, l’auteur de targets. Celle-ci est disponible en vidéo sur YouTube. Pour les personnes habituées au développement, il s’agit d’un équivalent à GNU Make pour R.↩︎ Ces données sont stockées dans le répertoire _targets à la racine du projet.↩︎ "],["22-ressources.html", "A Ressources A.1 Aide A.2 Ouvrages, blogs, MOOCs… A.3 Extensions", " A Ressources A.1 Aide A.1.1 Aide de R et RStudio Il est possible d’obtenir à tout moment de l’aide (en anglais) sur une fonction en tapant help() avec comme argument le nom de la fonction dans la console : help(&quot;mean&quot;) Vous pouvez aussi aller dans l’onglet Help de l’interface de RStudio (dans le quart de l’écran en bas à droite) et utiliser le moteur de recherche intégré. Chaque page d’aide est très complète mais pas toujours très accessible. Elle est structurée selon différentes sections, notamment : Description : donne un résumé en une phrase de ce que fait la fonction Usage : indique la ou les manières de l’utiliser Arguments : détaille les arguments possibles et leur signification Value : indique la forme du résultat renvoyé par la fonction Details : apporte des précisions sur le fonctionnement de la fonction See Also : renvoie vers d’autres fonctions semblables ou liées, ce qui peut être très utile pour découvrir ou retrouver une fonction dont on a oublié le nom Examples : donne une série d’exemples d’utilisation Les exemples d’une page d’aide peuvent être exécutés directement dans la console avec la fonction example : example(&quot;mean&quot;) L’onglet Help de RStudio permet d’afficher mais aussi de naviguer dans les pages d’aide de R et dans d’autres ressources : Onglet Help de Rstudio Cette page permet d’accéder aux manuels officiels de R (section Manuals), qui abordent différents aspects plus ou moins techniques du langage et du logiciel, en anglais. On citera notamment les documents An Introduction to R et R Data Import/Export. Elle propose également un lien vers la FAQ officielle. A.1.2 Aide en ligne Plusieurs sites proposent une interface permettant de naviguer et rechercher dans l’aide de R et de l’ensemble des extensions existantes. On notera notamment : RDocumentation rrdr.io A.1.3 Antisèches RStudio propose plusieurs cheat sheets (antisèches) en anglais qui proposent sur deux pages une synthèse compacte de fonctions et de leur usage selon différentes thématiques, notamment : Manipulation des données avec dplyr Visualisation avec ggplot2 Export avec RMarkdown etc. La liste complète est disponible en ligne : https://www.rstudio.com/resources/cheatsheets/ Ou directement depuis RStudio, via le menu Help, puis Cheatsheets. A.1.4 Où poser des questions Outre l’aide intégrée au logiciel, il existe de nombreuses ressources en ligne, forums, listes de discussions, pour poser ses questions et échanger avec des utilisateurs et utilisatrices de R. A.1.4.1 Discussion instantanée Grrr (“pour quand votre R fait Grrr”) est un groupe Slack (plateforme de discussion instantanée) francophone dédié aux échanges et à l’entraide autour de R. Il est ouvert à tous et se veut accessible aux débutants. Vous pouvez même utiliser un pseudonyme si vous préférez. Pour rejoindre la discussion, il suffit de suivre le lien d’invitation suivant : https://join.slack.com/t/r-grrr/shared_invite/zt-46utbgb9-uvo_bg5cbuxOV~H10YUX8w A.1.4.2 Listes de discussion La liste R-soc est une liste francophone spécialement dédiée aux utilisateurs et utilisatrices de R en sciences sociales. Toutes les questions y sont les bienvenues, et les réponses sont en général assez rapides. Il suffit de s’y abonner pour pouvoir ensuite poster sa question : https://groupes.renater.fr/sympa/subscribe/r-soc La liste semin-r est la liste de discussion du groupe des utilisateurs et utilisatrices de R animé par le Muséum national d’Histoire naturelle. Elle est ouverte à tous et les questions y sont bienvenues : https://listes.mnhn.fr/wws/subscribe/semin-r Il existe aussi une liste officielle anglophone baptisée R-help. Elle est cependant à réserver aux questions les plus pointues, et dans tous les cas il est nécessaire d’avoir en tête et de respecter les bonnes pratiques avant de poster sur la liste : https://stat.ethz.ch/mailman/listinfo/r-help A.1.4.3 Sur le Web Pour les anglophones, la ressource la plus riche concernant R est certainement le site StackOverflow. Sous forme de questions/réponses, il comporte un très grand nombre d’informations sur R et les réponses y sont très rapides. Avant de poster une question il est fortement recommandé de faire une recherche sur le site, car il y a de fortes chances que celle-ci ait déjà été posée : https://stackoverflow.com/questions/tagged/r Pour les francophones, on pourra citer le forum du CIRAD, qui comporte une section questions en cours assez active. Là aussi, pensez à faire une recherche sur le forum avant de poser votre question : http://forums.cirad.fr/logiciel-R/ A.2 Ouvrages, blogs, MOOCs… A.2.1 Francophones Parmi les ressources en français, on peut citer notamment R et espace, manuel d’initiation à la programmation avec R appliqué à l’analyse de l’information géographique, librement téléchargeable en ligne. La section Contributed documentation du site officiel de R contient également des liens vers différents documents en français, plus ou moins accessibles et plus ou moins récemment mis à jour. Le pôle bioinformatique lyonnais (PBIL) propose depuis longtemps une somme très importante de documents, qui comprend des cours complets de statistiques utilisant R : http://pbil.univ-lyon1.fr/R/ Plusieurs blogs francophones autour de R sont également actifs, parmi lesquels : ElementR, le blog du groupe du même nom, qui propose de nombreuses ressources sur R en général et en particulier sur la cartographie ou l’analyse de réseaux. R-atique, blog animé par Lise Vaudor, propose régulièrement des articles intéressants et accessibles sur des méthodes d’analyse ou sur des extensions R. Enfin, le site France Université Numérique propose régulièrement des sessions de cours en ligne, parmi lesquels une Introduction à la statistique avec R et un cours sur l’Analyse des données multidimensionnelles. A.2.2 Anglophones Les ressources anglophones sont évidemment très nombreuses. On citera essentiellement l’ouvrage en ligne R for data science, très complet, et qui fournit une introduction très complète et progressive à R, et aux packages du tidyverse. Il existe également en version papier. Pour aborder des aspects beaucoup plus avancés, l’ouvrage également en ligne Advanced R, d’Hadley Wickham, est extrêmement bien et fait et très complet. On notera également l’existence du R journal, revue en ligne consacrée à R, et qui propose régulièrement des articles sur des méthodes d’analyse, des extensions, et l’actualité du langage. La plateforme R-bloggers agrège les contenus de plusieurs centaines de blogs parlant de R, très pratique pour suivre l’actualité de la communauté. Enfin, sur Twitter, les échanges autour de R sont regroupés autour du hashtag #rstats. A.3 Extensions A.3.1 Où trouver des extensions intéressantes ? Il existe plusieurs milliers d’extensions pour R, et il n’est pas toujours facile de savoir laquelle choisir pour une tâche donnée. Si un des meilleurs moyens reste le bouche à oreille, on peut aussi se reporter à la page CRAN Task view qui liste un certain nombre de domaines (classification, sciences sociales, séries temporelles…) et indique, pour chacun d’entre eux, une liste d’extensions potentiellement intéressantes accompagnées d’une courte description. On peut même installer l’ensemble des extensions d’une catégorie avec la fonction install.views(). Une autre possibilité est de consulter la page listant l’ensemble des packages existant. S’il n’est évidemment pas possible de passer en revue les milliers d’extensions une à une, on peut toujours effectuer une recherche dans la page avec des mots-clés correspondant aux fonctionnalités recherchées. Un autre site intéressant est Awesome R, une liste élaborée collaborativement des extensions les plus utiles ou les plus populaires classées par grandes catégories : manipulation des données, graphiques interactifs, etc. La page frrrenchies liste des packages pouvant être utiles pour des utilisateurs et utilisatrices francophones (géolocalisation, traitement du langage, accès à des API…), ainsi que des ressources en français. Enfin, certaines extensions fournissent des “galeries” permettant de repérer ou découvrir certains packages. C’est notamment le cas de htmlwidgets, qui propose une galerie d’extensions proposant des graphiques interactifs, ou de R Markdown. A.3.2 L’extension questionr questionr est une extension utilisée régulièrement dans ce document et comprenant quelques fonctions utiles pour l’utilisation du logiciel en sciences sociales, ainsi que différents jeux de données. Elle est développée en collaboration avec François Briatte et Joseph Larmarange. L’installation se fait soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande suivante dans la console : install.packages(&quot;questionr&quot;) Il est possible d’installer la version de développement à l’aide de la fonction install_github de l’extension remotes : remotes::install_github(&quot;juba/questionr&quot;) questionr propose à la fois des fonctions, des interfaces interactives et des jeux de données d’exemple. A.3.2.1 Fonctions et utilisation Pour plus de détails sur la liste des fonctions de l’extension et son utilisation, on pourra se reporter au site Web de l’extension, hébergé sur GitHub. L’onglet Reference liste l’ensemble des fonctions de questionr, tandis que l’onglet Articles propose une présentation des trois interfaces interactives (Addins) visant à faciliter le recodage de certaines variables. Ces interfaces sont également abordées dans la partie 9. A.3.2.2 Jeu de données hdv2003 hdv2003 est un extrait comportant 2000 individus et 20 variables provenant de l’enquête Histoire de Vie réalisée par l’INSEE en 2003. L’extrait est tiré du fichier détail mis à disposition librement (ainsi que de nombreux autres) par l’INSEE. On trouvera une documentation complète à la même adresse. Les variables retenues ont été parfois partiellement recodées. La liste des variables est la suivante : Variable Description id Identifiant (numéro de ligne) poids Variable de pondération age Âge sexe Sexe nivetud Niveau d’études atteint occup Occupation actuelle qualif Qualification de l’emploi actuel freres.soeurs Nombre total de frères, sœurs, demi-frères et demi-sœurs clso Sentiment d’appartenance à une classe sociale relig Pratique et croyance religieuse trav.imp Importance accordée au travail trav.satisf Satisfaction ou insatisfaction au travail hard.rock Écoute du Hard rock ou assimilés lecture.bd Lecture de bandes dessinées peche.chasse Pêche ou chasse pour le plaisir au cours des 12 derniers mois cuisine Cuisine pour le plaisir au cours des 12 derniers mois bricol Bricolage ou mécanique pour le plaisir au cours des 12 derniers mois cinema Cinéma au cours des 12 derniers mois sport Sport ou activité physique pour le plaisir au cours des 12 derniers mois heures.tv Nombre moyen d’heures passées à regarder la télévision par jour Comme il s’agit d’un extrait du fichier, la variable de pondération n’a en toute rigueur aucune valeur statistique. Elle a été tout de même incluse à des fins “pédagogiques”. A.3.2.3 Jeu de données rp2012 rp2012 est un jeu de données issu du recensement de la population de 2012 de l’INSEE. Il comporte une petite partie des résultats pour l’ensemble des communes de plus de 2000 habitants de France métropolitaine, soit au final 5170 communes et 60 variables. Liste de quelques variables du fichier : Variable Description commune nom de la commune code_insee Code de la commune pop_tot Population total pop_act_15p Population active de 15 ans et plus log_rp Nombre de résidences principales agric Part des agriculteurs dans la population active indep Part des artisans, commerçants et chefs d’entreprises cadres Part des cadres interm Part des professions intermédiaires empl Part des employés ouvr Part des ouvriers chom Part des chômeurs etud Part des étudiants dipl_sup Part des diplômés du supérieur dipl_aucun Part des personnes sans diplôme proprio Part des propriétaires parmi les résidences principales hlm Part des logements HLM parmi les résidences principales locataire Part des locataires parmi les résidences principales maison Part des maisons parmi les résidences principales "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
