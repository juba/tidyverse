# Programmer avec R

Nous avons vu dans la partie précédente comment écrire nos propres fonctions. Pour pouvoir aller plus loin nous allons rappeler ou aborder ici de nouveaux types de données et éléments du langage qui permettent de programmer des actions un peu plus complexes.

Les notions décrites dans cette partie s'appliquent pour le développement de fonctions, mais peuvent aussi être mises en oeuvre à tout moment dans un script.

On commence par charger les jeux de données d'exemple utilisés par la suite :

```{r}
library(questionr)
data(hdv2003)
data(rp2012)
```


## Structures de données

R propose de nombreuses structures de données différentes, et les extensions peuvent en implémenter de nouvelles. Cette section présente les trois structures les plus utilisées : les vecteurs atomiques, les listes et les tableaux de données.

### Vecteurs atomiques

Les vecteurs atomiques sont des structures qui regroupent plusieurs éléments qui doivent tous être du même type. Ils ont déjà été évoqués section \@ref(vecteurs).

#### Création d'un vecteur

On construit un vecteur notamment avec l'opérateur `c`.

```{r}
x <- c(1, 3, 8)
```

On peut nommer les éléments d'un vecteur lors de sa création, ou avec la fonction `names`.

```{r}
x <- c(e1 = 1, e2 = 3, e3 = 8)
x
```

On peut utiliser `names()` pour récupérer les noms des éléments d'un vecteur.

```{r}
names(x)
```

On peut aussi utiliser `names()` pour créer ou modifier les noms d'un vecteur existant.

```{r}
names(x) <- c("foo", "bar", "baz")
x
```


#### Types de vecteurs

On peut déterminer le type d'un vecteur avec l'instruction `typeof`.

```{r}
x <- c(1, 3, 8)
typeof(x)
y <- c("foo", "bar", "baz")
typeof(y)
z <- c(TRUE, FALSE, FALSE)
typeof(z)
```

Parmi les principaux types de données on notera^[Il en existe d'autres, comme `complex` ou `raw`, mais qui sont moins fréquemment utilisés.].

- les chaîne de caractères (`character`)
- les nombres flottants (`double`)
- les nombres entiers (`int`)
- les booléens, ou valeurs logiques (`logical`)

Les `double` et les `int` sont des vecteurs de la famille `numeric`. Par défaut les nombres sont considérés comme des nombres flottants (des nombres décimaux avec une virgule) : pour les définir explicitement comme nombres entiers on peut leur ajouter le suffixe `L`.

```{r}
x <- c(1L, 3L, 8L)
typeof(x)
```

Tous les éléments d'un vecteur doivent être du même type. Si ça n'est pas le cas, les éléments seront convertis au type le plus "général", sachant que les `character` sont plus généraux que les `numeric`, qui sont eux-mêmes plus généraux que les `logical`.

```{r}
c(1, "foo")
c(TRUE, 2)
c(FALSE, "bar")
```

La valeur `NA`, comme on l'a vu, permet d'indiquer une valeur manquante (`Not Available`). Il existe en réalité plusieurs types de `NA`, même si cette distinction est la plupart du temps transparente pour l'utilisateur. On a ainsi notamment des valeur `NA_integer_`, `NA_character_`, `NA_real_`.

```{r}
c(1, 2, NA_character_)
```

Les vecteurs de type `factor` sont en fait basés sur des vecteurs de type entiers, et les vecteurs de type date sur des vecteurs numériques.

```{r}
typeof(factor(c("a", "b")))
typeof(Sys.Date())
```

#### Sélection et modification

On a vu section \@ref(vecteurs) que l'opérateur `[]` peut être utilisé pour sélectionner ou modifier des éléments d'un vecteur. Cet opérateur peut comporter :

- des nombres (qui sélectionnent par position)
- des chaînes de caractères (qui sélectionnent par nom)
- une condition ou des booléens (qui sélectionnent les éléments correspondant à `TRUE`)

```{r}
x <- c(e1 = 1, e2 = 2, e3 = 8, e4 = 12)
x[c(1, 4)]
x[c("e2", "e4")]
x[x < 10]
```

Utilisé conjointement avec l'opérateur d'assignation `<-`, l'opérateur `[]` permet aussi de remplacer certains éléments d'un vecteur.

```{r}
x[1] <- -1000
x[x > 10] <- NA
x
```

Utilisé sans arguments, `[]` se contente de renvoyer le vecteur. Mais couplé à une assignation, il remplace chacun des éléments du vecteur plutôt que le vecteur lui-même.

```{r}
x[] <- 3
x
```

### Listes

Les listes sont une généralisation des vecteurs : elles regroupent également plusieurs éléments, mais ceux-ci peuvent être de n'importe quel type, y compris des objets complexes. Une liste peut donc contenir elle-même des vecteurs, des listes, des tablaux de données, des fonctions, des graphiques `ggplot2` stockés dans un objet, etc.

#### Création et manipulation

On construit une liste avec la fonction `list`.

```{r}
l <- list(1, "foo", c("Pomme", "Citron"))
l
```

La manière dont R affiche le contenu d'une liste dans la console diffère de celle des vecteurs. Dans le cas d'une liste ses éléments sont affichés les uns en dessous des autres, et séparés par leur indice numérique entre une paire de crochets.

Comme pour les vecteurs, on peut nommer les éléments à la création de la liste ou avec `names` :

```{r}
l <- list(nombre = 1, char = "foo", vecteur = c("Pomme", "Citron"))
l
```

Dans ce cas l'affichage de la liste dans la console montre ces noms plutôt que les indices numériques.

Si les noms comportent des caractères spéciaux comme des espaces, il faut les entourer de quotes inverses.

```{r}
l <- list(`Élément 1` = 1, `Élément 2` = "foo")
l
```

L'affichage des listes peut vite devenir illisible quand la liste est plus complexe.

```{r}
l <- list(
    l2 = list(x = 1:10, y = c("Pomme", "Citron")), 
    df = data.frame(v1 = 2:5, v2 = LETTERS[2:5]), 
    y = runif(20)
)
l
```

Dans ce cas la fonction `str` peut être utile pour afficher de manière plus compacte la structure de la liste.

```{r}
str(l)
```

Attention, si on souhaite ajouter un nouvel élément à une liste, il ne faut pas utiliser à nouveau `list`, car dans ce cas notre liste de départ est vue comme une "sous-liste" :

```{r}
l2 <- list(l, nouveau = 100)
str(l2)
```

Il faut à la place utiliser `c`, comme pour les vecteurs :

```{r}
l3 <- c(l, nouveau = 100)
str(l3)
```

`c` permet aussi de "concaténer" deux listes existantes en une seule :

```{r}
l1 <- list(a = 1, b = 2)
l2 <- list(x = 3, y = 4)
c(l1, l2)
```


#### Sélection et modification

À la différence des vecteurs, il y a deux opérateurs différents qui permettent de sélectionner ou modifier les éléments d'une liste : les crochets simples `[]` et les crochets doubles `[[]]`. La différence entre les deux opérateurs est souvent source de confusion.

Partons de la liste suivante :

```{r}
l <- list(1:5, "foo", c("Pomme", "Citron"))
l
```

Si on utilise les crochets simples pour sélectionner le premier élément de cette liste, on obtient le résultat suivant :

```{r}
l[1]
```

On notera que le résultat est une liste à un seul élément.

Si on utilise les crochets doubles :

```{r}
l[[1]]
```

On obtient cette fois-ci non pas une liste à un seul élément, mais uniquement le premier élément de la liste de départ "tel quel".

```{block, type='rmdimportant'}
La différence est importante, mais pas toujours facile à retenir. On peut éventuellement utiliser deux petites astuces mnémotechniques :

- si une liste est un train composé de plusieurs wagons, `[1]` retourne le premier wagon du train, tandis que `[[1]]` renvoie le contenu du premier wagon.
- une alternative est de considérer que `[[]]` va chercher "plus profondément" que `[]`.
```

Un point important est que si on passe plusieurs éléments à `[[]]`, la sélection se fait d'une manière récursive pas très intuitive et rarement utile. Il est donc conseillé de **toujours utiliser `[[]]` avec un seul argument**, et d'utiliser `[]` si on souhaite sélectionner plusieurs éléments d'une liste.

```{r}
l[c(1, 2)]
```

Si la liste est nommée, on peut sélectionner des éléments par noms avec les deux opérateurs.

```{r}
l <- list(nombre = 1, char = "foo", vecteur = c("Pomme", "Citron"))
l[c("nombre", "char")]
```

```{r}
l[["vecteur"]]
```

On peut aussi utiliser l'opérateur `$`, qui équivaut à `[[]]` :

```{r}
l$vecteur
```

Là aussi, si le nom comporte des caractères spéciaux on doit l'entourer avec des quotes inverses.

```{r}
l <- list(`Élément 1` = 1, `Élément 2` = "foo")
l$`Élément 1`
```

Comme pour les vecteurs, on peut utiliser les opérateurs de sélection pour modifier des éléments. Si on n'en modifie qu'un seul, `[]` et `[[]]` sont équivalents.

```{r}
l <- list(nombre = 1:5, char = "foo", vecteur = c("Pomme", "Citron"))
l[1] <- "first"
l[[2]] <- "second"
l
```

Par contre si on souhaite modifier plusieurs éléments, il faut utiliser les crochets simples.

```{r}
l <- list(nombre = 1:5, char = "foo", vecteur = c("Pomme", "Citron"))
l[c(1, 3)] <- 0
l
```

```{block type='rmdimportant'}
Comme pour la sélection, attention à ne pas utiliser les crochets doubles pour modifier plusieurs éléments d'une liste. Ceux-ci ne génèreront pas forcément d'erreur mais n'auront pas le comportement attendu.
```

Enfin, si on souhaite supprimer un ou plusieurs éléments d'une liste, il faut leur attribuer la valeur `NULL`^[Si on veut ajouter un élément `NULL` à une liste, il faut utiliser les crochets simples avec la syntaxe `l["foo"] <- list(NULL)`.].

```{r}
l <- list(nombre = 1:5, char = "foo", vecteur = c("Pomme", "Citron"))
l$char <- NULL
l
l[3] <- list(NULL)
l
```


#### Utilisation

En tant que généralisation des vecteurs atomiques, les listes sont utiles dès qu'on souhaite regrouper des éléments complexes ou hétérogènes.

On les utilisera par exemple pour retourner plusieurs résultats différents depuis une fonction.

```{r}
indicateurs <- function(x) {
    list(moyenne = mean(x), variance = var(x))
}

x <- 1:10
res <- indicateurs(x)
res$moyenne
```

On peut également utiliser les listes pour stocker une série d'objets complexes et leur appliquer des fonctions, comme on le verra dans la section \@ref(purrr).

Pour donner un aperçu, l'exemple fictif suivant récupère les noms de tous les fichiers CSV du répertoire courant et les importent tous dans une liste à l'aide de `purrr::map()` et de `read_csv()`. 
```{r eval=FALSE}
files <- list.files(pattern = "*.csv")
dfs <- purrr::map(files, read_csv)
```

On pourra ensuite utiliser cette liste de tableaux pour leur appliquer des transformations ou les fusionner.


### *data frame* et *tibble*

On a déjà abordé les tableaux de données en manipulant des *data frames* ou des *tibbles*. Les seconds sont une variante des premiers, les différences entre les deux ayant été abordées section \@ref(tibbles). 

Un tableau de données est en fait une liste nommée de vecteurs avec une contrainte spécifique : ces vecteurs doivent tous être de même longueur, ce qui garantit le format "tabulaire" des données.

#### Sélection 

On a déjà vu dans les parties précédentes plusieurs manières de sélectionner des éléments dans un tableau de données. 

On a ainsi vu qu'on peut sélectionner une colonne via l'opérateur `$`.

```{r}
df <- data.frame(
    fruit = c("Pomme", "Pomme", "Citron"),
    poids = c(154, 167, 92),
    couleur = c("vert", "vert", "jaune")
)

df$fruit
```

Attention, si votre tableau de données est un *data frame*, R fera du *partial matching* sur le nom donné à `$`, ce qui n'est pas toujours un comportement souhaitable (les *tibbles* n'ont pas ce comportement).

```{r}
df$poi
```
```{r results="hide"}
as_tibble(df)$poi
```

Comme un tableau de données est en réalité une liste de colonnes, on peut utiliser l'opérateur `[[]]` pour sélectionner l'une de ces colonnes, par position ou par nom^[Attention, comme pour les listes, à ne pas utiliser `[[]]` avec un argument de longueur supérieur à 1, car cela mène soit à des erreurs soit à des résultats contre-intuitifs.].

```{r}
df[[2]]
df[["couleur"]]
```

Comme pour les listes, on peut aussi utiliser `[]` pour sélectionner des colonnes. La différence avec `[[]]` est que lorsqu'on sélectionne une unique colonne le résultat est un tableau à une colonne, et non un vecteur.

```{r}
df[["couleur"]]
```

```{r}
df["couleur"]
```

On peut également utiliser l'opérateur `[]` pour sélectionner à la fois des lignes et des colonnes, en lui passant deux arguments séparés par une virgule : d'abord la sélection des lignes puis celle des colonnes. Dans les deux cas on peut sélectionner par position, nom ou condition. Si on laisse un argument vide, on sélectionne l'intégralité des lignes ou des colonnes.

```{r}
df[c(1, 3), "poids"]
df[df$poids > 150, ]

library(stringr)
df[, str_detect(names(df), "o")]
```

```{block, type='rmdimportant'}
Attention, le comportement de `[,]` est différent entre les *tibbles* et les *data frame* lorsqu'on ne sélectionne qu'une seule colonne. Dans le cas d'un *data frame*, le résultat est un vecteur, dans le cas d'un *tibble* le résultat est un tableau à une colonne. Pour les *data frame* on peut forcer le résultat à être un tableau en ajoutant un troisième argument `drop = FALSE` : `df[, "fruit", drop = FALSE]`.
```

Enfin, on peut utiliser `[[]]` et `[]` avec l'opérateur d'assignation `<-` pour modifier tout ou partie d'un tableau de données.

```{r}
df[["poids_kg"]] <- df$poids / 1000
df[df$fruit == "Citron", "fruit"] <- "Agrume"
df
```

Enfin, `[]` utilisé sans arguments permet de sélectionner et de modifier, l'ensemble des valeurs du tableau. Ainsi les deux instructions suivantes ont des effets très différents.

```{r}
df[] <- "a"
df
```

```{r}
df <- "a"
df
```

L'utilisation de `[]` sur un tableau de données peut sembler redondante, et moins pratique, que l'utilisation des verbes de `dplyr`. Ils peuvent cependant être utiles lorsqu'on souhaite éviter les complications liées à l'utilisation du tidyverse à l'intérieur de fonctions, comme indiqué section \@ref(programmer-tidyverse).


#### Colonnes-listes et colonnes-tableaux

TODO : Ajouter ou non ?


## `if`, `else`, `switch` : exécuter du code sous certaines conditions

### `if`

L'instruction `if` est fondamentale puisqu'elle permet de n'exécuter du code que si une condition est remplie.

![](figures/structure_if.svg)

`if` prend une condition (entre parenthèses) puis un bloc de code (entre accolades) qui n'est exécuté que si la condition est vraie.

Par exemple, dans le code suivant, le message `Bonjour !` ne sera affiché que si la valeur de l'objet `prenom` vaut `"Pierre-Edmond"` :

Prenons tout de suite un exemple :

```{r}
prenom <- "Pierre-Edmond"
if (prenom == "Pierre-Edmond") {
    message("Bonjour !")
}
```

On peut utiliser ce code pour créer une passionnante fonction qui a pour objectif de ne dire bonjour qu'aux personnes qui s'appellent Pierre-Edmond :

```{r}
bonjour_pierre_edmond <- function(prenom) {
    if (prenom == "Pierre-Edmond") {
        message("Bonjour !")
    }
}
```
```{r}
bonjour_pierre_edmond("Pierre-Edmond")
```


```{r}
bonjour_pierre_edmond("Valérie-Charlotte")
```

Une autre utilisation possible (et un peu plus utile) dans le cadre d'une fonction est de n'exécuter du code que si un argument a été passé.

```{r}
moyenne <- function(x, arrondir = TRUE) {
    res <- mean(x)
    if (arrondir) {
        res <- round(res)
    }
    res
}

v <- c(1.4, 2.3, 8.9)
moyenne(v)
moyenne(v, arrondir = FALSE)
```

### `if` / `else`

On utilise souvent `if` en conjonction avec l'instruction `else`. `else` précède un autre bloc de code R qui ne s'exécute que si la condition donnée à `if` est fausse :

![](figures/structure_if_else.svg)

On peut ainsi utiliser `if` / `else` pour une nouvelle fonction fort utile qui nous évitera bien des désagréments météorologiques :

```{r}
conseil_vestimentaire <- function(temperature) {
    if (temperature > 15) {
        message("La polaire n'est pas forcément nécessaire.")
    } else {
        message("Vous devriez prendre une petite laine.")
    }
}

conseil_vestimentaire(-5)
```

Plus utile, on peut l'utiliser pour effectuer deux actions différentes en fonction de la valeur d'un paramètre. La fonction suivante génère deux graphiques différents selon le type du vecteur passé en argument :

```{r}
graph_var <- function(x) {
    if (is.character(x)) {
        barplot(table(x))
    } else {
        hist(x)
    }
}

graph_var(c("Pomme", "Pomme", "Citron"))
graph_var(c(1,5,10,3,1,4))
```

On peut évidemment passer des conditions plus complexes. Dans notre fonction, le test `is.character(x)` échoue si `x` est un facteur, alors qu'on souhaiterait quand même réaliser un `barplot`. On peut donc compléter la condition du `if` :

```{r}
graph_var <- function(x) {
    if (is.character(x) || is.factor(x)) {
        barplot(table(x))
    } else {
        hist(x)
    }
}

graph_var(factor(c("Pomme", "Pomme", "Citron")))
```

### `if` / `else if` / `else`

Une autre possibilité est de compléter le `if` ... `else` par des blocs supplémentaires `else if` qui permettent d'ajouter de nouvelles conditions. Dès qu'une condition est vraie, le bloc de code correspondant est exécuté. Le dernier bloc `else` est exécuté si aucune des conditions n'est vraie.

On peut donc améliorer encore notre fonction `graph_var` pour tester les différents types explicitement et afficher un message si aucun type géré n'a été reconnu.

```{r}
graph_var <- function(x) {
    if (is.character(x) || is.factor(x)) {
        barplot(table(x))
    } else if (is.numeric(x)) {
        hist(x)
    } else {
        message("Le type de x n'est pas géré par la fonction")
    }
}

graph_var(c(TRUE, FALSE, TRUE))
```

Attention, seule le bloc de la première condition vraie est exécuté, l'ordre des conditions est donc important. Dans l'exemple suivant, le second bloc n'est jamais exécuté et donc le second message jamais affiché.

```{r}
test_x <- function(x) {
    if (x < 100) {
        message("x est inférieur à 100")
    } else if (x < 10) {
        message("x est inférieur à 10")
    }
}

test_x(5)
```

Il est donc important d'ordonner les conditions de la plus spécifique à la plus générale.

### Différence entre `if` / `else` et `ifelse`

Une source fréquente de confusion concerne la différence entre les instructions `if` / `else` et la fonction `ifelse` de R base (ou son équivalent `if_else` de `dplyr`, voir section \@ref(if_else)). Les deux sont pourtant très différentes :

- `if` / `else` s'utilisent quand on teste une seule condition et qu'on veut exécuter des blocs de code différent
- `ifelse` et `if_else` appliquent un test à un vecteur et retournent un vecteur

Premier cas de figure : on a une seule valeur `x` et on veut afficher un message différent selon si celle-ci est inférieure ou supérieure à 10. Dans ce cas on utilise `if` / `else` :

```{r}
x <- 5

if (x >= 5) {
    message(">=5")
} else {
    message("<5")
}
```

Deuxième cas de figure : `x` est un vecteur et on souhaite recoder chacune de ses valeurs selon le même critère que ci-dessus. Dans ce cas on utilise `ifelse` ou `if_else` :

```{r}
x <- 1:10

ifelse(x >= 5, ">=5", "<5")
```

Une erreur fréquente, notamment quand on est dans une fonction, est de passer à `if` une condition appliquée à un vecteur. Dans ce cas R a la bonne idée de mettre un message d'avertissement :

```{r}
x <- 1:10

if (x >= 5) {
    message(">=5")
}
```


## Contrôle de l'exécution et gestion des erreurs

L'instruction `if` est souvent utilisée dans des fonctions pour valider les valeurs passées en arguments ou, plus généralement contrôler que l'exécution du code se déroule comme prévu.

### Utilisation de `return` pour sortir de la fonction

Une première utilisation peut être d'utiliser un `return` pour interrompre l'exécution de la fonction et retourner un résultat. On a en effet vu section \@ref(resfunc) que dès que R rencontre un `return` dans une fonction, il interrompt immédiatement l'exécution de celle-ci.

La fonction suivante retourne la longueur du mot le plus long dans un vecteur de chaînes de caractères. On ajoute donc un test qui retourne `NA` dans le cas où le vecteur passé en argument serait d'un type différent.

```{r}
mot_le_plus_long <- function(x) {
    if (!is.character(x)) {
        return(NA)
    }
    max(nchar(x))
}

mot_le_plus_long(c("Pomme", "Citron"))
mot_le_plus_long(1:5)
```


### `warning`

La fonction `warning` fonctionne comme `message` mais permet d'afficher un avertissement. Celui-ci est affiché de manière différente dans la console, de manière à attirer l'attention sur un point particulier. Il indique également la fonction qui a déclenché l'avertissement ce qui peut être utile quand on exécute toute une série d'instructions d'un seul coup.

Ainsi, dans la fonction précédente, on peut ajouter un avertissement dans le cas où le vecteur passé en argument n'est pas de type `character`.

```{r}
mot_le_plus_long <- function(x) {
    if (!is.character(x)) {
        warning("x n'est pas de type character, le résultat vaut NA.")
        return(NA)
    }
    max(nchar(x))
}

mot_le_plus_long(1:5)
```

### `stop` et `stopifnot`

`stop` fonctionne comme `warning` mais déclenche une erreur qui interrompt totalement l'exécution du code. Quand R le rencontre dans une fonction, il sort immédiatement de la fonction, ne retourne aucun résultat, et il interrompt également toutes les autres instructions en attente d'exécution.

On peut ainsi considérer, toujours dans la fonction `mot_le_plus_long`, que le fait de ne pas fournir en argument un vecteur de type character est suffisamment "grave" pour interrompre l'exécution en cours et laisser la personne qui utilise la fonction régler le problème.

```{r error = TRUE}
mot_le_plus_long <- function(x) {
    if (!is.character(x)) {
        stop("x doit être de type character.")
    }
    max(nchar(x))
}

mot_le_plus_long(1:5)
mot_le_plus_long(c("Pomme", "Citron"))
```

Dans ce cas on remarque que le deuxième appel `mot_le_plus_long(c("Pomme", "Citron"))` n'est pas exécuté : R a tout interrompu dès qu'il a rencontré l'instruction `stop()`.

```{block type="rmdnote"}
Savoir si un "problème" doit être traité comme un avertissement ou comme une erreur relève du choix de la personne qui développe la fonction : chaque cas est particulier.
```

`stopifnot` est une syntaxe alternative un peu plus compacte qui combien test et message d'erreur. On lui passe en premier argument une condition, et en deuxième argument un message à afficher si la condition est fausse.

On peut donc réécrire notre fonction `mot_le_plus_long` ci-dessus de la manière suivante :

```{r error = TRUE}
mot_le_plus_long <- function(x) {
    stopifnot(is.character(x), "x doit être de type character.")
    max(nchar(x))
}

mot_le_plus_long(1:5)

```

### Tester la présence d'un argument

Il y a deux méthodes pour tester si l'argument d'une fonction a été défini lors de l'appel de cette fonction. La plus courante est de donner à cet argument une valeur par défaut, le plus souvent `NULL`, et de tester cette valeur.

Soit une fonction qui génère un graphique avec un argument `titre` qui permet de définir son titre. On peut mettre par défaut cet argument à `NULL` et ajouter un titre par défaut si la personne qui l'utilise n'en a pas fourni.

```{r}
histo <- function(x, titre = NULL) {
    if (is.null(titre)) {
        titre <- paste("Moyenne : ", mean(x))
    }
    hist(x, main = titre)
}

histo(c(1, 15, 8, 10, 12, 18, 8, 4))

histo(c(1, 15, 8, 10, 12, 18, 8, 4), titre = "Quel bel histogramme")
```

Quand on ne souhaite pas mettre de valeur par défaut, on peut tester l'absence de l'argument à l'aide de la fonction `missing()`.

```{r error = TRUE}
moyenne_arrondie <- function(x) {
    if (missing(x)) stop("x est manquant")
    round(mean(x))
}

moyenne_arrondie()
```

En dehors de certains cas particuliers on ajoute rarement ce genre de tests dans des fonctions, car les arguments sans valeur par défaut sont le plus souvent des valeurs "obligatoires" qui génèrent de toutes manières une erreur quand elles ne sont pas définies :

```{r error=TRUE}
moyenne_arrondie <- function(x) {
    round(mean(x))
}

moyenne_arrondie()
```


## `for` et `while` : répéter des instructions dans une boucle

Un autre type d'instructions de R permettent de répéter du code plusieurs fois, soit en fonction d'une condition soit selon les éléments d'un vecteur. En complément, on verra également dans la section \@ref(purrr) d'autres fonctions tirées de l'extension `purrr` qui permettent d'appliquer une fonction en itérant sur les éléments de plusieurs objets.

### `for`

Le premier type de boucle est défini par l'instruction `for`. Sa structure est la suivante :

![](figures/structure_for.svg)

Le principe est assez simple : on fournit à `for` entre parenthèses une expression du type `item in vecteur`, puis un bloc de code entre accolades. `for` va exécuter le bloc de codes pour chacune des valeurs de `vecteur`, et affectera tour à tour à `item` la valeur courante de `vecteur`.

Prenons tout de suite un exemple pour mieux comprendre :

```{r}
for (item in 1:5) {
    print(item)
}
```

Ici notre vecteur "source" est constitué des entiers de 1 à 5. `for` va donc exécuter l'instruction `print(i)` 5 fois, en remplaçant la première fois `i` par 1, la seconde fois par 2, etc.

On peut itérer sur tout type d'objet, et le nom `i` peut être remplacé par ce que l'on souhaite :

```{r}
for (prenom in c("Pierre-Edmond", "Faustine-Charlotte")) {
    print(paste("Bonjour", prenom, "!"))
}
```

Exemple un peu plus complexe, la fonction suivante prend en entrée un data frame et un vecteur de noms de variables, et affiche le résultat de `summary` pour chacune d'entre elles.

```{r}
summaries <- function(d, vars) {
    for (var in vars) {
        message("--- ", var, " ---")
        print(summary(d[, var]))
    }
}

summaries(hdv2003, c("sexe", "age", "heures.tv"))
```

Un "pattern" relativement fréquent est de vouloir itérer sur les éléments d'un vecteur par leur position. Il est du coup assez naturel d'utiliser quelque chose comme `for (i in 1:length(x))`. Il est cependant préférable dans ces cas-là d'utiliser la fonction dédiée `seq_along(x)`^[L'intérêt de `seq_along(x)` est notamment qu'elle n'essaie pas d'exécuter le bloc de code si jamais `x` est de longueur nulle. *Cf.* des explications supplémentaires dans [Advanced R](https://adv-r.hadley.nz/control-flow.html#common-pitfalls)].

Dans l'exemple suivant, la fonction `affiche_dimensions` prend en entrée une liste de data frames et affiche leur nombre de lignes et de colonnes.

```{r}
affiche_dimensions <- function(dfs) {
    for (i in seq_along(dfs)) {
        name <- names(dfs)[[i]]
        df <- dfs[[i]]
        message("Dimensions de ", name, " : ", nrow(df), "x", ncol(df))
    }
}

l <- list(
    hdv = hdv2003,
    rp = rp2012
)
affiche_dimensions(l)
```

### `while`

`while` prend en argument une condition et exécute le bloc de code qui suit tant que la condition est vraie :

![](figures/structure_while.svg)

Par exemple, la fonction suivante simule un tirage à pile ou face. Elle s'exécute et affiche le résultat tant qu'on obtient "Pile" (et interrompt la boucle au premier "Face") :

```{r}
resultat <- ""
while (resultat != "Face") {
    tirage <- runif(1)
    if (tirage <= 0.5) {
        resultat <- "Pile"
    } else {
        resultat <- "Face"
    }
    print(resultat)
}
```

À noter qu'on peut tout à fait reproduire une boucle `for` à l'aide d'une boucle `while` :

```{r}
x <- 1:5
i <- 0
while (i < length(x)) {
    i <- i + 1
    print(i)
}
```


### `break` et `next`

Il peut arriver qu'on souhaite sortir d'une boucle avant d'avoir terminé toutes ses itérations, notamment dans le cas d'une boucle `for`. C'est ce que permet de faire l'instruction `break`, qui interrompt la boucle et continue à l'instruction suivante.

Par exemple, le code suivant permet de trouver la première valeur d'un vecteur supérieure à un certain seuil. 

```{r}
x <- c(1, 25, 4, 110, 41)
seuil <- 100

for (item in x) {
     if (item > seuil) break
}

print(item)
```

L'instruction `next` a un comportement assez similaire mais plutôt que de sortir de la boucle, elle passe à l'itération suivante.

Dans l'exemple suivant, on réécrit la fonction `summaries` pour prendre en compte le fait qu'un nom de variable non existante puisse être passé en argument. Dans ce cas on passe directement à la variable suivante.

```{r}
summaries <- function(d, vars) {
    for (var in vars) {
        if (!(var %in% names(d))) {
            next
        }
        message("--- ", var, " ---")
        print(summary(d[, var]))
    }
}

summaries(hdv2003, c("sexe", "diplodocus", "age", "heures.tv"))
```

### Quand (ne pas) utiliser des boucles

Le mécanisme des boucles, assez intuitif, peut rapidement être utilisé pour beaucoup d'opérations. Il y a cependant sous R des alternatives souvent plus rapides, qu'il est préférable de privilégier.

Avant tout, de nombreuses fonctions R sont "vectorisées" et s'appliquent directement à tous les éléments d'un vecteur. Dans le cas où une fonction vectorisée existe déjà, elle propose en général une syntaxe plus compacte et une exécution plus rapide.

Pour prendre un exemple caricatural, si on souhaite ajouter 10 à chaque élément d'un vecteur on évitera de faire :

```{r, eval=FALSE}
for (i in seq_along(x)) {
    x[i] <- x[i] + 10
}
```

Et on se contentera d'un beaucoup plus simple `x + 10`.

De la même manière, la boucle utilisée précédemment pour trouver la première valeur d'un vecteur supérieure à un certain seuil :

```{r}
x <- c(1, NA, 4, 110, NA)
y <- c(20, 30, 40, 50, 60)

for (i in seq_along(x)) {
    if (is.na(x[i])) x[i] <- y[i]
}

print(x)
```

Peut être remplacée par `x[is.na(x)] <- y[is.na(x)]`.

Une boucle peut être particulièrement lente lorsqu'on l'utilise pour créer un nouveau vecteur ou data frame. Dans l'exemple suivant, on utilise une boucle pour générér une liste de vecteurs de nombres aléatoires dont la longueur est stockée dans [x]. 

```{r}
x <- c(15, 25, 10, 8)
l <- list()

for (i in seq_along(x)) {
    l[[i]] <- runif(x[i])
}
```

Avec cette syntaxe, à chaque ajout d'élément à `l` R procède à une copie de la totalité de `l`. Si le coût en termes de performance est négligeable avec seulement quelques éléments, il peut vite devenir très important.

L'alternative ici, si on veut utiliser une boucle `for`, est de "pré-allouer" l'espace mémoire nécessaire à notre liste avant de la modifier ensuite dans la boucle. On évite ainsi la copie de `l` à chaque itération. Cette préallocation se fait via la fonction `vector`.

```{r}
x <- c(15, 25, 10, 8)
l <- vector("list", length(x))

for (i in seq_along(x)) {
    l[[i]] <- runif(x[i])
}
```

On verra cependant dans la section \@ref(purrr) que des fonctions permettent de faire ce genre de choses de manière beaucoup plus simple, ici par exemple avec un simple `purrr::map(x, runif)`.

Au final, entre les fonctions vectorisées existantes et les possibilités fournies par `purrr` ou les fonctions de type `apply` de base R, il est assez rare de devoir utiliser une boucle directement dans R.

Pour autant, il ne faut pas non plus tomber dans l'excès inverse et considérer que tout usage de `for` ou `while` doit être évité : ces fonctions sont parfaitement justifiées dans de nombreux cas de figure, et si vous trouvez une solution qui fonctionne de manière efficace avec une boucle `for`, il n'est pas toujours utile de chercher à la remplacer à tout prix.


## Ressources


https://r4ds.had.co.nz/vectors.html

https://adv-r.hadley.nz/vectors-chap.html

https://r4ds.had.co.nz/functions.html#conditional-execution

https://r4ds.had.co.nz/iteration.html

https://thinkr.fr/comment-faire-des-boucles-en-r-ou-pas/

https://privefl.github.io/blog/why-loops-are-slow-in-r/

## Exercices

