# Débuggage et performance {#debug-perf}

```{block type='rmdimportant'}
Cette partie est encore en cours de rédaction.
```

## Débugguer une fonction

Lorsqu'on commence à écrire des fonctions un peu complexes, avec des `if`, des `for`, etc., arrive forcément un moment où ça ne fonctionne pas comme on souhaiterait et où on ne comprend pas pourquoi. Bref, il y a un bug.

Trouver la cause d'un bug n'est pas toujours évident, mais heureusement il existe plusieurs outils permettant de faciliter les choses.

On commence par charger les extensions et les jeux de données dont on aura besoin par la suite.

```{r message=FALSE}
library(tidyverse)
library(questionr)
data(hdv2003)
data(starwars)
```

### print()

L'outil le plus simple, parfois décrié mais souvent efficace, est de rajouter un simple `print()` dans le code de notre fonction pour examiner le contenu d'un objet à un moment donné.

Prenons un premier exemple. La fonction suivante prend en argument un tableau de données et un nom de variable, et retourne la moyenne et l'écart-type de cette variable.

```{r}
indicateurs <- function(df, var) {
    valeurs <- df[, var]
    if (!is.numeric(valeurs)) return(NA)
    c(moyenne = mean(valeurs), sd = sd(valeurs))
}
```

On teste notre fonction sur une variable du jeu de données `mtcars` inclus dans R base. Tout semble fonctionner.

```{r}
indicateurs(mtcars, "mpg")
```

On teste à nouveau, cette fois sur une variable du jeu de données `starwars` de `dplyr`.

```{r}
indicateurs(starwars, "height")
```

On obtient `NA` en résultat, alors que notre variable `height` est bien numérique, on devrait donc obtenir un vecteur avec la moyenne et l'écart-type. Comment expliquer ce résultat ?

Comme on n'a pas d'explication immédiate juste en relisant le code de notre fonction, on va ajouter temporairement une instruction `print()` qui va afficher le contenu de `valeurs` avant le `if`.

```{r}
indicateurs <- function(df, var) {
    valeurs <- df[, var]
    print(valeurs)
    if (!is.numeric(valeurs)) return(NA)
    c(moyenne = mean(valeurs), sd = sd(valeurs))
}
```

On teste à nouveau sur `starwars` :

```{r}
indicateurs(starwars, "height")
```

Le `print()` nous indique que `valeurs` n'est pas un vecteur mais un tableau de données à une seule colonne. Or dans ce cas, le test `is.numeric`, qui est sensé s'appliquer à un vecteur atomique, renvoie `FALSE` :

```{r}
is.numeric(starwars[, "height"])
```

C'est donc la raison pour laquelle on obtient le résultat final `NA`.

Certes, mais alors pourquoi cela fonctionne-t-il dans notre exemple avec `mtcars` ? 

```{r}
indicateurs(mtcars, "mpg")
```

Ah ! Dans ce cas là `valeurs` est bien un vecteur, et on obtient donc le résultat attendu. Pourquoi cette différence ? On est en fait tombé sur une source d'erreur relativement fréquente qui est la différence de comportement, mentionnée section \@ref(df-sel), entre les *data frames* et les *tibbles* : lorsqu'on sélectionne une seule colonne avec l'opérateur `[,]`, un *data frame* retourne un vecteur tandis qu'un *tibble* retourne un tableau à une colonne.

Comment résoudre ce problème ? Il y a différentes manières, mais la plus simple est sans doute de remplacer `[,]` par `[[]]`, qui lui a le même comportement dans les deux cas. On peut donc modifier notre fonction (en n'oubliant pas d'enlever le `print()`) et vérifier que ça fonctionne désormais.

```{r}
indicateurs <- function(df, var) {
    valeurs <- df[[var]]
     if (!is.numeric(valeurs)) return(NA)
    c(moyenne = mean(valeurs), sd = sd(valeurs))
}

indicateurs(mtcars, "mpg")
indicateurs(starwars, "height")
```


```{block type='rmdimportant'}
Quand on ajoute des `print()` pour essayer d'identifier un problème, il faut bien penser à les supprimer une fois ce problème résolu, sinon on risque de se retrouver avec des messages "parasites" dans la console.
```


### Localiser une erreur

`print()` peut aussi être utile pour savoir à quel moment une erreur se produit, notamment lorsqu'on utilise une boucle.

Dans l'exemple suivant, on crée une fonction `min_freq_values()` qui prend en argument un tableau de données `df` et un effectif `n_min` et retourne une liste comportant les modalités de variables qui apparaissent dans au moins `n_min` lignes de `df` (on utilise ici une boucle `for`, mais on aurait aussi pu utiliser `map()`).

```{r}
min_freq_values <- function(df, n_min) {
    res <- list()
    for (col in names(df)) {
        # On fait le tri à plat des valeurs de la colonne
        freq <- table(df[[col]])
        # On ne conserve que les modalités avec effectif >= n
        freq <- freq[freq >= n_min]
        # On ajoute la colonne au résultat que s'il y a au moins une modalité
        if (length(freq) > 0) res[[col]] <- freq
    }
    res
}
```

Si on applique `min_freq_values()` à `hdv2003` avec une valeur de `n` à 1500, on obtient toutes les modalités correspondant à au moins 1500 observations.

```{r}
min_freq_values(hdv2003, 1500)
```

Essayons maintenant d'appliquer `min_freq_values()` au jeu de données `starwars` de `dplyr`.

```{r error=TRUE}
min_freq_values(starwars, 50)
```

On obtient une erreur plus ou moins sybilline : apparemment une erreur se produit au moment de faire le tri à plat des valeurs avec `table()`. Mais comme ce tri à plat s'effectue dans une boucle, on ne sait pas quelle variable de `starwars` cause le problème.

On va donc rajouter comme première instruction de la fonction du `for` un `print(col)`.

```{r error=TRUE}
min_freq_values <- function(df, n_min) {
    res <- list()
    for (col in names(df)) {
        print(col)
        # On fait le tri à plat des valeurs de la colonne
        freq <- table(df[[col]])
        # On ne conserve que les modalités avec effectif >= n
        freq <- freq[freq >= n_min]
        # On ajoute la colonne au résultat que s'il y a au moins une modalité
        if (length(freq) > 0) res[[col]] <- freq
    }
    res
}

min_freq_values(starwars, 50)
```

On voit que tout semble bien se passer pour les premières variables de notre tableau, et que l'erreur survient au moment de traiter la variable `films`. On regarde donc à quoi ressemble cette variable.

```{r}
head(starwars$films, 3)
```

*Damn*, cette variable n'est pas un vecteur atomique mais une liste ! Un tableau de données peut en effet contenir ce que l'on appelle des colonnes-listes. Comme ça n'est pas fréquent, on ne l'avait clairement pas prévu au moment de la création de la fonction.

On a désormais identifié le problème, on peut donc le corriger par exemple en ignorant les colonnes de type liste en utilisant `is.list()` et l'instruction `next`.

```{r}
min_freq_values <- function(df, n_min) {
    res <- list()
    for (col in names(df)) {
        # On passe à la colonne suivante si la colonne est une colonne-liste
        if (is.list(df[[col]])) next
        # On fait le tri à plat des valeurs de la colonne
        freq <- table(df[[col]])
        # On ne conserve que les modalités avec effectif >= n
        freq <- freq[freq >= n_min]
        # On ajoute la colonne au résultat que s'il y a au moins une modalité
        if (length(freq) > 0) res[[col]] <- freq
    }
    res
}

min_freq_values(starwars, 50)
```


### browser()

Il y a des alternatives plus efficaces à l'utilisation de `print()` pour identifier et résoudre des bugs. La plus utilisée est la fonction `browser()`. Celle-ci peut s'insérer à n'importe quel endroit du code, et lorsqu'elle est rencontrée par R celui-ci s'interrompt et affiche une invite de commande permettant notamment d'inspecter des objets.

On reprend l'exemple précédent en remplaçant le `print(col)` que nous avions inséré pour débugguer la fonction `min_freq_values` par un appel à `browser()`.


```{r eval=FALSE}
min_freq_values <- function(df, n_min) {
    res <- list()
    for (col in names(df)) {
        browser()
        # On fait le tri à plat des valeurs de la colonne
        freq <- table(df[[col]])
        # On ne conserve que les modalités avec effectif >= n
        freq <- freq[freq >= n_min]
        # On ajoute la colonne au résultat que s'il y a au moins une modalité
        if (length(freq) > 0) res[[col]] <- freq
    }
    res
}

min_freq_values(starwars, 50)
```

Lorsqu'on lance ce code, R s'interrompt et affiche l'invite de commande suivant :

```
Called from: min_freq_values(starwars, 50)

Browse[1]>
```

Cette invite de commande offre plusieurs possibilités. On peut lui indiquer du code R qui sera exécuté dans le contexte du moment de l'interruption. Notamment, si on indique un nom d'objet, on pourra voir sa valeur. Ainsi, si on tape `var`, R nous affiche la valeur actuelle de `var`, donc au moment de la première itération de la boucle.

```
Browse[1]> col                                       
[1] "name"
```

On peut également fournir des commandes spécifiques : si on tape `n`, R va passer à l'instruction suivante puis s'interrompre à nouveau^[Si on a un objet `n` dont on souhaite afficher le contenu, on doit faire `print(n)`.].

```
Browse[1]> n                                           
debug à #6 : freq <- table(df[[col]])
```

Si on tape `c`, R va relancer l'exécution jusqu'à la fin, ou jusqu'à la prochaine rencontre d'un `browser()`. Dans notre cas, cela signifie qu'on va continuer jusqu'au `browser()` de la deuxième itération de la boucle.

```
Browse[2]> c                                           
Called from: min_freq_values(starwars, 50)

Browse[1]> var                                         
[1] "height"
```

Si on souhaite sortir de cette invite de commande et tout interrompre, il suffit de taper `Q`.

`browser()` est donc un peu plus complexe à utiliser que des `print()` ajoutés manuellement, mais c'est aussi un outil plus souple et plus puissant.

```{block type='rmdnote'}
Cette section n'offre qu'un petit aperçu des possibilités de debugging. R propose d'autres fonctionnalités, et les environnements de développement comme RStudio ou Visual Studio Code proposent également leurs propres outils. 

Pour plus d'informations on pourra se reporter aux ressources indiquées dans la section ci-dessous.
```


## benchmarking : mesurer et comparer les temps d'exécution

Lorsqu'on commence à créer ses propres fonctions et de manière générale à écrire du code de plus en plus complexe ou à travailler sur des données de plus en plus volumineuses, on peut arriver sur des problèmes de performance et d'optimisation : les temps d'exécution deviennent longs et on aimerait essayer de les optimiser.

Un premier outil utile consiste à faire du *benchmarking* : comparer plusieurs manières différentes de faire la même chose, et mesurer leurs différences de vitesse d'exécution.

L'intruction la plus simple pour cela est sans doute `system.time()`. Celle-ci prend en argument une expression R, et affiche en retour le temps d'exécution en secondes.

```{r}
system.time(runif(1000000))
```

On peut passer plusieurs instruction à `system.time()`, soit en les isolant dans une fonction, soit en les indiquant directement entre une paire d'accolades.

```{r}
system.time({
    v <- runif(1000000)
    moy <- mean(v)
})
```

`system.time()` est cependant très limitée : on ne peut exécuter qu'une expression à la fois, on ne peut donc pas en comparer plusieurs, et surtout le temps d'exécution peut varier assez sensiblement selon l'utilisation du processeur de la machine sur lequel on l'exécute.

Il existe plusieurs extensions dédiées au *benchmarking*. On va utiliser ici l'extension [bench](https://bench.r-lib.org/), installable avec :

```{r eval=FALSE}
install.packages("bench")
```

`bench` propose une fonction principale, nommée `mark()`, qu'on peut donc appeler directement avec `bench::mark()`^[L'avantage d'utiliser `bench::mark()` est qu'on n'a pas besoin d'ajouter un `library(bench)` dans notre script.]. On passe à cette fonction plusieurs expressions, et `mark()` va effectuer les actions suivante :

- elle vérifie que les expressions retournent bien le même résultat
- elle lance ces expressions plusieurs fois et mesure à chaque fois leur temps d'exécution
- elle affiche un résumé de ces temps d'exécution en indiquant leur minimum et leur médiane

Exécuter chaque expression plusieurs fois permet de prendre en compte les fluctuation liées à l'activité du processeur de la machine.

Dans l'exemple suivant, on crée deux fonctions qui font la même chose : ajouter 10 à tous les éléments d'un vecteur passé en argument. Dans la première fonction `plus10_for` on utilise une boucle `for` qui ajoute 10 à tous les éléments l'un après l'autre (ce qu'il ne faut évidemment pas faire !), tandis que la deuxième fonction `plus10_vec` on utilise simplement la forme vectorisée `x + 10`.

```{r}
plus10_for <- function(x) {
    for (i in seq_along(x)) {
        x[i] <- x[i] + 10
    }
    x
}

plus10_vec <- function(x) {
    x + 10
}
```

On lance un benchmark avec `bench::mark()` et on stocke le résultat dans un objet.

```{r}
x <- 1:10000
bnch <- bench::mark(
    plus10_for(x),
    plus10_vec(x)
)
```

On affiche les résultats obtenus :

```{r}
bnch
```

La colonne la plus importante est sans doute la colonne `median`, qui affiche le temps médian d'exécution des deux expressions. Attention, l'unité de temps n'est pas forcément la même, ici l'exécution de `plus10_for` est affichée en millisecondes ("ms"), tandis que celle de `plus10_vec` l'est en microsecondes ("µs") donc avec une unité mille fois plus petite.

Si on préfère, on peut afficher les performances relatives des deux fonctions avec :

```{r}
summary(bnch, relative = TRUE)
```

Ces résultats nous permettent de voir que la version `vec` est 40 fois plus rapide que la version `for` ! Ce qui confirme le fait qu'il faut toujours prioriser l'utilisation de fonctions vectorisées lorsqu'elles existent.

On prend un second exemple : on souhaite mesurer si l'utilisation de `map` est plus rapide ou non qu'une boucle `for` pour une tache équivalente.

Pour cela on commence par créer artificiellement une liste de 200 tableaux de données en dupliquant 100 fois une liste composée des tableaux `rp2012` et `hdv2003`.

```{r}
dfs <- list(rp2012, hdv2003)
dfs <- rep(dfs, 100)
```

Puis on lance un benchmark sur une boucle `for` et un `map` qui retournent le nombre de lignes  de chacun des 200 tableaux. Cette-fois on ne crée pas de fonctions : on passe le code directement à `bench::mark()`, avec des noms permettant de les identifier plus facilement dans les résultats.

```{r}
bench::mark(
    boucle_for = {
        res <- list()
        for (df in dfs) {
            res <- c(res, nrow(df))
        }
        res
    },
    map = map(dfs, ~ nrow(.x) )
)
```

La lecture du résultat indique que dans ce cas de figure la boucle `for` est environ 4 fois plus lente que le `map`.


## profiling : identifier les problèmes de performance


## Ressources

L'ouvrage *Advanced R* (en anglais) consacre un chapitre entier [au debuggage](https://adv-r.hadley.nz/debugging.html).

Le site de RStudio propose une page entière détaillant ses [fonctionnalités de debugging](https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio) (en anglais). Pour les utilisateurs de Visual Studio Code, on pourra se référer à l'extension [VSCode-R-Debugger](https://github.com/ManuelHentschel/VSCode-R-Debugger).

