# Organiser ses traitements avec `targets`

[targets](https://docs.ropensci.org/targets/) est une extension R développée par [Will Landau](https://twitter.com/wmlandau) qui permet d'organiser un projet sous la forme d'un *pipeline* de traitements^[Pour les personnes habituées au développement, il s'agit d'un équivalent à [GNU Make](https://www.gnu.org/software/make/) pour R.]. Cette organisation a plusieurs avantages :

- elle permet une description de toutes les étapes du *pipeline* dans un fichier dédié, et force à séparer ces différentes étapes dans des fonctions à part, ce qui facilite la lisibilité et la maintenance du projet
- elle facilite la reproductibilité des traitements, car elle garantit que toutes les étapes ont bien été effectuées dans le bon ordre et dans un nouvel environnement
- elle optimise les temps de calcul, car en cas de une modification seules les étapes qui le nécessitent sont relancées

L'utilisation de `targets` dans des petits projets peut être vue comme une complexité supplémentaire pas toujours très utile, mais elle peut être très bénéfique pour des projets plus complexes ou comportant des temps de calculs importants à certaines étapes.


## Définition du pipeline

```{r, message=FALSE, warning=FALSE, echo=FALSE, cache=FALSE, eval=TRUE}
library(targets)

# On se place à la racine du projet d'exemple
knitr::opts_knit$set(root.dir = "resources/targets_sample_project/")
options(crayon.enabled = FALSE)

# On supprime le cache
targets::tar_destroy("all")
```


### Projet d'exemple

Pour illustrer la suite nous allons partir d'un projet très simple : à partir du [fichier national des prénoms donnés à la naissance](https://www.insee.fr/fr/statistiques/2540004), diffusé par l'INSEE, on souhaite produire un document indiquant les prénoms ayant les évolutions les plus fortes (à la hausse ou à la baisse) entre 2019 et 2020.

Le dossier de notre projet s'organise de la manière suivante :

```
data/
└── nat2020.csv
R/
├── fonctions_recode.R
└── fonctions_calculs.R
reports/
└── evolution.Rmd
_targets.R
```

```{block type='rmdnote'}
À noter que `targets` n'impose aucune structure de projet particulière en-dehors de la présence du fichier `_targets.R`. On aurait donc pu avoir une organisation tout à fait différente.
```

Le fichier `data/nat2020.csv` contient les données brutes téléchargées depuis le site de l'INSEE.

Le fichier `R/fonctions_recode.R` contient deux fonctions de traitement et de remise en forme des données.

```{r eval=FALSE, code=readLines('resources/targets_sample_project/R/fonctions_recode.R')}
```

Le fichier `R/fonctions_calculs.R` contient une seule fonction qui calcule les variables d'évolution 2019-2020.

```{r eval=FALSE, code=readLines('resources/targets_sample_project/R/fonctions_calculs.R')}
```


### `_targets.R`

```{r echo=FALSE, cache=FALSE, eval=FALSE}
# tar_script({
# # Packages nécessaires pour ce script
# library(targets)
# library(tarchetypes)

# # Chargement des fonctions
# source("R/fonctions_recode.R")
# source("R/fonctions_calculs.R")

# # Options pour les différentes étapes
# options(tidyverse.quiet = TRUE)
# tar_option_set(packages = "tidyverse")

# # Définition du pipeline
# tar_plan(
#     tar_file(csv_file, "data/nat2020.csv"),
#     donnees_brutes = read_csv2(csv_file),

#     donnees = donnees_brutes %>%
#         filter_data() %>%
#         pivot_2019_2020(),

#     donnees_evo = donnees %>%
#         calcule_evo(min_n = 1000)
# )
# })
```

```{r cache=FALSE}
targets_content_orig <- readLines("_targets.R", encoding = "UTF-8")

targets_content <- targets_content_orig[targets_content_orig != "    # Génération rapport"]
targets_content <- targets_content_orig[targets_content_orig != '    tar_render(report_evo, "reports/evolution.Rmd")']
file.rename("_targets.R", "_targets.R.orig")
writeLines(targets_content, "_targets.R")
```

Le fichier `_targets.R`, situé à la racine du dossier, constitue le coeur du projet. C'est là qu'on va définir le *pipeline* constitué de toutes les étapes de notre traitement : chargement et manipulation des données, calculs, génération de rapports, etc.

```{block type='rmdnote'}
La syntaxe présentée ici est celle proposée par l'extension `tarchetypes`, qui est un peu plus facile à prendre en main et plus lisible que la syntaxe native de `targets`.
```

Le fichier `_targets.R` commence par charger à la fois `targets` et `tarchetypes`.

```{r eval=FALSE}
# Packages nécessaires pour ce script
library(targets)
library(tarchetypes)
```

On va ensuite utiliser `source()` pour charger le contenu des deux fichiers `R/fonctions_recode.R` et `R/fonctions_calculs.R`, ce qui permet de rendre les fonctions qu'ils définissent disponibles par la suite.

```{r eval=FALSE}
# Chargement des fonctions
source("R/fonctions_recode.R")
source("R/fonctions_calculs.R")
```

On définit ensuite des options globales pour notre *pipeline*. Via la fonction `tar_option_set()`, on fixe l'option `packages` qui contient une liste d'extensions à charger systématiquement avant le lancement de chaque étape du *pipeline*. Ici on s'assure que l'extension `tidyverse` est bien chargée et disponible.

```{r eval=FALSE}
# Options pour les différentes étapes
options(tidyverse.quiet = TRUE)
tar_option_set(packages = "tidyverse")
```

Vient enfin la définition de notre *pipeline* proprement dit. Celle-ci se fait via la fonction `tar_plan()` de `tarchetypes`.

La première opération que l'on souhaite effectuer est de charger les données contenues dans `data/nat2020.csv`. Pour cela on va d'abord créer une première étape de *pipeline* qui consiste à *référencer* notre fichier CSV à l'aide de la fonction `tar_file()`.

```{r eval=FALSE}
tar_plan(
    # Chargement du fichier CSV
    tar_file(csv_file, "data/nat2020.csv")
)
```

Cette première étape définit une *cible* (*target*), nommée `csv_file`, qui pointe vers notre fichier CSV.

On ajoute une seconde étape qui charge les données à l'aide de `read_csv2()`. 

```{r eval=FALSE}
tar_plan(
    # Chargement du fichier CSV
    tar_file(csv_file, "data/nat2020.csv"),
    donnees_brutes = read_csv2(csv_file),
)
```

Cette étape définit une nouvelle cible nommée `donnees_brutes`. Cette cible correspond au nom d'une étape, mais aussi à un objet : dans ce qui suit, `donnees_brutes` correspond au tableau de données résultat du `read_csv2()`.

On va utiliser cet objet dans une troisième étape qui lui applique nos deux fonctions de filtrage et transformation définies dans `R/fonctions_recode.R`.

```{r eval=FALSE}
tar_plan(
    # Chargement du fichier CSV
    tar_file(csv_file, "data/nat2020.csv"),
    donnees_brutes = read_csv2(csv_file),

    # Mise en forme des données
    donnees = donnees_brutes %>%
        filter_data() %>%
        pivot_2019_2020()
)
```

Ici aussi, `donnees` est à la fois le nom d'une cible et un objet contenant nos données retravaillées. On utilise cet objet dans une nouvelle étape qui utilise la fonction de `R/fonctions_calculs.R` pour calculer les variables d'évolution.

```{r eval=FALSE}
tar_plan(
    # Chargement du fichier CSV
    tar_file(csv_file, "data/nat2020.csv"),
    donnees_brutes = read_csv2(csv_file),

    # Mise en forme des données
    donnees = donnees_brutes %>%
        filter_data() %>%
        pivot_2019_2020(),

    # Calcul indicateurs
    donnees_evo = donnees %>%
        calcule_evo(min_n = 1000)
)
```

```{block type='rmdnote'}
`targets` offre aussi la possibilité de définir notre *pipeline* directement dans un fichier RMarkdown, ce qui peut permettre notamment de mieux le documenter. Pour plus d'information on pourra se référer au chapitre [Target Markdown](https://books.ropensci.org/targets/markdown.html) du manuel en ligne.
```

Au final, notre fichier `_targets.R` est donc le suivant :

```{r eval=FALSE, code=readLines('resources/targets_sample_project/_targets.R')}
```

## Exécution du pipeline

```{r cache=FALSE}
tar_visnetwork()
```

Pour lancer et exécuter notre pipeline, on utilise simplement la fonction `tar_make()`.

```{r}
tar_make()
```

Lorsqu'on exécute le *pipeline*, `targets` va lancer une nouvelle session R (pour éviter des problèmes liés à l'existence d'objets dans notre session actuelle), charger les extensions définie via `tar_option_set()`, et exécuter les cibles définies avec `tar_plan()`.

À chaque étape, `targets` a conservé une copie de chacun des objets correspondants aux différentes cibles. On peut charger et inspecter ces objets avec les fonctions `tar_read()` et `tar_load()`^[Ces données sont stockées dans le répertoire `_targets` à la racine du projet.].

```{r}
tar_read(donnees)
```

```{r eval=FALSE}
tar_load(donnees)
```



## Modifications du pipeline

## RMarkdown

```{r cache=FALSE}
file.remove("_targets.R")
file.rename("_targets.R.orig", "_targets.R")
```


## Gestion des données en cache

tar_delete()
tar_destroy("all")

## Ressources

Nous n'avons vu ici qu'un petit aperçu des fonctionnalités de `targets`, qui propose 

https://docs.ropensci.org/targets

https://milesmcbain.xyz/the-drake-post/

https://books.ropensci.org/targets/

