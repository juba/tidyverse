# Programmer avec le *tidyverse* {#programmer-tidyverse}

Dans les parties précédentes, nous avons vu comment créer et utiliser nos propres fonctions. Cependant, un lectorat attentif aura remarqué que nous avons rigoureusement évité d'utiliser des fonctions du *tidyverse*, notamment de `dplyr`, de `tidyr` et de `ggplot2`, dans nos fonctions.

Nous allons voir dans cette section les spécificités et les manières d'utiliser ces extensions pour programmer et les inclure dans nos propres fonctions.

On commence avant toute chose par charger le *tidyverse* et le jeu de données `starwars` de `dplyr`.

```{r}
library(tidyverse)
data(starwars)
```

```{block type='rmdnote'}
Les notions et fonctions abordées dans cette partie sont propres aux extensions du *tidyverse*. Elles ne seront en général pas utilisables ailleurs dans R.
```

## Spécificités du *tidyverse*

Les extensions du *tidyverse* fournissent une syntaxe lisible et agréable à utiliser lorsqu'on appelle ces fonctions de manière interactive. Par exemple, si on veut filtrer les lignes et les colonnes d'un tableau de données en base R, on utilise quelque chose comme :

```{r results="hide"}
starwars[starwars$species == "Droid" & starwars$eye_color == "red" , c("height", "mass")]
```

Tandis qu'avec `dplyr` on peut faire :

```{r results="hide"}
starwars %>%
    filter(species == "Droid" & eye_color == "red") %>%
    select(height, mass)
```

L'avantage de `dplyr` est double :

1. dans `filter`, on sait qu'on travaille à l'intérieur du tableau de données, on indique donc juste `species` et pas `starwars$species`
2. dans `select`, on peut indiquer les noms de colonnes en omettant les guillemets

Cette simplification pour une utilisation interactive, la plus fréquente, entraîne cependant une complexification lorsqu'on souhaite utiliser ces fonctions pour programmer, notamment quand on veut les utiliser à l'intérieur d'autres fonctions.

### *data masking*

On part du tableau de données d'exemple suivant^[Effectivement, un salon de coiffure s'est à nouveau glissé dans ce jeu de données.].

```{r}
restos <- tibble(
    nom = c("Chez Jojo", "Vertige des sens", "Le Crousse", "Le bouchon coréen", "Le lampad'hair"),
    style = c("tradi", "gastro", "tradi", "gastro", "coiffure"),
    ville = c("Ecully", "Lyon", "Lyon", "Lyon", "Ecully"),
    evaluation = c(4.6, 3.2, 3.3, 4.1, 1.2),
    places = c(28, 32, 94, 18, 8),
    note = c("Pas mal", "Cher", "Ambiance jeune", "Original", "Euh ?")
)

restos
```

Avec `dplyr`, on peut sélectionner une colonne du tableau avec :

```{r}
restos %>% select(note)
```

Dans cette expression, `note` ne se réfère pas à un objet `note` de notre environnement, mais à une variable du tableau de données `restos`.

Que se passe-t-il si on passe à `select` non pas une colonne du tableau mais bien un objet de notre environnement ?

```{r}
x <- "note"
restos %>% select(x)
```

Ça fonctionne aussi : en l'absence de colonne nommée `x`, `select` va aller chercher le `x` de notre environnement et utiliser sa valeur pour sélectionner la colonne par nom.

Mais que se passe-t-il s'il existe à la fois une colonne du tableau et un objet de notre environnement du même nom ?

```{r}
note <- "nom"
restos %>% select(note)
```

Dans ce cas, c'est la colonne du tableau qui a la priorité. On dit que `dplyr` fait du *data masking* : les objets de notre environnement sont "masqués" par les colonnes du même nom de notre tableau de données. On retrouve ce *data masking* dans d'autres fonctions comme `filter()`, `mutate()` ou `summarise()`, mais aussi dans la sélection des variables avec `aes()` pour les fonctions de `ggplot2`.

Dans certains cas de figure, on peut vouloir outrepasser le *data masking*. Par exemple, dans le cas suivant, la nouvelle colonner `note_michelin` n'est pas créée à partir des nouvelles données de l'objet `note`, mais à partir de celles de la colonne `note`.

```{r}
note <- c(12, 14, 9, 15, NA)
restos %>% mutate(note_michelin = note)
```

*"Il suffit de changer le nom de l'objet note pour qu'il ne corresponde à aucune colonne !"*, s'exclamera la lectrice ou le lecteur attentif.ve. Mais, outre que cela peut être source d'erreur, il est des cas où on ne connaît pas le nom des colonnes du tableau, par exemple quand l'opération se déroule dans une fonction et que le tableau est passé en paramètre :

```{r}
filtre_nom <- function(df, valeurs) {
    df %>% filter(nom == valeurs)
}
```

Rien ne nous assure dans ce cas que le tableau `df` ne contient pas déjà une colonne nommée `valeurs` qui "masquerait" alors l'objet `valeurs` passé en argument ?

Pour pallier à ce problème, à chaque fois qu'on est dans un environnement où du *data masking* se produit, on peut utiliser deux "pronoms" spécifiques nommés `.data` et `.env` :

- `.data$var` ou `.data[["var"]]` pointe vers l'objet `var` correspondant à une colonne du tableau de données
- `.env$var` ou `.env[["var"]]` pointe vers l'objet `var` correspondant à un objet de notre environnement

Avec ces deux outils, on peut donc explicitement choisir d'où viennent les données qu'on utilise.

```{r}
note <- c(12, 14, 9, 15, NA)
restos %>% mutate(note_michelin = .env$note)
restos %>% mutate(note = str_to_upper(.data$note))
```

De même, en utilisant `.env`, on peut s'assurer que notre fonction `filtre_nom` va bien prendre les valeurs dans notre environnement, donc dans l'argument passé à la fonction, et pas dans une éventuelle colonne qui porterait le même nom.

```{r}
filtre_nom <- function(df, valeurs) {
    df %>% filter(nom %in% .env$valeurs)
}

restos %>% filtre_nom(c("Chez Jojo", "Le Crousse"))
```

  
### Utilisation dans des fonctions

Une autre difficulté survient quand les noms de colonnes du tableau ne sont pas saisis directement mais proviennent d'un argument de fonction.

Soit la fonction suivante qui prend en entrée un tableau de données et une colonne et retourne le résultat d'un `summmarise`.

```{r error=TRUE}
summarise_min <- function(df, col) {
    df %>% summarise(min = min(col))
}
```

On voudrait pouvoir appeler cette fonction de la même manière qu'on utilise `summarise`, mais cela ne fonctionne pas :

```{r error=TRUE}
summarise_min(restos, evaluation)
```

Le message d'erreur nous dit que l'objet `evaluation` est introuvable. La raison n'est pas triviale, elle repose sur plusieurs mécanismes assez complexes liés à l'évaluation des expressions dans R, mais on pourrait résumer en disant que les fonctions du *tidyverse* utilisent leur propre mécanisme d'évaluation qui tient compte notamment du *data masking*. Or, quand on utilise l'argument `col` dans le `summarise` de notre fonction, c'est l'évaluation "normale" de R qui est utilisée : le *data masking* n'étant pas pris en compte, l'objet `evaluation` est recherché dans notre environnement plutôt que dans notre tableau, ce qui génère une erreur puisqu'aucun objet de ce nom n'existe en-dehors du tableau.

C'est pourquoi les fonctions du *tidyverse* fournissent un opérateur permettant de "forcer" l'évaluation d'expression selon la manière qu'elles attendent. Cet opérateur prend la forme de double accolades `{{ }}` et se nomme *curly curly*.

Pour résoudre le problème de notre fonction `summarise_min()`, on peut donc simplement faire passer notre argument `col` dans l'opérateur *curly curly* :

```{r}
summarise_min <- function(df, col) {
    df %>% summarise(min = min({{ col }}))
}

summarise_min(restos, evaluation)
```

À noter que *curly curly* permet de passer en argument toute expression qui serait acceptée directement par les fonctions appelées. On peut donc combiner plusieurs colonnes, effectuer des opérations, etc.

```{r}
summarise_min(restos, evaluation * 4)
```

Et on peut même utiliser les pronoms `.data` et `.env` :

```{r}
evaluation <- 1:5
summarise_min(restos, .env$evaluation)
```


## Programmer avec `dplyr` et `tidyr`

### Utiliser une colonne passée en argument

Une opération courante quand on utilise les fonctions de `dplyr` ou `tidyr` dans une fonction est de prendre en argument des colonnes auxquelles on souhaite accéder. La règle dans ce cas est d'utiliser l'opérateur *curly curly* et d'entourer les utilisations de l'argument dans les fonctions du *tidyverse* par une paire d'accolades.

On a déjà vu un exemple précédemment avec `summarise`.

```{r}
resume <- function(df, col) {
    df %>% summarise(
        moyenne = mean({{ col }}),
        min = min({{ col }}),
        max = max({{ col }})
    )
}

resume(restos, evaluation)
```

```{r}
resume <- function(df, col) {
    df %>% summarise(
        moyenne = mean({{ col }}),
        min = min({{ col }}),
        max = max({{ col }})
    )
}

resume(restos, evaluation)
```


On peut aussi l'utiliser dans un `group_by` :

```{r}
resume_groupe <- function(df, col_group, col_var) {
    df %>%
        group_by({{ col_group }}) %>%
        summarise(
            moyenne = mean({{col_var}}),
            min = min({{ col_var }}),
            max = max({{ col_var }})
        )
}

resume_groupe(restos, style, evaluation)
```



### Utiliser une série de colonnes passées en arguments

Dans l'exemple précédent, on a utilisé à chaque fois une seule colonne, que ce soit dans le `group_by` ou dans le `summarise`. Si on souhaite grouper ou appliquer une fonction sur une série de colonnes, il faut alors utiliser `across()`.

```{r}
resume_groupe <- function(df, cols_group, cols_var) {
    df %>%
        group_by(
            across({{ cols_group }})
        ) %>%
        summarise(
            across(
                {{ cols_var }},
                list(
                    moyenne = mean,
                    min = min,
                    max = max
                )
            )
        )
}
```

On peut du coup utiliser tous les modes de sélection de colonnes permises par `select()` ou `across()`.

```{r}
resume_groupe(restos, c(style, ville), where(is.numeric))
```

De la même manière, si on utilise un argument de fonction pour sélectionner des variables avec `select()`, on doit l'entourer avec l'opérateur *curly curly*, et on peut dès lors utiliser toutes les fonctionnalités de sélection permises.

```{r}
select_cols <- function(df, cols) {
    df %>% select({{ cols }})
}

restos %>% select_cols(where(is.character) & !c(nom, note))
```

### Créer de nouvelles colonnes avec des noms passés en argument

Pour l'instant on a vu comment utiliser des colonnes passées en argument pour accéder à leur contenu. On peut aussi vouloir passer en argument des noms de colonnes qu'on souhaite créer, par exemple avec un `mutate`.

On pourrait essayer directement de la manière suivante, mais évidemment ce la ne fonctionne pas puisque la nouvelle colonne créée s'appelle "col_new", et pas la valeur de l'argument `col_new`.

```{r}
calcule_pourcentage <- function(df, col_new, col_var) {
    df %>% 
        mutate(
            col_new = {{ col_var }} / sum({{ col_var }}) * 100
        )
}

calcule_pourcentage(restos, pourcentage_places, places)
```

Dans ces cas-là, la syntaxe à utiliser est un peu plus complexe :

- on remplace l'opérateur `=` du `mutate()` par l'opérateur `:=`
- on place à gauche du `:=` une chaîne de caractères dans laquelle notre argument contenant le nom de la nouvelle variable est entouré d'une paire d'accolades.

Voici ce que ça donne pour l'exemple ci-dessus :

```{r}
calcule_pourcentage <- function(df, col_new, col_var) {
    df %>% 
        mutate(
            "{{col_new}}" := {{ col_var }} / sum({{ col_var }}) * 100
        )
}

calcule_pourcentage(restos, prop_places, places)
```

Cette syntaxe est un peu complexe de prime abord, mais elle à l'avantage d'être souple : notamment, on peut placer le texte que l'on souhaite dans la chaîne de caractères en plus des noms de variables entre double accolades. 

Cela permet par exemple de générer le nom d'une nouvelle variable automatiquement à partir de l'ancienne.

```{r}
calcule_pourcentage <- function(df, col_var) {
    df %>%
        mutate(
            "pourcentage_{{col_var}}" := {{ col_var }} / sum({{ col_var }}) * 100
        )
}

calcule_pourcentage(restos, places)
```

Ou de personnaliser les noms de colonnes dans un `summarise()`.

```{r}
resume <- function(df, col) {
    df %>% summarise(
        "{{col}}_moyenne" := mean({{ col }}),
        "{{col}}_min" := min({{ col }}),
        "{{col}}_max" := max({{ col }})
    )
}

resume(restos, places)
```

### Désambiguiser data / env

Lorsqu'on utilise des fonctions de `dplyr` ou `tidyr` dans d'autres, fonction, il peut être utile de préciser, quand on accède à un objet dont on connaît le nom (c'est-à-dire dont le nom n'est pas passé en argument), si c'est un objet de type "data" (une colonne du tableau de données dans lequel on travaille) ou de type "env" (un objet de l'environnement dans lequel on travaille).

Dans la fonction suivante, on calcule la moyenne d'une colonne numérique de `restos` selon les valeurs de la colonne `ville`, et on ne conserve que les villes pour lesquelles cette moyenne est supérieure à un certain seuil.

```{r}
stat_par_ville <- function(col_var, seuil = NULL) {
    res <- restos %>%
        group_by(.data$ville) %>%
        summarise(moyenne = mean({{col_var}})) %>%
        filter(moyenne > .env$seuil)
}

stat_par_ville(evaluation, seuil = 0)
stat_par_ville(evaluation, seuil = 3)
```

On sait que l'objet `ville` du `group_by` est toujours la colonne du tableau `restos` nommée `ville`, on peut donc s'assurer que c'est bien le cas en l'explicitant avec `.data$ville`. À l'inverse, on sait que la valeur `seuil` du `filter` celle de l'argument du même nom, donc d'un objet de l'environnement. On peut s'en assurer en indiquant `.env$seuil`.

Cette explicitation ne paraît pas forcément utile à première vue, mais elle peut éviter des problèmes à terme, notamment si on ajoute de nouvelles colonnes à un tableau de données et qu'on finit par avoir des objets "data" et des objets "env" avec le même nom.


### Quand les arguments sont des chaînes de caractères

Dans tous les exemples jusqu'à présent, les arguments de fonction étaient passés sous la forme d'expressions ou de symboles :

```{r eval=FALSE}
resume(restos, places)
summarise_min(restos, evaluation * 4)
```

Mais il arrive que les arguments comportent des noms de colonnes passés plutôt en chaînes de caractères :

```{r eval=FALSE}
resume(restos, "places")
summarise_min(restos, "evaluation")
```

Dans ce cas on ne peut pas utiliser l'opérateur *curly curly*, par contre on peut utiliser le pronom `.data` pour accéder aux colonnes à partir de leur nom.

```{r}
summarise_min <- function(df, col) {
    df %>% summarise(min = min(.data[[col]]))
}

summarise_min(restos, "evaluation")
```

Quand on veut plutôt sélectionner des colonnes avec `select()` ou `across()` et qu'on récupère les noms de ces colonnes dans un vecteur de chaînes de caractères, on peut alors utiliser les fonctions `all_of()` ou `any_of()`.

```{r}
evaluation_par_groupe <- function(cols_group) {
    restos %>%
        group_by(
            across(all_of(cols_group))
        ) %>%
        summarise(evaluation = mean(.data$evaluation))
}

evaluation_par_groupe("ville")
evaluation_par_groupe(c("ville", "style"))
```

La différence entre `all_of()` et `any_of()` et que `all_of()` produira une erreur si l'une des variables n'est pas trouvée.

```{r}
select_any_cols <- function(cols) {
    restos %>% select(any_of(cols))
}

select_any_cols(c("ville", "evaluation", "igloo"))
```
```{r error=TRUE}
select_all_cols <- function(cols) {
    restos %>% select(all_of(cols))
}

select_all_cols(c("ville", "evaluation", "igloo"))
```

## Programmer avec `ggplot2`

### Sélection de colonnes avec `aes()`

Les règles pour sélectionner des colonnes dans un appel à `aes()` à partir d'arguments passés à une fonction sont les mêmes que celles vues précédemment pour `dplyr` et `tidyr` :

- si les noms sont passés sous forme de symboles ou d'expressions, on utilise l'opérateur *curly curly* (`{{}}`)

```{r}
bar_graph <- function(df, col) {
    ggplot(df) +
        geom_bar(aes(x = {{ col }}), fill = "skyblue")
}

bar_graph(restos, ville)
```

- si les noms sont passés sous forme de chaînes de caractères, on utilise le pronom `.data`

```{r}
bar_graph <- function(df, col) {
    ggplot(df) +
        geom_bar(aes(x = .data[[col]]), fill = "skyblue")
}

bar_graph(restos, "ville")
```

### Faceting

Il y a une petite spécificité quand on utilise `facet_wrap()` ou `facet_grid()` : les variables utilisées pour faire le *faceting* étant spécifiées sous la forme d'une formule, leur spécification à partir d'arguments de fonction n'est pas directe.

`ggplot2` propose donc la fonction `vars()` pour 
faciliter cette opération.

Si la variable de faceting est donnée sous forme d'un symbole, on utilise `vars()` en conjonction avec l'opérateur *curly curly*.

```{r}
facet_evaluation <- function(facet) {
    ggplot(restos) +
        geom_density(aes(x = .data$evaluation)) +
        facet_wrap(vars({{ facet }}))
}

facet_evaluation(ville)
```

Si la variable de faceting est donnée sous forme d'une chaîne de caractères , on utilise `vars()` en conjonction avec le pronom `.data`.

```{r}
facet_evaluation <- function(facet) {
    ggplot(restos) +
        geom_density(aes(x = .data$evaluation)) +
        facet_wrap(vars(.data[[facet]]))
}

facet_evaluation("ville")
```

Si on utilise `facet_grid()`, la fonction doit accepter deux variables de faceting comme arguments. Celles-ci peuvent ensuite être passées à `facet_grid` via ses paramètres `rows` et `cols`.

```{r}
facet_points <- function(facet_row, facet_col) {
    ggplot(restos) +
        geom_point(aes(x = .data$evaluation, y = .data$places)) +
        facet_grid(
            rows = vars({{ facet_row }}),
            cols = vars({{ facet_col }})
        )
}

facet_points(ville, style)
```

## Aide-mémoire

On essaie de récapituler ici les points importants à garder en tête, pour pouvoir les retrouver facilement.

```{block type='rmdimportant'}
Premier point important : les spécificités vues ici ne s'appliquent que quand on veut utiliser certaines fonctions du *tidyverse* (`dplyr`, `tidyr`, `ggplot2`) à l'intérieur d'autres fonctions. Plus spécifiquement, elles sont à prendre en compte quand on souhaite passer en argument d'une fonction des noms de colonnes qui seront utilisées par des fonctions du *tidyverse*.

Elles ne s'appliquent pas si on passe en arguments d'autres paramètres comme le tableau de données qu'on souhaite utiliser, des valeurs numériques ou des chaînes de caractères qu'on souhaite récupérer telles quelles, etc.
```

1. Dans le cas où deux objets du même nom pourraient exister à la fois comme colonne de notre tableau de données (objet *data*) et comme objet de notre environnement (objet *env*), on peut expliciter lequel on souhaite utiliser avec les pronoms `.data$var` et `.env$var`

2. Si on récupère comme argument une colonnes passée sous la forme de symbole (`var`), on doit l'encadrer de l'opérateur *curly curly*.

```{r eval=FALSE}
summarise_col <- function(df, col) {
    df %>% summarise(moyenne = mean({{ col }}, na.rm = TRUE))
}

summarise_col(starwars, height)
```

3. Si on récupère comme argument un nom de colonne passée sous la forme d'une chaîne de caractères (`"var"`), on y accède avec le pronom `.data` :

```{r eval=FALSE}
summarise_col <- function(df, col_name) {
    df %>% summarise(moyenne = mean(.data[[col_name]], na.rm = TRUE))
}

summarise_col(starwars, "height")
```

4. Si on indique une spécification de plusieurs colonnes pour application d'une même transformation, on utilise `across()` et l'opérateur *curly curly* :

```{r eval=FALSE}
summarise_col_by <- function(df, col_by, col_var) {
    df %>%
        group_by(
            across({{ col_by }})
        ) %>%
        summarise(
            across(
                {{ col_var }},
                ~mean(.x, na.rm = TRUE)
            )
        )
}

summarise_col_by(starwars, c(gender, sex), where(is.numeric))
```

5. Si on indique une spécification de plusieurs colonnes pour utilisation dans un `select`, on l'encadre de l'opérateur *curly curly* :

```{r eval=FALSE}
select_cols <- function(df, cols) {
    df %>% select({{ cols }})
}

select_cols(starwars, !where(is.list))
```

6. Si on indique une spécification de plusieurs colonnes pour utilisation dans un `select` ou un `across` sous la forme d'un vecteur de chaînes de caractères, on utilise `all_of()` ou `any_of()` :

```{r eval=FALSE}
select_cols <- function(df, col_names) {
    df %>% select(all_of(col_names))
}

select_cols(starwars, c("height", "mass"))
```

6. Si on souhaite passer en argument un nom de nouvelle colonne que l'on souhaite créer, on l'utilise sous la forme d'une chaîne de caractères, entouré d'une paire d'accolades et avec l'opérateur `:=` :

```{r eval=FALSE}
add_mean_by_species <- function(col_var) {
    starwars %>%
        group_by(species) %>%
        mutate("moyenne_{{col_var}}" := mean({{ col_var}}))
}

add_mean_by_species(height)
```

7. Si on souhaite passer des variables pour du faceting dans un graphique `ggplot2`, on les place dans l'appel à `vars()` en les encadrant de l'opérateur *curly curly* :

```{r eval=FALSE}
graph_mean_by <- function(col_by, col_var) {
    ggplot(starwars) +
        geom_histogram(aes(x = {{ col_var }})) +
        facet_wrap(vars({{ col_by }}))
}

graph_mean_by(gender, height)
```

## Ressources

Pour plus de détails sur la programmation avec les fonctions de `dplyr`, on pourra se reporter à la vignette [Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html).

De la même manière, pour l'utilisation de `ggplot2` dans des fonctions, on trouvera plus de détails dans la vignette [Using ggplot2 in packages](https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html).

Les mécanismes d'évaluation et de métaprogrammation propres aux packages du *tidyverse* sont implémentés en grande partie dans le package [rlang](https://rlang.r-lib.org/).

Enfin, pour une présentation approfondie des possibilités de métaprogrammation dans R en général, on pourra consulter le chapitre [Metaprogramming](https://adv-r.hadley.nz/metaprogramming.html) de l'ouvrage en ligne *Advanced R*.


## Exercices

### 
