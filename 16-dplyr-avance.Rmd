# `dplyr` avancé

La partie \@ref(dplyr) a permis de présenter l'extension `dplyr`. On va voir ici comment aller un peu plus loin dans l'utilisation du *package*, notamment en utilisant nos propres fonctions et en appliquant des transformations à des ensembles de colonnes.

On charge les jeux de données `hdv2003` et `rp2012` depuis l'extension `questionr`.

```{r}
library(questionr)
data(hdv2003)
data(rp2012)
```

## Appliquer ses propres fonctions 

### Exemple avec un `mutate`

Dans le jeu de données `hdv2003` plusieurs variables comprennent les mêmes modalités `Oui` / `Non`. C'est le cas notamment de `cuisine` et `cinema`.

Supposons qu'on souhaite recoder les valeurs de `cuisine` en transformant `Oui` en `O`, `Non` en `N`. On a vu section \@ref(recode) qu'on peut utiliser pour cela la fonction `fct_recode()` de `forcats`.

```{r}
hdv2003 %>%
    mutate(
        cuisine = fct_recode(cuisine,
            "O" = "Oui",
            "N" = "Non"
        )
    )
```

Supposons qu'on souhaite également convertir les `NA` éventuelles de `cuisine` en vaeurs explicites `Non réponse`. On peut le faire avec la fonction `fct`explicit_na()` de `forcats`. Notre recodage doit donc se faire en deux étapes, par exemple de la manière suivante :

```{r}
hdv2003 %>%
    mutate(
        cuisine = fct_recode(cuisine,
            "O" = "Oui",
            "N" = "Non"
        ),
        cuisine = fct_explicit_na(cuisine, "Non réponse")
    )
```

Comme notre recodage commence à être un peu complexe, on pourrait l'extraire de notre `mutate` en créant une fonction. On la nomme `recode_oui_non`. Celle-ci prend en entrée un vecteur `v` et retourne le vecteur recodé.

```{r}
recode_oui_non <- function(v) {
    v %>%
        fct_recode(
            "O" = "Oui",
            "N" = "Non"
        ) %>%
        fct_explicit_na("Manquant")
}
```

On peut dès lors simplifier notre `mutate` en appelant notre nouvelle fonction.

```{r}
hdv2003 %>%
    mutate(cuisine = recode_oui_non(cuisine))
```

Premier avantage : on gagne en lisibilité. On a séparé le code d'une opération spécifique dans une fonction avec un nom "parlant", ce qui permet de savoir facilement à quoi elle sert. Et on a simplifié notre `mutate` qui est désormais plus lisible parce qu'il fait apparaître la logique des nos opérations (on veut recoder les valeurs "oui" / "non") sans en inclure les détails.

Le deuxième avantage évidemment, comme pour toute fonction, est qu'on peut la réutiliser pour appliquer ce recodage à plusieurs variables. Ainsi, si on veut recoder de la même manière `cuisine` et `cinema`, il suffit de faire :

```{r}
hdv2003 %>%
    mutate(
        cuisine = recode_oui_non(cuisine),
        cinema = recode_oui_non(cinema)
    )

```

Le code est plus court, plus lisible, on évite les erreurs de copier/coller, et si on souhaite modifier le recodage on a à intervenir qu'à un seul endroit.

### Exemple avec un `summarise`

Autre exemple, cette fois sur le jeu de données `rp2012`. Imaginons qu'on souhaite calculer, pour chaque région, le pourcentage de communes dont le nom se termine par une série de caractères donnée.

Comme il ne s'agit pas forcément d'une question triviale, on va décomposer le problème et rappeler (comme vu section \@ref(str-detect)) que la fonction `str_detect()` de l'extension `stringr` permet de détecter quels éléments d'un vecteur de chaînes de caractères correspondent à une expression régulière. Ainsi, si on veut détecter si un nom de commune (variable `rp2012$commune`) se termine par `"ac"`, on utilisera :

```{r}
library(stringr)
str_detect(rp2012$commune, "ac$")
```

Le `$` dans l'expression régulière `"ac$"` correspond à la fin de la chaîne de caractères. Il permet de s'assurer qu'on ne détecte que les noms de communes se terminant par "ac" (comme "Fige**ac**"), et pas ceux contenant "ac" à un autre endroit (comme "Arc**ac**hon").

Si on veut compter le nombre de communes pour lesquelles on a détecté une terminaison en "ac", on peut tout simplement appliquer la fonction `sum()` au résultat précédent : les `TRUE` du résultat du `str_detect` sont alors convertis en 1, les `FALSE` en 0, et le `sum()` renverra donc le nombre de `TRUE`.

```{r}
sum(str_detect(rp2012$commune, "ac$"))
```

Si on souhaite convertir ce résultat en pourcentage, il faut qu'on divise par le nombre total de communes, et qu'on multiplie par 100.

```{r}
sum(str_detect(rp2012$commune, "ac$")) / length(rp2012$commune) * 100
```

On va créer une fonction nommée `prop_suffixe` qui aura pour objectif d'effectuer ce calcul. Elle prendra en entrée deux arguments, un vecteur de chaînes de cractère, et un "motif" à détecter. On va rajouter nous-mêmes le "$" à la fin du motif en question pour faciliter l'usage de la fonction. Le résultat final est le suivant :

```{r}
prop_suffixe <- function(v, motif) {
    # On ajoute $ à la fin du motif pour capturer uniquement les suffixes
    motif <- paste0(motif, "$")
    # Détection du motif
    nb_detect <- sum(str_detect(v, motif))
    # On retourne le pourcentage
    nb_detect / length(v) * 100
}
```

On peut utiliser notre fonction de la manière suivante :

```{r}
prop_suffixe(rp2012$commune, "ac")
```

On a donc dans notre jeu de données `r round(prop_suffixe(rp2012$commune, "ac"), 2)`% de communes dont le nom se termine par "ac"^[Attention, le jeu de données ne comporte que les communes de plus de 2000 habitants.].

Si maintenant on souhaite calculer ce pourcentage pour toutes les régions françaises, il suffit d'appeler notre fonction dans dans un appel à `summarise` :

```{r}
rp2012 %>%
    group_by(region) %>%
    summarise(prop_ac = prop_suffixe(commune, "ac")) %>%
    arrange(desc(prop_ac))
```

L'avantage d'avoir créé une fonction pour effectuer cette opération et qu'on peut du coup très facilement faire le même calcul en faisant varier le suffixe recherché.

```{r}
rp2012 %>%
    group_by(region) %>%
    summarise(prop_ac = prop_suffixe(commune, "ieu")) %>%
    arrange(desc(prop_ac))
```

En créant une fonction plutôt qu'en mettant notre code directement dans le `summarise` on a un script plus lisible, plus facile à maintenir, et des fonctionnalités facilement réutilisables.

### Exemple avec un `rename_with`

On a vu section \@ref(select-rename) que `dplyr` propose la fonction `rename()` pour renommer des colonnes d'un tableau de données. On peut l'utiliser par exemple pour remplacer un `.` par un `_` dans le nom d'une variable d'`hdv2003`.

```{r}
hdv2003 %>% rename("lecture_bd" = "lecture.bd")
```

Supposons maintenant qu'on souhaite appliquer la même transformation à l'ensemble des variables de `hdv2003`. Une solution pour cela est d'utiliser la fonction `rename_with()`, toujours fournie par `dplyr`, qui prend en argument non pas une correspondance `"nouveau nom" = "ancien nom"` mais une fonction qui sera appliquée à l'ensemble des noms de colonnes.

Par exemple, si on souhaite convertir tous les noms de colonnes en majuscules, on peut passer comme argument la fonction `str_to_upper()` de `stringr`.

```{r}
hdv2003 %>% rename_with(str_to_upper)
```

Pour remplacer les `.` par des `_`, on va d'abord créer une fonction *ad hoc* qui utilise `str_replace_all`.

```{r}
remplace_points <- function(v) {
    str_replace_all(v, fixed("."), "_")
}
```

On notera qu'on est obligé d'utiliser ici la fonction `fixed()` pour indiquer que le motif `"."` est bien le caractère `.` et pas une expression régulière.

Dès lors, on peut appliquer cette fonction à l'ensemble de nos noms de variables :

```{r}
hdv2003 %>% rename_with(remplace_points)
```

Certain.es lectrices et lecteurs attentives auront peut-être noté que le même résultat peut être obtenu en utilisant `remplace_points()` avec la fonction `names()`. L'avantage de `rename_with()`, comme nous le verrons ci-dessous, c'est qu'elle permet si nécessaire de sélectionner finement les colonnes auxquelles appliquer le renommage.


## `across()` : appliquer des fonctions à plusieurs colonnes {#across}

### Appliquer une fonction à plusieurs colonnes

On a défini précédemment une fonction qui recode les modalités d'une variable "Oui" / "Non" et on a vu comment appliquer ce recodage à deux variables de `hdv2003`.

```{r}
recode_oui_non <- function(v) {
    v %>%
        fct_recode(
            "O" = "Oui",
            "N" = "Non"
        ) %>%
        fct_explicit_na("Manquant")
}

hdv2003 %>%
    mutate(
        cuisine = recode_oui_non(cuisine),
        cinema = recode_oui_non(cinema)
    )
```

Supposons qu'on souhaite appliquer ce recodage à toutes les variables "Oui" / "Non" de notre tableau. On pourrait évidemment créer autant de lignes que nécessaires dans notre `mutate`, mais on peut aussi utiliser la fonction `across()` de `dplyr`, qui permet justement ce type d'opérations.

`across()` prend deux arguments principaux :

- la définition d'un ensemble de colonnes de notre tableau de données
- une ou plusieurs fonctions à appliquer aux colonnes sélectionnées

Il existe de nombreuses manières de définir les colonnes qu'on souhaite transformer : celles-ci sont en fait les mêmes que celles offertes par le verbe `select()`. Une première possibilité est d'utiliser `c()` en lui passant les noms des variables (on notera qu'on n'est pas obligés de mettre ces noms entre guillemets).

```{r}
hdv2003 %>%
    mutate(
        across(
            c(cinema, cuisine, lecture.bd, bricol),
            recode_oui_non
        )
    )
```

Une autre possibilité est d'utiliser `:`, qui permet de définir une plage de colonnes en lui indiquant la colonne de début et la colonne de fin. Ainsi dans l'exemple suivant notre recodage est appliqué à toutes les colonnes situées entre `hard.rock` et `sport` (incluses).

```{r}
hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            recode_oui_non
        )
    )
```

Une autre possibilité est de sélectionner les variables via leurs noms. On peut ainsi choisir les variables qui commencent par une certaine chaîne de caractères via la fonction `starts_with()`, celles qui se terminent ou qui contiennent certains caractères avec `ends_with()` et `contains()`.

Dans l'exemple suivant, on effectue un `summarise` qui applique la fonction `max()` à toutes les variables de `rp2012` qui commencent par `dipl`.

```{r}
rp2012 %>%
    summarise(
        across(
            starts_with("dipl"),
            max
        )
    )
```

On peut également sélectionner des colonnes via une conditione avec la fonction `where()`. Celle-ci prend elle-même en argument une fonction qui doit renvoyer `TRUE` ou `FALSE`, et ne conserve que les colonnes qui correspondent à des `TRUE`.

Dans l'exemple suivant, on applique la fonction `max` seulement aux colonnes de `hdv2003` pour lesquelles la fonction `is.numeric` renvoie `TRUE`.

```{r}
hdv2003 %>%
    summarise(
        across(
            where(is.numeric),
            max
        )
    )
```

Pour des conditions plus complexes, on doit parfois définir soi-même la fonction passée à `where()`. Ainsi, si on souhaite appliquer `recode_oui_non()` à toutes les colonnes de `hdv2003` contenant la modalité "Oui", on peut faire :

```{r}
detecte_oui <- function(v) {
    "Oui" %in% v
}

hdv2003 %>%
    mutate(
        across(
            where(detecte_oui),
            recode_oui_non
        )
    )
```

Il est même possible, pour les cas les plus complexes, de combiner plusieurs sélections avec les opérateurs `&`, `|` et `!`. L'exemple suivant, applique la fonction `max()` à toutes les colonnes numériques de `hdv2003`, sauf aux colonnes `id` et `poids`.

```{r}
hdv2003 %>%
    summarise(
        across(
            where(is.numeric) & !c(id, poids),
            max
        )
    )
```

Enfin, la fonction spéciale `everything()` permet de sélectionner la totalité des colonnes d'un tableau. Dans l'exemple suivant, on applique `n_distinct()` pour afficher le nombre de valeurs distinctes de toutes les variables de `hdv2003`.

```{r}
hdv2003 %>%
    summarise(
        across(
            everything(),
            n_distinct
        )
    )
```

Il existe encore d'autres possibilités de sélection des colonnes, pour avoir un aperçu complet on pourra se référer à [la page de documentation de la fonction `select()`](https://dplyr.tidyverse.org/reference/select.html).

```{block type='rmdnote'}
Une erreur de syntaxe fréquente est de mettre la sélection des colonnes dans l'appel à `across()`, mais pas la fonction qu'on souhaite appliquer.

Ainsi le code suivant génèrera une erreur :

`mutate(across(hard.rock:sport), recode_oui_non)`

Il faut donc bien penser à passer la fonction comme argument du `across()`, donc à l'intérieur de ses parenthèses.

`mutate(across(hard.rock:sport, recode_oui_non))`
```


Par défaut, lorsqu'on utilise `across()` dans un `mutate`, les nouvelles colonnes portent le même nom que les colonnes d'origine, ce qui signifie que ces dernières sont "écrasées" par les nouvelles valeurs.

Ainsi dans l'exemple suivant vu précédemment, les valeurs d'origine des colonnes entre `hard.rock` et `sport` ont été écrasées par le résultat du recodage.

```{r}
hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            recode_oui_non
        )
    )
```

Si on préfère créer de nouvelles colonnes, on doit indiquer la manière de les nommer en utilisant l'argument `.names` de `across()`. Celui prend comme valeur une chaîne de caractère dans laquelle le motif `{.col}` sera remplacé par le nom de la colonne d'origine.

Ainsi, si on souhaite plutôt que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe `_rec`, on peut utiliser :

```{r}
hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            recode_oui_non,
            .names = "{.col}_rec"
        )
    )
```


### Appliquer plusieurs fonctions à plusieurs colonnes

`across()` offre également la possibilité d'appliquer plusieurs fonctions à un ensemble de colonnes. Dans ce cas, plutôt que de lui passer une seule fonction comme deuxième argument, on lui passe une liste nommée de fonctions.

Le code suivant calcule le minimum et le maximum pour quatre variables de `rp2012`

```{r}
rp2012 %>%
    summarise(
        across(
            cadres:ouvr,
            list(min = min, max = max)
        )
    )
```

Par défaut les nouvelles variables sont nommées sous la forme `{nom_variable}_{nom_fonction}`, mais on peut personnaliser cette règle en ajoutant un argument `.names` à `across()`. Cet argument est une chaîne de caractères dans laquelle `{.col}` sera remplacé par le nom de la colonne courante, et `{.fn}` par le nom de la fonction.

```{r}
rp2012 %>%
    summarise(
        across(
            cadres:ouvr,
            list(min = min, max = max),
            .names = "{.fn}-{.col}"
        )
    )

```

### Renommer plusieurs colonnes avec une fonctions

On a vu précédemment qu'on peut utiliser `rename_with()` pour renommer les colonnes d'un tableau de données à l'aide d'une fonction.

```{r}
remplace_points <- function(v) {
    str_replace_all(v, fixed("."), "_")
}

hdv2003 %>% rename_with(remplace_points)
```

Par défaut, `rename_with()` applique la fonction de renommage à l'ensemble des colonnes du tableau. Il est cependant possible de lui indiquer de ne renommer que certaines de ces colonnes. Pour cela, on peut lui ajouter un argument supplémentaire nommé `.cols`, dont la syntaxe est exactement la même que pour `across()` ou `select()`.

Par exemple, le code suivant convertit en majuscule uniquement les noms des colonnes `id` et `poids`.

```{r}
hdv2003 %>%
    rename_with(str_to_upper, c(id, poids))
```

Et le code suivant remplace les `.` par des `_` uniquement pour les colonnes qui ne sont pas numériques.

```{r}
hdv2003 %>%
    rename_with(remplace_points, .cols = !where(is.numeric))
```



## `rowwise()` et `c_across()` : appliquer une transformation ligne par ligne

Soit le tableau de données d'exemple suivant, qui contient des évaluations de restaurants sur quatre critères différents (on a initialisé les valeurs de chaque critère en tirant au sort des notes entre 0 et 5).

```{r}
alea <- function(n) {
    sample(0:5, size = n, replace = TRUE)
}

restos <- tibble(
    nom = c("La bonne fourchette", "La choucroute de l'amer", "L'Hair de rien", "La blanquette de Vaulx"),
    cuisine = alea(4),
    decor   = alea(4),
    accueil = alea(4),
    prix    = alea(4)
)

restos
```

(Un nom de salon de coiffure s'est glissé dans cette liste de restaurants. Saurez-vous le retrouver ?)

Imaginons qu'on souhaite faire la moyenne, pour chaque restaurant, des critères `decor` et `accueil`. On pourrait être tentés d'utiliser `mean()` de la manière suivante :

```{r}
restos <- restos %>%
    mutate(
        decor_accueil = mean(c(decor, accueil))
    )
```

Si on regarde le résultat, on constate qu'il ne correspond pas à ce que l'on souhaite faire puisque toutes les valeurs sont les mêmes.

```{r}
restos$decor_accueil
```

Que s'est-il passé ? En fait le `mutate` s'est appliqué sur la totalité du tableau. Ceci signifie que dans `mean(c(decor, accueil))`, les objets `decor` et `accueil` correspondent à la totalité des valeurs de chaque variables. On a donc concaténé ces deux vecteurs et calculé la moyenne, qui est du coup la même pour chaque ligne.

La valeur obtenue correspond aux résultat de :

```{r}
mean(c(restos$decor, restos$accueil))
```

Ce que nous souhaitons ici, c'est calculer non pas pour l'ensemble du tableau mais *pour chaque ligne*. Pour cela, on va utiliser la fonction `rowwise()`. Celle-ci est équivalente à un `group_by()` qui créerait autant de groupes qu'il y a de lignes dans notre tableau :

```{r}
restos %>% rowwise()
```

Quant notre tableau est groupé via un `rowwise()`, les opérations s'effectuent sur un tableau de données constitué uniquement de la ligne courante. Si on calcule la moyenne précédente, on obtient désormais le bon résultat :

```{r}
restos <- restos %>%
    rowwise() %>%
    mutate(decor_accueil = mean(c(decor, accueil)))

restos$decor_accueil
```

Supposons qu'on souhaite désormais calculer la moyenne de l'ensemble des critères. On peut évidemment reprendre le code précédent en saisissant toutes les variables concernées.

```{r}
restos %>%
    rowwise() %>%
    mutate(decor_accueil = mean(c(decor, accueil, cuisine, prix)))
```

Ceci peut cependant être peu pratique si le nombre de variables est important. C'est pourquoi `dplyr` propose la fonction `c_across()` : celle-ci permet de sélectionner des colonnes de la même manière que `select()` ou `across()`, et retourne un vecteur constitué des valeurs concaténées de ces colonnes.

L'exemple suivant calcule la moyenne de toutes les colonnes comprises entre `cuisine` et `prix`, en utilisant l'opérateur `:`.

```{r}
restos %>%
    rowwise() %>%
    mutate(
        total = mean(c_across(decor:prix))
    )
```

Comme pour `across()` ou `select()`, on peut utiliser la fonction `where()` pour calculer la moyenne sur toutes les colonnes numériques.

```{r}
restos %>%
    rowwise() %>%
    mutate(
        total = mean(
            c_across(where(is.numeric))
        )
    )
```


L'utilisation de `rowwise()` et `c_across()` est intéressante principalement quand il n'existe pas de fonction vectorisée pour la transformation qu'on souhaite appliquer. Quand elle existe, il est en général plus simple et plus rapide de l'utiliser.

Par exemple, pour trouver la valeur la plus élevée par restaurant, on pourrait être tenté d'utiliser le code suivant :

```{r}
restos %>%
    rowwise() %>%
    summarise(note_max = max(c(decor, accueil)))
```

Il est cependant plus lisible et plus efficace d'utiliser la fonction `pmax`, qui a justement pour objectif de parcourir des vecteurs en parallèle et de ne conserver que la plus grande valeur.

```{r}
restos %>%
    summarise(note_max = pmax(decor, accueil))
```

Une des limites de `pmax` cependant est qu'on ne peut pas l'utiliser avec `c_across()`, et qu'on ne peut donc pas faire de sélection des colonnes : on est obligés de taper leurs noms.

```{r}
restos %>%
    summarise(note_max = pmax(cuisine, decor, accueil, prix))
```

Dans certains cas, notamment lorsque les colonnes sont nombreuses où qu'on ne les a pas identifiées à l'avance, on pourra  utiliser `rowwise()` et `c_across()` même quand des alternatives vectorisées existent.

```{r}
restos %>%
    rowwise() %>%
    summarise(
        note_max = max(
            c_across(where(is.numeric))
        )
    )
```

## Fonctions anonymes et notations abrégées

Dans les sections précédentes, nous avons rencontré plusieurs fonctions, comme `rename_with()` ou `across()`, qui prennent  une fonction en argument.

Par exemple, dans l'utilisation suivante de `rename_with()`, on avait créé une fonction `remplace_points()`.

```{r}
remplace_points <- function(v) {
    str_replace_all(v, fixed("."), "_")
}

hdv2003 %>% rename_with(remplace_points)
```

Le fait de créer une fonction à part pour une opération d'une seule ligne ne se justifie pas forcément, surtout si on n'utilise pas cette fonction ailleurs dans notre code. Dans, ce cas, on peut définir notre fonction directement dans l'appel à `rename_with()` en utilisant une *fonction anonyme*.

```{r}
hdv2003 %>%
    rename_with(function(v) {
        str_replace_all(v, fixed("."), "_")
    })
```

Cette notation est assez pratique et souvent utilisée pour les fonctions à unage unique, ne serait-ce que pour s'économiser le fait de devoir lui trouver un nom pertinent.

La notation étant un peu lourde, il existe deux alternatives permettant une définition plus "compacte". 

- La première est propre aux packages du *tidyverse* (notamment `dplyr` et `purrr`), et ne fonctionnera pas pour les fonctions n'appartenant pas à ces packages. Il s'agit d'utiliser une notation de type "formule" : le corps de la formule contient les instructions de la fonction, et les arguments sont nommés `.x` (ou `.`) s'il n'y en a qu'un, `.x` et `.y` s'il y en a deux, et `..1`, `..2`, etc. s'ils sont plus nombreux.

- La deuxième est une notation apparue avec la version 4.1 de R, qui permet de remplacer `function(...)` par le raccourci `\(...)`.

Ainsi les définitions suivantes sont équivalents :

```{r}
# Fonctionne partout et tout le temps
function(x) { x + 2 }
# Fonctionne uniquement dans les fonctions du tidyverse
~ .x + 2
# Fonctionne uniquement à partir de R 4.1
\(x) x + 2
```

De même que les définitions suivantes :

```{r}
function(v1, v2) {
    res <- v1 / v2
    round(res, 1)
}

~ { 
    res <- .x / .y
    round(res, 1) 
}

\(v1, v2) {
    res <- v1 / v2
    round(res, 1)
}
```

On pourra du coup, si on le souhaite, utiliser ces notations compactes dans notre `rename_with()` pour définir notre fonction anonyme.

```{r eval = FALSE}
hdv2003 %>%
    rename_with(~ str_replace_all(.x, fixed("."), "_"))

hdv2003 %>%
    rename_with(\(x) str_replace_all(x, fixed("."), "_"))
```

Cette notation peut être utilisée partout où on peut passer une fonction comme argument et donc définir des fonctions anonymes. Dans l'exemple suivant déjà vu précédemment, on passe la fonction `detecte_oui` comme argument de `where()`.

```{r eval=FALSE}
detecte_oui <- function(v) {
    "Oui" %in% v
}

hdv2003 %>%
    mutate(
        across(
            where(detecte_oui),
            recode_oui_non
        )
    )
```

On peut donc remplacer la fonction par une fonction anonyme définie directement dans le `where()`.

```{r eval=FALSE}
hdv2003 %>%
    mutate(
        across(
            where(function(v) { "Oui" %in% v }),
            recode_oui_non
        )
    )
```

Et du coup utiliser une des deux notations "compactes".

```{r eval=FALSE}
hdv2003 %>%
    mutate(
        across(
            where(~ "Oui" %in% .),
            recode_oui_non
        )
    )

hdv2003 %>%
    mutate(
        across(
            where(\(v) "Oui" %in% v),
            recode_oui_non
        )
    )
```


## Ressources

[La page d'aide de la fonction `select`](https://dplyr.tidyverse.org/reference/select.html) (en anglais) liste toutes les possibilités offertes pour spécifier des ensembles de colonnes d'un tableau de données.

La vignette [Column-wise operations](https://dplyr.tidyverse.org/articles/colwise.html) de `dplyr` (en anglais) présente en détail l'utilisation et les fonctionnalités de `across()`.

La vignette [Row-wise operations](https://dplyr.tidyverse.org/articles/rowwise.html) de `dplyr` (toujours en anglais) présente de manière approfondie l'utilisation de `rowwise()` et `c_across()` pour opérer individuellement sur les lignes d'un tableau de données.


## Exercices

Pour certains des exercices qui suivent on utilisera le jeu de données `starwars` de `dplyr`. On peut le charger avec les instructions suivantes :

```{r}
library(dplyr)
data(starwars)
```

Le jeu de données contient les caractéristiques de 87 personnages présents dans les films : espèce, âge, planète d'origine, etc.

### Appliquer ses propres fonctions

**Exercice 1.1**

Créer une fonction `imc` prend en argument un vecteur `taille` (en cm) et un vecteur `poids` (en kg) et retourne les valeurs correspondante de l'indice de masse corporelle, qui se calcule en divisant le poids en kilos par la taille en mètres au carré.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
imc <- function(tailles, poids) {
    tailles_m <- tailles/100
    poids / tailles_m ^ 2
}
```
</div>
\fi

Utiliser cette fonction pour ajouter une nouvelle variable `imc` au tableau `starwars`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
starwars %>%
    mutate(imc = imc(height, mass))
```
</div>
\fi

Utiliser à nouveau cette fonction pour calculer l'IMC moyen selon les valeurs de la variable `species`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
starwars %>%
    group_by(species) %>%
    summarise(
        imc = mean(imc(height, mass), na.rm = TRUE)
    )
```
</div>
\fi

**Exercice 1.2**

À l'aide d'un `group_by()` et d'un `summarise()`, calculer pour chaque valeur de la variable `sex` la valeur de l'étendue de la variable `height` du jeu de données `starwars`, c'est-à-dire la différence entre sa valeur maximale et sa valeur minimale.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
starwars %>%
    group_by(sex) %>%
    summarise(etendue_taille = max(height, na.rm = TRUE) - min(height, na.rm = TRUE))
```
</div>
\fi

En partant du code précédent, créer une fonction `etendue` qui prend en argument un vecteur et retourne la différence entre sa valeur maximale et sa valeur minimale. En utilisant cette fonction, calculer pour chaque valeur de `sex` la valeur de l'étendue des variables `height` et `mass`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
etendue <- function(v) {
    max(v, na.rm = TRUE) - min(v, na.rm = TRUE)
}
starwars %>%
    group_by(sex) %>%
    summarise(
        etendue_taille = etendue(height),
        etendue_poids  = etendue(mass)
    )
```
</div>
\fi


**Exercice 1.3**

La liste suivante donne, pour chacun des neuf principaux films de la saga *Star Wars*, la date à laquelle ils se déroulent dans l'univers de la saga.

```{r}
list(
    "I"    = -32,
    "II"   = -22,
    "III"  = -19,
    "IV"   =   0,
    "V"    =   3,
    "VI"   =   4,
    "VII"  =  34,
    "VIII" =  34,
    "IX"   =  35
)
```

Dans le jeu de données `starwars`, la variable `birth_year` indique l'année de naissance du personnage en "années avant l'an zéro" (une valeur de 19 signifie donc une année de naissance de -19).

Créer une fonction `age_film` qui prend en entrée un vecteur d'années de naissance au même format que `birth_year` ainsi que l'identifiant d'un film, et calcule les âges correspondant à ces années de naissance à la date du film en question. 

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
age_film <- function(annees, film) {
    annees_films <- list(
        "I"    = -32,
        "II"   = -22,
        "III"  = -19,
        "IV"   =   0,
        "V"    =   3,
        "VI"   =   4,
        "VII"  =  34,
        "VIII" =  34,
        "IX"   =  35
    )
    annees_naissance <- -annees
    annee_ref <- annees_films[[film]]
    annee_ref - annees_naissance
}
```
</div>
\fi

Modifier la fonction pour qu'elle retourne un message d'erreur si l'identifiant du film n'a pas été reconnu.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
age_film <- function(annees, film) {
    annees_films <- list(
        "I"    = -32,
        "II"   = -22,
        "III"  = -19,
        "IV"   =   0,
        "V"    =   3,
        "VI"   =   4,
        "VII"  =  34,
        "VIII" =  34,
        "IX"   =  35
    )
    if (!(film %in% names(annees_films))) {
        stop("L'identifiant du film n'a pas été reconnu")
    }
    annees_naissance <- -annees
    annee_ref <- annees_films[[film]]
    annee_ref - annees_naissance
}
```
</div>
\fi

Utiliser la fonction pour ajouter deux nouvelles variables au tableau `starwars` : `age_iv` qui correspond à l'âge (potentiel) au moment du film IV, et `age_ix` qui correspond à l'âge au moment du film IX.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
starwars %>%
    mutate(
        age_iv = age_film(birth_year, "IV"),
        age_ix = age_film(birth_year, "IX"),
    )
```
</div>
\fi


### `across()`

**Exercice 2.1**

Reprendre la fonction `etendue` de l'exercice 1.2 :

```{r}
etendue <- function(v) {
    max(v, na.rm = TRUE) - min(v, na.rm = TRUE)
}
```

À l'aide de `across()` calculer l'étendue des variables `height` et `mass` pour chaque valeur de `sex`.

```{r}
starwars %>%
    group_by(sex) %>%
    summarise(
        across(
            c(height, mass),
            etendue
        )
    )
```

Toujours à l'aide d'`across()`, appliquer `etendue` de la même manière à toutes les variables numériques.

```{r}
starwars %>%
    group_by(sex) %>%
    summarise(
        across(
            where(is.numeric),
            etendue
        )
    )
```

En utilisant `&` et `!`, appliquer `etendue` à toutes les variables numériques sauf à celles qui finissent par "year".

```{r}
starwars %>%
    group_by(sex) %>%
    summarise(
        across(
            where(is.numeric) & !ends_with("year"),
            etendue
        )
    )
```

**Exercice 2.2**

Dans le jeu de données `starwars`, appliquer en un seul `summarise` les fonctions `min` et `max` aux variables `height` et `mass`.

```{r}
starwars %>%
    summarise(
        across(
            c(height, mass),
            list(min = min, max = max)
        )
    )
```

Modifier le code précédent pour que le calcul des valeurs minimales et maximales ne prennent pas en compte les valeurs manquantes.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
funs <- list(
    min = function(v) { min(v, na.rm = TRUE) },
    max = function(v) { max(v, na.rm = TRUE) }
)
starwars %>%
    summarise(
        across(
            c(height, mass),
            funs
        )
    )
# Autre possibilité : les arguments supplémentaires passés à across() sont
# transmis aux fonctions appliquées
starwars %>%
    summarise(
        across(
            c(height, mass),
            list(min = min, max = max),
            na.rm = TRUE
        )
    )
```
</div>
\fi


**Exercice 2.3**

Dans le jeu de données `hdv2003`, utiliser `across()` pour transformer les modalités "Oui" et "Non" en `TRUE` et `FALSE` pour toutes les variables de `hard.rock` à `sport`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
detecte_oui <- function(v) {
    v == "Oui"
}
hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            detecte_oui
        )
    )
```
</div>
\fi

Ajouter un argument `.names` à `across()` pour que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe `"_true"`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
detecte_oui <- function(v) {
    v == "Oui"
}
hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            detecte_oui,
            .names = "{.col}_true"
        )
    )
```
</div>
\fi


### `rowwise()` et `c_across()`

**Exercice 3.1**

On repart du code final de l'exercice 2.3, qui recodait une série de variables de `hdv2003` en valeurs `TRUE`/`FALSE` dans de nouvelles variables avec le suffixe "_true".

```{r}
detecte_oui <- function(v) {
    v == "Oui"
}
hdv2003 <- hdv2003 %>%
    mutate(
        across(
            hard.rock:sport,
            detecte_oui,
            .names = "{.col}_true"
        )
    )
```

Sans utiliser `rowwise()`, calculer le plus simplement possible une nouvelle variable `total` qui contient le nombre total de `TRUE` pour les variables `cinema_true` et `sport_true`.

```{r}
hdv2003 %>%
    mutate(total = cuisine_true + sport_true)
```

En utilisant `rowwise()` et `sum()`, recalculer la variable `total` pour qu'elle contienne le nombre total de `TRUE` pour les variables `bricol_true`, `cinema_true` et `sport_true`.

```{r}
hdv2003 %>%
    rowwise() %>%
    mutate(total = sum(cuisine_true, sport_true, bricol_true))
```

En utilisant `rowwise()`, `sum()` et `c_across()`, recalculer la variable `total` pour qu'elle contienne le nombre total de `TRUE` pour toutes les variables se terminant par "_true".

```{r}
hdv2003 %>%
    rowwise() %>%
    mutate(total = sum(c_across(ends_with("_true"))))
```

Reprendre le code précédent pour qu'il puisse s'appliquer directement sur les variables `hard.rock`...`sport`, sans passer par le recodage en `TRUE`/`FALSE`. 

```{r}
count_oui <- function(v) {
    sum(v == "Oui")
}
hdv2003 %>%
    rowwise() %>%
    mutate(
        total = count_oui(c_across(hard.rock:sport))
    )
```

**Exercice 3.2**

Dans le jeu de données `starwars`, la colonne `films` contient la liste des films dans lesquels apparaissent les différents personnages. Cette colonne a une forme un peu particulière puisqu'il s'agit d'une "colonne-liste" : les éléments de cette colonne sont eux-mêmes des listes :

```{r}
head(starwars$films, 3)
```

On essaye de calculer le nombre films pour chaque personnage avec le code suivant. Est-ce que ça fonctionne ? Pourquoi ?

```{r}
starwars %>%
    mutate(n_films = length(films))
```

Trouver une manière d'obtenir le résultat attendu.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
starwars %>%
    rowwise() %>%
    mutate(n_films = length(films))
```
</div>
\fi


### Fonctions anonymes et notations abrégées

**Exercice 4.1**

Soit le code suivant, qui renomme les colonnes du tableau `starwars` de type liste en leur ajoutant le préfixe "liste_".

```{r}
ajoute_prefixe_liste <- function(nom) {
    paste0("liste_", nom)
}

starwars %>%
    rename_with(ajoute_prefixe_liste, .cols = where(is.list))
```

Réécrire ce code avec une fonction anonyme en utilisant les trois notations : 

- classique (avec `function()`)
- formule (du *tidyverse*)
- compacte (à partir de R 4.1)

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
# Classique
starwars %>%
    rename_with(function(nom) { paste0("liste_", nom) }, .cols = where(is.list))
# Formule
starwars %>%
    rename_with(~ paste0("liste_", .x), .cols = where(is.list))
# Compacte
starwars %>%
    rename_with(\(nom) paste0("liste_", nom), .cols = where(is.list))
```
</div>
\fi

**Exercice 4.2**

TODO: which.max ne retourne que la première commune à chaque fois

Le code suivant indique, pour chaque région du jeu de données `rp2012`, le nom de la commune ayant la valeur maximale pour les variables `dipl_aucun` et `dipl_sup`.

```{r}
nom_commune_max <- function(valeurs, communes) {
    communes[which.max(valeurs)]
}
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            nom_commune_max,
            commune
        )
    )
```

Réécrire ce code en utilisant une fonction anonyme, avec la syntaxe de votre choix (classique, formule ou compacte).

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
# Classique
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            function(valeurs, communes) { communes[which.max(valeurs)] },
            commune
        )
    )
# Formule
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            ~ .y[which.max(.x)],
            commune
        )
    )
# Compacte
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            \(valeurs, communes) communes[which.max(valeurs)],
            commune
        )
    )
```
</div>
\fi

À l'aide d'une fonction anonyme supplémentaire, modifier le code pour qu'il retourne également, pour les mêmes variables, le nom des communes avec les valeurs minimales.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
# Formule
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            list(
                max = ~ .y[which.max(.x)],
                min = ~ .y[which.min(.x)]
            ),
            commune
        )
    )
# Compacte
rp2012 %>%
    group_by(region) %>%
    summarise(
        across(
            c(dipl_aucun, dipl_sup),
            list(
                max = \(valeurs, communes) communes[which.max(valeurs)],
                min = \(valeurs, communes) communes[which.min(valeurs)]
            ),
            commune
        )
    )
```
</div>
\fi

