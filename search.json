[
  {
    "objectID": "index.html#à-propos-de-ce-document",
    "href": "index.html#à-propos-de-ce-document",
    "title": "Introduction à R et au tidyverse",
    "section": "À propos de ce document",
    "text": "À propos de ce document\nCe document est une introduction à R, logiciel libre de traitement et d’analyse de données. Il se veut le plus accessible possible, y compris pour ceux qui ne sont pas particulièrement familiers avec l’informatique. Il se base à la fois sur les fonctionnalités de R “de base”, et sur une série d’extensions regroupées sous l’appellation tidyverse.\nCe document n’est pas une introduction aux méthodes statistiques d’analyse de données.\nIl est basé sur R version 4.2.2 (2022-10-31).\nCe document est régulièrement corrigé et mis à jour. La version HTML de référence est disponible en ligne, et il est téléchargeable aux formats PDF et EPUB.\nCe document est généré avec quarto, et son code source est disponible sur GitHub."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "Introduction à R et au tidyverse",
    "section": "Remerciements",
    "text": "Remerciements\nUn remerciement tout particulier à mes formidables collègues Sofiane Bouzid, Behnaz Khosravi et Karine Pietropaoli pour leurs nombreux et utiles retours sur la partie Aller plus loin.\nCe document a également bénéficié de la relecture, des suggestions et des corrections d’Éric Wiest, Diane Rodet, Mayeul Kauffmann, Jimmy Raturat, Fabienne Marquant, Julien Biaudet, Frédérique Giraud, Joël Gombin, Milan Bouchet-Valat et Joseph Larmarange."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "Introduction à R et au tidyverse",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International.\n\n\n\nLicence Creative Commons"
  },
  {
    "objectID": "01-presentation.html#à-propos-de-r",
    "href": "01-presentation.html#à-propos-de-r",
    "title": "1  Présentation",
    "section": "1.1 À propos de R",
    "text": "1.1 À propos de R\nR est un langage orienté vers le traitement et l’analyse quantitative de données, dérivé du langage . Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une large communauté d’utilisateurs et utilisatrices. C’est un logiciel libre, publié sous licence GNU GPL.\nL’utilisation de R présente plusieurs avantages :\n\nc’est un logiciel multiplateforme, qui fonctionne aussi bien sur des sytèmes Linux, Mac OS X ou Windows.\nc’est un logiciel libre, développé par ses utilisateurs et utilisatrices, diffusable et modifiable par tout un chacun.\nc’est un logiciel gratuit.\nc’est un logiciel puissant, dont les fonctionnalités de base peuvent être étendues à l’aide d’extensions développées par la communauté. Il en existe plusieurs milliers.\nc’est un logiciel avec d’excellentes capacités graphiques.\n\nComme rien n’est parfait, on peut également trouver quelques inconvénients :\n\nle logiciel, la documentation de référence et les principales ressources sont en anglais. Il est toutefois parfaitement possible d’utiliser R sans spécialement maîtriser cette langue et il existe de plus en plus de ressources francophones.\nR n’est pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à l’aide de scripts (des petits programmes) édités et exécutés au fur et à mesure de l’analyse.\nen tant que langage de programmation, R a la réputation d’être difficile d’accès, notamment pour ceux n’ayant jamais programmé auparavant.\n\nCe document ne demande aucun prérequis en informatique ou en programmation. Juste un peu de motivation pour l’apprentissage du langage et, si possible, des données intéressantes sur lesquelles appliquer les connaissances acquises.\nL’aspect langage de programmation et la difficulté qui en découle peuvent sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite d’instructions effectuant les différentes opérations d’une analyse) présente cependant de nombreux avantages :\n\nle script conserve l’ensemble des étapes d’une analyse, de l’importation des données à leur analyse en passant par les manipulations et les recodages.\non peut à tout moment revenir en arrière et corriger ou modifier ce qui a été fait.\nil est très rapide de réexécuter une suite d’opérations complexes.\non peut très facilement mettre à jour les résultats en cas de modification des données sources.\nle script garantit, sous certaines conditions, la reproductibilité des résultats obtenus."
  },
  {
    "objectID": "01-presentation.html#sec-rstudio",
    "href": "01-presentation.html#sec-rstudio",
    "title": "1  Présentation",
    "section": "1.2 À propos de RStudio",
    "text": "1.2 À propos de RStudio\nRStudio n’est pas à proprement parler une interface graphique pour R, il s’agit plutôt d’un environnement de développement intégré, qui propose des outils facilitant l’écriture de scripts et l’usage de R au quotidien. C’est une interface bien supérieure à celles fournies par défaut lorsqu’on installe R sous Windows ou sous Mac1.\nPour paraphraser Hadrien Commenges, il n’y a pas d’obligation à utiliser RStudio, mais il y a une obligation à ne pas utiliser les interfaces de R par défaut.\nRStudio est également un logiciel libre et gratuit. Une version payante existe, mais elle ne propose pas de fonctionnalités indispensables."
  },
  {
    "objectID": "01-presentation.html#à-propos-du-tidyverse",
    "href": "01-presentation.html#à-propos-du-tidyverse",
    "title": "1  Présentation",
    "section": "1.3 À propos du tidyverse",
    "text": "1.3 À propos du tidyverse\nLe tidyverse est un ensemble d’extensions pour R (code développé par la communauté permettant de rajouter des fonctionnalités à R) construites autour d’une philosophie commune et conçues pour fonctionner ensemble. Elles facilitent l’utilisation de R dans les domaines les plus courants : manipulation des données, recodages, production de graphiques, etc.\nLa deuxième partie de ce document est entièrement basée sur les extensions du tidyverse, qui est présenté plus en détail Chapitre 6."
  },
  {
    "objectID": "01-presentation.html#structure-du-document",
    "href": "01-presentation.html#structure-du-document",
    "title": "1  Présentation",
    "section": "1.4 Structure du document",
    "text": "1.4 Structure du document\nCe document est composé de trois grandes parties :\n\nUne Introduction à R, qui présente les bases du langage R et de l’interface RStudio\nUne Introduction au tidyverse qui présente cet ensemble d’extensions pour la visualisation, la manipulation des données et l’export de résultats\nUne partie Aller plus loin qui présente comment créer ses propres fonctions et introduit des notions de programmation plus avancées\n\nLes personnes déjà familières avec R “de base” peuvent passer directement à l’Introduction au tidyverse."
  },
  {
    "objectID": "01-presentation.html#prérequis",
    "href": "01-presentation.html#prérequis",
    "title": "1  Présentation",
    "section": "1.5 Prérequis",
    "text": "1.5 Prérequis\nLe seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux.\nPour installer R, il suffit de se rendre sur une des pages suivantes 2 :\n\nInstaller R sous Windows\nInstaller R sous Mac\n\nPour installer RStudio, rendez-vous sur la page de téléchargement du logiciel et installez la version adaptée à votre système."
  },
  {
    "objectID": "01-presentation.html#footnotes",
    "href": "01-presentation.html#footnotes",
    "title": "1  Présentation",
    "section": "",
    "text": "Sous Linux R n’est fourni que comme un outil en ligne de commande.↩︎\nSous Linux, utilisez votre gestionnaire de packages habituel.↩︎"
  },
  {
    "objectID": "02-prise_en_main.html#la-console",
    "href": "02-prise_en_main.html#la-console",
    "title": "2  Prise en main",
    "section": "2.1 La console",
    "text": "2.1 La console\n\n2.1.1 L’invite de commandes\nAu premier lancement de RStudio, l’interface est organisée en trois grandes zones.\n\n\n\nInterface de Rstudio\n\n\nLa zone de gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nLa Console doit normalement afficher un texte de bienvenue ressemblant à ceci :\nR version 4.2.2 Patched (2022-11-10 r83330) -- \"Innocent and Trusting\"\nCopyright (C) 2022 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu (64-bit)\n\nR est un logiciel libre livré sans AUCUNE GARANTIE.\nVous pouvez le redistribuer sous certaines conditions.\nTapez 'license()' ou 'licence()' pour plus de détails.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nTapez 'demo()' pour des démonstrations, 'help()' pour l'aide\nen ligne ou 'help.start()' pour obtenir l'aide au format HTML.\nTapez 'q()' pour quitter R.\nsuivi d’une ligne commençant par le caractère &gt; et sur laquelle devrait se trouver votre curseur. Cette ligne est appelée l’invite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine instruction.\nNous pouvons tout de suite lui fournir une première commande, en saisissant le texte suivant puis en appuyant sur Entrée :\n\n2 + 2\n#&gt; [1] 4\n\nR nous répond immédiatement, et nous pouvons constater avec soulagement qu’il sait faire des additions à un chiffre1. On peut donc continuer avec d’autres opérations :\n\n5 - 7\n#&gt; [1] -2\n4 * 12\n#&gt; [1] 48\n-10 / 3\n#&gt; [1] -3.333333\n5^2\n#&gt; [1] 25\n\nCette dernière opération utilise le symbole ^ qui représente l’opération puissance. 5^2 signifie donc “5 au carré”.\n\n\n2.1.2 Précisions concernant la saisie des commandes\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap."
  },
  {
    "objectID": "02-prise_en_main.html#objets",
    "href": "02-prise_en_main.html#objets",
    "title": "2  Prise en main",
    "section": "2.2 Objets",
    "text": "2.2 Objets\n\n2.2.1 Objets simples\nFaire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller.\nPour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n#&gt; [1] 2\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n#&gt; [1] 6\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n#&gt; [1] 7\n\n\n\n\n\n\n\nAvertissement\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n#&gt; [1] 5\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n#&gt; [1] 3\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n#&gt; [1] 3\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n#&gt; [1] \"Chihuahua\"\n\n\n\n2.2.2 Vecteurs\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n#&gt; [1] 167.4\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n#&gt; [1] 156 164 197 147 173\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n#&gt; [1] 1.56 1.64 1.97 1.47 1.73\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n#&gt; [1] 166 174 207 157 183\ntailles^2\n#&gt; [1] 24336 26896 38809 21609 29929\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n#&gt; [1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n#&gt; [1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n#&gt; [1] \"Bac\"\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre2 :\n [1] 4"
  },
  {
    "objectID": "02-prise_en_main.html#fonctions",
    "href": "02-prise_en_main.html#fonctions",
    "title": "2  Prise en main",
    "section": "2.3 Fonctions",
    "text": "2.3 Fonctions\n\n2.3.1 Principe\nNous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n#&gt; [1] 5\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n#&gt; [1] 147\nmax(tailles)\n#&gt; [1] 197\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n#&gt; [1] 167.4\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n#&gt; [1] 837\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n#&gt; [1] 147 197\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n#&gt; [1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n2.3.2 Arguments\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur3.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n#&gt; [1] 156 164 197  NA 173\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n#&gt; [1] NA\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(tailles, na.rm = TRUE)\n#&gt; [1] 172.5\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n#&gt; [1] NA\nmean(tailles, na.rm = FALSE)\n#&gt; [1] NA\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n2.3.3 Aide sur une fonction\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide."
  },
  {
    "objectID": "02-prise_en_main.html#regrouper-ses-commandes-dans-des-scripts",
    "href": "02-prise_en_main.html#regrouper-ses-commandes-dans-des-scripts",
    "title": "2  Prise en main",
    "section": "2.4 Regrouper ses commandes dans des scripts",
    "text": "2.4 Regrouper ses commandes dans des scripts\nJusqu’ici on a utilisé R de manière “interactive”, en saisissant des commandes directement dans la console. Ça n’est cependant pas la manière dont on va utiliser R au quotidien, pour une raison simple : lorsque R ou RStudio redémarre, tout ce qui a été effectué dans la console est perdu.\nPlutôt que de saisir nos commandes dans la console, on va donc les regrouper dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nPour créer un script, il suffit de sélectionner le menu File, puis New file et R script. Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nUn script est un fichier texte brut, qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne (comme on pouvait s’y attendre).\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nAu final, un script pourra ressembler à quelque chose comme ça :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n2.4.1 Commentaires\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jussqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)"
  },
  {
    "objectID": "02-prise_en_main.html#sec-packages",
    "href": "02-prise_en_main.html#sec-packages",
    "title": "2  Prise en main",
    "section": "2.5 Installer et charger des extensions (packages)",
    "text": "2.5 Installer et charger des extensions (packages)\nR étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio.\n\n\n\nInstaller une extension\n\n\nIl suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\n\n\n\nInstallation d’une extension\n\n\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante."
  },
  {
    "objectID": "02-prise_en_main.html#exercices",
    "href": "02-prise_en_main.html#exercices",
    "title": "2  Prise en main",
    "section": "2.6 Exercices",
    "text": "2.6 Exercices\nExercice 1\nConstruire le vecteur x suivant :\n\n#&gt; [1] 120 134 256  12\n\n\n\nx &lt;- c(120, 134, 256, 12)\n\n\nUtiliser ce vecteur x pour générer les deux vecteurs suivants :\n\n#&gt; [1] 220 234 356 112\n#&gt; [1] 240 268 512  24\n\n\n\nx + 100\nx * 2\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n\nrevenu_total &lt;- conjoint1 + conjoint2\nrevenu_total / nb_personnes\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n\n\nrange(conjoint1)\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n\n\nrange(conjoint1, na.rm = TRUE)\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\nCalculer la quantité totale de précipitations sur l’année.\n\n\nmean(temperature)\nsum(precipitations)\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations)\n#&gt;  [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\nMême question pour :\n\ndiff(temperature)\n#&gt;  [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2\n\n\ncumsum(precipitations) correspond à la somme cumulée des précipitations sur l’année. Par exemple, la 6e valeur du vecteur résultat correspond au total de précipitations de janvier à juin.\ndiff(temperature) correspond à la différence de température d’un mois sur l’autre. Par exemple, la 2e valeur de ce vecteur correspond à l’écart de température entre le mois de février et le mois de janvier.\n\nExercice 5\nOn a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs :\n\nmaths &lt;- c(12, 16, 8, 18, 6, 10)\nanglais &lt;- c(14, 9, 13, 15, 17, 11)\nsport &lt;- c(18, 11, 14, 10, 8, 12)\n\nCalculer la moyenne des élèves de la classe en anglais.\n\n\nmean(anglais)\n\n\nCalculer la moyenne générale de chaque élève (la moyenne des ses notes dans les trois matières).\n\n\n(maths + anglais + sport) / 3\n\n\nEssayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) :\n\npmin(maths, anglais, sport)\n#&gt; [1] 12  9  8 10  6 10\n\n\npmax(maths, anglais, sport)\n#&gt; [1] 18 16 14 18 17 12\n\n\npmin et pmax renvoient les minimum et maximum “parallèles” des trois vecteurs passés en argument. Ainsi, pmin renvoie pour chaque élève la note minimale dans les trois matières, et pmax la note maximale."
  },
  {
    "objectID": "02-prise_en_main.html#footnotes",
    "href": "02-prise_en_main.html#footnotes",
    "title": "2  Prise en main",
    "section": "",
    "text": "On peut ignorer pour le moment la présence du [1] en début de ligne.↩︎\nEt permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎\nc est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎"
  },
  {
    "objectID": "03-premier_travail.html#jeu-de-données-dexemple",
    "href": "03-premier_travail.html#jeu-de-données-dexemple",
    "title": "3  Premier travail avec des données",
    "section": "3.1 Jeu de données d’exemple",
    "text": "3.1 Jeu de données d’exemple\nDans cette partie nous allons (enfin) travailler sur des “vraies” données, et utiliser un jeu de données présent dans l’extension questionr. Nous devons donc avant toute chose installer cette extension.\nPour installer ce package, deux possibilités :\n\nDans l’onglet Packages de la zone de l’écran en bas à droite, cliquez sur le bouton Install. Dans le dialogue qui s’ouvre, entrez “questionr” dans le champ Packages puis cliquez sur Install.\nSaisissez directement la commande suivante dans la console : install.packages(\"questionr\")\n\nDans les deux cas, tout un tas de messages devraient s’afficher dans la console. Attendez que l’invite de commandes &gt; apparaisse à nouveau.\nPour plus d’informations sur les extensions et leur installation, voir Section 2.5.\nLe jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour une description plus complète et une liste des variables, voir la Section A.3.2.2.\nPour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) :\n\nlibrary(questionr)\n\nL’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension.\nNous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data :\n\ndata(hdv2003)\n\nCette commande ne renvoie aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003.\n\n\n\nOnglet Environment\n\n\nCet objet est d’un type nouveau : il s’agit d’un tableau de données."
  },
  {
    "objectID": "03-premier_travail.html#tableau-de-données-data-frame",
    "href": "03-premier_travail.html#tableau-de-données-data-frame",
    "title": "3  Premier travail avec des données",
    "section": "3.2 Tableau de données (data frame)",
    "text": "3.2 Tableau de données (data frame)\nUn data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel.\nSi on se contente d’exécuter le nom de notre tableau de données R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile.\n\nhdv2003\n\nUne autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment :\n\n\n\nView icon\n\n\nOu d’utiliser la fonction View :\n\nView(hdv2003)\n\nDans les deux cas votre tableau devrait s’afficher dans RStudio avec une interface de type tableur :\n\n\n\nInterface “View”\n\n\nIl est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille1.\n\n\n\n\n\n\nNote\n\n\n\nSous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine.\n\n\nUn data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire :\n\nd &lt;- hdv2003\n\nce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite.\nPour résumer, comme nous avons désormais décidé de saisir nos commandes dans un script et non plus directement dans la console, les premières lignes de notre fichier de travail sur les données de l’enquête Histoire de vie pourraient donc ressembler à ceci :\n\n## Chargement des extensions nécessaires\nlibrary(questionr)\n\n## Jeu de données hdv2003\ndata(hdv2003)\nd &lt;- hdv2003\n\n\n3.2.1 Structure du tableau\nUn tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau.\n\nnrow(d)\n#&gt; [1] 2000\n\n\nncol(d)\n#&gt; [1] 20\n\nLa fonction dim renvoie ses dimensions, donc les deux nombres précédents.\n\ndim(d)\n#&gt; [1] 2000   20\n\nLa fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables.\n\nnames(d)\n#&gt;  [1] \"id\"            \"age\"           \"sexe\"          \"nivetud\"      \n#&gt;  [5] \"poids\"         \"occup\"         \"qualif\"        \"freres.soeurs\"\n#&gt;  [9] \"clso\"          \"relig\"         \"trav.imp\"      \"trav.satisf\"  \n#&gt; [13] \"hard.rock\"     \"lecture.bd\"    \"peche.chasse\"  \"cuisine\"      \n#&gt; [17] \"bricol\"        \"cinema\"        \"sport\"         \"heures.tv\"\n\nEnfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type 2 et affiche les premières valeurs.\n\nstr(d)\n#&gt; 'data.frame':    2000 obs. of  20 variables:\n#&gt;  $ id           : int  1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ age          : int  28 23 59 34 71 35 60 47 20 28 ...\n#&gt;  $ sexe         : Factor w/ 2 levels \"Homme\",\"Femme\": 2 2 1 1 2 2 2 1 2 1 ...\n#&gt;  $ nivetud      : Factor w/ 8 levels \"N'a jamais fait d'etudes\",..: 8 NA 3 8 3 6 3 6 NA 7 ...\n#&gt;  $ poids        : num  2634 9738 3994 5732 4329 ...\n#&gt;  $ occup        : Factor w/ 7 levels \"Exerce une profession\",..: 1 3 1 1 4 1 6 1 3 1 ...\n#&gt;  $ qualif       : Factor w/ 7 levels \"Ouvrier specialise\",..: 6 NA 3 3 6 6 2 2 NA 7 ...\n#&gt;  $ freres.soeurs: int  8 2 2 1 0 5 1 5 4 2 ...\n#&gt;  $ clso         : Factor w/ 3 levels \"Oui\",\"Non\",\"Ne sait pas\": 1 1 2 2 1 2 1 2 1 2 ...\n#&gt;  $ relig        : Factor w/ 6 levels \"Pratiquant regulier\",..: 4 4 4 3 1 4 3 4 3 2 ...\n#&gt;  $ trav.imp     : Factor w/ 4 levels \"Le plus important\",..: 4 NA 2 3 NA 1 NA 4 NA 3 ...\n#&gt;  $ trav.satisf  : Factor w/ 3 levels \"Satisfaction\",..: 2 NA 3 1 NA 3 NA 2 NA 1 ...\n#&gt;  $ hard.rock    : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ lecture.bd   : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ peche.chasse : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 2 2 1 1 ...\n#&gt;  $ cuisine      : Factor w/ 2 levels \"Non\",\"Oui\": 2 1 1 2 1 1 2 2 1 1 ...\n#&gt;  $ bricol       : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 2 1 1 1 2 1 1 ...\n#&gt;  $ cinema       : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 1 2 1 2 1 1 2 2 ...\n#&gt;  $ sport        : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 2 2 1 2 1 1 1 2 ...\n#&gt;  $ heures.tv    : num  0 1 0 2 3 2 2.9 1 2 2 ...\n\nÀ noter que sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment.\n\n\n\nStructure d’un objet\n\n\n\n\n3.2.2 Accéder aux variables d’un tableau\nUne opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape :\n\nd$sexe\n#&gt;   [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme Homme\n#&gt;  [13] Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme Femme Femme\n#&gt;  [25] Femme Homme Femme Homme Homme Homme Homme Homme Homme Homme Femme Femme\n#&gt;  [37] Homme Femme Femme Homme Femme Homme Homme Femme Femme Homme Femme Femme\n#&gt;  [49] Femme Femme Homme Femme Homme Femme Homme Femme Femme Femme Homme Femme\n#&gt;  [61] Femme Homme Homme Homme Homme Femme Homme Homme Femme Femme Homme Homme\n#&gt;  [73] Femme Femme Femme Femme Homme Femme Femme Femme Femme Femme Femme Homme\n#&gt;  [85] Homme Femme Homme Homme Homme Homme Homme Femme Homme Femme Femme Femme\n#&gt;  [97] Homme Homme Femme Femme Femme Homme Femme Homme Homme Femme Femme Femme\n#&gt; [109] Femme Homme Homme Homme Homme Homme Femme Homme Homme Femme Homme Homme\n#&gt; [121] Femme Femme Femme Homme Femme Femme Homme Femme Femme Homme Femme Homme\n#&gt; [133] Femme Femme Femme Homme Homme Homme Homme Homme Homme Homme Homme Femme\n#&gt; [145] Homme Homme Homme Femme Femme Femme Homme Femme Femme Femme Femme Homme\n#&gt; [157] Femme Homme Homme Homme Femme Homme Femme Homme Femme Homme Homme Femme\n#&gt; [169] Femme Femme Homme Femme Homme Femme Femme Femme Homme Homme Homme Femme\n#&gt; [181] Homme Femme Femme Homme Homme Femme Femme Femme Femme Femme Homme Homme\n#&gt; [193] Femme Homme Homme Femme Homme Femme Homme Femme\n#&gt;  [ reached getOption(\"max.print\") -- omitted 1800 entries ]\n#&gt; Levels: Homme Femme\n\nR va afficher l’ensemble des valeurs de la variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment.\nLa fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères.\nSi on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail.\n\nhead(d$age)\n#&gt; [1] 28 23 59 34 71 35\n\n\ntail(d$age, 10)\n#&gt;  [1] 52 42 50 41 46 45 46 24 24 66\n\nLe deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher.\n\n\n3.2.3 Créer une nouvelle variable\nOn peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur.\nPar exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé.\n\nhead(d$heures.tv, 10)\n#&gt;  [1] 0.0 1.0 0.0 2.0 3.0 2.0 2.9 1.0 2.0 2.0\n\nOn peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée convertie en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante :\n\nd$minutes.tv &lt;- d$heures.tv * 60\n\nOn peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau.\n\nhead(d$minutes.tv)\n#&gt; [1]   0  60   0 120 180 120"
  },
  {
    "objectID": "03-premier_travail.html#analyse-univariée",
    "href": "03-premier_travail.html#analyse-univariée",
    "title": "3  Premier travail avec des données",
    "section": "3.3 Analyse univariée",
    "text": "3.3 Analyse univariée\nOn a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $.\nSi on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.).\n\n3.3.1 Analyser une variable quantitative\nUne variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv).\n\n3.3.1.1 Indicateurs de centralité\nCaractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent.\nPour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range.\n\nmin(d$age)\n#&gt; [1] 18\nmax(d$age)\n#&gt; [1] 97\nrange(d$age)\n#&gt; [1] 18 97\n\nOn peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean.\n\nmean(d$age)\n#&gt; [1] 48.157\n\nIl existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median.\n\nmedian(d$age)\n#&gt; [1] 48\n\nUne différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2019, le salaire net moyen des salariés à temps plein dans le secteur privé en France était de 2424 euros, tandis que le salaire net médian n’était que de 1940 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut.\n\n\n3.3.1.2 Indicateurs de dispersion\nLes indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées.\nL’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations :\n\nmax(d$age) - min(d$age)\n#&gt; [1] 79\n\nLes indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation).\n\nvar(d$age)\n#&gt; [1] 287.0249\n\n\nsd(d$age)\n#&gt; [1] 16.94181\n\nPlus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées.\nUne autre manière de mesurer la dispersion est de calculer les quartiles :\n\nle premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus\nle deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane)\nle troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus\n\nOn peut les calculer avec la fonction quantile :\n\n## Premier quartile\nquantile(d$age, prob = 0.25)\n#&gt; 25% \n#&gt;  35\n\n\n## Troisième quartile\nquantile(d$age, prob = 0.75)\n#&gt; 75% \n#&gt;  60\n\nquantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc.\nNotons enfin que la fonction summary permet d’obtenir d’un seul coup plusieurs indicateurs classiques :\n\nsummary(d$age)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;   18.00   35.00   48.00   48.16   60.00   97.00\n\n\n\n3.3.1.3 Représentation graphique\nL’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique.\nLa représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist.\n\nhist(d$age)\n\n\n\n\nCette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio.\nOn peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite.\n\nhist(d$age, breaks = 10)\n\n\n\n\n\nhist(d$age, breaks = 70)\n\n\n\n\nLe choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances.\nLes arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col3, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. :\n\nhist(d$age, col = \"skyblue\",\n     main = \"Répartition des âges des enquêtés\",\n     xlab = \"Âge\",\n     ylab = \"Effectif\")\n\n\n\n\nLa fonction hist fait partie des fonctions graphique de base de R. On verra plus en détail d’autres fonctions graphiques dans le Chapitre 8 de ce document, consacrée à l’extension ggplot2, qui fait partie du tidyverse et qui permet la production et la personnalisation de graphiques complexes.\n\n\n\n3.3.2 Analyser une variable qualitative\nUne variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)…\nÀ noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs.\n\n3.3.2.1 Tri à plat\nL’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table.\n\ntable(d$sexe)\n#&gt; \n#&gt; Homme Femme \n#&gt;   899  1101\n\nCe tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes.\n\ntable(d$qualif)\n#&gt; \n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                      203                      292                       86 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      160                      260                      594 \n#&gt;                    Autre \n#&gt;                       58\n\nUn tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif.\n\ntab &lt;- table(d$qualif)\nsort(tab)\n#&gt; \n#&gt;                    Autre               Technicien Profession intermediaire \n#&gt;                       58                       86                      160 \n#&gt;       Ouvrier specialise                    Cadre         Ouvrier qualifie \n#&gt;                      203                      260                      292 \n#&gt;                  Employe \n#&gt;                      594\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$qualif, useNA = \"always\").\n\n\nÀ noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles.\n\nsummary(d$qualif)\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                      203                      292                       86 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      160                      260                      594 \n#&gt;                    Autre                     NA's \n#&gt;                       58                      347\n\nPar défaut ces tris à plat sont en effectifs et ne sont pas toujours très lisibles, notamment quand on a des effectifs importants. On leur rajoute donc en général la répartition en pourcentages. Pour cela, nous allons utiliser la fonction freq de l’extension questionr, qui devra donc avoir précédemment été chargée avec library(questionr).\n\n## À rajouter en haut de script et à exécuter\nlibrary(questionr)\n\nUne fois l’extension chargée on peut utiliser la fonction freq.\n\nfreq(d$qualif)\n#&gt;                            n    % val%\n#&gt; Ouvrier specialise       203 10.2 12.3\n#&gt; Ouvrier qualifie         292 14.6 17.7\n#&gt; Technicien                86  4.3  5.2\n#&gt; Profession intermediaire 160  8.0  9.7\n#&gt; Cadre                    260 13.0 15.7\n#&gt; Employe                  594 29.7 35.9\n#&gt; Autre                     58  2.9  3.5\n#&gt; NA                       347 17.3   NA\n\nLa colonne n représente les effectifs de chaque catégorie, la colonne % le pourcentage, et la colonne val% le pourcentage calculé sur les valeurs valides, donc en excluant les NA. Une ligne a également été rajoutée pour indiquer le nombre et la proportion de NA.\nfreq accepte un certain nombre d’arguments pour personnaliser son affichage. Par exemple :\n\nvalid indique si on souhaite ou non afficher les pourcentages sur les valeurs valides\ncum indique si on souhaite ou non afficher les pourcentages cumulés\ntotal permet d’ajouter une ligne avec les effectifs totaux\nsort permet de trier le tableau par fréquence croissante (sort=\"inc\") ou décroissante (sort=\"dec\").\n\n\nfreq(d$qualif, valid = FALSE, total = TRUE, sort = \"dec\")\n#&gt;                             n     %\n#&gt; Employe                   594  29.7\n#&gt; Ouvrier qualifie          292  14.6\n#&gt; Cadre                     260  13.0\n#&gt; Ouvrier specialise        203  10.2\n#&gt; Profession intermediaire  160   8.0\n#&gt; Technicien                 86   4.3\n#&gt; Autre                      58   2.9\n#&gt; NA                        347  17.3\n#&gt; Total                    2000 100.0\n\n\n\n3.3.2.2 Représentations graphiques\nOn peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes.\n\ntab &lt;- table(d$clso)\nbarplot(tab)\n\n\n\n\nOn peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique :\n\nbarplot(sort(tab))\n\n\n\n\nUne alternative au graphique en barres est le diagramme de Cleveland, qu’on peut obtenir avec la fonction dotchart. Celle-ci s’applique elle aussi au tri à plat de la variable calculé avec table.\n\ndotchart(table(d$qualif))\n\n\n\n\nLà aussi, pour améliorer la lisibilité du graphique il est préférable de trier le tri à plat de la variable avant de le représenter :\n\ndotchart(sort(table(d$qualif)))"
  },
  {
    "objectID": "03-premier_travail.html#exercices",
    "href": "03-premier_travail.html#exercices",
    "title": "3  Premier travail avec des données",
    "section": "3.4 Exercices",
    "text": "3.4 Exercices\nExercice 1\nCréer un nouveau script qui effectue les actions suivantes :\n\ncharger l’extension questionr\ncharger le jeu de données nommé hdv2003\ncopier le jeu de données dans un nouvel objet nommé df\nafficher les dimensions et la liste des variables de df\n\n\nlibrary(questionr)\n\ndata(hdv2003)\ndf &lt;- hdv2003\n\ndim(df)\nnames(df)\n\n:::\nExercice 2\nOn souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes.\n\n\nsummary(df$heures.tv)\nsd(df$heures.tv, na.rm = TRUE)\n\nhist(df$heures.tv, breaks = 10)\n\n\nExercice 3\nOn s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table.\n\n\ntable(df$trav.imp)\n\n\nFaites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ?\n\n\nfreq(df$trav.imp)\n\n\nReprésentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres.\n\n\ntab &lt;- sort(table(df$trav.imp))\nbarplot(tab)\n\n\nUtilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato.\n\n\nbarplot(tab, col = \"tomato\")\n\n\nTapez colors() dans la console pour afficher l’ensemble des noms de couleurs disponibles dans R. Testez chaque couleur une à une pour trouver votre couleur préférée.\n\nC’est une blague, hein ! Cela dit moccasin ou palevioletred sont pas mal, si vous voulez essayer :-)"
  },
  {
    "objectID": "03-premier_travail.html#footnotes",
    "href": "03-premier_travail.html#footnotes",
    "title": "3  Premier travail avec des données",
    "section": "",
    "text": "La seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎\nLes différents types de variables seront décrits plus en détail Chapitre 9 sur les recodages.↩︎\nLes différentes manières de spécifier des couleurs sont indiquées dans l’encadré Section 8.7.3.↩︎"
  },
  {
    "objectID": "04-bivarie.html#croisement-de-deux-variables-qualitatives",
    "href": "04-bivarie.html#croisement-de-deux-variables-qualitatives",
    "title": "4  Analyse bivariée",
    "section": "4.1 Croisement de deux variables qualitatives",
    "text": "4.1 Croisement de deux variables qualitatives\n\n4.1.1 Tableaux croisés\nOn continue à travailler avec le jeu de données tiré de l’enquête Histoire de vie inclus dans l’extension questionr. On commence donc par charger l’extension, le jeu de données, et à le renommer en un nom plus court pour gagner un peu de temps de saisie au clavier.\n\nlibrary(questionr)\ndata(hdv2003)\nd &lt;- hdv2003\n\nQuand on veut croiser deux variables qualitatives, on fait un tableau croisé. Comme pour un tri à plat ceci s’obtient avec la fonction table de R, mais à laquelle on passe cette fois deux variables en argument. Par exemple, si on veut croiser la catégorie socio-professionnelle et le sexe des enquêtés :\n\ntable(d$qualif, d$sexe)\n#&gt;                           \n#&gt;                            Homme Femme\n#&gt;   Ouvrier specialise          96   107\n#&gt;   Ouvrier qualifie           229    63\n#&gt;   Technicien                  66    20\n#&gt;   Profession intermediaire    88    72\n#&gt;   Cadre                      145   115\n#&gt;   Employe                     96   498\n#&gt;   Autre                       21    37\n\nPour pouvoir interpréter ce tableau on doit passer du tableau en effectifs au tableau en pourcentages ligne ou colonne. Pour cela, on peut utiliser les fonctions lprop et cprop de l’extension questionr, qu’on applique au tableau croisé précédent.\nPour calculer les pourcentages ligne :\n\ntab &lt;- table(d$qualif, d$sexe)\nlprop(tab)\n#&gt;                           \n#&gt;                            Homme Femme Total\n#&gt;   Ouvrier specialise        47.3  52.7 100.0\n#&gt;   Ouvrier qualifie          78.4  21.6 100.0\n#&gt;   Technicien                76.7  23.3 100.0\n#&gt;   Profession intermediaire  55.0  45.0 100.0\n#&gt;   Cadre                     55.8  44.2 100.0\n#&gt;   Employe                   16.2  83.8 100.0\n#&gt;   Autre                     36.2  63.8 100.0\n#&gt;   All                       44.8  55.2 100.0\n\nEt pour les pourcentages colonne :\n\ncprop(tab)\n#&gt;                           \n#&gt;                            Homme Femme All  \n#&gt;   Ouvrier specialise        13.0  11.7  12.3\n#&gt;   Ouvrier qualifie          30.9   6.9  17.7\n#&gt;   Technicien                 8.9   2.2   5.2\n#&gt;   Profession intermediaire  11.9   7.9   9.7\n#&gt;   Cadre                     19.6  12.6  15.7\n#&gt;   Employe                   13.0  54.6  35.9\n#&gt;   Autre                      2.8   4.1   3.5\n#&gt;   Total                    100.0 100.0 100.0\n\n\n\n\n\n\n\nNote\n\n\n\nPour savoir si on doit faire des pourcentages ligne ou colonne, on pourra se référer à l’article suivant :\nhttps://alain-leger.lescigales.org/textes/lignecolonne.pdf\nEn résumé, quand on fait un tableau croisé, celui-ci est parfaitement symétrique : on peut inverser les lignes et les colonnes, ça ne change pas son interprétation. Par contre, on a toujours en tête un “sens” de lecture dans le sens où on considère que l’une des variables dépend de l’autre. Par exemple, si on croise sexe et type de profession, on dira que le type de profession dépend du sexe, et non l’inverse : le type de profession est alors la variable dépendante (à expliquer), et le sexe la variable indépendante (explicative).\nPour faciliter la lecture d’un tableau croisé, il est recommandé de faire les pourcentages sur la variable indépendante. Dans notre exemple, la variable indépendante est le sexe, elle est en colonne, on calcule donc les pourcentages colonnes qui permettent de comparer directement, pour chaque sexe, la répartition des catégories socio-professionnelles.\n\n\n\n\n4.1.2 Test du χ²\nComme on travaille sur un échantillon et pas sur une population entière, on peut compléter ce tableau croisé par un test d’indépendance du χ². Celui-ci permet de tester, et éventuellement de rejeter, l’hypothèse d’indépendance des lignes et des colonnes du tableau, c’est à dire l’hypothèse que les écarts à l’indépendance observés seraient uniquement dus au biais d’échantillonnage (au fait qu’on n’a pas interrogé toute notre population).\nPour effectuer un test de ce type, on applique la fonction chisq.test au tableau croisé calculé précédemment.\n\nchisq.test(tab)\n#&gt; \n#&gt;  Pearson's Chi-squared test\n#&gt; \n#&gt; data:  tab\n#&gt; X-squared = 387.56, df = 6, p-value &lt; 0.00000000000000022\n\nLe résultat nous indique trois valeurs :\n\nX-squared, la valeur de la statistique du χ² pour notre tableau, c’est-à-dire une “distance” entre notre tableau observé et celui attendu si les deux variables étaient indépendantes.\ndf, le nombre de degrés de libertés du test, qui dépend des dimensions du tableau.\np-value, le fameux p, qui indique la probabilité d’obtenir une valeur de la statistique du χ² au moins aussi extrême sous l’hypothèse d’indépendance.\n\nIci, le p est extrêmement petit (la notation &lt; 2.2e-16 indique qu’il est plus petit que la plus petite valeur proche de zéro calculable par R), donc certainement en-dessous du seuil de décision choisi préalablement au test (souvent 5%, soit 0.05). On peut donc rejeter l’hypothèse d’indépendance des lignes et des colonnes du tableau.\nEn complément du test du χ², on peut aussi regarder les résidus de ce test pour affiner la lecture du tableau. Ceux-ci s’obtiennent avec la fonction chisq.residuals de questionr :\n\nchisq.residuals(tab)\n#&gt;                           \n#&gt;                             Homme  Femme\n#&gt;   Ouvrier specialise         0.52  -0.47\n#&gt;   Ouvrier qualifie           8.57  -7.73\n#&gt;   Technicien                 4.42  -3.98\n#&gt;   Profession intermediaire   1.92  -1.73\n#&gt;   Cadre                      2.64  -2.38\n#&gt;   Employe                  -10.43   9.41\n#&gt;   Autre                     -0.98   0.88\n\nL’interprétation des résidus est la suivante :\n\nsi la valeur du résidu pour une case est inférieure à -2, alors il y a une sous-représentation de cette case dans le tableau : les effectifs sont significativement plus faibles que ceux attendus sous l’hypothèse d’indépendance\nà l’inverse, si le résidu est supérieur à 2, il y a sur-représentatation de cette case\nsi le résidu est compris entre -2 et 2, il n’y a pas d’écart à l’indépendance significatif\n\nLes résidus peuvent être une aide utile à l’interprétation, notamment pour des tableaux de grande dimension.\n\n\n4.1.3 Représentation graphique\nIl est possible de faire une représentation graphique d’un tableau croisé, par exemple avec la fonction mosaicplot :\n\nmosaicplot(tab)\n\n\n\n\nOn peut améliorer ce graphique en colorant les cases selon les résidus du test du χ² (argument shade = TRUE) et en orientant verticalement les labels de colonnes (argument las = 3) :\n\nmosaicplot(tab, las = 3, shade = TRUE)\n\n\n\n\nChaque rectangle de ce graphique représente une case de tableau. Sa largeur correspond au pourcentage des modalités en colonnes (il y’a beaucoup d’employés et d’ouvriers et très peu d’“autres”). Sa hauteur correspond aux pourcentages colonnes : la proportion d’hommes chez les cadres est plus élevée que chez les employés. Enfin, la couleur de la case correspond au résidu du test du χ² correspondant : les cases en rouge sont sous-représentées, les cases en bleu sur-représentées, et les cases blanches sont proches des effectifs attendus sous l’hypothèse d’indépendance."
  },
  {
    "objectID": "04-bivarie.html#croisement-dune-variable-quantitative-et-dune-variable-qualitative",
    "href": "04-bivarie.html#croisement-dune-variable-quantitative-et-dune-variable-qualitative",
    "title": "4  Analyse bivariée",
    "section": "4.2 Croisement d’une variable quantitative et d’une variable qualitative",
    "text": "4.2 Croisement d’une variable quantitative et d’une variable qualitative\n\n4.2.1 Représentation graphique\nCroiser une variable quantitative et une variable qualitative, c’est essayer de voir si les valeurs de la variable quantitative se répartissent différemment selon la catégorie d’appartenance de la variable qualitative.\nPour cela, l’idéal est de commencer par une représentation graphique de type “boîte à moustache” à l’aide de la fonction boxplot. Par exemple, si on veut visualiser la répartition des âges selon la pratique ou non d’un sport, on va utiliser la syntaxe suivante :\n\nboxplot(d$age ~ d$sport)\n\n\n\n\n\n\n\nNote\n\n\n\nCette syntaxe de boxplot utilise une nouvelle notation de type “formule”. Celle-ci est utilisée notamment pour la spécification des modèles de régression. Ici le ~ peut se lire comme “en fonction de” : on veut représenter le boxplot de l’âge en fonction du sport.\n\n\nCe qui va nous donner le résultat suivant :\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nL’interprétation d’un boxplot est la suivante : Les bords inférieurs et supérieurs du carré central représentent le premier et le troisième quartile de la variable représentée sur l’axe vertical. On a donc 50% de nos observations dans cet intervalle. Le trait horizontal dans le carré représente la médiane. Enfin, des “moustaches” s’étendent de chaque côté du carré, jusqu’aux valeurs minimales et maximales, avec une exception : si des valeurs sont éloignées du carré de plus de 1,5 fois l’écart interquartile (la hauteur du carré), alors on les représente sous forme de points (symbolisant des valeurs considérées comme “extrêmes”).\n\n\nDans le graphique ci-dessus, on voit que ceux qui ont pratiqué un sport au cours des douze derniers mois ont l’air d’être sensiblement plus jeunes que les autres.\n\n\n4.2.2 Calculs d’indicateurs\nOn peut aussi vouloir comparer certains indicateurs (moyenne, médiane) d’une variable quantitative selon les modalités d’une variable qualitative. Si on reprend l’exemple précédent, on peut calculer la moyenne d’âge pour ceux qui pratiquent un sport et pour ceux qui n’en pratiquent pas.\nUne première méthode pour cela est d’extraire de notre population autant de sous-populations qu’il y a de modalités dans la variable qualitative. On peut le faire notamment avec la fonction filter du package dplyr 1.\nOn commence par charger dplyr (en l’ayant préalablement installé) :\n\nlibrary(dplyr)\n\nPuis on applique filter pour créer deux sous-populations, stockées dans deux nouveaux tableaux de données :\n\nd_sport &lt;- filter(d, sport == \"Oui\")\nd_nonsport &lt;- filter(d, sport == \"Non\")\n\nOn peut ensuite utiliser ces deux nouveaux tableaux de données comme on en a l’habitude, et calculer les deux moyennes d’âge :\n\nmean(d_sport$age)\n#&gt; [1] 40.92531\n\n\nmean(d_nonsport$age)\n#&gt; [1] 52.25137\n\nUne autre possibilité est d’utiliser la fonction tapply, qui prend en paramètre une variable quantitative, une variable qualitative et une fonction, puis applique automatiquement la fonction aux valeurs de la variables quantitative pour chaque niveau de la variable qualitative :\n\ntapply(d$age, d$sport, mean)\n#&gt;      Non      Oui \n#&gt; 52.25137 40.92531\n\nOn verra Chapitre 10 d’autres méthodes basées sur dplyr pour effectuer ce genre d’opérations.\n\n\n4.2.3 Tests statistiques\nUn des tests les plus connus est le test du t de Student, qui permet de tester si les moyennes de deux sous-populations peuvent être considérées comme différentes (compte tenu des fluctuations aléatoires provenant du biais d’échantillonnage).\nUn test t s’effectue à l’aide de la fonction t.test. Ainsi, on peut tester l’hypothèse d’égalité des âges moyens selon la pratique ou non d’un sport avec la commande suivante :\n\nt.test(d$age ~ d$sport)\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  d$age by d$sport\n#&gt; t = 15.503, df = 1600.4, p-value &lt; 0.00000000000000022\n#&gt; alternative hypothesis: true difference in means between group Non and group Oui is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;   9.893117 12.759002\n#&gt; sample estimates:\n#&gt; mean in group Non mean in group Oui \n#&gt;          52.25137          40.92531\n\nLe résultat du test est significatif, avec un p extrêmement petit, et on peut rejeter l’hypothèse nulle d’égalité des moyennes des deux groupes. Le test nous donne même un intervalle de confiance à 95% pour la valeur de la différence entre les deux moyennes.\nNous sommes cependant allés un peu vite, et avons négligé le fait que le test t s’applique normalement à des distributions normales. On peut se faire un premier aperçu visuel de cette normalité en traçant les histogrammes des deux répartitions :\n\nhist(d_sport$age)\n\n\n\n\n\nhist(d_nonsport$age)\n\n\n\n\nSi l’âge dans le groupe des non sportifs se rapproche d’une distribution normale, celui des sportifs en semble assez éloigné, notamment du fait de la limite d’âge à 18 ans imposée par construction de l’enquête.\nOn peut tester cette normalité à l’aide du test de Shapiro-Wilk et de la fonction shapiro.test :\n\nshapiro.test(d_sport$age)\n#&gt; \n#&gt;  Shapiro-Wilk normality test\n#&gt; \n#&gt; data:  d_sport$age\n#&gt; W = 0.96203, p-value = 0.0000000000009734\n\n\nshapiro.test(d_nonsport$age)\n#&gt; \n#&gt;  Shapiro-Wilk normality test\n#&gt; \n#&gt; data:  d_nonsport$age\n#&gt; W = 0.98844, p-value = 0.00000001654\n\nLe test est significatif dans les deux cas et rejette l’hypothèse d’une normalité des deux distributions.\nDans ce cas on peut faire appel à un test non-paramétrique, qui ne fait donc pas d’hypothèses sur les lois de distribution des variables testées, en l’occurrence le test des rangs de Wilcoxon, à l’aide de la fonction wilcox.test :\n\nwilcox.test(d$age ~ d$sport)\n#&gt; \n#&gt;  Wilcoxon rank sum test with continuity correction\n#&gt; \n#&gt; data:  d$age by d$sport\n#&gt; W = 640577, p-value &lt; 0.00000000000000022\n#&gt; alternative hypothesis: true location shift is not equal to 0\n\nLa valeur p étant à nouveau extrêmement petite, on peut rejeter l’hypothèse d’indépendance et considérer que les distributions des âges dans les deux sous-populations sont différentes."
  },
  {
    "objectID": "04-bivarie.html#croisement-de-deux-variables-quantitatives",
    "href": "04-bivarie.html#croisement-de-deux-variables-quantitatives",
    "title": "4  Analyse bivariée",
    "section": "4.3 Croisement de deux variables quantitatives",
    "text": "4.3 Croisement de deux variables quantitatives\nLe jeu de données hdv2003 comportant assez peu de variables quantitatives, on va s’intéresser maintenant à un autre jeu de données comportant des informations du recensement de la population de 2018. On le charge avec :\n\ndata(rp2018)\n\nUn nouveau tableau de données rp2018 devrait apparaître dans votre environnement. Celui-ci comprend les 5417 communes françaises de plus de 2000 habitants, et une soixantaine de variables telles que le département, la population, le taux de chômage, etc. Pour une description plus complète et une liste des variables, voir Section A.3.2.3.\n\n4.3.1 Représentation graphique\nQuand on croise deux variables quantitatives, l’idéal est de faire une représentation graphique sous forme de nuage de points à l’aide de la fonction plot. On va représenter le croisement entre le pourcentage de cadres et le pourcentage de propriétaires dans la commune :\n\nplot(rp2018$cadres, rp2018$proprio)\n\n\n\n\nUne représentation graphique est l’idéal pour visualiser l’existence d’un lien entre les deux variables. Voici quelques exemples d’interprétation :\n\n\n\n\n\nDans ce premier graphique généré sur nos données, il semble difficile de mettre en évidence une relation de dépendance. Si par contre on croise le pourcentage de cadres et celui de diplômés de niveau Bac+5 ou plus, on obtient une belle relation de dépendance linéaire.\n\nplot(rp2018$cadres, rp2018$dipl_sup)\n\n\n\n\n\n\n4.3.2 Calcul d’indicateurs\nEn plus d’une représentation graphique, on peut calculer certains indicateurs permettant de mesurer le degré d’association de deux variables quantitatives.\n\n4.3.2.1 Corrélation linéaire (Pearson)\nLa corrélation est une mesure du lien d’association linéaire entre deux variables quantitatives. Sa valeur varie entre -1 et 1. Si la corrélation vaut -1, il s’agit d’une association linéaire négative parfaite. Si elle vaut 1, il s’agit d’une association linéaire positive parfaite. Si elle vaut 0, il n’y a aucune association linéaire entre les variables.\nOn la calcule dans R à l’aide de la fonction cor.\nAinsi la corrélation entre le pourcentage de cadres et celui de diplômés du supérieur vaut :\n\ncor(rp2018$cadres, rp2018$dipl_sup)\n#&gt; [1] 0.9291504\n\nCe qui est extrêmement fort. Il y a donc un lien linéaire et positif entre les deux variables (quand la valeur de l’une augmente, la valeur de l’autre augmente également).\nÀ l’inverse, la corrélation entre le pourcentage de cadres et le pourcentage de propriétaires vaut :\n\ncor(rp2018$cadres, rp2018$proprio)\n#&gt; [1] 0.06425958\n\nCe qui indique, pour nos données, une absence de liaison linéaire entre les deux variables.\n\n\n4.3.2.2 Corrélation des rangs (Spearman)\nLe coefficient de corrélation de Pearson ci-dessus fait une hypothèse forte sur les données : elles doivent être liées par une association linéaire. Quand ça n’est pas le cas mais qu’on est en présence d’une association monotone, on peut utiliser un autre coefficient, le coefficient de corrélation des rangs de Spearman.\nPlutôt que de se baser sur les valeurs des variables, cette corrélation va se baser sur leurs rangs, c’est-à-dire sur leur position parmi les différentes valeurs prises par les variables.\nAinsi, si la valeur la plus basse de la première variable est associée à la valeur la plus basse de la deuxième, et ainsi de suite jusqu’à la valeur la plus haute, on obtiendra une corrélation de 1. Si la valeur la plus forte de la première variable est associée à la valeur la plus faible de la seconde, et ainsi de suite, et que la valeur la plus faible de la première est associée à la plus forte de la deuxième, on obtiendra une corrélation de -1. Si les rangs sont “mélangés”, sans rapports entre eux, on obtiendra une corrélation autour de 0.\n\n\n\n\n\nLa corrélation des rangs a aussi pour avantage d’être moins sensibles aux valeurs extrêmes ou aux points isolés. On dit qu’elle est plus “robuste”.\nPour calculer une corrélation de Spearman, on utilise la fonction cor mais avec l’argument method = \"spearman\".\n\ncor(rp2018$cadres, rp2018$dipl_sup, method = \"spearman\")\n#&gt; [1] 0.8986656\n\n\n\n\n4.3.3 Régression linéaire\nQuand on est en présence d’une association linéaire entre deux variables, on peut vouloir faire la régression linéaire d’une des variables sur l’autres.\nUne régression linéaire simple se fait à l’aide de la fonction lm :\n\nlm(rp2018$cadres ~ rp2018$dipl_sup)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = rp2018$cadres ~ rp2018$dipl_sup)\n#&gt; \n#&gt; Coefficients:\n#&gt;     (Intercept)  rp2018$dipl_sup  \n#&gt;           3.578            1.256\n\n\n\n\n\n\n\nNote\n\n\n\nOn retrouve avec lm la syntaxe “formule” déjà rencontrée avec boxplot. Elle permet ici de spécifier des modèles de régression : la variable dépendante se place à gauche du ~, et la variable indépendante à droite. Si on souhaite faire une régression multiple avec plusieurs variables indépendantes, on aura une formule du type dep ~ indep1 + indep2. Il est également possible de spécifier des termes plus complexes, des interactions, etc.\n\n\nlm nous renvoie par défaut les coefficients de la droite de régression :\n\nl’ordonnée à l’origine (Intercept) vaut 3.578\nle coefficient associé à dipl_sup vaut 1.256\n\nPour des résultats plus détaillés, on peut stocker le résultat de la régression dans un objet et lui appliquer la fonction summary.\n\nreg &lt;- lm(rp2018$cadres ~ rp2018$dipl_sup)\nsummary(reg)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = rp2018$cadres ~ rp2018$dipl_sup)\n#&gt; \n#&gt; Residuals:\n#&gt;      Min       1Q   Median       3Q      Max \n#&gt; -15.8329  -1.9320  -0.2953   1.7184  21.6096 \n#&gt; \n#&gt; Coefficients:\n#&gt;                 Estimate Std. Error t value            Pr(&gt;|t|)    \n#&gt; (Intercept)      3.57796    0.06925   51.67 &lt;0.0000000000000002 ***\n#&gt; rp2018$dipl_sup  1.25580    0.00679  184.94 &lt;0.0000000000000002 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.116 on 5415 degrees of freedom\n#&gt; Multiple R-squared:  0.8633, Adjusted R-squared:  0.8633 \n#&gt; F-statistic: 3.42e+04 on 1 and 5415 DF,  p-value: &lt; 0.00000000000000022\n\nCes résultats montrent notamment que les coefficients sont significativement différents de 0. La part de cadres augmente donc bien avec celle de diplômés du supérieur.\nOn peut enfin représenter la droite de régression sur notre nuage de points à l’aide de la fonction abline.\n\nplot(rp2018$dipl_sup, rp2018$cadres)\nabline(reg, col = \"red\")"
  },
  {
    "objectID": "04-bivarie.html#exercices",
    "href": "04-bivarie.html#exercices",
    "title": "4  Analyse bivariée",
    "section": "4.4 Exercices",
    "text": "4.4 Exercices\nExercice 1\nDans le jeu de données hdv2003, faire le tableau croisé entre la catégorie socio-professionnelle (variable qualif) et le fait de croire ou non en l’existence des classes sociales (variable clso). Identifier la variable indépendante et la variable dépendante, et calculer les pourcentages ligne ou colonne. Interpréter le résultat.\n\n\nlibrary(questionr)\ndata(hdv2003)\ntab &lt;- table(hdv2003$qualif, hdv2003$clso)\n\n## Ici la variable indépendante est `qualif`, on calcule donc\n## les pourcentages lignes\nlprop(tab)\n\n\nFaire un test du χ². Peut-on rejeter l’hypothèse d’indépendance ?\n\n\nchisq.test(tab)\n\n## On peut rejeter l'hypothèse d'indépendance au seuil de 0.05,\n## et même au seuil de 0.001\n\n\nReprésenter ce tableau croisé sous la forme d’un mosaicplot en colorant les cases selon les résidus du test du χ².\n\n\nmosaicplot(tab, shade = TRUE)\n\n\nExercice 2\nToujours sur le jeu de données hdv2003, faire le boxplot qui croise le nombre d’heures passées devant la télévision (variable heures.tv) avec le statut d’occupation (variable occup).\n\n\nboxplot(hdv2003$heures.tv ~ hdv2003$occup)\n\n\nCalculer la durée moyenne devant la télévision en fonction du statut d’occupation à l’aide de tapply.\n\n\ntapply(hdv2003$heures.tv, hdv2003$occup, mean, na.rm = TRUE)\n\n\nExercice 3\nSur le jeu de données rp2018, représenter le nuage de points croisant le pourcentage de personnes sans diplôme (variable dipl_aucun) et le pourcentage de propriétaires (variable proprio).\n\n\nlibrary(questionr)\ndata(rp2018)\nplot(rp2018$dipl_aucun, rp2018$proprio)\n\n\nCalculer le coefficient de corrélation linéaire correspondant.\n\n\ncor(rp2018$dipl_aucun, rp2018$proprio)"
  },
  {
    "objectID": "04-bivarie.html#footnotes",
    "href": "04-bivarie.html#footnotes",
    "title": "4  Analyse bivariée",
    "section": "",
    "text": "Le package en question est présenté en détail Chapitre 10.↩︎"
  },
  {
    "objectID": "05-organiser.html#sec-projets",
    "href": "05-organiser.html#sec-projets",
    "title": "5  Organiser ses scripts",
    "section": "5.1 Les projets dans RStudio",
    "text": "5.1 Les projets dans RStudio\nLa notion de projet est une fonctionnalité très pratique de RStudio, qui permet d’organiser son travail et de faciliter l’accès à l’ensemble des fichiers constitutifs d’une analyse (données, scripts, documentation, etc.).\nEn pratique, un projet est un dossier que vous avez créé où bon vous semble sur votre disque dur, et dans lequel vous regrouperez tous les fichiers en question. Utiliser des projets procure plusieurs avantages :\n\nRStudio lance automatiquement R dans le dossier du projet et facilite ainsi grandement l’accès aux fichiers de données à importer (plus besoin de taper le chemin d’accès complet). De même, si vous déplacez votre dossier sur votre disque, le projet continuera à fonctionner.\nL’onglet Files de la zone en bas à droite de l’interface de RStudio vous permet de naviguer facilement dans les fichiers de votre projet.\nVous pouvez très facilement passer d’un projet à l’autre si vous travaillez sur plusieurs jeux de données en parallèle.\n\nPour créer un projet, il faut aller dans le menu File puis sélectionner New project.\n\n\n\nCréation d’un nouveau projet\n\n\nSelon que le dossier du projet existe déjà ou pas, on choisira Existing directory ou New directory. L’étape d’après consiste à créer ou sélectionner le dossier, puis on n’a plus qu’à cliquer sur Create project.\nÀ la création du projet, et chaque fois que vous l’ouvrirez, une nouvelle session R est lancée dans la fenêtre Console avec le dossier du projet comme répertoire de travail, et l’onglet Files affiche les fichiers contenus dans ce dossier.\nUne fois le projet créé, son nom est affiché dans un petit menu déroulant en haut à droite de l’interface de RStudio (menu qui permet de passer facilement d’un projet à un autre).\n\n\n\nMenu projets\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne retrouvez pas le nom du projet dans ce menu, vous pouvez l’ouvrir en sélectionnant File puis Open Project… et en allant sélectionner le fichier .Rproj qui se trouve dans le dossier du projet à ouvrir."
  },
  {
    "objectID": "05-organiser.html#créer-des-sections-dans-un-script",
    "href": "05-organiser.html#créer-des-sections-dans-un-script",
    "title": "5  Organiser ses scripts",
    "section": "5.2 Créer des sections dans un script",
    "text": "5.2 Créer des sections dans un script\nLorsqu’un script est long, RStudio permet de créer des “sections” facilitant la navigation.\nPour créer une section, il suffit de faire suivre une ligne de commentaires par plusieurs tirets -, comme ceci  :\n## Titre de la section -------------------------------------\nLe nombre de tirets n’a pas d’importance, il doit juste y’en avoir plus de quatre. RStudio affiche alors dans la marge de gauche du script un petit triangle noir qui permet de replier ou déplier le contenu de la section :\n\n\n\nSection de script dépliée\n\n\n\n\n\nSection de script repliée\n\n\nDe plus, en cliquant sur l’icône Show document outline (la plus à droite de la barre d’outils de la fenêtre du script), ou en utilisant le raccourci clavier Ctrl+Maj+O, RStudio affiche une “table des matières” automatiquement mise à jour qui liste les sections existantes et permet de naviguer facilement dans le script :\n\n\n\nListe dynamique des sections"
  },
  {
    "objectID": "05-organiser.html#répartir-son-travail-entre-plusieurs-scripts",
    "href": "05-organiser.html#répartir-son-travail-entre-plusieurs-scripts",
    "title": "5  Organiser ses scripts",
    "section": "5.3 Répartir son travail entre plusieurs scripts",
    "text": "5.3 Répartir son travail entre plusieurs scripts\nSi le script devient très long, les sections peuvent ne plus être suffisantes. De plus, il est souvent intéressant d’isoler certaines parties d’un script, par exemple pour pouvoir les mutualiser. On peut alors répartir les étapes d’une analyse entre plusieurs scripts.\nUn exemple courant concerne les recodages et la manipulation des données. Il est fréquent, au cours d’une analyse, de calculer de nouvelles variables, recoder des variables qualitatives existantes, etc. Il peut alors être intéressant de regrouper tous ces recodages dans un script à part (nommé, par exemple, recodages.R). Ce fichier contient alors l’ensemble des recodages “validés”, ceux qu’on a testé et qu’on sait vouloir conserver.\nPour exécuter ces recodages, on peut évidemment ouvrir le script recodages.R dans RStudio et lancer l’ensemble du code qu’il contient. Mais une méthode plus pratique est d’utiliser la fonction source : celle-ci prend en paramètre un nom de fichier .R, et quand on l’exécute elle va exécuter l’ensemble du code contenu dans ce fichier.\nAinsi, un début de script analyse.R pourra ressembler à ceci :\n\n# Analyse des données Histoire de vie 2003\n\n# Chargement des extensions et des données --------------------------\n\nlibrary(questionr)\n\ndata(hdv2003)\nsource(\"recodages.R\")\n\n# Analyse de l'âge --------------------------------------------------\n\nhist(hdv2003$age)\n\n(...)\n\nL’avantage principal est qu’on peut à tout moment revenir à nos données d’origine et aux recodages “validés” simplement en exécutant les deux lignes :\n\ndata(hdv2003)\nsource(\"recodages.R\")\n\nL’autre avantage est qu’on peut répartir nos analyses entre différents scripts, et conserver ces deux lignes en haut de chaque script, ce qui permet de “mutualiser” les recodages validés. On pourrait ainsi créer un deuxième script analyse_qualif.R qui pourrait ressembler à ceci :\n\n# Analyse des données Histoire de vie 2003 - Qualifications\n\n# Chargement des extensions et des données --------------------------\n\nlibrary(questionr)\n\ndata(hdv2003)\nsource(\"recodages.R\")\n\n# Analyse des qualifications --------------------------------------------------\n\nfreq(hdv2003$qualif)\n\n(...)\n\nOn peut évidemment répartir les recodages entre plusieurs fichiers et faire appel à autant de source que l’on souhaite.\n\n\n\n\n\n\nNote\n\n\n\nCette organisation recalcule l’ensemble des recodages à chaque début de script. C’est intéressant et pratique pour des données de taille raisonnable, mais pour des fichiers plus volumineux les calculs peuvent être trop longs. Dans ce cas il est préférable de créer des scripts dédiés qui chargent les données source, effectuent calculs et recodages, et enregistrent les données résultantes dans un fichier de données (voir le chapitre sur l’import/export de données). Et c’est ce fichier résultat qui sera chargé par les scripts d’analyse."
  },
  {
    "objectID": "05-organiser.html#désactiver-la-sauvegarde-de-lespace-de-travail",
    "href": "05-organiser.html#désactiver-la-sauvegarde-de-lespace-de-travail",
    "title": "5  Organiser ses scripts",
    "section": "5.4 Désactiver la sauvegarde de l’espace de travail",
    "text": "5.4 Désactiver la sauvegarde de l’espace de travail\nVous avez sans doute remarqué qu’au moment de quitter RStudio, une boîte de dialogue semblable à celle-ci s’affiche parfois :\n\n\n\nDialogue d’enregistrement de l’espace de travail\n\n\nEt il est bien difficile de comprendre de quoi cela parle.\nIl s’agit en fait d’une fonctionnalité de R lui-même qui propose d’enregistrer notre espace de travail (workspace), c’est-à-dire l’ensemble des objets qui existent actuellement dans notre environnement, dans un fichier nommé .RData. La prochaine fois que R est lancé dans le même dossier (par exemple à la réouverture du projet), s’il trouve un fichier .RData il va le lire automatiquement et restaurer l’ensemble des objets dans l’état où ils étaient.\nCeci peut sembler pratique, mais c’est en fait une mauvaise idée, pour deux raisons :\n\non peut se retrouver avec des objets dont on ne sait plus d’où ils viennent et comment ils ont été calculés\ncette manière de faire casse la logique principale de R, qui est que c’est le script qui est central, et que c’est lui qui retrace toutes les étapes de notre analyse et permet de les reproduire\n\nIl est donc fortement recommandé, juste après l’installation de RStudio, de désactiver cette fonctionnalité. Pour cela, aller dans le menu Tools, puis Global Options, et s’assurer que :\n\nla case Restore .RData into workspace at startup est décochée\nle champ Save workspace to .RData on exit vaut Never\n\n\n\n\nOptions d’enregistrement de l’espace de travail"
  },
  {
    "objectID": "06-tidyverse.html#extensions",
    "href": "06-tidyverse.html#extensions",
    "title": "6  Le tidyverse",
    "section": "6.1 Extensions",
    "text": "6.1 Extensions\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune.\nElles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) :\n\nvisualisation\nmanipulation des tableaux de données\nimport/export de données\nmanipulation de variables\nextraction de données du Web\nprogrammation\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio."
  },
  {
    "objectID": "06-tidyverse.html#installation",
    "href": "06-tidyverse.html#installation",
    "title": "6  Le tidyverse",
    "section": "6.2 Installation",
    "text": "6.2 Installation\ntidyverse est également le nom d’une extension qu’on peut installer de manière classique, soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande :\n\ninstall.packages(\"tidyverse\")\n\nCette commande va en fait installer plusieurs extensions qui constituent le “coeur” du tidyverse, à savoir :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\nlubridate (manipulation de dates)\n\n\n\n\nPackages de l’extension tidyverse\n\n\nDe la même manière, charger l’extension avec :\n\nlibrary(tidyverse)\n\nChargera l’ensemble des extensions précédentes.\nIl existe d’autres extensions qui font partie du tidyverse mais qui doivent être chargées explicitement, comme par exemple readxl (pour l’importation de données depuis des fichiers Excel). La liste complète se trouve sur le site officiel du tidyverse.\nCe document est basé sur les versions d’extension suivantes :\n\n#&gt; ggplot2   3.4.1     dplyr     1.1.0\n#&gt; tibble    3.2.0     stringr   1.5.0\n#&gt; tidyr     1.3.0     forcats   1.0.0\n#&gt; readr     2.1.4     lubridate 1.9.2\n#&gt; purrr     1.0.1"
  },
  {
    "objectID": "06-tidyverse.html#sec-tidydata",
    "href": "06-tidyverse.html#sec-tidydata",
    "title": "6  Le tidyverse",
    "section": "6.3 tidy data",
    "text": "6.3 tidy data\nLe tidyverse est en partie fondé sur le concept de tidy data, développé à l’origine par Hadley Wickham dans un article de 2014 du Journal of Statistical Software.\nIl s’agit d’un modèle d’organisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation préalable à la mise en oeuvre de méthodes d’analyse.\nLes principes d’un jeu de données tidy sont les suivants :\n\nchaque variable est une colonne\nchaque observation est une ligne\nchaque type d’observation est dans une table différente\n\nOn verra plus précisément Chapitre 12 comment définir et rendre des données tidy avec l’extension tidyr.\nLes extensions du tidyverse, notamment ggplot2 et dplyr, sont prévues pour fonctionner avec des données tidy."
  },
  {
    "objectID": "06-tidyverse.html#sec-tibbles",
    "href": "06-tidyverse.html#sec-tibbles",
    "title": "6  Le tidyverse",
    "section": "6.4 tibbles",
    "text": "6.4 tibbles\nUne autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble, qui est une évolution plus moderne du classique data frame du R de base. Ce format est fourni et géré par l’extension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse acceptent des data frames en entrée, mais retournent un objet de classe tibble.\nContrairement aux data frames, les tibbles :\n\nn’ont pas de noms de lignes (rownames)\nautorisent des noms de colonnes invalides pour les data frames (espaces, caractères spéciaux, nombres…)1\ns’affichent plus intelligemment que les data frames : seules les premières lignes sont affichées, ainsi que quelques informations supplémentaires utiles (dimensions, types des colonnes…)\nne font pas de partial matching sur les noms de colonnes2\naffichent un avertissement si on essaie d’accéder à une colonne qui n’existe pas\n\nPour autant, les tibbles restent compatibles avec les data frames. On peut ainsi facilement convertir un data frame en tibble avec as_tibble :\n\nas_tibble(mtcars)\n#&gt; # A tibble: 32 × 11\n#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # … with 22 more rows\n\nSi le data frame d’origine a des rownames, on peut d’abord les convertir en colonnes avec rownames_to_columns :\n\nd &lt;- as_tibble(rownames_to_column(mtcars))\nd\n#&gt; # A tibble: 32 × 12\n#&gt;    rowname       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # … with 22 more rows\n\nÀ l’inverse, on peut à tout moment convertir un tibble en data frame avec as.data.frame :\n\nas.data.frame(d)\n#&gt;                rowname  mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; 1            Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; 2        Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; 3           Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; 4       Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; 5    Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; 6              Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; 7           Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; 8            Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; 9             Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; 10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; 11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; 12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; 13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; 14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; 15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; 16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt;  [ reached 'max' / getOption(\"max.print\") -- omitted 16 rows ]\n\nLà encore, on peut convertir la colonne rowname en “vrais” rownames avec column_to_rownames :\n\ncolumn_to_rownames(as.data.frame(d))\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt;  [ reached 'max' / getOption(\"max.print\") -- omitted 14 rows ]\n\n\n\n\n\n\n\nNote\n\n\n\nLes deux fonctions column_to_rownames et rownames_to_column acceptent un argument supplémentaire var qui permet d’indiquer un nom de colonne autre que le nom rowname utilisé par défaut pour créer ou identifier la colonne contenant les noms de lignes."
  },
  {
    "objectID": "06-tidyverse.html#footnotes",
    "href": "06-tidyverse.html#footnotes",
    "title": "6  Le tidyverse",
    "section": "",
    "text": "Quand on veut utiliser des noms de ce type, on doit les entourer avec des backticks (`)↩︎\nDans R de base, si une table d contient une colonne qualif, d$qual retournera cette colonne.↩︎"
  },
  {
    "objectID": "07-import.html#import-de-fichiers-textes",
    "href": "07-import.html#import-de-fichiers-textes",
    "title": "7  Importer et exporter des données",
    "section": "7.1 Import de fichiers textes",
    "text": "7.1 Import de fichiers textes\nL’extension readr, qui fait partie du tidyverse, permet l’importation de fichiers texte, notamment au format CSV (Comma separated values), format standard pour l’échange de données tabulaires entre logiciels.\nCette extension fait partie du “coeur” du tidyverse, elle est donc automatiquement chargée avec :\n\nlibrary(tidyverse)\n\nSi votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read_csv en lui passant en argument le nom du fichier :\n\nd &lt;- read_csv(\"fichier.csv\")\n\nSi votre fichier vient d’Excel, avec des valeurs séparées par des points virgule, utilisez la fonction read_csv2 :\n\nd &lt;- read_csv2(\"fichier.csv\")\n\nDans la même famille de fonction, read_tsv permet d’importer des fichiers dont les valeurs sont séparées par des tabulations, et read_delim des fichiers délimités par un séparateur indiqué en argument.\nChaque fonction dispose de plusieurs arguments, parmi lesquels :\n\ncol_names indique si la première ligne contient le nom des colonnes (TRUE par défaut)\ncol_types permet de spécifier manuellement le type des colonnes si readr ne les identifie pas correctement\nna est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(\"\", \"NA\") par défaut\n\nIl peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut alors spécifier manuellement l’encodage du fichier importé à l’aide de l’option locale. Par exemple, si l’on est sous Mac ou Linux et que le fichier a été créé sous Windows, il est possible qu’il soit encodé au format iso-8859-1. On peut alors l’importer avec :\n\nd &lt;- read_csv(\"fichier.csv\", locale = locale(encoding = \"ISO-8859-1\"))\n\nÀ l’inverse, si vous importez un fichier sous Windows et que les accents ne sont pas affichés correctement, il est sans doute encodé en UTF-8 :\n\nd &lt;- read_csv(\"fichier.csv\", locale = locale(encoding = \"UTF-8\"))\n\nPour plus d’informations sur ces fonctions, voir le site de l’extension readr.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que si vous souhaitez importer des fichiers textes très volumineux le plus rapidement possible, la fonction fread de l’extension data.table est plus rapide que read_csv.\n\n\n\n7.1.1 Interface interactive d’import de fichiers\nRStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour y accéder, dans l’onglet Environment, cliquez sur le bouton Import Dataset :\n\n\n\nMenu Import Dataset\n\n\nSélectionnez From Text (readr)…. Une nouvelle fenêtre s’affiche :\n\n\n\nDialogue d’importation\n\n\nIl vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct :\n\n\n\nExemple de dialogue d’importation\n\n\nVous pouvez modifier les options d’importation, changer le type des colonnes, etc. et l’aperçu se met à jour. De même, le code correspondant à l’importation du fichier avec les options sélectionnées est affiché dans la partie Code Preview.\n\n\n\n\n\n\nAvertissement\n\n\n\nImportant : une fois que l’import semble correct, ne cliquez pas sur le bouton Import. À la place, sélectionnez le code généré et copiez-le (ou cliquez sur l’icône en forme de presse papier) et choisissez Cancel. Ensuite, collez le code dans votre script et exécutez-le (vous pouvez supprimer la ligne commençant par View).\nCette manière de faire permet “d’automatiser” l’importation des données, puisqu’à la prochaine ouverture du script vous aurez juste à exécuter le code en question, sans repasser par l’interface d’import."
  },
  {
    "objectID": "07-import.html#import-depuis-un-fichier-excel",
    "href": "07-import.html#import-depuis-un-fichier-excel",
    "title": "7  Importer et exporter des données",
    "section": "7.2 Import depuis un fichier Excel",
    "text": "7.2 Import depuis un fichier Excel\nL’extension readxl, qui fait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx.\nElle ne fait pas partie du “coeur” du tidyverse, il faut donc la charger explicitement avec :\n\nlibrary(readxl)\n\nOn peut alors utiliser la fonction read_excel en lui spécifiant le nom du fichier :\n\nd &lt;- read_excel(\"fichier.xls\")\n\nIl est possible de spécifier la feuille et la plage de cellules que l’on souhaite importer avec les arguments sheet et range :\n\nd &lt;- read_excel(\"fichier.xls\", sheet = \"Feuille2\", range = \"C1:F124\")\n\nComme pour l’import de fichiers texte, une interface interactive d’import de fichiers Excel est disponible dans RStudio dans l’onglet Environment. Pour y accéder, cliquez sur Import Dataset puis From Excel….\n\n\n\nDialogue d’importation d’un fichier Excel\n\n\nSpécifiez le chemin ou l’URL du fichier dans le premier champ, vérifiez l’import dans la partie Data Preview, modifiez si besoin les options d’importation, copiez le code d’importation généré dans la partie Code Preview et collez le dans votre script.\nPour plus d’informations, voir le site de l’extension readxl."
  },
  {
    "objectID": "07-import.html#import-de-fichiers-sas-spss-et-stata",
    "href": "07-import.html#import-de-fichiers-sas-spss-et-stata",
    "title": "7  Importer et exporter des données",
    "section": "7.3 Import de fichiers SAS, SPSS et Stata",
    "text": "7.3 Import de fichiers SAS, SPSS et Stata\nL’import de fichiers de données au format SAS, SPSS ou Stata se fait via les fonctions de l’extension haven.\nCelle-ci fait partie du tidyverse, mais doit être chargée explicitement avec :\n\nlibrary(haven)\n\n\nPour les fichiers provenant de SAS, vous pouvez utiliser les fonctions read_sas ou read_xpt\nPour les fichiers provenant de SPSS, vous pouvez utiliser read_sav ou read_por\nPour les fichiers provenant de Stata, utilisez read_dta\n\nChaque fonction dispose de plusieurs options. Le plus simple est d’utiliser, là aussi l’interface interactive d’importation de données de RStudio : dans l’onglet Environment, sélectionnez Import Dataset puis From SPSS, From SAS ou From Stata. Indiquez le chemin ou l’url du fichier, réglez les options d’importation, puis copiez le code d’importation généré et collez le dans votre script.\nPour plus d’informations, voir le site de l’extension haven"
  },
  {
    "objectID": "07-import.html#import-de-fichiers-dbase",
    "href": "07-import.html#import-de-fichiers-dbase",
    "title": "7  Importer et exporter des données",
    "section": "7.4 Import de fichiers dBase",
    "text": "7.4 Import de fichiers dBase\nLe format dBase est encore utilisé, notamment par l’INSEE, pour la diffusion de données volumineuses.\nLes fichiers au format dbf peuvent être importées à l’aide de la fonction read.dbf de l’extension foreign 1 :\n\nlibrary(foreign)\nd &lt;- read.dbf(\"fichier.dbf\")\n\nLa fonction read.dbf n’admet qu’un seul argument, as.is. Si as.is = FALSE (valeur par défaut), les chaînes de caractères sont automatiquement converties en factor à l’importation. Si as.is = TRUE, elles sont conservées telles quelles."
  },
  {
    "objectID": "07-import.html#connexion-à-des-bases-de-données",
    "href": "07-import.html#connexion-à-des-bases-de-données",
    "title": "7  Importer et exporter des données",
    "section": "7.5 Connexion à des bases de données",
    "text": "7.5 Connexion à des bases de données\n\n7.5.1 Interfaçage via l’extension DBI\nR est capable de s’interfacer avec différents systèmes de bases de données relationnelles, dont SQLite, MS SQL Server, PostgreSQL, MariaDB, etc.\nPour illustrer rapidement l’utilisation de bases de données, on va créer une base SQLite d’exemple à l’aide du code R suivant, qui copie la table du jeu de données mtcars dans une base de données bdd.sqlite :\n\nlibrary(DBI)\nlibrary(RSQLite)\ncon &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = \"resources/bdd.sqlite\")\ndata(mtcars)\nmtcars$name &lt;- rownames(mtcars)\ndbWriteTable(con, \"mtcars\", mtcars)\ndbDisconnect(con)\n\nSi on souhaite se connecter à cette base de données par la suite, on peut utiliser l’extension DBI, qui propose une interface générique entre R et différents systèmes de bases de données. On doit aussi avoir installé et chargé l’extension spécifique à notre base, ici RSQLite. On commence par ouvrir une connexion à l’aide de la fonction dbConnect de DBI :\n\nlibrary(DBI)\nlibrary(RSQLite)\ncon &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = \"resources/bdd.sqlite\")\n\nLa connexion est stockée dans un objet con, qu’on va utiliser à chaque fois qu’on voudra interroger la base.\nOn peut vérifier la liste des tables présentes et les champs de ces tables avec dbListTables et dbListFields :\n\ndbListTables(con)\n#&gt; [1] \"mtcars\"\n\n\ndbListFields(con, \"mtcars\")\n#&gt;  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n#&gt; [11] \"carb\" \"name\"\n\nOn peut également lire le contenu d’une table dans un objet de notre environnement avec dbReadTable :\n\ncars &lt;- dbReadTable(con, \"mtcars\")\n\nOn peut également envoyer une requête SQL directement à la base et récupérer le résultat :\n\ndbGetQuery(con, \"SELECT * FROM mtcars WHERE cyl = 4\")\n#&gt;     mpg cyl  disp  hp drat    wt  qsec vs am gear carb           name\n#&gt; 1  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1     Datsun 710\n#&gt; 2  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2      Merc 240D\n#&gt; 3  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2       Merc 230\n#&gt; 4  32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1       Fiat 128\n#&gt; 5  30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2    Honda Civic\n#&gt; 6  33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 Toyota Corolla\n#&gt; 7  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1  Toyota Corona\n#&gt; 8  27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1      Fiat X1-9\n#&gt; 9  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2  Porsche 914-2\n#&gt; 10 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2   Lotus Europa\n#&gt; 11 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2     Volvo 142E\n\nEnfin, quand on a terminé, on peut se déconnecter à l’aide de dbDisconnect :\n\ndbDisconnect(con)\n\nCeci n’est évidemment qu’un tout petit aperçu des fonctionnalités de DBI.\n\n\n7.5.2 Utilisation de dplyr et dbplyr\nL’extension dplyr est dédiée à la manipulation de données, elle est présentée Chapitre 10. En installant l’extension complémentaire dbplyr, on peut utiliser dplyr directement sur une connection à une base de données générée par DBI :\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dplyr)\ncon &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = \"resources/bdd.sqlite\")\n\nLa fonction tbl notamment permet de créer un nouvel objet qui représente une table de la base de données :\n\ncars_tbl &lt;- tbl(con, \"mtcars\")\n\n\n\n\n\n\n\nAvertissement\n\n\n\nIci l’objet cars_tbl n’est pas un tableau de données, c’est juste un objet permettant d’interroger la table de notre base de données.\n\n\nOn peut utiliser cet objet avec les verbes de dplyr :\n\ncars_tbl %&gt;%\n  filter(cyl == 4) %&gt;%\n  select(name, mpg, cyl)\n#&gt; # Source:   SQL [?? x 3]\n#&gt; # Database: sqlite 3.40.1 [/home/runner/work/tidyverse/tidyverse/resources/bdd.sqlite]\n#&gt;    name             mpg   cyl\n#&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 Datsun 710      22.8     4\n#&gt;  2 Merc 240D       24.4     4\n#&gt;  3 Merc 230        22.8     4\n#&gt;  4 Fiat 128        32.4     4\n#&gt;  5 Honda Civic     30.4     4\n#&gt;  6 Toyota Corolla  33.9     4\n#&gt;  7 Toyota Corona   21.5     4\n#&gt;  8 Fiat X1-9       27.3     4\n#&gt;  9 Porsche 914-2   26       4\n#&gt; 10 Lotus Europa    30.4     4\n#&gt; # … with more rows\n\ndbplyr s’occupe, de manière transparente, de transformer les instructions dplyr en requête SQL, d’interroger la base de données et de renvoyer le résultat. De plus, tout est fait pour qu’un minimum d’opérations sur la base, parfois coûteuses en temps de calcul, ne soient effectuées.\n\n\n\n\n\n\nAvertissement\n\n\n\nIl est possible de modifier des objets de type tbl, par exemple avec mutate :\ncars_tbl &lt;- cars_tbl %&gt;% mutate(type = \"voiture\")\nDans ce cas la nouvelle colonne type est bien créée et on peut y accéder par la suite. Mais cette création se fait dans une table temporaire : elle n’existe que le temps de la connexion à la base de données. À la prochaine connexion, cette nouvelle colonne n’apparaîtra pas dans la table.\n\n\nBien souvent on utilisera une base de données quand les données sont trop volumineuses pour être gérées par un ordinateur de bureau. Mais si les données ne sont pas trop importantes, il sera en général plus rapide de récupérer l’intégralité de la table dans notre session R pour pouvoir la manipuler comme les tableaux de données habituels. Ceci se fait grâce à la fonction collect de dplyr :\n\ncars &lt;- cars_tbl %&gt;% collect\n\nIci, cars est bien un tableau de données classique, copie de la table de la base au moment du collect.\nEt dans tous les cas, on n’oubliera pas de se déconnecter avec :\n\ndbDisconnect(con)\n\n\n\n7.5.3 Ressources\nPour plus d’informations, voir la documentation très complète (en anglais) proposée par RStudio.\nPar ailleurs, depuis la version 1.1, RStudio facilite la connexion à certaines bases de données grâce à l’onglet Connections. Pour plus d’informations on pourra se référer à l’article (en anglais) Using RStudio Connections."
  },
  {
    "objectID": "07-import.html#export-de-données",
    "href": "07-import.html#export-de-données",
    "title": "7  Importer et exporter des données",
    "section": "7.6 Export de données",
    "text": "7.6 Export de données\n\n7.6.1 Export de tableaux de données\nOn peut avoir besoin d’exporter un tableau de données dans R vers un fichier dans différents formats. La plupart des fonctions d’import disposent d’un équivalent permettant l’export de données. On citera notamment :\n\nwrite_csv, write_csv2, read_tsv permettent d’enregistrer un data frame ou un tibble dans un fichier au format texte délimité\nwrite_sas permet d’exporter au format SAS\nwrite_sav permet d’exporter au format SPSS\nwrite_dta permet d’exporter au format Stata\n\nIl n’existe par contre pas de fonctions permettant d’enregistrer directement au format xls ou xlsx. On peut dans ce cas passer par un fichier CSV.\nCes fonctions sont utiles si on souhaite diffuser des données à quelqu’un d’autre, ou entre deux logiciels.\nSi vous travaillez sur des données de grandes dimensions, les formats texte peuvent être lents à exporter et importer. Dans ce cas, d’autres extensions comme arrow ou fst peuvent être utiles : elles permettent d’enregistrer des data frames dans des formats plus rapides. Les formats proposés par arrow permettent en outre l’échange de données tabulaires avec d’autres langages de programmation comme Python ou JavaScript.\n\n\n7.6.2 Sauvegarder des objets\nUne autre manière de sauvegarder des données est de les enregistrer au format RData. Ce format propre à R est compact, rapide, et permet d’enregistrer plusieurs objets R, quel que soit leur type, dans un même fichier.\nPour enregistrer des objets, il suffit d’utiliser la fonction save et de lui fournir la liste des objets à sauvegarder et le nom du fichier :\n\nsave(d, rp2018, tab, file = \"fichier.RData\")\n\nPour charger des objets préalablement enregistrés, utiliser load :\n\nload(\"fichier.RData\")\n\nLes objets d, rp2018 et tab devraient alors apparaître dans votre environnement.\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, quand on utilise load, les objets chargés sont importés directement dans l’environnement en cours avec leur nom d’origine. Si d’autres objets du même nom existent déjà, ils sont écrasés sans avertissement.\n\n\nUne alternative est d’utiliser les fonctions saveRDS et readRDS, qui permettent d’enregistrer un unique objet, et de le charger dans notre session avec le nom que l’on souhaite.\n\nsaveRDS(rp2018, \"fichier.rds\")\ndf &lt;- readRDS(\"fichier.rds\")"
  },
  {
    "objectID": "07-import.html#footnotes",
    "href": "07-import.html#footnotes",
    "title": "7  Importer et exporter des données",
    "section": "",
    "text": "foreign est une extension installée de base avec R, vous n’avez pas besoin de l’installer, il vous suffit de la charger avec library.↩︎"
  },
  {
    "objectID": "08-ggplot2.html#préparation",
    "href": "08-ggplot2.html#préparation",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.1 Préparation",
    "text": "8.1 Préparation\nggplot2 fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\nOn peut également la charger explicitement avec :\n\nlibrary(ggplot2)\n\nDans ce qui suit on utilisera le jeu de données issu du recensement de la population de 2018 inclus dans l’extension questionr (résultats partiels concernant les communes de plus de 2000 habitants de France métropolitaine). On charge ces données et on en extrait les données de 5 départements (l’utilisation de la fonction filter sera expliquée Section 10.2.2) :\n\nlibrary(questionr)\ndata(rp2018)\n\nrp &lt;- filter(\n  rp2018,\n  departement %in% c(\"Oise\", \"Rhône\", \"Hauts-de-Seine\", \"Lozère\", \"Bouches-du-Rhône\")\n)"
  },
  {
    "objectID": "08-ggplot2.html#initialisation",
    "href": "08-ggplot2.html#initialisation",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.2 Initialisation",
    "text": "8.2 Initialisation\nUn graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction :\n\nggplot(data = rp)\n## Ou, équivalent\nggplot(rp)\n\nOn a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. Ces éléments sont appelés des geom, et on les ajoute à l’objet graphique de base avec l’opérateur +.\nUn des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante :\n\nggplot(rp) + geom_histogram()\n\nReste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter sur l’axe des x (l’axe horizontal). Ainsi, si on souhaite représenter la distribution des communes du jeu de données selon le pourcentage de cadres dans leur population active (variable cadres), on pourra faire :\n\nggplot(rp) + geom_histogram(aes(x = cadres))\n\n\n\n\nSi on veut représenter une autre variable, il suffit de changer la valeur de x :\n\nggplot(rp) + geom_histogram(aes(x = ouvr))\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand on spécifie une variable, inutile d’indiquer le nom du tableau de données sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué avec le paramètre data. On peut donc se contenter de ouvr.\n\n\nCertains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points, on peut le faire en ajoutant un geom_point. On doit alors indiquer à la fois la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points, il faut donc passer ces deux arguments à aes() :\n\nggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nOn peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha :\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres),\n    color = \"darkgreen\", size = 3, alpha = 0.3\n  )\n\n\n\n\nOn notera que dans ce cas les arguments sont dans la fonction geom mais à l’extérieur du aes(). Plus d’explications sur ce point dans quelques instants."
  },
  {
    "objectID": "08-ggplot2.html#exemples-de-geom",
    "href": "08-ggplot2.html#exemples-de-geom",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.3 Exemples de geom",
    "text": "8.3 Exemples de geom\nIl existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre les geom_histogram et geom_point que l’on vient de voir, on pourra noter les geom suivants.\n\n8.3.1 geom_boxplot\ngeom_boxplot permet de représenter des boîtes à moustaches. On lui passe en y la variable numérique dont on veut étudier la répartition, et en x la variable qualitative contenant les classes qu’on souhaite comparer. Ainsi, si on veut comparer la répartition du pourcentage de maisons en fonction du département de la commune, on pourra faire :\n\nggplot(rp) + geom_boxplot(aes(x = departement, y = maison))\n\n\n\n\nOn peut personnaliser la présentation avec différents argument supplémentaires comme fill ou color :\n\nggplot(rp) +\n  geom_boxplot(\n    aes(x = departement, y = maison),\n    fill = \"wheat\", color = \"tomato4\"\n  )\n\n\n\n\nUn autre argument utile, varwidth, permet de faire varier la largeur des boîtes en fonction des effectifs de la classe (donc, ici, en fonction du nombre de communes de chaque département) :\n\nggplot(rp) +\n  geom_boxplot(aes(x = departement, y = maison), varwidth = TRUE)\n\n\n\n\n\n\n8.3.2 geom_violin\ngeom_violin est très semblable à geom_boxplot, mais utilise des graphes en violon à la place des boîtes à moustache.\n\nggplot(rp) + geom_violin(aes(x = departement, y = maison))\n\n\n\n\nLes graphes en violon peuvent donner une lecture plus fine des différences de distribution selon les classes. Comme pour les graphiques de densité, on peut faire varier le niveau de “détail” de la représentation en utilisant l’argument bw (bande passante).\n\nggplot(rp) +\n  geom_violin(\n    aes(x = departement, y = maison),\n    bw = 2\n  )\n\n\n\n\n\n\n8.3.3 geom_bar et geom_col\ngeom_bar permet de produire un graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité.\nPar exemple, si on veut afficher le nombre de communes de notre jeu de données pour chaque département :\n\nggplot(rp) + geom_bar(aes(x = departement))\n\n\n\n\nSi on préfère avoir un graphique en barres horizontales, il suffit de passer la variable comme attribut y plutôt que x.\n\nggplot(rp) + geom_bar(aes(y = departement))\n\n\n\n\nUne autre possibilité est d’utiliser coord_flip(), qui permet d’intervertir l’axe horizontal et l’axe vertical.\n\nggplot(rp) +\n  geom_bar(aes(x = departement)) +\n  coord_flip()\n\n\n\n\nÀ noter que coord_flip() peut s’appliquer à n’importe quel graphique ggplot2.\nParfois, on a déjà calculé le tri à plat de la variable à représenter. Dans ce cas on souhaite représenter les effectifs directement, sans les calculer.\nC’est le cas par exemple si on a les données sous la forme suivante dans un tableau de données nommé tab :\n\ntab\n#&gt;        departement   n\n#&gt; 1 Bouches-du-Rhône 115\n#&gt; 2   Hauts-de-Seine  35\n#&gt; 3           Lozère   8\n#&gt; 4             Oise  76\n#&gt; 5            Rhône 132\n\nDans ce cas on peut utiliser geom_col. Il faut alors spécifier, en plus de l’argument x, un argument y indiquant la variable contenant la hauteur des barres. Dans notre exemple, il s’agit de la variable n.\n\nggplot(tab) + geom_col(aes(x = departement, y = n))\n\n\n\n\nQue ce soit pour geom_bar ou geom_col, on peut modifier l’apparence du graphique en passant des arguments supplémentaires comme fill ou width.\n\nggplot(rp) +\n  geom_bar(\n    aes(x = departement),\n    fill = \"darkblue\", width = .5\n  )\n\n\n\n\n\n\n8.3.4 geom_text\ngeom_text permet d’afficher des étiquettes de texte. On doit lui fournir trois paramètres dans aes : x et y pour la position des étiquettes, et label pour leur texte.\nPar exemple, si on souhaite représenter le nuage croisant la part des diplômés du supérieur et la part de cadres, mais en affichant le nom de la commune (variable commune) plutôt qu’un simple point, on peut faire :\n\nggplot(rp) +\n  geom_text(\n    aes(x = dipl_sup, y = cadres, label = commune)\n  )\n\n\n\n\nOn peut personnaliser l’apparence et la position du texte avec des arguments comme size, color, etc.\n\nggplot(rp) +\n  geom_text(\n    aes(x = dipl_sup, y = cadres, label = commune),\n    color = \"darkred\", size = 2\n  )\n\n\n\n\n\n\n8.3.5 geom_label\ngeom_label est identique à geom_text, mais avec une présentation un peu différente.\n\nggplot(rp) + geom_label(aes(x = dipl_sup, y = cadres, label = commune))\n\n\n\n\n\n\n8.3.6 geom_density\ngeom_density permet d’afficher l’estimation de densité d’une variable numérique. Son usage est similaire à celui de geom_histogram.\nAinsi, si on veut afficher la densité de la répartition de la part des cadres dans les communes de notre jeu de données :\n\nggplot(rp) + geom_density(aes(x = cadres))\n\n\n\n\nOn peut utiliser différents arguments pour ajuster le calcul de l’estimation de densité, parmi lesquels kernel et bw (voir la page d’aide de la fonction density pour plus de détails). bw (abbréviation de bandwidth, bande passante) permet de régler la “finesse” de l’estimation de densité, un peu comme le choix du nombre de classes dans un histogramme :\n\nggplot(rp) + geom_density(aes(x = cadres), bw = 1)\n\n\n\n\n\n\n8.3.7 geom_line\ngeom_line trace des lignes connectant les différentes observations entre elles. Il est notamment utilisé pour la représentation de séries temporelles. On passe à geom_line deux paramètres : x et y. Les observations sont alors connectées selon l’ordre des valeurs passées en x.\nComme il n’y a pas de données adaptées pour ce type de représentation dans notre jeu de données d’exemple, on va utiliser ici le jeu de données economics inclus dans ggplot2 et représenter l’évolution du taux de chômage aux États-Unis (variable unemploy) dans le temps (variable date) :\n\ndata(\"economics\")\neconomics\n#&gt; # A tibble: 574 × 6\n#&gt;    date         pce    pop psavert uempmed unemploy\n#&gt;    &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 1967-07-01  507. 198712    12.6     4.5     2944\n#&gt;  2 1967-08-01  510. 198911    12.6     4.7     2945\n#&gt;  3 1967-09-01  516. 199113    11.9     4.6     2958\n#&gt;  4 1967-10-01  512. 199311    12.9     4.9     3143\n#&gt;  5 1967-11-01  517. 199498    12.8     4.7     3066\n#&gt;  6 1967-12-01  525. 199657    11.8     4.8     3018\n#&gt;  7 1968-01-01  531. 199808    11.7     5.1     2878\n#&gt;  8 1968-02-01  534. 199920    12.3     4.5     3001\n#&gt;  9 1968-03-01  544. 200056    11.7     4.1     2877\n#&gt; 10 1968-04-01  544  200208    12.3     4.6     2709\n#&gt; # … with 564 more rows\n\n\nggplot(economics) + geom_line(aes(x = date, y = unemploy))\n\n\n\n\n\n\n8.3.8 geom_hex et geom_bin2d\nLorsque le nombre de points est important, la représentation sous forme de nuage peut vite devenir illisible : la superposition des données empêche de voir précisément leur répartition.\n\nggplot(rp2018) + geom_point(aes(x = cadres, y = dipl_sup))\n\n\n\n\nDans ces cas-là, on peut utiliser geom_bin2d, qui va créer une grille sur toute la zone du graphique et colorier chaque carré selon le nombre de points qu’il contient (les carrés n’en contenant aucun restant transparents).\n\nggplot(rp2018) +\n  geom_bin2d(aes(x = cadres, y = dipl_sup))\n\n\n\n\nUne variante fonctionnant de manière très semblable est geom_hex, qui elle crée une grille constituée d’hexagones.\n\nggplot(rp2018) +\n  geom_hex(aes(x = cadres, y = dipl_sup))\n\n\n\n\nDans les deux cas, on peut faire varier le nombre de zones, et donc la finesse du “quadrillage”, en utilisant l’argument bins (dont la valeur par défaut est 30).\n\nggplot(rp2018) +\n  geom_bin2d(\n    aes(x = cadres, y = dipl_sup),\n    bins = 50\n  )\n\n\n\n\n\nggplot(rp2018) +\n  geom_hex(\n    aes(x = cadres, y = dipl_sup),\n    bins = 70\n  )"
  },
  {
    "objectID": "08-ggplot2.html#mappages",
    "href": "08-ggplot2.html#mappages",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.4 Mappages",
    "text": "8.4 Mappages\nUn mappage, dans ggplot2, est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données.\nCes mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic).\n\n8.4.1 Exemples de mappages\nOn a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) dépend de la valeur des variables passées comme arguments x et y dans aes().\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres)\n  )\n\n\n\n\nMais on peut ajouter d’autres mappages. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable. Ainsi, on peut vouloir colorer les points selon le département de la commune correspondante.\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres, color = departement)\n  )\n\n\n\n\nOn peut aussi faire varier la taille des points avec size. Ici, la taille dépend de la population totale de la commune :\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)\n  )\n\n\n\n\nOn peut même associer la transparence des points à une variable avec alpha :\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)\n  )\n\n\n\n\nChaque geom possède sa propre liste de mappages.\n\n\n8.4.2 aes() or not aes() ?\nComme on l’a déjà vu, parfois on souhaite changer un attribut sans le relier à une variable : c’est le cas par exemple si on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes().\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres),\n    color = \"red\"\n  )\n\n\n\n\nPar contre, si on veut faire varier la couleur en fonction des valeurs prises par une variable, on réalise un mappage, et on doit donc placer l’attribut color à l’intérieur de aes().\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres, color = departement)\n  )\n\n\n\n\nOn peut mélanger attributs liés à une variable (mappage, donc dans aes()) et attributs constants (donc à l’extérieur). Dans l’exemple suivant, la taille varie en fonction de la variable pop_tot, mais la couleur est constante pour tous les points.\n\nggplot(rp) +\n  geom_point(\n    aes(x = dipl_sup, y = cadres, size = pop_tot),\n    color = \"royalblue\"\n  )\n\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nLa règle est donc simple mais très importante :\nSi on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit en-dehors de la fonction aes().\n\n\n\n\n8.4.3 geom_bar et position\nUn des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une deuxième variable :\n\nggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl))\n\n\n\n\nL’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut l’argument vaut position = \"stack\" et elles sont donc “empilées”. Mais on peut préciser position = \"dodge\" pour les mettre côte à côte.\n\nggplot(rp) +\n  geom_bar(\n    aes(x = departement, fill = pop_cl),\n    position = \"dodge\"\n  )\n\n\n\n\nOu encore position = \"fill\" pour représenter non plus des effectifs, mais des proportions.\n\nggplot(rp) +\n  geom_bar(\n    aes(x = departement, fill = pop_cl),\n    position = \"fill\"\n  )\n\n\n\n\nLà encore, on peut utiliser coord_flip() si on souhaite une visualisation avec des barres horizontales.\n\nggplot(rp) +\n  geom_bar(\n    aes(x = departement, fill = pop_cl),\n    position = \"fill\"\n  ) +\n  coord_flip()"
  },
  {
    "objectID": "08-ggplot2.html#représentation-de-plusieurs-geom",
    "href": "08-ggplot2.html#représentation-de-plusieurs-geom",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.5 Représentation de plusieurs geom",
    "text": "8.5 Représentation de plusieurs geom\nOn peut représenter plusieurs geom simultanément sur un même graphique, il suffit de les ajouter à tour de rôle avec l’opérateur +.\nPar exemple, on peut superposer la position des points au-dessus d’un boxplot. On va pour cela ajouter un geom_point après avoir ajouté notre geom_boxplot.\n\nggplot(rp) +\n  geom_boxplot(aes(x = departement, y = maison)) +\n  geom_point(\n    aes(x = departement, y = maison),\n    col = \"red\", alpha = 0.2\n  )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand une commande ggplot2 devient longue, il peut être plus lisible de la répartir sur plusieurs lignes. Dans ce cas, il faut penser à placer l’opérateur + en fin de ligne, afin que R comprenne que la commande n’est pas complète et qu’il prenne en compte la suite.\n\n\nPour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation.\n\nggplot(rp) +\n  geom_boxplot(aes(x = departement, y = maison)) +\n  geom_jitter(\n    aes(x = departement, y = maison),\n    col = \"red\", alpha = 0.2\n  )\n\n\n\n\nPour simplifier un peu le code, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages).\n\nggplot(rp, aes(x = departement, y = maison)) +\n  geom_boxplot() +\n  geom_jitter(color = \"red\", alpha = 0.2)\n\n\n\n\nAutre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n  geom_point(alpha = 0.2) +\n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\nEt on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n  geom_point(alpha = 0.2) +\n  geom_density2d(color = \"red\") +\n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n8.5.1 Plusieurs sources de données\nOn peut associer à différents geom des sources de données différentes. Supposons qu’on souhaite afficher sur un nuage de points les noms des communes de plus de 50000 habitants. On commencer par créer un tableau de données contenant uniquement ces communes à l’aide de la fonction filter.\n\ncom50 &lt;- filter(rp, pop_tot &gt;= 50000)\n\nOn fait ensuite le nuage de points comme précédemment :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n  geom_point(alpha = 0.2)\n\n\n\n\nPour superposer les noms de communes de plus de 50 000 habitants, on peut ajouter un geom_text, mais en spécifiant que les données proviennent du nouveau tableau com50 et non de notre tableau initial rp. On le fait en passant un argument data spécifique à geom_text :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n  geom_point(alpha = 0.2) +\n  geom_text(\n    data = com50, aes(label = commune),\n    color = \"red\", size = 3\n  )\n\n\n\n\nAinsi, on obtient un graphique avec deux geom superposés, mais dont les données proviennent de deux tableaux différents."
  },
  {
    "objectID": "08-ggplot2.html#faceting",
    "href": "08-ggplot2.html#faceting",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.6 Faceting",
    "text": "8.6 Faceting\nLe faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives.\nPar exemple, on a vu qu’on peut représenter l’histogramme du pourcentage de cadres dans nos communes avec le code suivant :\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres))\n\n\n\n\nOn souhaite comparer cette distribution de la part des cadres selon le département, et donc faire un histogramme pour chacun de ces départements. C’est ce que permettent les fonctions facet_wrap et facet_grid.\nfacet_wrap prend un paramètre de la forme vars(variable), où variable est le nom de la variable en fonction de laquelle on souhaite faire les différents graphiques. Ceux-ci sont alors affichés les uns à côté des autres et répartis automatiquement dans la page.\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  facet_wrap(vars(departement))\n\n\n\n\nPour facet_grid, les graphiques sont disposés selon une grille. La fonction prend alors deux arguments, rows et cols, auxquels on passe les variables à afficher en ligne ou en colonne via la fonction vars().\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  facet_grid(rows = vars(departement))\n\n\n\n\nUn des intérêts du faceting dans ggplot2 est que tous les graphiques générés ont les mêmes échelles, ce qui permet une comparaison directe.\nEnfin, notons qu’on peut même faire du faceting sur plusieurs variables à la fois. On peut par exemple faire des histogrammes de la répartition de la part des cadres pour chaque croisement des variables departement et pop_cl :\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  facet_grid(\n    rows = vars(departement), cols = vars(pop_cl)\n  )\n\n\n\n\nL’histogramme en haut à gauche représente la répartition du pourcentage de cadres parmi les communes de 2000 à 3000 habitants dans les Bouches-du-Rhône, etc."
  },
  {
    "objectID": "08-ggplot2.html#scales",
    "href": "08-ggplot2.html#scales",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.7 Scales",
    "text": "8.7 Scales\nOn a vu qu’avec ggplot2 on définit des mappages entre des attributs graphiques (position, taille, couleur, etc.) et des variables d’un tableau de données. Ces mappages sont définis, pour chaque geom, via la fonction aes().\nLes scales dans ggplot2 permettent de modifier la manière dont un attribut graphique va être relié aux valeurs d’une variable, et dont la légende correspondante va être affichée. Par exemple, pour l’attribut color, on pourra définir la palette de couleur utilisée. Pour size, les tailles minimales et maximales, etc.\nPour modifier une scale existante, on ajoute un nouvel élément à notre objet ggplot2 avec l’opérateur +. Cet élément prend la forme scale_&lt;attribut&gt;_&lt;type&gt;.\nVoyons tout de suite quelques exemples.\n\n8.7.1 scale_size\nSi on souhaite modifier les tailles minimales et maximales des objets quand on a effectué un mappage de type size, on peut utiliser la fonction scale_size et son argument range.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n  scale_size(range = c(0, 20))\n\n\n\n\nÀ comparer par exemple à :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n  scale_size(range = c(2, 8))\n\n\n\n\nOn peut ajouter d’autres paramètres à scale_size. Le premier argument est toujours le titre donné à la légende.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n  scale_size(\n    \"Population\",\n    range = c(0, 15)\n  )\n\n\n\n\nOn peut aussi définir manuellement les éléments de légende représentés.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n  scale_size(\n    \"Population\",\n    range = c(0, 15),\n    breaks = c(1000, 5000, 10000, 50000)\n  )\n\n\n\n\n\n\n8.7.2 scale_x, scale_y\nLes scales scale_x_&lt;type&gt; et scale_y_&lt;type&gt; modifient les axes x et y du graphique.\nscale_x_continuous et scale_y_continuous s’appliquent lorsque la variable x ou y est numérique (quantitative).\nC’est le cas de notre nuage de points croisant part de cadres et part de diplômés du supérieur.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nComme on représente des pourcentages, on peut vouloir forcer les axes x et y à s’étendre des valeurs 0 à 100. On peut le faire en ajoutant un élément scale_x_continuous et un élément scale_y_continuous, et en utilisant leur argument limits.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres)) +\n  scale_x_continuous(limits = c(0,100)) +\n  scale_y_continuous(limits = c(0,100))\n\n\n\n\nLà aussi, on peut modifier les étiquettes des axes en indiquant une chaîne de caractères en premier argument.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres)) +\n  scale_x_continuous(\"Part des diplômés du supérieur (%)\", limits = c(0,100)) +\n  scale_y_continuous(\"Part des cadres (%)\", limits = c(0,100))\n\n\n\n\nOn peut utiliser scale_x_log10 et scale_y_log10 pour passer un axe à une échelle logarithmique.\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres)) +\n  scale_x_log10(\"Diplômés du supérieur\")\n\n\n\n\nscale_x_discrete et scale_y_discrete s’appliquent lorsque l’axe correspond à une variable discrète (qualitative). C’est le cas par exemple de l’axe des x dans un diagramme en barres.\n\nggplot(rp) +\n  geom_bar(aes(x = departement)) +\n  scale_x_discrete(\"Département\")\n\n\n\n\nL’argument limits de scale_x_discrete permet d’indiquer quelles valeurs sont affichées et dans quel ordre.\n\nggplot(rp) +\n  geom_bar(aes(x = departement)) +\n  scale_x_discrete(\"Département\", limits = c(\"Oise\", \"Lozère\", \"Rhône\"))\n#&gt; Warning: Removed 150 rows containing non-finite values (`stat_count()`).\n\n\n\n\n\n\n8.7.3 scale_color, scale_fill\nCes scales permettent, entre autre, de modifier les palettes de couleur utilisées pour le dessin (color) ou le remplissage (fill) des éléments graphiques. Dans ce qui suit, pour chaque fonction scale_color présentée il existe une fonction scale_fill équivalente et avec en général les mêmes arguments.\n\n8.7.3.1 Variables quantitatives\nLe graphique suivant colore les points selon la valeur d’une variable numérique quantitative (ici la part de chômeurs) :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = chom))\n\n\n\n\nOn peut modifier les couleurs utilisées avec les arguments low et high de la fonction scale_color_gradient. Ici on souhaite que la valeur la plus faible soit blanche, et la plus élevée rouge :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n  scale_color_gradient(\"Taux de chômage\", low = \"white\", high = \"red\")\n\n\n\n\nOn peut aussi utiliser des palettes prédéfinies. L’une des plus populaires est la palette viridis, accessible en utilisant scale_color_viridis_c :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n  scale_color_viridis_c(\"Taux de chômage\")\n\n\n\n\nviridis propose également trois autres palettes, magma, inferno et plasma, accessibles via l’argument option :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n  scale_color_viridis_c(\"Taux de chômage\", option = \"plasma\")\n\n\n\n\nOn peut aussi utiliser scale_color_distiller, qui transforme une des palettes pour variable qualitative de scale_color_brewer en palette continue pour variable numérique :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n  scale_color_distiller(\"Taux de chômage\", palette = \"Spectral\")\n\n\n\n\nLa liste des palettes de scale_color_brewer est indiquée en fin de section suivante.\n\n\n8.7.3.2 Variables qualitatives\nSi on a fait un mappage avec une variable discrète (qualitative), comme ici avec le département :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = departement))\n\n\n\n\nUne première possibilité est de modifier la palette manuellement avec scale_color_manual et son argument values :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n  scale_color_manual(\n    \"Département\",\n    values = c(\"red\", \"#FFDD45\", rgb(0.1,0.2,0.6), \"darkgreen\", \"grey80\")\n  )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nL’exemple précédent montre plusieurs manières de définir manuellement des couleurs dans R :\n\nPar code hexadécimal : \"#FFDD45\"\nEn utilisant la fonction rgb et en spécifiant les composantes rouge, vert, bleu par des nombres entre 0 et 1 (et optionnellement une quatrième composante d’opacité, toujours entre 0 et 1) : rgb(0.1,0.2,0.6)\nEn donnant un nom de couleur : \"red\", \"darkgreen\"\n\nLa liste complète des noms de couleurs connus par R peut être obtenu avec la fonction colors(). Vous pouvez aussi retrouver en ligne la liste des couleurs et leur nom (PDF).\n\n\nIl est cependant souvent plus pertinent d’utiliser des palettes prédéfinies. Celles du site Colorbrewer, initialement prévues pour la cartographie, permettent une bonne lisibilité, et peuvent être adaptées pour certains types de daltonisme.\nCes palettes s’utilisent via la fonction scale_color_brewer, en passant le nom de la palette via l’argument palette. Par exemple, si on veut utiliser la palette Set1 :\n\nggplot(rp) +\n  geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n  scale_color_brewer(\"Département\", palette = \"Set1\")\n\n\n\n\nLe graphique suivant, accessible via la fonction display.brewer.all(), montre la liste de toutes les palettes disponibles via scale_color_brewer. Elles sont réparties en trois familles : les palettes séquentielles (pour une variable quantitative), les palettes qualitatives, et les palettes divergentes (typiquement pour une variable quantitative avec une valeur de référence, souvent 0, et deux palettes continues distinctes pour les valeurs inférieures et pour les valeurs supérieures).\n\nRColorBrewer::display.brewer.all()\n\n\n\n\n\n\nIl existe d’autres méthodes pour définir les couleurs : pour plus d’informations on pourra se reporter à l’article de la documentation officielle sur ce sujet."
  },
  {
    "objectID": "08-ggplot2.html#thèmes",
    "href": "08-ggplot2.html#thèmes",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.8 Thèmes",
    "text": "8.8 Thèmes\nLes thèmes permettent de contrôler l’affichage de tous les éléments du graphique qui ne sont pas reliés aux données : titres, grilles, fonds, etc.\nIl existe un certain nombre de thèmes préexistants, par exemple le thème theme_bw :\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  theme_bw()\n\n\n\n\nOu le thème theme_minimal :\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  theme_minimal()\n\n\n\n\nOn peut cependant modifier manuellement les différents éléments. Par exemple, les fonctions ggtitle, xlab et ylab permettent d’ajouter ou de modifier le titre du graphique, ainsi que les étiquettes des axes x et y :\n\nggplot(data = rp) +\n  geom_histogram(aes(x = cadres)) +\n  ggtitle(\"Un bien bel histogramme\") +\n  xlab(\"Pourcentage de cadres\") +\n  ylab(\"Effectif\")\n\n\n\n\nLes éléments personnalisables étant nombreux, un bon moyen de se familiariser avec tous les arguments est sans doute l’addin RStudio ggThemeAssist. Pour l’utiliser il suffit d’installer le package du même nom, de sélectionner dans son script RStudio le code correspondant à un graphique ggplot2, puis d’aller dans le menu Addins et choisir ggplot Theme Assistant. Une interface graphique s’affiche alors permettant de modifier les différents éléments. Si on clique sur Done, le code sélectionné dans le script est alors automatiquement mis à jour pour correspondre aux modifications effectuées.\nCe qui permet d’obtenir très facilement des résultats extrêmement moches :\n\nggplot(data = rp) + geom_histogram(aes(x = cadres)) +\n theme(panel.grid.major = element_line(colour = \"dodgerblue\",\n    size = 0.5, linetype = \"dotdash\"), axis.title = element_text(family = \"serif\",\n    size = 18, face = \"italic\", colour = \"white\"),\n    axis.text = element_text(family = \"serif\",\n        size = 15, face = \"bold\"), axis.text.x = element_text(family = \"mono\"),\n    plot.title = element_text(family = \"serif\"),\n    legend.text = element_text(family = \"serif\"),\n    legend.title = element_text(family = \"serif\"),\n    panel.background = element_rect(fill = \"coral\"),\n    plot.background = element_rect(fill = \"blueviolet\"))"
  },
  {
    "objectID": "08-ggplot2.html#ladd-in-esquisse",
    "href": "08-ggplot2.html#ladd-in-esquisse",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.9 L’add-in esquisse",
    "text": "8.9 L’add-in esquisse\nesquisse est un package développé notamment par Victor Perrier de dreamRs et qui fournit une interface graphique pour la construction de graphiques avec ggplot2.\nPour l’utiliser, il faut évidemment préalablement installer l’extension :\n\ninstall.packages(\"esquisse\")\n\nPour lancer l’interface, ouvrez le menu Addins dans la barre d’outils de RStudio, et cliquez sur ‘ggplot2’ builder1.\n\nUne fenêtre s’ouvre : la première étape consiste à choisir un data frame de votre environnement, et éventuellement à ne sélectionner que certaines de ses variables.\n Une fois le choix effectué, cliquez sur Validate imported data.\nL’interface principale s’affiche alors. La liste des variables du data frame apparaît en haut, et vous pouvez les faire glisser dans les zones X, Y, Fill, Color, Size et Facet pour créer des mappages. Le graphique se met automatiquement à jour.\n\nPar défaut, esquisse sélectionne le type de graphique le plus approprié selon la nature de vos variables. Mais vous pouvez choisir un autre type de graphique à l’aide de l’icône en haut à gauche, parmi onze disponibles (dont Auto):\n.\nEnfin, une série de menus en bas de l’interface vous permet de personnaliser les titres, les annotations (labels), la présentation ou de filtrer des valeurs de vos variables.\nQuand vous avez généré un graphique que vous souhaitez conserver, ouvrez le menu Export & code :\n\nVous y trouverez le code R correspondant au graphique actuellement affiché. Vous pouvez dès lors le copier pour le coller dans votre script, ou cliquer sur Insert code in script pour l’insérer directement dans votre script à l’endroit où se trouve votre curseur.\nesquisse ne propose pas (encore) tous les geom ou toutes les possibilités de ggplot2, mais ça peut être un outil très utile et pratique pour une exploration rapide de données ou lorsqu’on est un peu perdu dans la syntaxe et les fonctions de l’extension.\nPour plus d’informations, vous pouvez vous référer à la page du projet sur GitHub (en anglais)."
  },
  {
    "objectID": "08-ggplot2.html#ressources",
    "href": "08-ggplot2.html#ressources",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.10 Ressources",
    "text": "8.10 Ressources\nLa documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne.\nUne “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Cheatsheets &gt; Data visualization with ggplot2) ou en ligne.\nLes parties Data visualisation et Graphics for communication de l’ouvrage en ligne R for data science, de Hadley Wickham, sont une très bonne introduction à ggplot2.\nPlusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, toujours de Hadley Wickham, et le R Graphics Cookbook de Winston Chang.\nLe site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes.\nEnfin, si ggplot2 présente déjà un très grand nombre de fonctionnalités, il existe aussi un système d’extensions permettant d’ajouter des geom, des thèmes, etc. Le site ggplot2 extensions est une très bonne ressource pour les parcourir et les découvrir, notamment grâce à sa galerie."
  },
  {
    "objectID": "08-ggplot2.html#exercices",
    "href": "08-ggplot2.html#exercices",
    "title": "8  Visualiser avec ggplot2",
    "section": "8.11 Exercices",
    "text": "8.11 Exercices\nPour les exercices qui suivent, on commence par charger les extensions nécessaires et les données du jeu de données rp2018. On crée alors un objet rp69 comprenant uniquement les communes du Rhône et de la Loire.\n\nlibrary(tidyverse)\nlibrary(questionr)\ndata(rp2018)\n\nrp69 &lt;- filter(rp2018, departement %in% c(\"Rhône\", \"Loire\"))\n\nExercice 1\nFaire un nuage de points croisant le pourcentage de sans diplôme (dipl_aucun) et le pourcentage d’ouvriers (ouvr).\n\n\n\n\n\n\n\nggplot(rp69) + geom_point(aes(x = dipl_aucun, y = ouvr))\n\n\nExercice 2\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers, avec les points en rouge et de transparence 0.2.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = dipl_aucun, y = ouvr), color = \"red\", alpha = 0.2)\n\n\nExercice 3\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches.\n\n\n\n\n\n\n\nggplot(rp69) + geom_boxplot(aes(x = pop_cl, y = proprio))\n\n\nExercice 4\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes sous la forme d’un diagramme en bâtons.\n\n\n\n\n\n\n\nggplot(rp69) + geom_bar(aes(x = pop_cl))\n\n\nExercice 5\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Faire varier la couleur selon le département (departement).\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = dipl_aucun, y = ouvr, color = departement))\n\n\nSur le même graphique, faire varier la taille des points selon la population totale de la commune (pop_tot).\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = dipl_aucun, y = ouvr, color = departement, size = pop_tot))\n\n\nEnfin, toujours sur le même graphique, rendre les points transparents en plaçant leur opacité à 0.5.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = dipl_aucun, y = ouvr, color = departement, size = pop_tot), alpha = 0.5)\n\n\nExercice 6\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches. Faire varier la couleur de remplissage (attribut fill) selon le département.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_boxplot(aes(x = pop_cl, y = proprio, fill = departement))\n\n\nExercice 7\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes (variable pop_cl) sous forme de diagramme en bâtons empilés, avec une couleur différente selon le département.\n\n\n\n\n\n\n\nggplot(rp69) + geom_bar(aes(x = pop_cl, fill = departement))\n\n\nFaire varier la valeur du paramètre position pour afficher les barres les unes à côté des autres.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_bar(aes(x = pop_cl, fill = departement),\n           position = \"dodge\")\n\n\nChanger à nouveau la valeur du paramètre position pour représenter les proportions de communes de chaque département pour chaque catégorie de taille.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_bar(aes(x = pop_cl, fill = departement),\n           position = \"fill\")\n\n\nExercice 8\nFaire un nuage de points représentant en abscisse le pourcentage de cadres (cadres) et en ordonnée le pourcentage de diplômés du supérieur (dipl_sup). Représenter ce nuage par deux graphiques différents selon le département en utilisant facet_grid.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = cadres, y = dipl_sup)) +\n  facet_grid(cols = vars(departement))\n\n\nSur le même graphique, faire varier la taille des points selon la population totale de la communes (variable pop_tot) et rendre les points transparents.\n\n\n\n\n\n\n\nggplot(rp69) +\n  geom_point(aes(x = cadres, y = dipl_sup, size = pop_tot), alpha = 0.5) +\n  facet_grid(cols = vars(departement))\n\n\nExercice 9\nFaire le nuage de points croisant pourcentage de chômeurs (chom) et pourcentage de sans diplôme. Y ajouter les noms des communes correspondant (variable commune), en rouge et en taille 2.5 :\n\n\n\n\n\n\n\nggplot(rp69, aes(x = chom, y = dipl_aucun)) +\n  geom_point() +\n  geom_text(aes(label = commune), color = \"red\", size = 2.5)\n\n\nExercice 10\nDans le graphique précédent, n’afficher que le nom des communes ayant plus de 15% de chômage.\n\n\n\n\n\n\n\nchom15 &lt;- filter(rp69, chom &gt; 15)\nggplot(rp69, aes(x = chom, y = dipl_aucun)) +\n  geom_point(alpha = 0.15) +\n  geom_text(data = chom15, aes(label = commune), color=\"red\", size=3)"
  },
  {
    "objectID": "08-ggplot2.html#footnotes",
    "href": "08-ggplot2.html#footnotes",
    "title": "8  Visualiser avec ggplot2",
    "section": "",
    "text": "Vous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎"
  },
  {
    "objectID": "09-recodages.html#sec-vecteurs",
    "href": "09-recodages.html#sec-vecteurs",
    "title": "9  Recoder des variables",
    "section": "9.1 Rappel sur les variables et les vecteurs",
    "text": "9.1 Rappel sur les variables et les vecteurs\nDans R, une variable, en général une colonne d’un tableau de données, est un objet de type vecteur. Un vecteur est un ensemble d’éléments, tous du même type.\nOn a vu qu’on peut construire un vecteur manuellement de différentes manières :\n\ncouleur &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nnombres &lt;- 1:10\n\nMais le plus souvent on manipule des vecteurs faisant partie d’une table importée dans R. Dans ce qui suit on va utiliser le jeu de données d’exemple hdv2003 de l’extension questionr.\n\nlibrary(questionr)\ndata(hdv2003)\n\nQuand on veut accéder à un vecteur d’un tableau de données, on peut utiliser l’opérateur $ :\n\nhdv2003$qualif\n\nOn peut facilement créer de nouvelles variables (ou colonnes) dans un tableau de données en utilisant le $ dans une assignation :\n\nhdv2003$minutes.tv &lt;- hdv2003$heures.tv * 60\n\nLes vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent.\nOn a ainsi des vecteurs de type integer ou double, qui contiennent respectivement des nombres entiers ou décimaux :\n\ntypeof(hdv2003$age)\n#&gt; [1] \"integer\"\n\n\ntypeof(hdv2003$heures.tv)\n#&gt; [1] \"double\"\n\nDes vecteurs de type character, qui contiennent des chaînes de caractères :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\ntypeof(vec)\n#&gt; [1] \"character\"\n\nEt des vecteurs de type logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE).\n\nvec &lt;- c(TRUE, FALSE, FALSE, TRUE)\ntypeof(vec)\n#&gt; [1] \"logical\"\n\nOn peut convertir un vecteur d’un type en un autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA.\n\nx &lt;- c(\"1\", \"2.35\", \"8.2e+03\", \"foo\")\nas.numeric(x)\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]    1.00    2.35 8200.00      NA\n\ny &lt;- 2:6\nas.character(y)\n#&gt; [1] \"2\" \"3\" \"4\" \"5\" \"6\"\n\nOn peut sélectionner certains éléments d’un vecteur à l’aide de l’opérateur []. La manière la plus simple est d’indiquer la position des éléments qu’on veut sélectionner :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[c(1, 3)]\n#&gt; [1] \"Jaune\" \"Rouge\"\n\nLa sélection peut aussi être utilisée pour modifier certains éléments d’un vecteur, par exemple :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[2] &lt;- \"Violet\"\nvec\n#&gt; [1] \"Jaune\"  \"Violet\" \"Rouge\"  \"Vert\""
  },
  {
    "objectID": "09-recodages.html#sec-tests",
    "href": "09-recodages.html#sec-tests",
    "title": "9  Recoder des variables",
    "section": "9.2 Tests et comparaison",
    "text": "9.2 Tests et comparaison\nUn test est une opération logique de comparaison qui renvoie vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur.\nParmi les opérateurs de comparaison disponibles, on trouve notamment :\n\n== qui teste l’égalité\n!= qui teste la différence\n&gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité\n%in% qui teste l’appartenance à un ensemble de valeurs\n\nExemple le plus simple :\n\n2 == 3\n#&gt; [1] FALSE\n\n\n2 != 3\n#&gt; [1] TRUE\n\nExemple appliqué à un vecteur :\n\nx &lt;- 1:10\nx &lt; 5\n#&gt;  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nOn peut combiner plusieurs tests avec les opérateurs logiques et (&) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6 inclus, on peut faire :\n\nx &gt;= 3 & x &lt;= 6\n#&gt;  [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\nSi on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec == \"Jaune\" | vec == \"Vert\"\n#&gt; [1]  TRUE  TRUE FALSE  TRUE\n\nÀ noter que dans ce cas, on peut utiliser l’opérateur %in%1, qui teste si une valeur fait partie des éléments d’un vecteur :\n\nvec %in% c(\"Jaune\", \"Vert\")\n#&gt; [1]  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, si on souhaite tester si une valeur x est inconnue (ou ‘manquante’), c’est-à-dire si elle est codée NA (Not Available), faire le test x == NA ne donnera pas le résultat escompté. En effet, fidèle à sa réputation de rigueur informaticienne, pour R NA == NA ne vaut pas TRUE mais… NA (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).\nPour tester si une valeur est inconnue (NA), il faut utiliser la fonction dédiée is.na et faire is.na(x).\nCependant, par convention, NA %in% NA vaut TRUE.\n\n\nEnfin, on peut inverser un test avec l’opérateur non (!) :\n\n!(vec %in% c(\"Jaune\", \"Vert\"))\n#&gt; [1] FALSE FALSE  TRUE FALSE\n\nLes tests sont notamment utilisés par le verbe filter de dplyr (voir Section 10.2.2) qui permet de sélectionner certaines lignes d’un tableau de données. On peut ainsi sélectionner les individus ayant entre 20 et 40 ans en filtrant sur la variable age :\n\nfilter(hdv2003, age &gt;= 20 & age &lt;= 40)\n\nOu sélectionner les personnes ayant comme catégorie socio-professionnelle Ouvrier specialise ou Ouvrier qualifie en filtrant sur la variable qualif :\n\nfilter(hdv2003, qualif %in% c(\"Ouvrier specialise\", \"Ouvrier qualifie\"))\n\nOn peut utiliser les tests pour sélectionner certains éléments d’un vecteur. Si on passe un test à l’opérateur de sélection [], seuls les éléments pour lesquels ce test est vrai seront conservés :\n\nx &lt;- c(12, 8, 14, 7, 6, 18)\nx[x &gt; 10]\n#&gt; [1] 12 14 18\n\nEnfin, on peut aussi utiliser les tests et la sélection pour modifier les valeurs d’un vecteur. Ainsi, si on assigne une valeur à une sélection, les éléments pour lesquels le test est vrai sont remplacés par cette valeur :\n\nx &lt;- c(12, 8, 14, 7, 6, 18)\nx[x &gt; 10] &lt;- 100\nx\n#&gt; [1] 100   8 100   7   6 100\n\nEn utilisant cette assignation via un test, on peut effectuer des recodages de variables. Soit le vecteur suivant :\n\nvec &lt;- c(\"Femme\", \"Homme\", \"Femme\", \"Garçon\")\n\nSi on souhaite recoder la modalité “Garçon” en “Homme”, on peut utiliser la syntaxe suivante :\n\nvec[vec == \"Garçon\"] &lt;- \"Homme\"\nvec\n#&gt; [1] \"Femme\" \"Homme\" \"Femme\" \"Homme\"\n\nCette syntaxe est tout à fait valable et couramment utilisée. On va cependant voir dans la section suivante différentes fonctions qui facilitent ces opérations de recodage.\nPour plus d’informations sur les vecteurs et les structures de données de R, voir Chapitre 16."
  },
  {
    "objectID": "09-recodages.html#sec-recoder-une-variable-qualitative",
    "href": "09-recodages.html#sec-recoder-une-variable-qualitative",
    "title": "9  Recoder des variables",
    "section": "9.3 Recoder une variable qualitative",
    "text": "9.3 Recoder une variable qualitative\nPour rappel, on appelle variable qualitative une variable pouvant prendre un nombre limité de modalités (de valeurs possibles).\n\n9.3.1 Facteurs et forcats\nDans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). Si vous utilisez les fonctions des extensions du tidyverse comme readr, readxl ou haven pour importer vos données, vos variables qualitatives seront importées sous forme de character. Mais dans d’autres cas elles se retrouveront parfois sous forme de factor. C’est le cas de notre jeu de données d’exemple hdv2003.\n\nclass(hdv2003$qualif)\n#&gt; [1] \"factor\"\n\nLes facteurs sont un type de variable ne pouvant prendre qu’un nombre défini de modalités nommés levels.\n\nlevels(hdv2003$qualif)\n#&gt; [1] \"Ouvrier specialise\"       \"Ouvrier qualifie\"        \n#&gt; [3] \"Technicien\"               \"Profession intermediaire\"\n#&gt; [5] \"Cadre\"                    \"Employe\"                 \n#&gt; [7] \"Autre\"\n\nCeci complique les opérations de recodage car du coup l’opération suivante, qui tente de modifier une modalité de la variable, aboutit à un avertissement, et l’opération n’est pas effectuée.\n\nhdv2003$qualif[hdv2003$qualif == \"Ouvrier specialise\"] &lt;- \"Ouvrier\"\n#&gt; Warning in `[&lt;-.factor`(`*tmp*`, hdv2003$qualif == \"Ouvrier specialise\", :\n#&gt; invalid factor level, NA generated\n\nforcats est une extension facilitant la manipulation des variables qualitatives, qu’elles soient sous forme de vecteurs character ou de facteurs. Elle fait partie du tidyverse, et est donc automatiquement chargée par :\n\nlibrary(tidyverse)\n\n\n\n9.3.2 Modifier les modalités d’une variable qualitative\nUne opération courante consiste à modifier les valeurs d’une variable qualitative, que ce soit pour avoir des intitulés plus courts ou plus clairs ou pour regrouper des modalités entre elles.\nIl existe plusieurs possibilités pour effectuer ce type de recodage, mais ici on va utiliser la fonction fct_recode de l’extension forcats. Celle-ci prend en argument une liste de recodages sous la forme \"Nouvelle valeur\" = \"Ancienne valeur\".\nUn exemple :\n\nf &lt;- c(\"Pomme\", \"Poire\", \"Pomme\", \"Cerise\")\nf &lt;- fct_recode(\n    f,\n    \"Fraise\" = \"Pomme\",\n    \"Ananas\" = \"Poire\"\n)\nf\n#&gt; [1] Fraise Ananas Fraise Cerise\n#&gt; Levels: Cerise Ananas Fraise\n\nAutre exemple sur une “vraie” variable :\n\nfreq(hdv2003$qualif)\n#&gt;                            n    % val%\n#&gt; Ouvrier specialise         0  0.0  0.0\n#&gt; Ouvrier qualifie         292 14.6 20.1\n#&gt; Technicien                86  4.3  5.9\n#&gt; Profession intermediaire 160  8.0 11.0\n#&gt; Cadre                    260 13.0 17.9\n#&gt; Employe                  594 29.7 41.0\n#&gt; Autre                     58  2.9  4.0\n#&gt; NA                       550 27.5   NA\n\n\nhdv2003$qualif5 &lt;- fct_recode(\n    hdv2003$qualif,\n    \"Ouvrier\" = \"Ouvrier specialise\",\n    \"Ouvrier\" = \"Ouvrier qualifie\",\n    \"Interm\" = \"Technicien\",\n    \"Interm\" = \"Profession intermediaire\"\n)\n\nfreq(hdv2003$qualif5)\n#&gt;           n    % val%\n#&gt; Ouvrier 292 14.6 20.1\n#&gt; Interm  246 12.3 17.0\n#&gt; Cadre   260 13.0 17.9\n#&gt; Employe 594 29.7 41.0\n#&gt; Autre    58  2.9  4.0\n#&gt; NA      550 27.5   NA\n\nAttention, les anciennes valeurs saisies doivent être exactement égales aux valeurs des modalités de la variable recodée : toute différence d’accent ou d’espace fera que ce recodage ne sera pas pris en compte. Dans ce cas, forcats affiche un avertissement nous indiquant qu’une valeur saisie n’a pas été trouvée dans les modalités de la variable.\n\nhdv2003$qualif_test &lt;- fct_recode(\n    hdv2003$qualif,\n    \"Ouvrier\" = \"Ouvrier spécialisé\",\n    \"Ouvrier\" = \"Ouvrier qualifié\"\n)\n#&gt; Warning: Unknown levels in `f`: Ouvrier spécialisé, Ouvrier qualifié\n\nSi on souhaite recoder une modalité de la variable en NA, il faut (contre intuitivement) lui assigner la valeur NULL.\n\nhdv2003$qualif_rec &lt;- fct_recode(\n    hdv2003$qualif, \n    NULL = \"Autre\"\n)\n\nfreq(hdv2003$qualif_rec)\n#&gt;                            n    % val%\n#&gt; Ouvrier specialise         0  0.0  0.0\n#&gt; Ouvrier qualifie         292 14.6 21.0\n#&gt; Technicien                86  4.3  6.2\n#&gt; Profession intermediaire 160  8.0 11.5\n#&gt; Cadre                    260 13.0 18.7\n#&gt; Employe                  594 29.7 42.7\n#&gt; NA                       608 30.4   NA\n\nÀ l’inverse, si on souhaite recoder les NA d’une variable, on utilisera la fonction fct_explicit_na, qui convertit toutes les valeurs manquantes (NA) d’un facteur en une modalité spécifique.\n\nhdv2003$qualif_rec &lt;- fct_explicit_na(hdv2003$qualif, na_level = \"(Manquant)\")\n#&gt; Warning: `fct_explicit_na()` was deprecated in forcats 1.0.0.\n#&gt; ℹ Please use `fct_na_value_to_level()` instead.\n\nfreq(hdv2003$qualif_rec)\n#&gt;                            n    % val%\n#&gt; Ouvrier specialise         0  0.0  0.0\n#&gt; Ouvrier qualifie         292 14.6 14.6\n#&gt; Technicien                86  4.3  4.3\n#&gt; Profession intermediaire 160  8.0  8.0\n#&gt; Cadre                    260 13.0 13.0\n#&gt; Employe                  594 29.7 29.7\n#&gt; Autre                     58  2.9  2.9\n#&gt; (Manquant)               550 27.5 27.5\n\nD’autres fonctions sont proposées par forcats pour faciliter certains recodage, comme fct_collapse, qui propose une autre syntaxe pratique quand on doit regrouper ensemble des modalités.\n\nhdv2003$qualif_rec &lt;- fct_collapse(\n    hdv2003$qualif,\n    \"Ouvrier\" = c(\"Ouvrier specialise\", \"Ouvrier qualifie\"),\n    \"Interm\" = c(\"Technicien\", \"Profession intermediaire\")\n)\n\nfreq(hdv2003$qualif_rec)\n#&gt;           n    % val%\n#&gt; Ouvrier 292 14.6 20.1\n#&gt; Interm  246 12.3 17.0\n#&gt; Cadre   260 13.0 17.9\n#&gt; Employe 594 29.7 41.0\n#&gt; Autre    58  2.9  4.0\n#&gt; NA      550 27.5   NA\n\nfct_other, qui regroupe une liste de modalités en une seule modalité “Other”.\n\nhdv2003$qualif_rec &lt;- fct_other(\n    hdv2003$qualif,\n    drop = c(\"Ouvrier specialise\", \"Ouvrier qualifie\", \"Cadre\", \"Autre\")\n)\n\nfreq(hdv2003$qualif_rec)\n#&gt;                            n    % val%\n#&gt; Technicien                86  4.3  5.9\n#&gt; Profession intermediaire 160  8.0 11.0\n#&gt; Employe                  594 29.7 41.0\n#&gt; Other                    610 30.5 42.1\n#&gt; NA                       550 27.5   NA\n\nfct_lump, qui regroupe automatiquement les modalités les moins fréquentes en une seule modalité “Other” (avec possibilité d’indiquer des seuils de regroupement).\n\nhdv2003$qualif_rec &lt;- fct_lump(hdv2003$qualif)\n\nfreq(hdv2003$qualif_rec)\n#&gt;                            n    % val%\n#&gt; Ouvrier qualifie         292 14.6 20.1\n#&gt; Profession intermediaire 160  8.0 11.0\n#&gt; Cadre                    260 13.0 17.9\n#&gt; Employe                  594 29.7 41.0\n#&gt; Other                    144  7.2  9.9\n#&gt; NA                       550 27.5   NA\n\n\n9.3.2.1 Interface graphique de recodage\nL’extension questionr propose une interface graphique facilitant le recodage des modalités d’une variable qualitative. L’objectif est de permettre à la personne qui l’utilise de saisir les nouvelles valeurs dans un formulaire, et de générer ensuite le code R correspondant au recodage indiqué.\nPour utiliser cette interface, sous RStudio vous pouvez aller dans le menu Addins (présent dans la barre d’outils principale) puis choisir Levels recoding. Sinon, vous pouvez lancer dans la console la fonction irec() en lui passant comme paramètre la variable à recoder.\n\n\n\nInterface graphique de irec\n\n\nL’interface se compose de trois onglets : l’onglet Variable et paramètres vous permet de sélectionner la variable à recoder, le nom de la nouvelle variable et d’autres paramètres, l’onglet Recodages vous permet de saisir les nouvelles valeurs des modalités, et l’onglet Code et résultat affiche le code R correspondant ainsi qu’un tableau permettant de vérifier les résultats.\nUne fois votre recodage terminé, cliquez sur le bouton Done et le code R sera inséré dans votre script R ou affiché dans la console.\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le recodage soit réellement effectif.\n\n\n\n\n\n9.3.3 Ordonner les modalités d’une variable qualitative\nL’avantage des facteurs (par rapport aux vecteurs de type character) est que leurs modalités peuvent être ordonnées, ce qui peut faciliter la lecture de tableaux ou graphiques.\nOn peut ordonner les modalités d’un facteur manuellement, par exemple avec la fonction fct_relevel() de l’extension forcats.\n\nhdv2003$qualif_rec &lt;- fct_relevel(\n    hdv2003$qualif,\n    \"Cadre\", \"Profession intermediaire\", \"Technicien\",\n    \"Employe\", \"Ouvrier qualifie\", \"Ouvrier specialise\",\n    \"Autre\"\n)\n\nfreq(hdv2003$qualif_rec)\n#&gt;                            n    % val%\n#&gt; Cadre                    260 13.0 17.9\n#&gt; Profession intermediaire 160  8.0 11.0\n#&gt; Technicien                86  4.3  5.9\n#&gt; Employe                  594 29.7 41.0\n#&gt; Ouvrier qualifie         292 14.6 20.1\n#&gt; Ouvrier specialise         0  0.0  0.0\n#&gt; Autre                     58  2.9  4.0\n#&gt; NA                       550 27.5   NA\n\nUne autre possibilité est d’ordonner les modalités d’un facteur selon les valeurs d’une autre variable. Par exemple, si on représente le boxplot de la répartition de l’âge selon le statut d’occupation :\n\nlibrary(ggplot2)\nggplot(hdv2003) +\n  geom_boxplot(aes(x = occup, y = age))\n\n\n\n\nLe graphique pourrait être plus lisible si les modalités étaient triées par âge median croissant. On peut dans ce cas utiliser la fonction fct_reorder. Celle-ci prend 3 arguments : le facteur à réordonner, la variable dont les valeurs doivent être utilisées pour ce réordonnancement, et enfin une fonction à appliquer à cette deuxième variable.\n\nhdv2003$occup_age &lt;- fct_reorder(hdv2003$occup, hdv2003$age, median)\n\nggplot(hdv2003) +\n  geom_boxplot(aes(x = occup_age, y = age))\n\n\n\n\nOn peut aussi effectuer le réordonnancement directement dans l’appel à ggplot2, sans créer de nouvelle variable.\n\nggplot(hdv2003) +\n  geom_boxplot(\n    aes(\n      x = fct_reorder(occup, age, median),\n      y = age\n    )\n  )\n\nLorsqu’on effectue un diagramme en barres avec geom_bar, on peut aussi réordonner les modalités selon leurs effectifs à l’aide de fct_infreq.\n\nggplot(hdv2003) +\n  geom_bar(aes(x = fct_infreq(occup)))\n\n\n\n\n\n9.3.3.1 Interface graphique\nquestionr propose une interface graphique afin de faciliter les opérations de réordonnancement manuel. Pour la lancer, sélectionner le menu Addins puis Levels ordering, ou exécuter la fonction iorder() en lui passant comme paramètre le facteur à réordonner.\n\n\n\nInterface graphique de iorder\n\n\nLe fonctionnement de l’interface est similaire à celui de l’interface de recodage. Vous pouvez réordonner les modalités en les faisant glisser avec la souris, puis récupérer et exécuter le code R généré."
  },
  {
    "objectID": "09-recodages.html#combiner-plusieurs-variables",
    "href": "09-recodages.html#combiner-plusieurs-variables",
    "title": "9  Recoder des variables",
    "section": "9.4 Combiner plusieurs variables",
    "text": "9.4 Combiner plusieurs variables\nParfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions ifelse pour les cas les plus simples, ou case_when pour les cas plus complexes. Cette dernière fonction est incluse dans l’extension dplyr, qu’il faut donc avoir chargé précédemment.\n\n9.4.1 ifelse\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n#&gt; [1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nhdv2003$statut &lt;- ifelse(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60,\n    \"Homme de plus de 60 ans\",\n    \"Autre\"\n)\n\nfreq(hdv2003$statut)\n#&gt;                            n    % val%\n#&gt; Autre                   1778 88.9 88.9\n#&gt; Homme de plus de 60 ans  222 11.1 11.1\n\n\n\n9.4.2 case_when\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Homme\" ~ \"Homme de plus de 60 ans\",\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Femme\" ~ \"Femme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\nfreq(hdv2003$statut)\n#&gt;                            n    % val%\n#&gt; Autre                   1512 75.6 75.6\n#&gt; Femme de plus de 60 ans  266 13.3 13.3\n#&gt; Homme de plus de 60 ans  222 11.1 11.1\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.\n\n\nPour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\nfreq(hdv2003$statut)\n#&gt;          n  % val%\n#&gt; Autre 1101 55   55\n#&gt; Homme  899 45   45\n\nComme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" & age &gt; 60, cette deuxième condition n’est jamais testée, et on n’obtiendra donc jamais la valeur correspondante.\nPour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général.\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    TRUE ~ \"Autre\"\n)\n\nfreq(hdv2003$statut)\n#&gt;                            n    % val%\n#&gt; Autre                   1101 55.0 55.0\n#&gt; Homme                    677 33.9 33.9\n#&gt; Homme de plus de 60 ans  222 11.1 11.1"
  },
  {
    "objectID": "09-recodages.html#découper-une-variable-numérique-en-classes",
    "href": "09-recodages.html#découper-une-variable-numérique-en-classes",
    "title": "9  Recoder des variables",
    "section": "9.5 Découper une variable numérique en classes",
    "text": "9.5 Découper une variable numérique en classes\nUne autre opération courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer une variable revenu contenant le revenu mensuel en une variable qualitative avec des catégories Moins de 500 euros, 501-1000 euros, etc.\nOn utilise pour cela la fonction cut() :\n\nhdv2003$agecl &lt;- cut(hdv2003$age, breaks = 5)\n\nfreq(hdv2003$agecl)\n#&gt;               n    % val%\n#&gt; (17.9,33.8] 454 22.7 22.7\n#&gt; (33.8,49.6] 628 31.4 31.4\n#&gt; (49.6,65.4] 556 27.8 27.8\n#&gt; (65.4,81.2] 319 16.0 16.0\n#&gt; (81.2,97.1]  43  2.1  2.1\n\nSi on donne un nombre entier à l’argument breaks, un nombre correspondant de classes d’amplitudes égales sont automatiquement calculées. Comme il est souvent préférable d’avoir des limites “arrondies”, on peut aussi spécifier ces dernières manuellement en passant un vecteur à breaks.\n\nhdv2003$agecl &lt;- cut(\n    hdv2003$age,\n    breaks = c(18, 25, 35, 45, 55, 65, 97),\n    include.lowest = TRUE\n)\n\nfreq(hdv2003$agecl)\n#&gt;           n    % val%\n#&gt; [18,25] 191  9.6  9.6\n#&gt; (25,35] 338 16.9 16.9\n#&gt; (35,45] 390 19.5 19.5\n#&gt; (45,55] 414 20.7 20.7\n#&gt; (55,65] 305 15.2 15.2\n#&gt; (65,97] 362 18.1 18.1\n\nIci on a été obligé d’ajouter l’argument include.lowest = TRUE car sinon la valeur 18 n’aurait pas été incluse, et on aurait eu des valeurs manquantes.\n\n9.5.1 Interface graphique\nComme l’utilisation des arguments de cut n’est pas toujours très intuitive, l’extension questionr propose une interface graphique facilitant cette opération de découpage en classes d’une variable numérique.\nPour lancer cette interface, sous RStudio ouvrir le menu Addins et sélectionner Numeric range dividing, ou exécuter la fonction icut() dans la console en lui passant comme argument la variable quantitative à découper.\n\n\n\nInterface graphique de icut\n\n\nVous pouvez alors choisir la variable à découper dans l’onglet Variable et paramètres, indiquer les limites de vos classes ainsi que quelques options complémentaires dans l’onglet Découpage en classes, et vérifier le résultat dans l’onglet Code et résultat. Une fois le résultat satisfaisant, cliquez sur Done : si vous êtes sous RStudio le code généré sera directement inséré dans votre script actuel à l’emplacement du curseur. Sinon, ce code sera affiché dans la console et vous pourrez le copier/coller pour l’inclure dans votre script.\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le découpage soit réellement effectif."
  },
  {
    "objectID": "09-recodages.html#exercices",
    "href": "09-recodages.html#exercices",
    "title": "9  Recoder des variables",
    "section": "9.6 Exercices",
    "text": "9.6 Exercices\n\n9.6.1 Préparation\nPour la plupart de ces exercices, on a besoin des extensions forcats et questionr, et du jeu de données d’exemple hdv2003.\n\nlibrary(forcats)\nlibrary(questionr)\ndata(hdv2003)\n\n\n\n9.6.2 Vecteurs et tests\nExercice 1.1\nConstruire le vecteur suivant :\n\nx &lt;- c(\"12\", \"3.5\", \"421\", \"2,4\")\n\nEt le convertir en vecteur numérique. Que remarquez-vous ?\n\n\nas.numeric(x)\n\n## Un nombre avec une virgule comme séparateur décimal\n## renvoie NA\n\n\nExercice 1.2\nConstruire le vecteur suivant :\n\nx &lt;- c(1, 20, 21, 15.5, 14, 12, 8)\n\n\nÉcrire le test qui indique si les éléments du vecteur sont strictement supérieurs à 15.\nUtiliser ce test pour extraire du vecteur les éléments correspondants.\n\n\n\nx &gt; 15\nx[x &gt; 15]\n\n\nExercice 1.3\nLe code suivant génère un vecteur de 1000 nombres aléatoires compris entre 0 et 10 :\n\nx &lt;- runif(1000, 0, 10)\n\nCombien d’éléments de ce vecteur sont compris entre 2 et 4 ?\n\n\n## Possibilité 1\nlength(x[x &gt;= 2 & x &lt;= 4])\n## Possibilité 2\ntable(x &gt;= 2 & x &lt;= 4)\n\n\n\n\n9.6.3 Recodages de variable qualitative\nExercice 2.1\nConstruire un vecteur f à l’aide du code suivant :\n\nf &lt;- c(\"Jan\", \"Jan\", \"Fev\", \"Juil\")\n\nRecoder le vecteur à l’aide de la fonction fct_recode pour obtenir le résultat suivant :\n\n#&gt; [1] Janvier Janvier Février Juillet\n#&gt; Levels: Février Janvier Juillet\n\n\n\nf &lt;- fct_recode(f,\n          \"Janvier\" = \"Jan\",\n          \"Février\" = \"Fev\",\n          \"Juillet\" = \"Juil\")\n\nf\n\n\nExercice 2.2\nÀ l’aide de l’interface graphique de questionr, recoder la variable relig du jeu de données hdv2003 pour obtenir le tri à plat suivant (il se peut que l’ordre des modalités dans le tri à plat soit différent) :\n\n#&gt;                               n    % val%\n#&gt; Pratiquant                  708 35.4 35.4\n#&gt; Appartenance                760 38.0 38.0\n#&gt; Ni croyance ni appartenance 399 20.0 20.0\n#&gt; Rejet                        93  4.7  4.7\n#&gt; NSP                          40  2.0  2.0\n\n\n\nhdv2003$relig_rec &lt;- fct_recode(\n    hdv2003$relig,\n    \"Pratiquant\" = \"Pratiquant regulier\",\n    \"Pratiquant\" = \"Pratiquant occasionnel\",\n    \"Appartenance\" = \"Appartenance sans pratique\",\n    \"NSP\" = \"NSP ou NVPR\"\n)\n\nfreq(hdv2003$relig_rec)\n\n\nExercice 2.3\nÀ l’aide de l’interface graphique de questionr, recoder la variable nivetud pour obtenir le tri à plat suivant (il se peut que l’ordre des modalités dans le tri à plat soit différent) :\n\n#&gt;                                           n    % val%\n#&gt; N'a jamais fait d'etudes                 39  2.0  2.1\n#&gt; Études primaires                        427 21.3 22.6\n#&gt; 1er cycle                               204 10.2 10.8\n#&gt; 2eme cycle                              183  9.2  9.7\n#&gt; Enseignement technique ou professionnel 594 29.7 31.5\n#&gt; Enseignement superieur                  441 22.0 23.4\n#&gt; NA                                      112  5.6   NA\n\n\n\nhdv2003$nivetud_rec &lt;- fct_recode(\n    hdv2003$nivetud,\n    \"Études primaires\" = \"A arrete ses etudes, avant la derniere annee d'etudes primaires\",\n    \"Études primaires\" = \"Derniere annee d'etudes primaires\",\n    \"Enseignement technique ou professionnel\" = \"Enseignement technique ou professionnel court\",\n    \"Enseignement technique ou professionnel\" = \"Enseignement technique ou professionnel long\",\n    \"Enseignement superieur\" = \"Enseignement superieur y compris technique superieur\"\n)\n\nfreq(hdv2003$nivetud_rec)\n\n\nToujours à l’aide de l’interface graphique, réordonner les modalités de cette variable recodée pour obtenir le tri à plat suivant :\n\n#&gt;                                           n    % val%\n#&gt; Enseignement superieur                  441 22.0 23.4\n#&gt; Enseignement technique ou professionnel 594 29.7 31.5\n#&gt; 2eme cycle                              183  9.2  9.7\n#&gt; 1er cycle                               204 10.2 10.8\n#&gt; Études primaires                        427 21.3 22.6\n#&gt; N'a jamais fait d'etudes                 39  2.0  2.1\n#&gt; NA                                      112  5.6   NA\n\n\n\nhdv2003$nivetud_rec &lt;- factor(\n  hdv2003$nivetud_rec, \n  levels = c(\n    \"Enseignement superieur\", \"Enseignement technique ou professionnel\", \n    \"2eme cycle\", \"1er cycle\", \"Études primaires\", \"N'a jamais fait d'etudes\"\n  )\n)\n\nfreq(hdv2003$nivetud_rec)\n\n\nExercice 2.4\nÀ l’aide de la fonction fct_reorder, trier les modalités de la variable relig du jeu de données hdv2003 selon leur âge médian.\nVérifier en générant le boxplot suivant :\n\n\n\n\n\n\n\nhdv2003$relig &lt;- fct_reorder(hdv2003$relig, hdv2003$age, median)\nggplot(hdv2003) + geom_boxplot(aes(x = relig, y = age))\n\n\n\n\n9.6.4 Combiner plusieurs variables\nExercice 3.1\nÀ l’aide de la fonction ifelse, créer une nouvelle variable cinema_bd permettant d’identifier les personnes qui vont au cinéma et déclarent lire des bandes dessinées.\nVous devriez obtenir le tri à plat suivant pour cette nouvelle variable :\n\n#&gt;                 n    % val%\n#&gt; Autre        1971 98.6 98.6\n#&gt; Cinéma et BD   29  1.5  1.5\n\n\n\nhdv2003$cinema_bd &lt;- ifelse(\n  hdv2003$cinema == \"Oui\" & hdv2003$lecture.bd == \"Oui\",\n  \"Cinéma et BD\",\n  \"Autre\"\n)\n\nfreq(hdv2003$cinema_bd)\n\n\nExercice 3.2\nÀ l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes :\n\nHomme ayant plus de 2 frères et soeurs\nFemme ayant plus de 2 frères et soeurs\nAutre\n\nVous devriez obtenir le tri à plat suivant :\n\n#&gt;                                           n    % val%\n#&gt; Autre                                  1001 50.0 50.0\n#&gt; Femme ayant plus de 2 frères et soeurs  546 27.3 27.3\n#&gt; Homme ayant plus de 2 frères et soeurs  453 22.7 22.7\n\n\n\nhdv2003$groupe &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$freres.soeurs &gt; 2 ~ \"Homme ayant plus de 2 frères et soeurs\",\n    hdv2003$sexe == \"Femme\" & hdv2003$freres.soeurs &gt; 2 ~ \"Femme ayant plus de 2 frères et soeurs\",\n    TRUE ~ \"Autre\"\n)\n\nfreq(hdv2003$groupe)\n\n\nExercice 3.3\nÀ l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes :\n\nHomme de plus de 30 ans\nHomme de plus de 40 ans satisfait par son travail\nFemme pratiquant le sport ou le bricolage\nAutre\n\nVous devriez obtenir le tri à plat suivant :\n\n#&gt;                                                     n    % val%\n#&gt; Autre                                             714 35.7 35.7\n#&gt; Femme pratiquant le sport ou le bricolage         549 27.5 27.5\n#&gt; Homme de plus de 30 ans                           610 30.5 30.5\n#&gt; Homme de plus de 40 ans satisfait par son travail 127  6.3  6.3\n\n\n\nhdv2003$groupe &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 40 & hdv2003$trav.satisf == \"Satisfaction\" ~ \"Homme de plus de 40 ans satisfait par son travail\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 30 ~ \"Homme de plus de 30 ans\",\n    hdv2003$sexe == \"Femme\" & (hdv2003$sport == \"Oui\" | hdv2003$bricol == \"Oui\") ~ \"Femme pratiquant le sport ou le bricolage\",\n    TRUE ~ \"Autre\"\n)\n\nfreq(hdv2003$groupe)\n\n\n\n\n9.6.5 Découper une variable numérique\nExercice 4.1\nDans le jeu de données hdv2003, découper la variable heures.tv en classes de manière à obtenir au final le tri à plat suivant :\n\n#&gt;          n    % val%\n#&gt; [0,1]  684 34.2 34.3\n#&gt; (1,2]  535 26.8 26.8\n#&gt; (2,4]  594 29.7 29.8\n#&gt; (4,6]  138  6.9  6.9\n#&gt; (6,12]  44  2.2  2.2\n#&gt; NA       5  0.2   NA\n\n\n\nhdv2003$tv_cl &lt;- cut(\n    hdv2003$heures.tv,\n    include.lowest = TRUE,\n    right = TRUE,\n    breaks = c(0, 1, 2, 4, 6, 12)\n)\n\nfreq(hdv2003$tv_cl)"
  },
  {
    "objectID": "09-recodages.html#footnotes",
    "href": "09-recodages.html#footnotes",
    "title": "9  Recoder des variables",
    "section": "",
    "text": "Pour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎"
  },
  {
    "objectID": "10-dplyr.html#préparation",
    "href": "10-dplyr.html#préparation",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.1 Préparation",
    "text": "10.1 Préparation\ndplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\nOn peut également la charger individuellement.\n\nlibrary(dplyr)\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement."
  },
  {
    "objectID": "10-dplyr.html#les-verbes-de-dplyr",
    "href": "10-dplyr.html#les-verbes-de-dplyr",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.2 Les verbes de dplyr",
    "text": "10.2 Les verbes de dplyr\nLa manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\n\n10.2.1 slice\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n#&gt; # A tibble: 1 × 8\n#&gt;   faa   name                lat   lon   alt    tz dst   tzone            \n#&gt;   &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                            lat   lon   alt    tz dst   tzone       \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n#&gt; 3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n#&gt; 4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n#&gt; 5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n#&gt; # A tibble: 3 × 8\n#&gt;   faa   name                        lat   lon   alt    tz dst   tzone           \n#&gt;   &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n#&gt; 1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n#&gt; 2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n#&gt; 3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\nslice_head(airlines, prop = 0.2)\n#&gt; # A tibble: 3 × 2\n#&gt;   carrier name                  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n#&gt; 1 9E      Endeavor Air Inc.     \n#&gt; 2 AA      American Airlines Inc.\n#&gt; 3 AS      Alaska Airlines Inc.\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n#&gt; # A tibble: 1 × 19\n#&gt;    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;       &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1  2013    12     7     2040        2123     -43      40    2352      48 B6     \n#&gt; # … with 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,\n#&gt; #   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,\n#&gt; #   time_hour &lt;dttm&gt;, and abbreviated variable names ¹​sched_dep_time,\n#&gt; #   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                              lat   lon   alt    tz dst   tzone     \n#&gt;   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n#&gt; 1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n#&gt; 2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n#&gt; 3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n#&gt; 4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n#&gt; 5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n10.2.2 filter\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir Section 9.2.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n#&gt; # A tibble: 27,004 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      544        545      -1    1004    1022     -18 B6     \n#&gt;  5  2013     1     1      554        600      -6     812     837     -25 DL     \n#&gt;  6  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  7  2013     1     1      555        600      -5     913     854      19 B6     \n#&gt;  8  2013     1     1      557        600      -3     709     723     -14 EV     \n#&gt;  9  2013     1     1      557        600      -3     838     846      -8 B6     \n#&gt; 10  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt; # … with 26,994 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n#&gt; # A tibble: 14,919 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      611        600      11     945     931      14 UA     \n#&gt;  2  2013     1     1      623        610      13     920     915       5 AA     \n#&gt;  3  2013     1     1      743        730      13    1107    1100       7 AA     \n#&gt;  4  2013     1     1      743        730      13    1059    1056       3 DL     \n#&gt;  5  2013     1     1      851        840      11    1215    1206       9 UA     \n#&gt;  6  2013     1     1      912        900      12    1241    1220      21 AA     \n#&gt;  7  2013     1     1      914        900      14    1058    1043      15 UA     \n#&gt;  8  2013     1     1      920        905      15    1039    1025      14 B6     \n#&gt;  9  2013     1     1     1011       1001      10    1133    1128       5 EV     \n#&gt; 10  2013     1     1     1112       1100      12    1440    1438       2 UA     \n#&gt; # … with 14,909 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n#&gt; # A tibble: 167,133 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      544        545      -1    1004    1022     -18 B6     \n#&gt;  5  2013     1     1      555        600      -5     913     854      19 B6     \n#&gt;  6  2013     1     1      557        600      -3     838     846      -8 B6     \n#&gt;  7  2013     1     1      558        600      -2     849     851      -2 B6     \n#&gt;  8  2013     1     1      558        600      -2     853     856      -3 B6     \n#&gt;  9  2013     1     1      558        600      -2     924     917       7 UA     \n#&gt; 10  2013     1     1      558        600      -2     923     937     -14 UA     \n#&gt; # … with 167,123 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\n10.2.3 select et rename\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n#&gt; # A tibble: 1,458 × 2\n#&gt;      lat    lon\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1  41.1  -80.6\n#&gt;  2  32.5  -85.7\n#&gt;  3  42.0  -88.1\n#&gt;  4  41.4  -74.4\n#&gt;  5  31.1  -81.4\n#&gt;  6  36.4  -82.2\n#&gt;  7  41.5  -84.5\n#&gt;  8  42.9  -76.8\n#&gt;  9  39.8  -76.6\n#&gt; 10  48.1 -123. \n#&gt; # … with 1,448 more rows\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n#&gt; # A tibble: 1,458 × 6\n#&gt;    faa   name                             alt    tz dst   tzone              \n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n#&gt;  1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n#&gt;  2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n#&gt;  3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n#&gt;  4 06N   Randall Airport                  523    -5 A     America/New_York   \n#&gt;  5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n#&gt;  6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n#&gt;  7 0G6   Williams County Airport          730    -5 A     America/New_York   \n#&gt;  8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n#&gt;  9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n#&gt; 10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n#&gt; # … with 1,448 more rows\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n#&gt; # A tibble: 336,776 × 2\n#&gt;    dep_time dep_delay\n#&gt;       &lt;int&gt;     &lt;dbl&gt;\n#&gt;  1      517         2\n#&gt;  2      533         4\n#&gt;  3      542         2\n#&gt;  4      544        -1\n#&gt;  5      554        -6\n#&gt;  6      554        -4\n#&gt;  7      555        -5\n#&gt;  8      557        -3\n#&gt;  9      557        -3\n#&gt; 10      558        -2\n#&gt; # … with 336,766 more rows\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n#&gt; # A tibble: 336,776 × 3\n#&gt;     year month   day\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt;  1  2013     1     1\n#&gt;  2  2013     1     1\n#&gt;  3  2013     1     1\n#&gt;  4  2013     1     1\n#&gt;  5  2013     1     1\n#&gt;  6  2013     1     1\n#&gt;  7  2013     1     1\n#&gt;  8  2013     1     1\n#&gt;  9  2013     1     1\n#&gt; 10  2013     1     1\n#&gt; # … with 336,766 more rows\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n#&gt; # A tibble: 1,458 × 8\n#&gt;    faa   name                           latitude longi…¹   alt    tz dst   tzone\n#&gt;    &lt;chr&gt; &lt;chr&gt;                             &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 04G   Lansdowne Airport                  41.1   -80.6  1044    -5 A     Amer…\n#&gt;  2 06A   Moton Field Municipal Airport      32.5   -85.7   264    -6 A     Amer…\n#&gt;  3 06C   Schaumburg Regional                42.0   -88.1   801    -6 A     Amer…\n#&gt;  4 06N   Randall Airport                    41.4   -74.4   523    -5 A     Amer…\n#&gt;  5 09J   Jekyll Island Airport              31.1   -81.4    11    -5 A     Amer…\n#&gt;  6 0A9   Elizabethton Municipal Airport     36.4   -82.2  1593    -5 A     Amer…\n#&gt;  7 0G6   Williams County Airport            41.5   -84.5   730    -5 A     Amer…\n#&gt;  8 0G7   Finger Lakes Regional Airport      42.9   -76.8   492    -5 A     Amer…\n#&gt;  9 0P2   Shoestring Aviation Airfield       39.8   -76.6  1000    -5 U     Amer…\n#&gt; 10 0S9   Jefferson County Intl              48.1  -123.    108    -8 A     Amer…\n#&gt; # … with 1,448 more rows, and abbreviated variable name ¹​longitude\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n#&gt; # A tibble: 336,776 × 2\n#&gt;    `retard départ` `retard arrivée`\n#&gt;              &lt;dbl&gt;            &lt;dbl&gt;\n#&gt;  1               2               11\n#&gt;  2               4               20\n#&gt;  3               2               33\n#&gt;  4              -1              -18\n#&gt;  5              -6              -25\n#&gt;  6              -4               12\n#&gt;  7              -5               19\n#&gt;  8              -3              -14\n#&gt;  9              -3               -8\n#&gt; 10              -2                8\n#&gt; # … with 336,766 more rows\n\n\n\n10.2.4 arrange\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013    12     7     2040       2123     -43      40    2352      48 B6     \n#&gt;  2  2013     2     3     2022       2055     -33    2240    2338     -58 DL     \n#&gt;  3  2013    11    10     1408       1440     -32    1549    1559     -10 EV     \n#&gt;  4  2013     1    11     1900       1930     -30    2233    2243     -10 DL     \n#&gt;  5  2013     1    29     1703       1730     -27    1947    1957     -10 F9     \n#&gt;  6  2013     8     9      729        755     -26    1002     955       7 MQ     \n#&gt;  7  2013    10    23     1907       1932     -25    2143    2143       0 EV     \n#&gt;  8  2013     3    30     2030       2055     -25    2213    2250     -37 MQ     \n#&gt;  9  2013     3     2     1431       1455     -24    1601    1631     -30 9E     \n#&gt; 10  2013     5     5      934        958     -24    1225    1309     -44 B6     \n#&gt; # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1    11     1900       1930     -30    2233    2243     -10 DL     \n#&gt;  2  2013     1    29     1703       1730     -27    1947    1957     -10 F9     \n#&gt;  3  2013     1    12     1354       1416     -22    1606    1650     -44 FL     \n#&gt;  4  2013     1    21     2137       2159     -22    2232    2316     -44 DL     \n#&gt;  5  2013     1    20      704        725     -21    1025    1035     -10 AS     \n#&gt;  6  2013     1    12     2050       2110     -20    2310    2355     -45 B6     \n#&gt;  7  2013     1    12     2134       2154     -20       4      50     -46 B6     \n#&gt;  8  2013     1    14     2050       2110     -20    2329    2355     -26 B6     \n#&gt;  9  2013     1     4     2140       2159     -19    2241    2316     -35 DL     \n#&gt; 10  2013     1    11     1947       2005     -18    2209    2230     -21 9E     \n#&gt; # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     9      641        900    1301    1242    1530    1272 HA     \n#&gt;  2  2013     6    15     1432       1935    1137    1607    2120    1127 MQ     \n#&gt;  3  2013     1    10     1121       1635    1126    1239    1810    1109 MQ     \n#&gt;  4  2013     9    20     1139       1845    1014    1457    2210    1007 AA     \n#&gt;  5  2013     7    22      845       1600    1005    1044    1815     989 MQ     \n#&gt;  6  2013     4    10     1100       1900     960    1342    2211     931 DL     \n#&gt;  7  2013     3    17     2321        810     911     135    1020     915 DL     \n#&gt;  8  2013     6    27      959       1900     899    1236    2226     850 DL     \n#&gt;  9  2013     7    22     2257        759     898     121    1026     895 DL     \n#&gt; 10  2013    12     5      756       1700     896    1058    2020     878 AA     \n#&gt; # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n#&gt; # A tibble: 3 × 19\n#&gt;    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;       &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1  2013     1     9      641         900    1301    1242    1530    1272 HA     \n#&gt; 2  2013     6    15     1432        1935    1137    1607    2120    1127 MQ     \n#&gt; 3  2013     1    10     1121        1635    1126    1239    1810    1109 MQ     \n#&gt; # … with 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,\n#&gt; #   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,\n#&gt; #   time_hour &lt;dttm&gt;, and abbreviated variable names ¹​sched_dep_time,\n#&gt; #   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\n10.2.5 mutate\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n#&gt; # A tibble: 336,776 × 2\n#&gt;    air_time duree_h\n#&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1      227   3.78 \n#&gt;  2      227   3.78 \n#&gt;  3      160   2.67 \n#&gt;  4      183   3.05 \n#&gt;  5      116   1.93 \n#&gt;  6      150   2.5  \n#&gt;  7      158   2.63 \n#&gt;  8       53   0.883\n#&gt;  9      140   2.33 \n#&gt; 10      138   2.3  \n#&gt; # … with 336,766 more rows\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n#&gt; # A tibble: 336,776 × 5\n#&gt;    air_time duree_h distance distance_km vitesse\n#&gt;       &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1      227   3.78      1400       2253.    596.\n#&gt;  2      227   3.78      1416       2279.    602.\n#&gt;  3      160   2.67      1089       1753.    657.\n#&gt;  4      183   3.05      1576       2536.    832.\n#&gt;  5      116   1.93       762       1226.    634.\n#&gt;  6      150   2.5        719       1157.    463.\n#&gt;  7      158   2.63      1065       1714.    651.\n#&gt;  8       53   0.883      229        369.    417.\n#&gt;  9      140   2.33       944       1519.    651.\n#&gt; 10      138   2.3        733       1180.    513.\n#&gt; # … with 336,766 more rows\n\nÀ noter que mutate est évidemment parfaitement compatible avec les fonctions vues Chapitre 9 sur les recodages : fct_recode, ifelse, case_when…\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante."
  },
  {
    "objectID": "10-dplyr.html#sec-pipe",
    "href": "10-dplyr.html#sec-pipe",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.3 Enchaîner les opérations avec le pipe",
    "text": "10.3 Enchaîner les opérations avec le pipe\nQuand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe3. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n\n\n\n\n\n\nNote\n\n\n\nOn appelle une suite d’instructions de ce type un pipeline.\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\n\nNote\n\n\n\nL’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit.\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nDepuis la version 4.1, R propose un pipe “natif”, qui fonctionne partout, même si on n’utilise pas les extensions du tidyverse. Celui-ci est noté |&gt;.\nIl s’utilise de la même manière que %&gt;% :\nflights |&gt; filter(dest == \"LAX\")\nCe pipe natif est à la fois un peu plus rapide et un peu moins souple. Par exemple, il est possible avec %&gt;% d’appeler une fonction sans mettre de parenthèses :\ndf %&gt;% View\nCe n’est pas possible d’omettre les parenthèses avec |&gt;, on doit obligatoirement faire :\ndf |&gt; View()\nDans la suite de ce document on privilégiera (pour l’instant) le pipe du tidyverse %&gt;%, pour des raisons de compatibilité avec des versions de R moins récentes."
  },
  {
    "objectID": "10-dplyr.html#opérations-groupées",
    "href": "10-dplyr.html#opérations-groupées",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.4 Opérations groupées",
    "text": "10.4 Opérations groupées\n\n10.4.1 group_by\nUn élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      544        545      -1    1004    1022     -18 B6     \n#&gt;  5  2013     1     1      554        600      -6     812     837     -25 DL     \n#&gt;  6  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  7  2013     1     1      555        600      -5     913     854      19 B6     \n#&gt;  8  2013     1     1      557        600      -3     709     723     -14 EV     \n#&gt;  9  2013     1     1      557        600      -3     838     846      -8 B6     \n#&gt; 10  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt; # … with 336,766 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n#&gt; # A tibble: 12 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     2     1      456        500      -4     652     648       4 US     \n#&gt;  3  2013     3     1        4       2159     125     318      56     142 B6     \n#&gt;  4  2013     4     1      454        500      -6     636     640      -4 US     \n#&gt;  5  2013     5     1        9       1655     434     308    2020     408 VX     \n#&gt;  6  2013     6     1        2       2359       3     341     350      -9 B6     \n#&gt;  7  2013     7     1        1       2029     212     236    2359     157 B6     \n#&gt;  8  2013     8     1       12       2130     162     257      14     163 B6     \n#&gt;  9  2013     9     1        9       2359      10     343     340       3 B6     \n#&gt; 10  2013    10     1      447        500     -13     614     648     -34 US     \n#&gt; 11  2013    11     1        5       2359       6     352     345       7 B6     \n#&gt; 12  2013    12     1       13       2359      14     446     445       1 B6     \n#&gt; # … with 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,\n#&gt; #   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,\n#&gt; #   time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;, and\n#&gt; #   abbreviated variable names ¹​sched_dep_time, ²​dep_delay, ³​arr_time,\n#&gt; #   ⁴​sched_arr_time, ⁵​arr_delay\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n#&gt; # A tibble: 12 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     9      641        900    1301    1242    1530    1272 HA     \n#&gt;  2  2013     2    10     2243        830     853     100    1106     834 F9     \n#&gt;  3  2013     3    17     2321        810     911     135    1020     915 DL     \n#&gt;  4  2013     4    10     1100       1900     960    1342    2211     931 DL     \n#&gt;  5  2013     5     3     1133       2055     878    1250    2215     875 MQ     \n#&gt;  6  2013     6    15     1432       1935    1137    1607    2120    1127 MQ     \n#&gt;  7  2013     7    22      845       1600    1005    1044    1815     989 MQ     \n#&gt;  8  2013     8     8     2334       1454     520     120    1710     490 EV     \n#&gt;  9  2013     9    20     1139       1845    1014    1457    2210    1007 AA     \n#&gt; 10  2013    10    14     2042        900     702    2255    1127     688 DL     \n#&gt; 11  2013    11     3      603       1645     798     829    1913     796 DL     \n#&gt; 12  2013    12     5      756       1700     896    1058    2020     878 AA     \n#&gt; # … with 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,\n#&gt; #   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,\n#&gt; #   time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;, and\n#&gt; #   abbreviated variable names ¹​sched_dep_time, ²​dep_delay, ³​arr_time,\n#&gt; #   ⁴​sched_arr_time, ⁵​arr_delay\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n#&gt; Adding missing grouping variables: `carrier`\n#&gt; # A tibble: 336,776 × 3\n#&gt; # Groups:   carrier [16]\n#&gt;    carrier dep_delay mean_delay_carrier\n#&gt;    &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n#&gt;  1 UA              2              12.1 \n#&gt;  2 UA              4              12.1 \n#&gt;  3 AA              2               8.59\n#&gt;  4 B6             -1              13.0 \n#&gt;  5 DL             -6               9.26\n#&gt;  6 UA             -4              12.1 \n#&gt;  7 B6             -5              13.0 \n#&gt;  8 EV             -3              20.0 \n#&gt;  9 B6             -3              13.0 \n#&gt; 10 AA             -2               8.59\n#&gt; # … with 336,766 more rows\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n#&gt; Adding missing grouping variables: `carrier`\n#&gt; # A tibble: 336,776 × 4\n#&gt; # Groups:   carrier [16]\n#&gt;    carrier dep_delay median_delay delay_carrier    \n#&gt;    &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n#&gt;  1 UA              2            0 Supérieur        \n#&gt;  2 UA              4            0 Supérieur        \n#&gt;  3 AA              2           -3 Supérieur        \n#&gt;  4 B6             -1           -1 Inférieur ou égal\n#&gt;  5 DL             -6           -2 Inférieur ou égal\n#&gt;  6 UA             -4            0 Inférieur ou égal\n#&gt;  7 B6             -5           -1 Inférieur ou égal\n#&gt;  8 EV             -3           -1 Inférieur ou égal\n#&gt;  9 B6             -3           -1 Inférieur ou égal\n#&gt; 10 AA             -2           -3 Supérieur        \n#&gt; # … with 336,766 more rows\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n#&gt; # A tibble: 78,164 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      611        600      11     945     931      14 UA     \n#&gt;  2  2013     1     1      623        610      13     920     915       5 AA     \n#&gt;  3  2013     1     1      632        608      24     740     728      12 EV     \n#&gt;  4  2013     1     1      732        645      47    1011     941      30 UA     \n#&gt;  5  2013     1     1      743        730      13    1107    1100       7 AA     \n#&gt;  6  2013     1     1      743        730      13    1059    1056       3 DL     \n#&gt;  7  2013     1     1      749        710      39     939     850      49 MQ     \n#&gt;  8  2013     1     1      811        630     101    1047     830     137 MQ     \n#&gt;  9  2013     1     1      826        715      71    1136    1045      51 AA     \n#&gt; 10  2013     1     1      848       1835     853    1001    1950     851 MQ     \n#&gt; # … with 78,154 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     9      641        900    1301    1242    1530    1272 HA     \n#&gt;  2  2013     6    15     1432       1935    1137    1607    2120    1127 MQ     \n#&gt;  3  2013     1    10     1121       1635    1126    1239    1810    1109 MQ     \n#&gt;  4  2013     9    20     1139       1845    1014    1457    2210    1007 AA     \n#&gt;  5  2013     7    22      845       1600    1005    1044    1815     989 MQ     \n#&gt;  6  2013     4    10     1100       1900     960    1342    2211     931 DL     \n#&gt;  7  2013     3    17     2321        810     911     135    1020     915 DL     \n#&gt;  8  2013     6    27      959       1900     899    1236    2226     850 DL     \n#&gt;  9  2013     7    22     2257        759     898     121    1026     895 DL     \n#&gt; 10  2013    12     5      756       1700     896    1058    2020     878 AA     \n#&gt; # … with 336,766 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     9      641        900    1301    1242    1530    1272 HA     \n#&gt;  2  2013     1    10     1121       1635    1126    1239    1810    1109 MQ     \n#&gt;  3  2013     1     1      848       1835     853    1001    1950     851 MQ     \n#&gt;  4  2013     1    13     1809        810     599    2054    1042     612 DL     \n#&gt;  5  2013     1    16     1622        800     502    1911    1054     497 B6     \n#&gt;  6  2013     1    23     1551        753     478    1812    1006     486 DL     \n#&gt;  7  2013     1    10     1525        900     385    1713    1039     394 UA     \n#&gt;  8  2013     1     1     2343       1724     379     314    1938     456 EV     \n#&gt;  9  2013     1     2     2131       1512     379    2340    1741     359 UA     \n#&gt; 10  2013     1     7     2021       1415     366    2332    1724     368 B6     \n#&gt; # … with 336,766 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\n10.4.2 summarise et count\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 1 × 2\n#&gt;   retard_dep retard_arr\n#&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1       12.6       6.90\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 12 × 4\n#&gt;    month max_delay min_delay mean_delay\n#&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1     1      1301       -30      10.0 \n#&gt;  2     2       853       -33      10.8 \n#&gt;  3     3       911       -25      13.2 \n#&gt;  4     4       960       -21      13.9 \n#&gt;  5     5       878       -24      13.0 \n#&gt;  6     6      1137       -21      20.8 \n#&gt;  7     7      1005       -22      21.7 \n#&gt;  8     8       520       -26      12.6 \n#&gt;  9     9      1014       -24       6.72\n#&gt; 10    10       702       -25       6.24\n#&gt; 11    11       798       -32       5.44\n#&gt; 12    12       896       -43      16.6\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n#&gt; # A tibble: 105 × 2\n#&gt;    dest     nb\n#&gt;    &lt;chr&gt; &lt;int&gt;\n#&gt;  1 ABQ     254\n#&gt;  2 ACK     265\n#&gt;  3 ALB     439\n#&gt;  4 ANC       8\n#&gt;  5 ATL   17215\n#&gt;  6 AUS    2439\n#&gt;  7 AVL     275\n#&gt;  8 BDL     443\n#&gt;  9 BGR     375\n#&gt; 10 BHM     297\n#&gt; # … with 95 more rows\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;    dest      n\n#&gt;    &lt;chr&gt; &lt;int&gt;\n#&gt;  1 ABQ     254\n#&gt;  2 ACK     265\n#&gt;  3 ALB     439\n#&gt;  4 ANC       8\n#&gt;  5 ATL   17215\n#&gt;  6 AUS    2439\n#&gt;  7 AVL     275\n#&gt;  8 BDL     443\n#&gt;  9 BGR     375\n#&gt; 10 BHM     297\n#&gt; # … with 95 more rows\n\n\n\n10.4.3 Grouper selon plusieurs variables\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 1,113 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1    12 BZN           75  \n#&gt;  2     7 TUL           72.6\n#&gt;  3     3 DSM           71.0\n#&gt;  4     7 CAE           69.4\n#&gt;  5    11 SBN           67.5\n#&gt;  6     7 BHM           64.6\n#&gt;  7     7 TYS           60.6\n#&gt;  8     6 BHM           57.2\n#&gt;  9     1 TUL           55.2\n#&gt; 10     1 SAV           54.8\n#&gt; # … with 1,103 more rows\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n#&gt; # A tibble: 224 × 3\n#&gt;    origin dest      n\n#&gt;    &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt;  1 JFK    LAX   11262\n#&gt;  2 LGA    ATL   10263\n#&gt;  3 LGA    ORD    8857\n#&gt;  4 JFK    SFO    8204\n#&gt;  5 LGA    CLT    6168\n#&gt;  6 EWR    ORD    6100\n#&gt;  7 JFK    BOS    5898\n#&gt;  8 LGA    MIA    5781\n#&gt;  9 JFK    MCO    5464\n#&gt; 10 EWR    BOS    5327\n#&gt; # … with 214 more rows\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n#&gt; `summarise()` has grouped output by 'month', 'origin'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 12 × 4\n#&gt; # Groups:   month [12]\n#&gt;    month origin dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 EWR    TUL           55.2\n#&gt;  2     2 EWR    DSM           48.6\n#&gt;  3     3 EWR    DSM           71.0\n#&gt;  4     4 EWR    OKC           47.0\n#&gt;  5     5 EWR    TYS           60.6\n#&gt;  6     6 EWR    TYS           68.2\n#&gt;  7     7 EWR    CAE           81.5\n#&gt;  8     8 LGA    GSO           50.1\n#&gt;  9     9 LGA    MSN           24.7\n#&gt; 10    10 EWR    CAE           50.1\n#&gt; 11    11 LGA    SBN           67.5\n#&gt; 12    12 EWR    BZN           75\n\n\n\n10.4.4 Dégroupage\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n#&gt; `summarise()` has grouped output by 'month', 'origin'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 2,313 × 4\n#&gt; # Groups:   month, origin [36]\n#&gt;    month origin dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 EWR    ALB          41.4 \n#&gt;  2     1 EWR    ATL           8.07\n#&gt;  3     1 EWR    AUS           6.67\n#&gt;  4     1 EWR    AVL          25.5 \n#&gt;  5     1 EWR    BDL          21.1 \n#&gt;  6     1 EWR    BNA          16.3 \n#&gt;  7     1 EWR    BOS           8.99\n#&gt;  8     1 EWR    BQN          12.3 \n#&gt;  9     1 EWR    BTV          20.5 \n#&gt; 10     1 EWR    BUF          23.1 \n#&gt; # … with 2,303 more rows\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 36 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 TUL           55.2\n#&gt;  2     1 SAV           54.8\n#&gt;  3     1 DSM           42.2\n#&gt;  4     2 DSM           48.6\n#&gt;  5     2 TUL           34.2\n#&gt;  6     2 GSP           32.4\n#&gt;  7     3 DSM           71.0\n#&gt;  8     3 PVD           47.5\n#&gt;  9     3 CAE           46.9\n#&gt; 10     4 OKC           47.0\n#&gt; # … with 26 more rows\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 3 × 3\n#&gt;   month dest  retard_moyen\n#&gt;   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt; 1    12 BZN           75  \n#&gt; 2     7 TUL           72.6\n#&gt; 3     3 DSM           71.0\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n#&gt; # A tibble: 1,113 × 3\n#&gt;    month dest      n\n#&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n#&gt;  1     1 ALB      64\n#&gt;  2     1 ATL    1396\n#&gt;  3     1 AUS     169\n#&gt;  4     1 AVL       2\n#&gt;  5     1 BDL      37\n#&gt;  6     1 BHM      25\n#&gt;  7     1 BNA     399\n#&gt;  8     1 BOS    1245\n#&gt;  9     1 BQN      93\n#&gt; 10     1 BTV     223\n#&gt; # … with 1,103 more rows"
  },
  {
    "objectID": "10-dplyr.html#autres-fonctions-utiles",
    "href": "10-dplyr.html#autres-fonctions-utiles",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.5 Autres fonctions utiles",
    "text": "10.5 Autres fonctions utiles\ndplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données.\n\n10.5.1 slice_sample\nCe verbe permet de sélectionner aléatoirement un nombre de lignes (avec l’argument n) ou une fraction des lignes (avec l’argument prop) d’un tableau.\nAinsi si on veut choisir 5 lignes au hasard dans le tableau airports :\n\nairports %&gt;% slice_sample(n = 5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                            lat    lon   alt    tz dst   tzone      \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      \n#&gt; 1 TWF   Magic Valley Regional Airport  42.5 -114.   4151    -7 A     America/De…\n#&gt; 2 AUS   Austin Bergstrom Intl          30.2  -97.7   542    -6 A     America/Ch…\n#&gt; 3 CAK   Akron Canton Regional Airport  40.9  -81.4  1228    -5 A     America/Ne…\n#&gt; 4 CPS   St. Louis Downtown Airport     38.6  -90.2   413    -6 U     America/Ch…\n#&gt; 5 ARB   Ann Arbor Municipal Airport    42.1  -83.4   839    -5 A     America/Ne…\n\nSi on veut tirer au hasard 10% des lignes de flights :\n\nflights %&gt;% slice_sample(prop = 0.1)\n#&gt; # A tibble: 33,677 × 22\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     9     4      740        749      -9    1025    1043     -18 B6     \n#&gt;  2  2013     9    16      905        905       0    1115    1117      -2 DL     \n#&gt;  3  2013     4    15     1359       1359       0    1656    1714     -18 AA     \n#&gt;  4  2013    11    21     1452       1446       6    1802    1753       9 B6     \n#&gt;  5  2013     7     9      833        825       8    1100    1108      -8 DL     \n#&gt;  6  2013    11     9     1157       1135      22    1445    1438       7 DL     \n#&gt;  7  2013    11    22     1017       1023      -6    1219    1218       1 US     \n#&gt;  8  2013     2    10     1500       1500       0    1745    1742       3 DL     \n#&gt;  9  2013     5    22     1320       1300      20    1433    1410      23 US     \n#&gt; 10  2013     6    30     1932       1825      67    2148    2029      79 DL     \n#&gt; # … with 33,667 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nCes fonctions sont utiles notamment pour faire de “l’échantillonnage” en tirant au hasard un certain nombre d’observations du tableau.\n\n\n10.5.2 lead et lag\nlead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag).\n\nlead(1:5)\n#&gt; [1]  2  3  4  5 NA\nlag(1:5)\n#&gt; [1] NA  1  2  3  4\n\nCeci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre le retard au départ de chaque vol et celui du vol précédent :\n\nflights %&gt;%\n  mutate(\n      dep_delay_prev = lag(dep_delay),\n      dep_delay_diff = dep_delay - dep_delay_prev\n  ) %&gt;%\n  select(dep_delay_prev, dep_delay, dep_delay_diff)\n#&gt; # A tibble: 336,776 × 3\n#&gt;    dep_delay_prev dep_delay dep_delay_diff\n#&gt;             &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n#&gt;  1             NA         2             NA\n#&gt;  2              2         4              2\n#&gt;  3              4         2             -2\n#&gt;  4              2        -1             -3\n#&gt;  5             -1        -6             -5\n#&gt;  6             -6        -4              2\n#&gt;  7             -4        -5             -1\n#&gt;  8             -5        -3              2\n#&gt;  9             -3        -3              0\n#&gt; 10             -3        -2              1\n#&gt; # … with 336,766 more rows\n\n\n\n10.5.3 distinct et n_distinct\ndistinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double.\n\nflights %&gt;%\n  select(day, month) %&gt;%\n  distinct()\n#&gt; # A tibble: 365 × 2\n#&gt;      day month\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1     1\n#&gt;  2     2     1\n#&gt;  3     3     1\n#&gt;  4     4     1\n#&gt;  5     5     1\n#&gt;  6     6     1\n#&gt;  7     7     1\n#&gt;  8     8     1\n#&gt;  9     9     1\n#&gt; 10    10     1\n#&gt; # … with 355 more rows\n\nOn peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles.\n\nflights %&gt;%\n  distinct(month, day)\n#&gt; # A tibble: 365 × 2\n#&gt;    month   day\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1     1\n#&gt;  2     1     2\n#&gt;  3     1     3\n#&gt;  4     1     4\n#&gt;  5     1     5\n#&gt;  6     1     6\n#&gt;  7     1     7\n#&gt;  8     1     8\n#&gt;  9     1     9\n#&gt; 10     1    10\n#&gt; # … with 355 more rows\n\nL’option .keep_all permet, dans l’opération précédente, de conserver l’ensemble des colonnes du tableau :\n\nflights %&gt;%\n  distinct(month, day, .keep_all = TRUE)\n#&gt; # A tibble: 365 × 22\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     2       42       2359      43     518     442      36 B6     \n#&gt;  3  2013     1     3       32       2359      33     504     442      22 B6     \n#&gt;  4  2013     1     4       25       2359      26     505     442      23 B6     \n#&gt;  5  2013     1     5       14       2359      15     503     445      18 B6     \n#&gt;  6  2013     1     6       16       2359      17     451     442       9 B6     \n#&gt;  7  2013     1     7       49       2359      50     531     444      47 B6     \n#&gt;  8  2013     1     8      454        500      -6     625     648     -23 US     \n#&gt;  9  2013     1     9        2       2359       3     432     444     -12 B6     \n#&gt; 10  2013     1    10        3       2359       4     426     437     -11 B6     \n#&gt; # … with 355 more rows, 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;, distance_km &lt;dbl&gt;,\n#&gt; #   vitesse &lt;dbl&gt;, and abbreviated variable names ¹​sched_dep_time, ²​dep_delay,\n#&gt; #   ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nLa fonction n_distinct, elle, renvoie le nombre de valeurs distinctes d’un vecteur. On peut notamment l’utiliser dans un summarise.\nDans l’exemple qui suit on calcule, pour les trois aéroports de départ de la table flights le nombre de valeurs distinctes de l’aéroport d’arrivée :\n\nflights %&gt;%\n  group_by(origin) %&gt;%\n  summarise(n_dest = n_distinct(dest))\n#&gt; # A tibble: 3 × 2\n#&gt;   origin n_dest\n#&gt;   &lt;chr&gt;   &lt;int&gt;\n#&gt; 1 EWR        86\n#&gt; 2 JFK        70\n#&gt; 3 LGA        68\n\n\n\n10.5.4 relocate\nrelocate peut être utilisé pour réordonner les colonnes d’une table. Par défaut, si on lui passe un ou plusieurs noms de colonnes, relocate les place en début de tableau.\n\nairports %&gt;% relocate(lat, lon)\n#&gt; # A tibble: 1,458 × 8\n#&gt;      lat    lon faa   name                             alt    tz dst   tzone    \n#&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n#&gt;  1  41.1  -80.6 04G   Lansdowne Airport               1044    -5 A     America/…\n#&gt;  2  32.5  -85.7 06A   Moton Field Municipal Airport    264    -6 A     America/…\n#&gt;  3  42.0  -88.1 06C   Schaumburg Regional              801    -6 A     America/…\n#&gt;  4  41.4  -74.4 06N   Randall Airport                  523    -5 A     America/…\n#&gt;  5  31.1  -81.4 09J   Jekyll Island Airport             11    -5 A     America/…\n#&gt;  6  36.4  -82.2 0A9   Elizabethton Municipal Airport  1593    -5 A     America/…\n#&gt;  7  41.5  -84.5 0G6   Williams County Airport          730    -5 A     America/…\n#&gt;  8  42.9  -76.8 0G7   Finger Lakes Regional Airport    492    -5 A     America/…\n#&gt;  9  39.8  -76.6 0P2   Shoestring Aviation Airfield    1000    -5 U     America/…\n#&gt; 10  48.1 -123.  0S9   Jefferson County Intl            108    -8 A     America/…\n#&gt; # … with 1,448 more rows\n\nLes arguments supplémentaires .before et .after permettent de préciser à quel endroit déplacer la ou les colonnes indiquées.\n\nairports %&gt;% relocate(starts_with('tz'), .after = name)\n#&gt; # A tibble: 1,458 × 8\n#&gt;    faa   name                              tz tzone       lat    lon   alt dst  \n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt;  1 04G   Lansdowne Airport                 -5 America/…  41.1  -80.6  1044 A    \n#&gt;  2 06A   Moton Field Municipal Airport     -6 America/…  32.5  -85.7   264 A    \n#&gt;  3 06C   Schaumburg Regional               -6 America/…  42.0  -88.1   801 A    \n#&gt;  4 06N   Randall Airport                   -5 America/…  41.4  -74.4   523 A    \n#&gt;  5 09J   Jekyll Island Airport             -5 America/…  31.1  -81.4    11 A    \n#&gt;  6 0A9   Elizabethton Municipal Airport    -5 America/…  36.4  -82.2  1593 A    \n#&gt;  7 0G6   Williams County Airport           -5 America/…  41.5  -84.5   730 A    \n#&gt;  8 0G7   Finger Lakes Regional Airport     -5 America/…  42.9  -76.8   492 A    \n#&gt;  9 0P2   Shoestring Aviation Airfield      -5 America/…  39.8  -76.6  1000 U    \n#&gt; 10 0S9   Jefferson County Intl             -8 America/…  48.1 -123.    108 A    \n#&gt; # … with 1,448 more rows"
  },
  {
    "objectID": "10-dplyr.html#tables-multiples",
    "href": "10-dplyr.html#tables-multiples",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.6 Tables multiples",
    "text": "10.6 Tables multiples\nLe jeu de données nycflights13 est un exemple de données réparties en plusieurs tables. Ici on en a trois : les informations sur les vols dans flights, celles sur les aéroports dans airports et celles sur les compagnies aériennes dans airlines.\ndplyr propose différentes fonctions permettant de travailler avec des données structurées de cette manière.\n\n10.6.1 Concaténation : bind_rows et bind_cols\nLes fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables.\nL’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows. On commence par créer trois tableaux t1, t2 et t3 :\n\nt1 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(1:2)\nt1\n#&gt; # A tibble: 2 × 4\n#&gt;   faa   name                            lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6\n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7\n\n\nt2 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(5:6)\n\nt2\n#&gt; # A tibble: 2 × 4\n#&gt;   faa   name                             lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n\n\nt3 &lt;- airports %&gt;%\n  select(faa, name) %&gt;%\n  slice(100:101)\nt3\n#&gt; # A tibble: 2 × 2\n#&gt;   faa   name             \n#&gt;   &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1 ADW   Andrews Afb      \n#&gt; 2 AET   Allakaket Airport\n\nOn concaténe ensuite les trois tables avec bind_rows :\n\nbind_rows(t1, t2, t3)\n#&gt; # A tibble: 6 × 4\n#&gt;   faa   name                             lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 ADW   Andrews Afb                     NA    NA  \n#&gt; 6 AET   Allakaket Airport               NA    NA\n\nOn remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes lat et lon de t3, des NA sont automatiquement insérées.\nIl peut être utile, quand on concatène des lignes, de garder une trace du tableau d’origine de chacune des lignes dans le tableau final. C’est possible grâce à l’argument .id de bind_rows. On passe à cet argument le nom d’une colonne qui contiendra l’indicateur d’origine des lignes :\n\nbind_rows(t1, t2, t3, .id = \"source\")\n#&gt; # A tibble: 6 × 5\n#&gt;   source faa   name                             lat   lon\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 1      04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 1      06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 2      09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 2      0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 3      ADW   Andrews Afb                     NA    NA  \n#&gt; 6 3      AET   Allakaket Airport               NA    NA\n\nPar défaut la colonne .id ne contient qu’un nombre, différent pour chaque tableau. On peut lui spécifier des valeurs plus explicites en “nommant” les tables dans bind_rows de la manière suivante :\n\nbind_rows(table1 = t1, table2 = t2, table3 = t3, .id = \"source\")\n#&gt; # A tibble: 6 × 5\n#&gt;   source faa   name                             lat   lon\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 table1 04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 table1 06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 table2 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 table2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 table3 ADW   Andrews Afb                     NA    NA  \n#&gt; 6 table3 AET   Allakaket Airport               NA    NA\n\nbind_cols permet de concaténer des colonnes et fonctionne de manière similaire :\n\nt1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time)\nt2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest)\nt3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time)\nbind_cols(t1, t2, t3)\n#&gt; # A tibble: 5 × 6\n#&gt;   dep_delay dep_time origin dest  arr_delay arr_time\n#&gt;       &lt;dbl&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1         2      517 EWR    IAH          11      830\n#&gt; 2         4      533 LGA    IAH          20      850\n#&gt; 3         2      542 JFK    MIA          33      923\n#&gt; 4        -1      544 JFK    BQN         -18     1004\n#&gt; 5        -6      554 LGA    ATL         -25      812\n\nÀ noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit être identique). Pour associer des tables par valeur, on doit utiliser des jointures.\n\n\n10.6.2 Jointures\n\n10.6.2.1 Clés implicites\nTrès souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient le code de la compagnie aérienne du vol dans la variable carrier :\n\nflights %&gt;% select(carrier)\n#&gt; # A tibble: 336,776 × 1\n#&gt;    carrier\n#&gt;    &lt;chr&gt;  \n#&gt;  1 UA     \n#&gt;  2 UA     \n#&gt;  3 AA     \n#&gt;  4 B6     \n#&gt;  5 DL     \n#&gt;  6 UA     \n#&gt;  7 B6     \n#&gt;  8 EV     \n#&gt;  9 B6     \n#&gt; 10 AA     \n#&gt; # … with 336,766 more rows\n\nEt que par ailleurs la table airlines contient une information supplémentaire relative à ces compagnies, à savoir le nom complet.\n\nairlines\n#&gt; # A tibble: 16 × 2\n#&gt;    carrier name                       \n#&gt;    &lt;chr&gt;   &lt;chr&gt;                      \n#&gt;  1 9E      Endeavor Air Inc.          \n#&gt;  2 AA      American Airlines Inc.     \n#&gt;  3 AS      Alaska Airlines Inc.       \n#&gt;  4 B6      JetBlue Airways            \n#&gt;  5 DL      Delta Air Lines Inc.       \n#&gt;  6 EV      ExpressJet Airlines Inc.   \n#&gt;  7 F9      Frontier Airlines Inc.     \n#&gt;  8 FL      AirTran Airways Corporation\n#&gt;  9 HA      Hawaiian Airlines Inc.     \n#&gt; 10 MQ      Envoy Air                  \n#&gt; 11 OO      SkyWest Airlines Inc.      \n#&gt; 12 UA      United Air Lines Inc.      \n#&gt; 13 US      US Airways Inc.            \n#&gt; 14 VX      Virgin America             \n#&gt; 15 WN      Southwest Airlines Co.     \n#&gt; 16 YV      Mesa Airlines Inc.\n\nIl est donc naturel de vouloir associer les deux, ici pour ajouter les noms complets des compagnies à la table flights. Pour cela on va effectuer une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés.\nPour faire une jointure de ce type, on va utiliser la fonction left_join :\n\nleft_join(flights, airlines)\n\nPour faciliter la lecture, on va afficher seulement certaines colonnes du résultat :\n\nleft_join(flights, airlines) %&gt;%\n  select(month, day, carrier, name)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 × 4\n#&gt;    month   day carrier name                    \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;                   \n#&gt;  1     1     1 UA      United Air Lines Inc.   \n#&gt;  2     1     1 UA      United Air Lines Inc.   \n#&gt;  3     1     1 AA      American Airlines Inc.  \n#&gt;  4     1     1 B6      JetBlue Airways         \n#&gt;  5     1     1 DL      Delta Air Lines Inc.    \n#&gt;  6     1     1 UA      United Air Lines Inc.   \n#&gt;  7     1     1 B6      JetBlue Airways         \n#&gt;  8     1     1 EV      ExpressJet Airlines Inc.\n#&gt;  9     1     1 B6      JetBlue Airways         \n#&gt; 10     1     1 AA      American Airlines Inc.  \n#&gt; # … with 336,766 more rows\n\nOn voit que la table résultat est bien la fusion des deux tables d’origine selon les valeurs des deux colonnes clés carrier. On est parti de la table flights, et pour chaque ligne de celle-ci on a ajouté les colonnes de airlines pour lesquelles la valeur de carrier est la même. On a donc bien une nouvelle colonne name dans notre table résultat, avec le nom complet de la compagnie aérienne.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter qu’on peut tout à fait utiliser le pipe avec les fonctions de jointure :\nflights %&gt;% left_join(airlines).\n\n\nNous sommes ici dans le cas le plus simple concernant les clés de jointure : les deux clés sont uniques et portent le même nom dans les deux tables. Par défaut, si on ne lui spécifie pas explicitement les clés, dplyr fusionne en utilisant l’ensemble des colonnes communes aux deux tables. On peut d’ailleurs voir dans cet exemple qu’un message a été affiché précisant que la jointure s’est bien faite sur la variable carrier.\n\n\n10.6.2.2 Clés explicites\nLa table airports, contient des informations supplémentaires sur les aéroports : nom complet, altitude, position géographique, etc. Chaque aéroport est identifié par un code contenu dans la colonne faa.\nSi on regarde la table flights, on voit que le code d’identification des aéroports apparaît à deux endroits différents : pour l’aéroport de départ dans la colonne origin, et pour celui d’arrivée dans la colonne dest. On a donc deux clés de jointure possibles, et qui portent un nom différent de la clé de airports.\nOn va commencer par fusionner les données concernant l’aéroport de départ. Pour simplifier l’affichage des résultats, on va se contenter d’un sous-ensemble des deux tables :\n\nflights_ex &lt;- flights %&gt;% select(month, day, origin, dest)\nairports_ex &lt;- airports %&gt;% select(faa, alt, name)\n\nSi on se contente d’un left_join comme à l’étape précédente, on obtient un message d’erreur car aucune colonne commune ne peut être identifiée comme clé de jointure :\n\nflights_ex %&gt;% left_join(airports_ex)\n#&gt; Error in `left_join()`:\n#&gt; ! `by` must be supplied when `x` and `y` have no common variables.\n#&gt; ℹ Use `cross_join()` to perform a cross-join.\n\nOn doit donc spécifier explicitement les clés avec l’argument by de left_join. Ici la clé est nommée origin dans la première table, et faa dans la seconde. La syntaxe est donc la suivante :\n\nflights_ex %&gt;% \n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n#&gt; # A tibble: 336,776 × 6\n#&gt;    month   day origin dest    alt name               \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;              \n#&gt;  1     1     1 EWR    IAH      18 Newark Liberty Intl\n#&gt;  2     1     1 LGA    IAH      22 La Guardia         \n#&gt;  3     1     1 JFK    MIA      13 John F Kennedy Intl\n#&gt;  4     1     1 JFK    BQN      13 John F Kennedy Intl\n#&gt;  5     1     1 LGA    ATL      22 La Guardia         \n#&gt;  6     1     1 EWR    ORD      18 Newark Liberty Intl\n#&gt;  7     1     1 EWR    FLL      18 Newark Liberty Intl\n#&gt;  8     1     1 LGA    IAD      22 La Guardia         \n#&gt;  9     1     1 JFK    MCO      13 John F Kennedy Intl\n#&gt; 10     1     1 LGA    ORD      22 La Guardia         \n#&gt; # … with 336,766 more rows\n\nOn constate que les deux nouvelles colonnes name et alt contiennent bien les données correspondant à l’aéroport de départ.\nOn va stocker le résultat de cette jointure dans la table flights_ex :\n\nflights_ex &lt;- flights_ex %&gt;%\n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\nSupposons qu’on souhaite maintenant fusionner à nouveau les informations de la table airports, mais cette fois pour les aéroports d’arrivée de notre nouvelle table flights_ex. Les deux clés sont donc désormais dest dans la première table, et faa dans la deuxième. La syntaxe est donc la suivante :\n\nflights_ex %&gt;%\n  left_join(airports_ex, by = c(\"dest\" = \"faa\"))\n#&gt; # A tibble: 336,776 × 8\n#&gt;    month   day origin dest  alt.x name.x              alt.y name.y              \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;               \n#&gt;  1     1     1 EWR    IAH      18 Newark Liberty Intl    97 George Bush Interco…\n#&gt;  2     1     1 LGA    IAH      22 La Guardia             97 George Bush Interco…\n#&gt;  3     1     1 JFK    MIA      13 John F Kennedy Intl     8 Miami Intl          \n#&gt;  4     1     1 JFK    BQN      13 John F Kennedy Intl    NA &lt;NA&gt;                \n#&gt;  5     1     1 LGA    ATL      22 La Guardia           1026 Hartsfield Jackson …\n#&gt;  6     1     1 EWR    ORD      18 Newark Liberty Intl   668 Chicago Ohare Intl  \n#&gt;  7     1     1 EWR    FLL      18 Newark Liberty Intl     9 Fort Lauderdale Hol…\n#&gt;  8     1     1 LGA    IAD      22 La Guardia            313 Washington Dulles I…\n#&gt;  9     1     1 JFK    MCO      13 John F Kennedy Intl    96 Orlando Intl        \n#&gt; 10     1     1 LGA    ORD      22 La Guardia            668 Chicago Ohare Intl  \n#&gt; # … with 336,766 more rows\n\nCela fonctionne, les informations de l’aéroport d’arrivée ont bien été ajoutées, mais on constate que les colonnes ont été renommées. En effet, ici les deux tables fusionnées contenaient toutes les deux des colonnes name et alt. Comme on ne peut pas avoir deux colonnes avec le même nom dans un tableau, dplyr a renommé les colonnes de la première table en name.x et alt.x, et celles de la deuxième en name.y et alt.y.\nC’est pratique, mais pas forcément très parlant. On pourrait renommer manuellement les colonnes avec rename avant de faire la jointure pour avoir des intitulés plus explicites, mais on peut aussi utiliser l’argument suffix de left_join, qui permet d’indiquer les suffixes à ajouter aux colonnes.\n\nflights_ex %&gt;%\n  left_join(\n    airports_ex,\n    by = c(\"dest\" = \"faa\"),\n    suffix = c(\"_depart\", \"_arrivee\")\n  )\n#&gt; # A tibble: 336,776 × 8\n#&gt;    month   day origin dest  alt_depart name_depart         alt_arrivee name_ar…¹\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;chr&gt;    \n#&gt;  1     1     1 EWR    IAH           18 Newark Liberty Intl          97 George B…\n#&gt;  2     1     1 LGA    IAH           22 La Guardia                   97 George B…\n#&gt;  3     1     1 JFK    MIA           13 John F Kennedy Intl           8 Miami In…\n#&gt;  4     1     1 JFK    BQN           13 John F Kennedy Intl          NA &lt;NA&gt;     \n#&gt;  5     1     1 LGA    ATL           22 La Guardia                 1026 Hartsfie…\n#&gt;  6     1     1 EWR    ORD           18 Newark Liberty Intl         668 Chicago …\n#&gt;  7     1     1 EWR    FLL           18 Newark Liberty Intl           9 Fort Lau…\n#&gt;  8     1     1 LGA    IAD           22 La Guardia                  313 Washingt…\n#&gt;  9     1     1 JFK    MCO           13 John F Kennedy Intl          96 Orlando …\n#&gt; 10     1     1 LGA    ORD           22 La Guardia                  668 Chicago …\n#&gt; # … with 336,766 more rows, and abbreviated variable name ¹​name_arrivee\n\nOn obtient ainsi directement des noms de colonnes nettement plus clairs.\n\n\n\n10.6.3 Types de jointures\nJusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures.\nPartons de deux tables d’exemple, personnes et voitures :\n\npersonnes &lt;- tibble(\n    nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n    voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\n\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nMonique\nScenic\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\n\nvoitures &lt;- tibble(\n    voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n    vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\n\n\n\n\n\nvoiture\nvitesse\n\n\n\n\nTwingo\n140\n\n\nFerrari\n280\n\n\nClio\n160\n\n\nLada\n85\n\n\n208\n160\n\n\n\n\n\n\n10.6.3.1 left_join\nSi on fait un left_join de voitures sur personnes :\n\npersonnes %&gt;% left_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nOn voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mise à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas.\nSi on fait un left_join cette fois de personnes sur voitures, c’est l’inverse :\n\nvoitures %&gt;% left_join(personnes)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n#&gt; Warning in left_join(., personnes): Each row in `x` is expected to match at most 1 row in `y`.\n#&gt; ℹ Row 1 of `x` matches multiple rows.\n#&gt; ℹ If multiple matches are expected, set `multiple = \"all\"` to silence this\n#&gt;   warning.\n\n\n\n\nvoiture\nvitesse\nnom\n\n\n\n\nTwingo\n140\nSylvie\n\n\nTwingo\n140\nRayan\n\n\nFerrari\n280\nSylvie\n\n\nClio\n160\nRayan\n\n\nLada\n85\nGunter\n\n\n208\n160\nNA\n\n\n\n\n\nLa ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan.\nEn résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, et dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA pour les nouvelles colonnes.\nIntuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”.\nEn général, left_join sera le type de jointures le plus fréquemment utilisé.\n\n\n10.6.3.2 right_join\nLa jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(y, x) :\n\npersonnes %&gt;% right_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n10.6.3.3 inner_join\nDans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont conservées (et si nécessaire dupliquées) dans la table résultat :\n\npersonnes %&gt;% inner_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nIci la ligne 208 est absente, ainsi que la ligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA.\n\n\n10.6.3.4 full_join\nDans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table :\n\npersonnes %&gt;% full_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n10.6.3.5 semi_join et anti_join\nsemi_join et anti_join sont des jointures filtrantes, c’est-à-dire qu’elles sélectionnent les lignes de x sans ajouter les colonnes de y.\nAinsi, semi_join ne conservera que les lignes de x pour lesquelles une ligne de y existe également, et supprimera les autres. Dans notre exemple, la ligne Monique est donc supprimée :\n\npersonnes %&gt;% semi_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\nUn anti_join fait l’inverse, il ne conserve que les lignes de x absentes de y. Dans notre exemple, on ne garde donc que la ligne Monique :\n\npersonnes %&gt;% anti_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\n\n\n\n\nMonique\nScenic"
  },
  {
    "objectID": "10-dplyr.html#ressources",
    "href": "10-dplyr.html#ressources",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.7 Ressources",
    "text": "10.7 Ressources\nToutes les ressources ci-dessous sont en anglais…\nLe livre R for data science, librement accessible en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment :\n\nData transformation pour les manipulations\nRelational data pour les tables multiples\n\nLe site de l’extension comprend une liste des fonctions et les pages d’aide associées, mais aussi une introduction au package et plusieurs articles dont un spécifiquement sur les jointures.\nEnfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr."
  },
  {
    "objectID": "10-dplyr.html#exercices",
    "href": "10-dplyr.html#exercices",
    "title": "10  Manipuler les données avec dplyr",
    "section": "10.8 Exercices",
    "text": "10.8 Exercices\nOn commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n10.8.1 Les verbes de base de dplyr\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\n\n#&gt; # A tibble: 1 × 8\n#&gt;   faa   name                    lat   lon   alt    tz dst   tzone              \n#&gt;   &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n#&gt; 1 0S9   Jefferson County Intl  48.1 -123.   108    -8 A     America/Los_Angeles\n\n\n\nslice(airports, 10)\n\n\nSélectionner les 5 premières lignes de la table airlines.\n\n#&gt; # A tibble: 5 × 2\n#&gt;   carrier name                  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n#&gt; 1 9E      Endeavor Air Inc.     \n#&gt; 2 AA      American Airlines Inc.\n#&gt; 3 AS      Alaska Airlines Inc.  \n#&gt; 4 B6      JetBlue Airways       \n#&gt; 5 DL      Delta Air Lines Inc.\n\n\n\nslice_head(airlines, n = 5)\n\n\nSélectionner l’aéroport avec l’altitude la plus basse.\n\n#&gt; # A tibble: 1 × 8\n#&gt;   faa   name          lat   lon   alt    tz dst   tzone              \n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n#&gt; 1 IPL   Imperial Co  32.8 -116.   -54    -8 A     America/Los_Angeles\n\n\n\nslice_min(airports, alt)\n\n\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\n\n#&gt; # A tibble: 29,425 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     7     1        1       2029     212     236    2359     157 B6     \n#&gt;  2  2013     7     1        2       2359       3     344     344       0 B6     \n#&gt;  3  2013     7     1       29       2245     104     151       1     110 B6     \n#&gt;  4  2013     7     1       43       2130     193     322      14     188 B6     \n#&gt;  5  2013     7     1       44       2150     174     300     100     120 AA     \n#&gt;  6  2013     7     1       46       2051     235     304    2358     186 B6     \n#&gt;  7  2013     7     1       48       2001     287     308    2305     243 VX     \n#&gt;  8  2013     7     1       58       2155     183     335      43     172 B6     \n#&gt;  9  2013     7     1      100       2146     194     327      30     177 B6     \n#&gt; 10  2013     7     1      100       2245     135     337     135     122 B6     \n#&gt; # … with 29,415 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nfilter(flights, month == 7)\n\n\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\n\n#&gt; # A tibble: 36,392 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  3  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt;  4  2013     1     1      558        600      -2     924     917       7 UA     \n#&gt;  5  2013     1     1      600        600       0     837     825      12 MQ     \n#&gt;  6  2013     1     1      611        600      11     945     931      14 UA     \n#&gt;  7  2013     1     1      623        610      13     920     915       5 AA     \n#&gt;  8  2013     1     1      624        630      -6     840     830      10 MQ     \n#&gt;  9  2013     1     1      629        630      -1     824     810      14 AA     \n#&gt; 10  2013     1     1      632        608      24     740     728      12 EV     \n#&gt; # … with 36,382 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nfilter(flights, arr_delay &gt;= 5 & arr_delay &lt;= 15)\n\n\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\n\n#&gt; # A tibble: 139,504 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      554        600      -6     812     837     -25 DL     \n#&gt;  5  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  6  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt;  7  2013     1     1      558        600      -2     924     917       7 UA     \n#&gt;  8  2013     1     1      558        600      -2     923     937     -14 UA     \n#&gt;  9  2013     1     1      559        600      -1     941     910      31 AA     \n#&gt; 10  2013     1     1      559        600      -1     854     902      -8 UA     \n#&gt; # … with 139,494 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nfilter(flights, carrier %in% c(\"DL\", \"UA\", \"AA\"))\n\n\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\n\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     9      641        900    1301    1242    1530    1272 HA     \n#&gt;  2  2013     6    15     1432       1935    1137    1607    2120    1127 MQ     \n#&gt;  3  2013     1    10     1121       1635    1126    1239    1810    1109 MQ     \n#&gt;  4  2013     9    20     1139       1845    1014    1457    2210    1007 AA     \n#&gt;  5  2013     7    22      845       1600    1005    1044    1815     989 MQ     \n#&gt;  6  2013     4    10     1100       1900     960    1342    2211     931 DL     \n#&gt;  7  2013     3    17     2321        810     911     135    1020     915 DL     \n#&gt;  8  2013     6    27      959       1900     899    1236    2226     850 DL     \n#&gt;  9  2013     7    22     2257        759     898     121    1026     895 DL     \n#&gt; 10  2013    12     5      756       1700     896    1058    2020     878 AA     \n#&gt; # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\narrange(flights, desc(dep_delay))\n\n\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\n\n#&gt; # A tibble: 1,458 × 3\n#&gt;    name                             lat    lon\n#&gt;    &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1 Lansdowne Airport               41.1  -80.6\n#&gt;  2 Moton Field Municipal Airport   32.5  -85.7\n#&gt;  3 Schaumburg Regional             42.0  -88.1\n#&gt;  4 Randall Airport                 41.4  -74.4\n#&gt;  5 Jekyll Island Airport           31.1  -81.4\n#&gt;  6 Elizabethton Municipal Airport  36.4  -82.2\n#&gt;  7 Williams County Airport         41.5  -84.5\n#&gt;  8 Finger Lakes Regional Airport   42.9  -76.8\n#&gt;  9 Shoestring Aviation Airfield    39.8  -76.6\n#&gt; 10 Jefferson County Intl           48.1 -123. \n#&gt; # … with 1,448 more rows\n\n\n\nselect(airports, name, lat, lon)\n\n\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\n\n#&gt; # A tibble: 1,458 × 6\n#&gt;    faa   name                             lat    lon   alt dst  \n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt;  1 04G   Lansdowne Airport               41.1  -80.6  1044 A    \n#&gt;  2 06A   Moton Field Municipal Airport   32.5  -85.7   264 A    \n#&gt;  3 06C   Schaumburg Regional             42.0  -88.1   801 A    \n#&gt;  4 06N   Randall Airport                 41.4  -74.4   523 A    \n#&gt;  5 09J   Jekyll Island Airport           31.1  -81.4    11 A    \n#&gt;  6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593 A    \n#&gt;  7 0G6   Williams County Airport         41.5  -84.5   730 A    \n#&gt;  8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492 A    \n#&gt;  9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000 U    \n#&gt; 10 0S9   Jefferson County Intl           48.1 -123.    108 A    \n#&gt; # … with 1,448 more rows\n\n\n\nselect(airports, -tz, -tzone)\n\n\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\n\n#&gt; # A tibble: 336,776 × 2\n#&gt;    dep_delay arr_delay\n#&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n#&gt;  1         2        11\n#&gt;  2         4        20\n#&gt;  3         2        33\n#&gt;  4        -1       -18\n#&gt;  5        -6       -25\n#&gt;  6        -4        12\n#&gt;  7        -5        19\n#&gt;  8        -3       -14\n#&gt;  9        -3        -8\n#&gt; 10        -2         8\n#&gt; # … with 336,766 more rows\n\n\n\nselect(flights, ends_with(\"delay\"))\n\n\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\n\n#&gt; # A tibble: 1,458 × 8\n#&gt;    faa   name                             lat    lon altit…¹    tz dst   fusea…²\n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n#&gt;  1 04G   Lansdowne Airport               41.1  -80.6    1044    -5 A     Americ…\n#&gt;  2 06A   Moton Field Municipal Airport   32.5  -85.7     264    -6 A     Americ…\n#&gt;  3 06C   Schaumburg Regional             42.0  -88.1     801    -6 A     Americ…\n#&gt;  4 06N   Randall Airport                 41.4  -74.4     523    -5 A     Americ…\n#&gt;  5 09J   Jekyll Island Airport           31.1  -81.4      11    -5 A     Americ…\n#&gt;  6 0A9   Elizabethton Municipal Airport  36.4  -82.2    1593    -5 A     Americ…\n#&gt;  7 0G6   Williams County Airport         41.5  -84.5     730    -5 A     Americ…\n#&gt;  8 0G7   Finger Lakes Regional Airport   42.9  -76.8     492    -5 A     Americ…\n#&gt;  9 0P2   Shoestring Aviation Airfield    39.8  -76.6    1000    -5 U     Americ…\n#&gt; 10 0S9   Jefferson County Intl           48.1 -123.      108    -8 A     Americ…\n#&gt; # … with 1,448 more rows, and abbreviated variable names ¹​altitude,\n#&gt; #   ²​fuseau_horaire\n\n\n\nrename(airports, altitude = alt, fuseau_horaire = tzone)\n\n\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n#&gt; # A tibble: 1,458 × 2\n#&gt;      alt  alt_m\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1  1044 318.  \n#&gt;  2   264  80.5 \n#&gt;  3   801 244.  \n#&gt;  4   523 159.  \n#&gt;  5    11   3.35\n#&gt;  6  1593 486.  \n#&gt;  7   730 223.  \n#&gt;  8   492 150.  \n#&gt;  9  1000 305.  \n#&gt; 10   108  32.9 \n#&gt; # … with 1,448 more rows\n\n\n\ntmp &lt;- mutate(airports, alt_m = alt / 3.2808)\nselect(tmp, alt, alt_m)\n\n\n\n\n10.8.2 Enchaîner des opérations\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\n\n\nairports %&gt;%\n  mutate(alt_m = alt / 3.2808) %&gt;%\n  select(alt, alt_m)\n\n\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\n\n#&gt; # A tibble: 13,331 × 19\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     9    20     1139       1845    1014    1457    2210    1007 AA     \n#&gt;  2  2013     7     7     2123       1030     653      17    1345     632 VX     \n#&gt;  3  2013     7     7     2059       1030     629     106    1350     676 VX     \n#&gt;  4  2013     7     6      149       1600     589     456    1935     561 DL     \n#&gt;  5  2013     7    10      133       1800     453     455    2130     445 B6     \n#&gt;  6  2013     7    10     2342       1630     432     312    1959     433 VX     \n#&gt;  7  2013     7     7     2204       1525     399     107    1823     404 UA     \n#&gt;  8  2013     7     7     2306       1630     396     250    1959     411 VX     \n#&gt;  9  2013     6    23     1833       1200     393      NA    1507      NA UA     \n#&gt; 10  2013     7    10     2232       1609     383     138    1928     370 UA     \n#&gt; # … with 13,321 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nflights %&gt;%\n  filter(dest == \"SFO\") %&gt;%\n  arrange(desc(dep_delay))\n\n\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n#&gt; # A tibble: 5 × 3\n#&gt;   dest  dep_delay retard_h\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 SFO        1014    16.9 \n#&gt; 2 ATL         702    11.7 \n#&gt; 3 DTW         696    11.6 \n#&gt; 4 ATL         602    10.0 \n#&gt; 5 MSP         593     9.88\n\n\n\nflights %&gt;%\n  filter(month %in% c(9, 10)) %&gt;%\n  select(dest, dep_delay) %&gt;%\n  mutate(retard_h = dep_delay / 60) %&gt;%\n  slice_max(retard_h, n = 5)\n\n\n\n\n10.8.3 group_by et summarise\nExercice 3.1\nAffichez le nombre de vols par mois.\n\n#&gt; # A tibble: 12 × 2\n#&gt;    month     n\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1 27004\n#&gt;  2     2 24951\n#&gt;  3     3 28834\n#&gt;  4     4 28330\n#&gt;  5     5 28796\n#&gt;  6     6 28243\n#&gt;  7     7 29425\n#&gt;  8     8 29327\n#&gt;  9     9 27574\n#&gt; 10    10 28889\n#&gt; 11    11 27268\n#&gt; 12    12 28135\n\n\n\nflights %&gt;%\n  count(month)\n\n\nTriez la table résultat selon le nombre de vols croissant.\n\n#&gt; # A tibble: 12 × 2\n#&gt;    month     n\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     2 24951\n#&gt;  2     1 27004\n#&gt;  3    11 27268\n#&gt;  4     9 27574\n#&gt;  5    12 28135\n#&gt;  6     6 28243\n#&gt;  7     4 28330\n#&gt;  8     5 28796\n#&gt;  9     3 28834\n#&gt; 10    10 28889\n#&gt; 11     8 29327\n#&gt; 12     7 29425\n\n\n\nflights %&gt;%\n  count(month) %&gt;%\n  arrange(n)\n\n\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\n\n#&gt; # A tibble: 3 × 2\n#&gt;   origin distance_moyenne\n#&gt;   &lt;chr&gt;             &lt;dbl&gt;\n#&gt; 1 EWR               1057.\n#&gt; 2 JFK               1266.\n#&gt; 3 LGA                780.\n\n\n\nflights %&gt;%\n  group_by(origin) %&gt;%\n  summarise(distance_moyenne = mean(distance))\n\n\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\n\n#&gt; # A tibble: 12 × 2\n#&gt;    month     n\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1  1159\n#&gt;  2     2  1030\n#&gt;  3     3  1178\n#&gt;  4     4  1382\n#&gt;  5     5  1453\n#&gt;  6     6  1430\n#&gt;  7     7  1500\n#&gt;  8     8  1505\n#&gt;  9     9  1384\n#&gt; 10    10  1409\n#&gt; 11    11  1336\n#&gt; 12    12  1408\n\n\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  count(month)\n\n\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\n\n#&gt; # A tibble: 1,113 × 3\n#&gt;    month dest      n\n#&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n#&gt;  1     1 ALB      64\n#&gt;  2     1 ATL    1396\n#&gt;  3     1 AUS     169\n#&gt;  4     1 AVL       2\n#&gt;  5     1 BDL      37\n#&gt;  6     1 BHM      25\n#&gt;  7     1 BNA     399\n#&gt;  8     1 BOS    1245\n#&gt;  9     1 BQN      93\n#&gt; 10     1 BTV     223\n#&gt; # … with 1,103 more rows\n\n\n\nflights %&gt;%\n  count(month, dest)\n\n\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\n\n#&gt; # A tibble: 12 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month dest      n\n#&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n#&gt;  1     1 ATL    1396\n#&gt;  2     2 ATL    1267\n#&gt;  3     3 ATL    1448\n#&gt;  4     4 ATL    1490\n#&gt;  5     5 ORD    1582\n#&gt;  6     6 ORD    1547\n#&gt;  7     7 ORD    1573\n#&gt;  8     8 ORD    1604\n#&gt;  9     9 ORD    1582\n#&gt; 10    10 ORD    1604\n#&gt; 11    11 ATL    1384\n#&gt; 12    12 ATL    1463\n\n\n\nflights %&gt;%\n  count(month, dest) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(n)\n\n\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\n\n#&gt; # A tibble: 12 × 3\n#&gt;    month     n pourcentage\n#&gt;    &lt;int&gt; &lt;int&gt;       &lt;dbl&gt;\n#&gt;  1     1 27004        8.02\n#&gt;  2     2 24951        7.41\n#&gt;  3     3 28834        8.56\n#&gt;  4     4 28330        8.41\n#&gt;  5     5 28796        8.55\n#&gt;  6     6 28243        8.39\n#&gt;  7     7 29425        8.74\n#&gt;  8     8 29327        8.71\n#&gt;  9     9 27574        8.19\n#&gt; 10    10 28889        8.58\n#&gt; 11    11 27268        8.10\n#&gt; 12    12 28135        8.35\n\n\n\nflights %&gt;%\n  count(month) %&gt;%\n  mutate(pourcentage = n / sum(n) * 100)\n\n\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue.\n\n#&gt; `summarise()` has grouped output by 'origin'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 3 × 3\n#&gt; # Groups:   origin [3]\n#&gt;   origin dest  duree_moyenne\n#&gt;   &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n#&gt; 1 EWR    HNL            612.\n#&gt; 2 JFK    HNL            623.\n#&gt; 3 LGA    DEN            228.\n\n\n\nflights %&gt;%\n  group_by(origin, dest) %&gt;%\n  summarise(duree_moyenne = mean(air_time, na.rm = TRUE)) %&gt;%\n  # Le group_by suivant n'est pas obligatoire\n  group_by(origin) %&gt;%\n  slice_max(duree_moyenne)\n\n\n\n\n10.8.4 Jointures\nExercice 4.1\nFaire la jointure de la table airlines sur la table flights à l’aide de left_join.\n\n#&gt; # A tibble: 336,776 × 20\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      544        545      -1    1004    1022     -18 B6     \n#&gt;  5  2013     1     1      554        600      -6     812     837     -25 DL     \n#&gt;  6  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  7  2013     1     1      555        600      -5     913     854      19 B6     \n#&gt;  8  2013     1     1      557        600      -3     709     723     -14 EV     \n#&gt;  9  2013     1     1      557        600      -3     838     846      -8 B6     \n#&gt; 10  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt; # … with 336,766 more rows, 10 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, name &lt;chr&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nflights %&gt;%\n  left_join(airlines)\n\n\nExercice 4.2\nÀ partir de la table résultat de l’exercice précédent, calculer le retard moyen au départ pour chaque compagnie, et trier selon ce retard décroissant.\n\n#&gt; # A tibble: 16 × 2\n#&gt;    name                        retard_moyen\n#&gt;    &lt;chr&gt;                              &lt;dbl&gt;\n#&gt;  1 Frontier Airlines Inc.             20.2 \n#&gt;  2 ExpressJet Airlines Inc.           20.0 \n#&gt;  3 Mesa Airlines Inc.                 19.0 \n#&gt;  4 AirTran Airways Corporation        18.7 \n#&gt;  5 Southwest Airlines Co.             17.7 \n#&gt;  6 Endeavor Air Inc.                  16.7 \n#&gt;  7 JetBlue Airways                    13.0 \n#&gt;  8 Virgin America                     12.9 \n#&gt;  9 SkyWest Airlines Inc.              12.6 \n#&gt; 10 United Air Lines Inc.              12.1 \n#&gt; 11 Envoy Air                          10.6 \n#&gt; 12 Delta Air Lines Inc.                9.26\n#&gt; 13 American Airlines Inc.              8.59\n#&gt; 14 Alaska Airlines Inc.                5.80\n#&gt; 15 Hawaiian Airlines Inc.              4.90\n#&gt; 16 US Airways Inc.                     3.78\n\n\n\nflights %&gt;%\n  left_join(airlines) %&gt;%\n  group_by(name) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n\nExercice 4.3\nFaire la jointure de la table airports sur la table flights en utilisant comme clé le code de l’aéroport de destination.\n\n#&gt; # A tibble: 336,776 × 26\n#&gt;     year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;      &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;  \n#&gt;  1  2013     1     1      517        515       2     830     819      11 UA     \n#&gt;  2  2013     1     1      533        529       4     850     830      20 UA     \n#&gt;  3  2013     1     1      542        540       2     923     850      33 AA     \n#&gt;  4  2013     1     1      544        545      -1    1004    1022     -18 B6     \n#&gt;  5  2013     1     1      554        600      -6     812     837     -25 DL     \n#&gt;  6  2013     1     1      554        558      -4     740     728      12 UA     \n#&gt;  7  2013     1     1      555        600      -5     913     854      19 B6     \n#&gt;  8  2013     1     1      557        600      -3     709     723     -14 EV     \n#&gt;  9  2013     1     1      557        600      -3     838     846      -8 B6     \n#&gt; 10  2013     1     1      558        600      -2     753     745       8 AA     \n#&gt; # … with 336,766 more rows, 16 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;,\n#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,\n#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, name &lt;chr&gt;, lat &lt;dbl&gt;, lon &lt;dbl&gt;,\n#&gt; #   alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;, and abbreviated variable names\n#&gt; #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n\nflights %&gt;%\n  left_join(airports, by = c(\"dest\" = \"faa\"))\n\n\nÀ partir de cette table, afficher pour chaque mois le nom de l’aéroport de destination ayant eu le plus petit nombre de vol.\n\n#&gt; # A tibble: 14 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month name                      n\n#&gt;    &lt;int&gt; &lt;chr&gt;                 &lt;int&gt;\n#&gt;  1     1 Key West Intl             1\n#&gt;  2     2 Jackson Hole Airport      3\n#&gt;  3     3 Bangor Intl               2\n#&gt;  4     4 Key West Intl             1\n#&gt;  5     4 Myrtle Beach Intl         1\n#&gt;  6     5 Columbia Metropolitan     9\n#&gt;  7     6 Myrtle Beach Intl         1\n#&gt;  8     7 La Guardia                1\n#&gt;  9     8 South Bend Rgnl           1\n#&gt; 10     9 South Bend Rgnl           5\n#&gt; 11    10 Albany Intl               1\n#&gt; 12    10 South Bend Rgnl           1\n#&gt; 13    11 Blue Grass                1\n#&gt; 14    12 South Bend Rgnl           1\n\n\n\nflights %&gt;%\n  left_join(airports, by = c(\"dest\" = \"faa\")) %&gt;%\n  count(month, name) %&gt;%\n  group_by(month) %&gt;%\n  slice_min(n)\n\n\nExercice 4.4\nCréer une table indiquant, pour chaque vol, uniquement le nom de l’aéroport de départ et celui de l’aéroport d’arrivée.\n\n#&gt; # A tibble: 336,776 × 2\n#&gt;    orig_name           dest_name                      \n#&gt;    &lt;chr&gt;               &lt;chr&gt;                          \n#&gt;  1 Newark Liberty Intl George Bush Intercontinental   \n#&gt;  2 La Guardia          George Bush Intercontinental   \n#&gt;  3 John F Kennedy Intl Miami Intl                     \n#&gt;  4 John F Kennedy Intl &lt;NA&gt;                           \n#&gt;  5 La Guardia          Hartsfield Jackson Atlanta Intl\n#&gt;  6 Newark Liberty Intl Chicago Ohare Intl             \n#&gt;  7 Newark Liberty Intl Fort Lauderdale Hollywood Intl \n#&gt;  8 La Guardia          Washington Dulles Intl         \n#&gt;  9 John F Kennedy Intl Orlando Intl                   \n#&gt; 10 La Guardia          Chicago Ohare Intl             \n#&gt; # … with 336,766 more rows\n\n\n\nflights %&gt;%\n  left_join(airports, by = c(\"dest\" = \"faa\")) %&gt;%\n  rename(dest_name = name) %&gt;%\n  left_join(airports, by = c(\"origin\" = \"faa\")) %&gt;%\n  rename(orig_name = name) %&gt;%\n  select(orig_name, dest_name)\n\n\n\n\n10.8.5 Bonus\nExercice 5.1\nCalculer le nombre de vols selon l’aéroport de destination, et fusionnez la table airports sur le résultat avec left_join. Stocker le résultat final dans un objet nommé flights_dest.\n\n\nflights_dest &lt;- flights %&gt;%\n  count(dest) %&gt;%\n  left_join(airports, by = c(\"dest\"=\"faa\"))\n\n\nCréez une carte interactive des résultats avec le package leaflet et le code suivant :\n\nlibrary(leaflet)\nleaflet(data = flights_dest) %&gt;%\n  addTiles %&gt;%\n  addCircles(lng = ~lon, lat = ~lat, radius = ~n * 10, popup = ~name)\n\n\n#&gt; Warning in validateCoords(lng, lat, funcName): Data contains 4 rows with either\n#&gt; missing or invalid lat/lon values and will be ignored"
  },
  {
    "objectID": "10-dplyr.html#footnotes",
    "href": "10-dplyr.html#footnotes",
    "title": "10  Manipuler les données avec dplyr",
    "section": "",
    "text": "À noter que cette opération est un peu plus “fragile” que les autres, car si l’ordre des colonnes change elle peut renvoyer un résultat différent.↩︎\nIl est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎\nLe pipe a été introduit à l’origine par l’extension magrittr, et repris par dplyr↩︎"
  },
  {
    "objectID": "11-stringr.html#expressions-régulières",
    "href": "11-stringr.html#expressions-régulières",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.1 Expressions régulières",
    "text": "11.1 Expressions régulières\nLes fonctions présentées ci-dessous sont pour la plupart prévues pour fonctionner avec des expressions régulières. Celles-ci constituent un mini-langage, qui peut paraître assez cryptique, mais qui est très puissant pour spécifier des motifs de chaînes de caractères.\nElles permettent par exemple de sélectionner le dernier mot avant la fin d’une chaîne, l’ensemble des suites alphanumériques commençant par une majuscule, des nombres de 3 ou 4 chiffres situés en début de chaîne, et beaucoup beaucoup d’autres choses encore bien plus complexes.\nPour donner un exemple concret, l’expression régulière suivante permet de détecter une adresse de courrier électronique1 :\n[\\w\\d+.-_]+@[\\w\\d.-]+\\.[a-zA-Z]{2,}\nPar souci de simplicité, dans ce qui suit les exemples seront donnés autant que possible avec de simples chaînes de caractères, sans expression régulière. Mais si vous pensez manipuler des données textuelles, il peut être très utile de s’intéresser à cette syntaxe."
  },
  {
    "objectID": "11-stringr.html#sec-concat",
    "href": "11-stringr.html#sec-concat",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.2 Concaténer des chaînes",
    "text": "11.2 Concaténer des chaînes\nLa première opération de base consiste à concaténer des chaînes de caractères entre elles. On peut le faire avec la fonction paste.\nPar exemple, si on veut concaténer l’adresse et la ville :\n\npaste(d$adresse, d$ville)\n#&gt; [1] \"3 rue des Fleurs Nouméa\"              \n#&gt; [2] \"47 ave de la Libération Marseille\"    \n#&gt; [3] \"12 rue du 17 octobre 1961 Vénissieux\" \n#&gt; [4] \"221 avenue de la Libération Marseille\"\n\nPar défaut, paste concatène en ajoutant un espace entre les différentes chaînes. On peut spécifier un autre séparateur avec son argument sep :\n\npaste(d$adresse, d$ville, sep = \" - \")\n#&gt; [1] \"3 rue des Fleurs - Nouméa\"              \n#&gt; [2] \"47 ave de la Libération - Marseille\"    \n#&gt; [3] \"12 rue du 17 octobre 1961 - Vénissieux\" \n#&gt; [4] \"221 avenue de la Libération - Marseille\"\n\nIl existe une variante, paste0, qui concatène sans mettre de séparateur, et qui est légèrement plus rapide :\n\npaste0(d$adresse, d$ville)\n#&gt; [1] \"3 rue des FleursNouméa\"              \n#&gt; [2] \"47 ave de la LibérationMarseille\"    \n#&gt; [3] \"12 rue du 17 octobre 1961Vénissieux\" \n#&gt; [4] \"221 avenue de la LibérationMarseille\"\n\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que paste et paste0 sont des fonctions R de base. L’équivalent pour stringr se nomme str_c.\n\n\nParfois on cherche à concaténer les différents éléments d’un vecteur non pas avec ceux d’un autre vecteur, comme on l’a fait précédemment, mais entre eux. Dans ce cas paste seule ne fera rien :\n\npaste(d$ville)\n#&gt; [1] \"Nouméa\"     \"Marseille\"  \"Vénissieux\" \"Marseille\"\n\nIl faut lui ajouter un argument collapse, avec comme valeur la chaîne à utiliser pour concaténer les éléments :\n\npaste(d$ville, collapse = \", \")\n#&gt; [1] \"Nouméa, Marseille, Vénissieux, Marseille\""
  },
  {
    "objectID": "11-stringr.html#convertir-en-majuscules-minuscules",
    "href": "11-stringr.html#convertir-en-majuscules-minuscules",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.3 Convertir en majuscules / minuscules",
    "text": "11.3 Convertir en majuscules / minuscules\nLes fonctions str_to_lower, str_to_upper et str_to_title permettent respectivement de mettre en minuscules, mettre en majuscules, ou de capitaliser les éléments d’un vecteur de chaînes de caractères :\n\nstr_to_lower(d$nom)\n#&gt; [1] \"mr félicien machin\"  \"mme raymonde bidule\" \"m. martial truc\"    \n#&gt; [4] \"mme huguette chose\"\n\n\nstr_to_upper(d$nom)\n#&gt; [1] \"MR FÉLICIEN MACHIN\"  \"MME RAYMONDE BIDULE\" \"M. MARTIAL TRUC\"    \n#&gt; [4] \"MME HUGUETTE CHOSE\"\n\n\nstr_to_title(d$nom)\n#&gt; [1] \"Mr Félicien Machin\"  \"Mme Raymonde Bidule\" \"M. Martial Truc\"    \n#&gt; [4] \"Mme Huguette Chose\""
  },
  {
    "objectID": "11-stringr.html#découper-des-chaînes",
    "href": "11-stringr.html#découper-des-chaînes",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.4 Découper des chaînes",
    "text": "11.4 Découper des chaînes\nLa fonction str_split permet de “découper” une chaîne de caractère en fonction d’un délimiteur. On passe la chaîne en premier argument, et le délimiteur en second :\n\nstr_split(\"un-deux-trois\", \"-\")\n#&gt; [[1]]\n#&gt; [1] \"un\"    \"deux\"  \"trois\"\n\nOn peut appliquer la fonction à un vecteur, dans ce cas le résultat sera une liste :\n\nstr_split(d$nom, \" \")\n#&gt; [[1]]\n#&gt; [1] \"Mr\"       \"Félicien\" \"Machin\"  \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"Mme\"      \"Raymonde\" \"Bidule\"  \n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"M.\"      \"Martial\" \"Truc\"   \n#&gt; \n#&gt; [[4]]\n#&gt; [1] \"Mme\"      \"Huguette\" \"Chose\"\n\nOu un tableau (plus précisément une matrice) si on ajoute simplify = TRUE.\n\nstr_split(d$nom, \" \", simplify = TRUE)\n#&gt;      [,1]  [,2]       [,3]    \n#&gt; [1,] \"Mr\"  \"Félicien\" \"Machin\"\n#&gt; [2,] \"Mme\" \"Raymonde\" \"Bidule\"\n#&gt; [3,] \"M.\"  \"Martial\"  \"Truc\"  \n#&gt; [4,] \"Mme\" \"Huguette\" \"Chose\"\n\nSi on souhaite créer de nouvelles colonnes dans un tableau de données en découpant une colonne de type texte, on pourra utiliser la fonction separate de l’extension tidyr. Celle-ci est expliquée Section 12.3.3.\nVoici juste un exemple de son utilisation :\n\nlibrary(tidyr)\nd %&gt;% separate(nom, c(\"genre\", \"prenom\", \"nom\"), sep = \" \")\n#&gt; # A tibble: 4 × 5\n#&gt;   genre prenom   nom    adresse                     ville     \n#&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                       &lt;chr&gt;     \n#&gt; 1 Mr    Félicien Machin 3 rue des Fleurs            Nouméa    \n#&gt; 2 Mme   Raymonde Bidule 47 ave de la Libération     Marseille \n#&gt; 3 M.    Martial  Truc   12 rue du 17 octobre 1961   Vénissieux\n#&gt; 4 Mme   Huguette Chose  221 avenue de la Libération Marseille"
  },
  {
    "objectID": "11-stringr.html#extraire-des-sous-chaînes-par-position",
    "href": "11-stringr.html#extraire-des-sous-chaînes-par-position",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.5 Extraire des sous-chaînes par position",
    "text": "11.5 Extraire des sous-chaînes par position\nLa fonction str_sub permet d’extraire des sous-chaînes par position, en indiquant simplement les positions des premier et dernier caractères :\n\nstr_sub(d$ville, 1, 3)\n#&gt; [1] \"Nou\" \"Mar\" \"Vén\" \"Mar\""
  },
  {
    "objectID": "11-stringr.html#sec-str-detect",
    "href": "11-stringr.html#sec-str-detect",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.6 Détecter des motifs",
    "text": "11.6 Détecter des motifs\nstr_detect permet de détecter la présence d’un motif parmi les élements d’un vecteur. Par exemple, si on souhaite identifier toutes les adresses contenant “Libération” :\n\nstr_detect(d$adresse, \"Libération\")\n#&gt; [1] FALSE  TRUE FALSE  TRUE\n\nstr_detect renvoie un vecteur de valeurs logiques et peut donc être utilisée, par exemple, avec le verbe filter de dplyr pour extraire des sous-populations.\nUne variante, str_count, compte le nombre d’occurrences d’une chaîne pour chaque élément d’un vecteur :\n\nstr_count(d$ville, \"s\")\n#&gt; [1] 0 1 2 1\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention, les fonctions de stringr étant prévues pour fonctionner avec des expressions régulières, certains caractères n’auront pas le sens habituel dans la chaîne indiquant le motif à rechercher. Par exemple, le . ne sera pas un point mais le symbole représentant “n’importe quel caractère”.\nLa section sur les modificateurs de motifs explique comment utiliser des chaîne “classiques” au lieu d’expressions régulières.\n\n\nOn peut aussi utiliser str_subset pour ne garder d’un vecteur que les éléments correspondant au motif :\n\nstr_subset(d$adresse, \"Libération\")\n#&gt; [1] \"47 ave de la Libération\"     \"221 avenue de la Libération\""
  },
  {
    "objectID": "11-stringr.html#extraire-des-motifs",
    "href": "11-stringr.html#extraire-des-motifs",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.7 Extraire des motifs",
    "text": "11.7 Extraire des motifs\nstr_extract permet d’extraire les valeurs correspondant à un motif. Si on lui passe comme motif une chaîne de caractère, cela aura peu d’intérêt :\n\nstr_extract(d$adresse, \"Libération\")\n#&gt; [1] NA           \"Libération\" NA           \"Libération\"\n\nC’est tout de suite plus intéressant si on utilise des expressions régulières. Par exemple la commande suivante permet d’isoler les numéros de rue.\n\nstr_extract(d$adresse, \"^\\\\d+\")\n#&gt; [1] \"3\"   \"47\"  \"12\"  \"221\"\n\nstr_extract ne récupère que la première occurrence du motif. Si on veut toutes les extraire on peut utiliser str_extract_all. Ainsi, si on veut extraire l’ensemble des nombres présents dans les adresses :\n\nstr_extract_all(d$adresse, \"\\\\d+\")\n#&gt; [[1]]\n#&gt; [1] \"3\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"47\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"12\"   \"17\"   \"1961\"\n#&gt; \n#&gt; [[4]]\n#&gt; [1] \"221\"\n\n\n\n\n\n\n\nNote\n\n\n\nSi on veut faire de l’extraction de groupes dans des expressions régulières (identifiés avec des parenthèses), on pourra utiliser str_match.\n\n\nÀ noter que si on souhaite extraire des valeurs d’une colonne texte d’un tableau de données pour créer de nouvelles variables, on pourra utiliser la fonction extract de l’extension tidyr, décrite Section 12.3.6.\nPar exemple :\n\nlibrary(tidyr)\nd %&gt;% extract(adresse, \"type_rue\", \"^\\\\d+ (.*?) \", remove = FALSE)\n#&gt; # A tibble: 4 × 4\n#&gt;   nom                 adresse                     type_rue ville     \n#&gt;   &lt;chr&gt;               &lt;chr&gt;                       &lt;chr&gt;    &lt;chr&gt;     \n#&gt; 1 Mr Félicien Machin  3 rue des Fleurs            rue      Nouméa    \n#&gt; 2 Mme Raymonde Bidule 47 ave de la Libération     ave      Marseille \n#&gt; 3 M. Martial Truc     12 rue du 17 octobre 1961   rue      Vénissieux\n#&gt; 4 Mme Huguette Chose  221 avenue de la Libération avenue   Marseille"
  },
  {
    "objectID": "11-stringr.html#remplacer-des-motifs",
    "href": "11-stringr.html#remplacer-des-motifs",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.8 Remplacer des motifs",
    "text": "11.8 Remplacer des motifs\nLa fonction str_replace_all permet de remplacer une chaîne ou un motif par une autre.\nPar exemple, on peut remplacer les occurrence de “Mr” par “M.” dans notre variable nom :\n\nstr_replace_all(d$nom, \"Mr\", \"M.\")\n#&gt; [1] \"M. Félicien Machin\"  \"Mme Raymonde Bidule\" \"M. Martial Truc\"    \n#&gt; [4] \"Mme Huguette Chose\"\n\nOn peut également spécifier plusieurs remplacements en une seule fois :\n\nstr_replace_all(\n    d$adresse,\n    c(\"avenue\" = \"Avenue\", \"ave\" = \"Avenue\", \"rue\" = \"Rue\")\n)\n#&gt; [1] \"3 Rue des Fleurs\"            \"47 Avenue de la Libération\" \n#&gt; [3] \"12 Rue du 17 octobre 1961\"   \"221 Avenue de la Libération\""
  },
  {
    "objectID": "11-stringr.html#sec-modificateurs",
    "href": "11-stringr.html#sec-modificateurs",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.9 Modificateurs de motifs",
    "text": "11.9 Modificateurs de motifs\nPar défaut, les motifs passés aux fonctions comme str_detect, str_extract ou str_replace sont des expressions régulières classiques.\nOn peut spécifier qu’un motif n’est pas une expression régulière mais une chaîne de caractères normale en lui appliquant la fonction fixed. Par exemple, si on veut compter le nombre de points dans les noms de notre tableau, le paramétrage par défaut ne fonctionnera pas car dans une expression régulière le . est un symbole signifiant “n’importe quel caractère” :\n\nstr_count(d$nom, \".\")\n#&gt; [1] 18 19 15 18\n\nIl faut donc spécifier que notre point est bien un point avec fixed :\n\nstr_count(d$nom, fixed(\".\"))\n#&gt; [1] 0 0 1 0\n\nOn peut aussi modifier le comportement des expressions régulières à l’aide de la fonction regex. On peut ainsi rendre les motifs insensibles à la casse avec ignore_case :\n\nstr_detect(d$nom, \"mme\")\n#&gt; [1] FALSE FALSE FALSE FALSE\n\n\nstr_detect(d$nom, regex(\"mme\", ignore_case = TRUE))\n#&gt; [1] FALSE  TRUE FALSE  TRUE\n\nOn peut également permettre aux regex d’être multilignes avec l’option multiline = TRUE, etc."
  },
  {
    "objectID": "11-stringr.html#ressources",
    "href": "11-stringr.html#ressources",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.10 Ressources",
    "text": "11.10 Ressources\nL’ouvrage R for Data Science, accessible en ligne, contient un chapitre entier sur les chaînes de caractères et les expressions régulières (en anglais).\nLe site officiel de stringr contient une liste des fonctions et les pages d’aide associées, ainsi qu’un article dédié aux expressions régulières.\nPour des besoins plus pointus, on pourra aussi utiliser l’extension stringi sur laquelle est elle-même basée stringr."
  },
  {
    "objectID": "11-stringr.html#exercices",
    "href": "11-stringr.html#exercices",
    "title": "11  Manipuler du texte avec stringr",
    "section": "11.11 Exercices",
    "text": "11.11 Exercices\nDans ces exercices on utilise un tableau d, généré par le code suivant :\n\nd &lt;- tibble(\n  nom = c(\"M. rené Bézigue\", \"Mme Paulette fouchin\", \"Mme yvonne duluc\", \"M. Jean-Yves Pernoud\"),\n  naissance = c(\"18/04/1937 Vesoul\", \"En 1947 à Grenoble (38)\", \"Le 5 mars 1931 à Bar-le-Duc\", \"Marseille, juin 1938\"),\n  profession = c(\"Ouvrier agric\", \"ouvrière qualifiée\", \"Institutrice\", \"Exploitant agric\")\n)\n\n\n\n\n\n\nnom\nnaissance\nprofession\n\n\n\n\nM. rené Bézigue\n18/04/1937 Vesoul\nOuvrier agric\n\n\nMme Paulette fouchin\nEn 1947 à Grenoble (38)\nouvrière qualifiée\n\n\nMme yvonne duluc\nLe 5 mars 1931 à Bar-le-Duc\nInstitutrice\n\n\nM. Jean-Yves Pernoud\nMarseille, juin 1938\nExploitant agric\n\n\n\n\n\nExercice 1\nCapitalisez les noms des personnes avec str_to_title :\n\n#&gt; [1] \"M. René Bézigue\"      \"Mme Paulette Fouchin\" \"Mme Yvonne Duluc\"    \n#&gt; [4] \"M. Jean-Yves Pernoud\"\n\n\n\nstr_to_title(d$nom)\n\n\nExercice 2\nDans la variable profession, remplacer toutes les occurrences de l’abbréviation “agric” par “agricole” :\n\n#&gt; [1] \"Ouvrier agricole\"    \"ouvrière qualifiée\"  \"Institutrice\"       \n#&gt; [4] \"Exploitant agricole\"\n\n\n\nstr_replace(d$profession, \"agric\", \"agricole\")\n\n\nExercice 3\nÀ l’aide de str_detect, identifier les personnes de catégorie professionnelle “Ouvrier”. Indication : pensez au modificateur ignore_case.\n\n#&gt; [1]  TRUE  TRUE FALSE FALSE\n\n\n\nstr_detect(d$profession, regex(\"Ouvr\", ignore_case = TRUE))\n\n\nExercice 4\nÀ l’aide de case_when et de str_detect, créer une nouvelle variable sexe identifiant le sexe de chaque personne en fonction de la présence de M. ou de Mme dans son nom.\n\n#&gt; # A tibble: 4 × 4\n#&gt;   nom                  naissance                   profession         sexe \n#&gt;   &lt;chr&gt;                &lt;chr&gt;                       &lt;chr&gt;              &lt;chr&gt;\n#&gt; 1 M. rené Bézigue      18/04/1937 Vesoul           Ouvrier agric      Homme\n#&gt; 2 Mme Paulette fouchin En 1947 à Grenoble (38)     ouvrière qualifiée Femme\n#&gt; 3 Mme yvonne duluc     Le 5 mars 1931 à Bar-le-Duc Institutrice       Femme\n#&gt; 4 M. Jean-Yves Pernoud Marseille, juin 1938        Exploitant agric   Homme\n\n\n\nd %&gt;%\n  mutate(sexe = case_when(\n          str_detect(nom, fixed(\"Mme\")) ~ \"Femme\",\n          str_detect(nom, fixed(\"M.\")) ~ \"Homme\"\n      )\n  )\n\n\nExercice 5\nExtraire l’année de naissance de chaque individu avec str_extract. Vous pouvez utiliser le regex \"\\\\d\\\\d\\\\d\\\\d\" qui permet d’identifier les nombres de quatre chiffres.\nVous devez obtenir le vecteur suivant :\n\n#&gt; [1] \"1937\" \"1947\" \"1931\" \"1938\"\n\n\n\nstr_extract(d$naissance, \"\\\\d\\\\d\\\\d\\\\d\")\n\n\nÀ l’aide de la fonction extract de l’extension tidyr et du regex précédent, créez une nouvelle variable annee dans le tableau, qui contient l’année de naissance (pour plus d’informations sur extract, voir Section 12.3.6).\n\n#&gt; # A tibble: 4 × 4\n#&gt;   nom                  naissance                   annee profession        \n#&gt;   &lt;chr&gt;                &lt;chr&gt;                       &lt;chr&gt; &lt;chr&gt;             \n#&gt; 1 M. rené Bézigue      18/04/1937 Vesoul           1937  Ouvrier agric     \n#&gt; 2 Mme Paulette fouchin En 1947 à Grenoble (38)     1947  ouvrière qualifiée\n#&gt; 3 Mme yvonne duluc     Le 5 mars 1931 à Bar-le-Duc 1931  Institutrice      \n#&gt; 4 M. Jean-Yves Pernoud Marseille, juin 1938        1938  Exploitant agric\n\n\n\nlibrary(tidyr)\nd %&gt;%\n    extract(\n        naissance,\n        \"annee\",\n        \"(\\\\d\\\\d\\\\d\\\\d)\",\n        remove = FALSE\n    )"
  },
  {
    "objectID": "11-stringr.html#footnotes",
    "href": "11-stringr.html#footnotes",
    "title": "11  Manipuler du texte avec stringr",
    "section": "",
    "text": "Il s’agit en fait d’une version très simplifiée, la “véritable” expression permettant de tester si une adresse mail est valide fait plus de 80 lignes…↩︎"
  },
  {
    "objectID": "12-tidyr.html#tidy-data",
    "href": "12-tidyr.html#tidy-data",
    "title": "12  Mettre en ordre avec tidyr",
    "section": "12.1 Tidy data",
    "text": "12.1 Tidy data\nComme indiqué Section 6.3, les extensions du tidyverse comme dplyr ou ggplot2 partent du principe que les données sont “bien rangées” sous forme de tidy data.\nPrenons un exemple avec les données suivantes, qui indique la population de trois pays pour quatre années différentes :\n\n\n\n\n\ncountry\n1992\n1997\n2002\n2007\n\n\n\n\nBelgium\n10045622\n10199787\n10311970\n10392226\n\n\nFrance\n57374179\n58623428\n59925035\n61083916\n\n\nGermany\n80597764\n82011073\n82350671\n82400996\n\n\n\n\n\nImaginons qu’on souhaite représenter avec ggplot2 l’évolution de la population pour chaque pays sous forme de lignes : c’est impossible avec les données sous ce format. On a besoin d’arranger le tableau de la manière suivante :\n\n\n\n\n\ncountry\nannee\npopulation\n\n\n\n\nBelgium\n1992\n10045622\n\n\nBelgium\n1997\n10199787\n\n\nBelgium\n2002\n10311970\n\n\nBelgium\n2007\n10392226\n\n\nFrance\n1992\n57374179\n\n\nFrance\n1997\n58623428\n\n\nFrance\n2002\n59925035\n\n\nFrance\n2007\n61083916\n\n\nGermany\n1992\n80597764\n\n\nGermany\n1997\n82011073\n\n\nGermany\n2002\n82350671\n\n\nGermany\n2007\n82400996\n\n\n\n\n\nC’est seulement avec les données dans ce format qu’on peut réaliser le graphique :\n\nggplot(d) +\n  geom_line(aes(x = annee, y = population, color = country)) +\n  scale_x_continuous(breaks = unique(d$annee))\n\n\n\n\nC’est la même chose pour dplyr, par exemple si on voulait calculer la population minimale pour chaque pays avec summarise :\n\nd %&gt;%\n  group_by(country) %&gt;%\n  summarise(pop_min = min(population))\n#&gt; # A tibble: 3 × 2\n#&gt;   country  pop_min\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Belgium 10045622\n#&gt; 2 France  57374179\n#&gt; 3 Germany 80597764"
  },
  {
    "objectID": "12-tidyr.html#trois-règles-pour-des-données-bien-rangées",
    "href": "12-tidyr.html#trois-règles-pour-des-données-bien-rangées",
    "title": "12  Mettre en ordre avec tidyr",
    "section": "12.2 Trois règles pour des données bien rangées",
    "text": "12.2 Trois règles pour des données bien rangées\nLe concept de tidy data repose sur trois règles interdépendantes. Des données sont considérées comme tidy si :\n\nchaque ligne correspond à une observation\nchaque colonne correspond à une variable\nchaque valeur est présente dans une unique case de la table ou, de manière équivalente, des unités d’observations différentes sont présentes dans des tables différentes\n\nCes règles ne sont pas forcément très intuitives. De plus, il y a une infinité de manières pour un tableau de données de ne pas être tidy.\nPrenons par exemple les règles 1 et 2 et le tableau de notre premier exemple :\n\n\n\n\n\ncountry\n1992\n1997\n2002\n2007\n\n\n\n\nBelgium\n10045622\n10199787\n10311970\n10392226\n\n\nFrance\n57374179\n58623428\n59925035\n61083916\n\n\nGermany\n80597764\n82011073\n82350671\n82400996\n\n\n\n\n\nPourquoi ce tableau n’est pas tidy ? Parce que si on essaie d’identifier les variables mesurées dans le tableau, il y en a trois : le pays, l’année et la population. Or elles ne correspondent pas aux colonnes de la table. C’est le cas par contre pour la table transformée :\n\n\n\n\n\ncountry\nannee\npopulation\n\n\n\n\nBelgium\n1992\n10045622\n\n\nBelgium\n1997\n10199787\n\n\nBelgium\n2002\n10311970\n\n\nBelgium\n2007\n10392226\n\n\nFrance\n1992\n57374179\n\n\nFrance\n1997\n58623428\n\n\nFrance\n2002\n59925035\n\n\nFrance\n2007\n61083916\n\n\nGermany\n1992\n80597764\n\n\nGermany\n1997\n82011073\n\n\nGermany\n2002\n82350671\n\n\nGermany\n2007\n82400996\n\n\n\n\n\nOn peut remarquer qu’en modifiant notre table pour satisfaire à la deuxième règle, on a aussi réglé la première : chaque ligne correspond désormais à une observation, en l’occurrence l’observation de trois pays à plusieurs moments dans le temps. Dans notre table d’origine, chaque ligne comportait en réalité quatre observations différentes.\nCe point permet d’illustrer le fait que les règles sont interdépendantes.\nAutre exemple, généré depuis le jeu de données nycflights13, permettant cette fois d’illustrer la troisième règle :\n\n\n\n\n\nyear\nmonth\nday\ndep_time\ncarrier\nname\n\n\n\n\n2013\n1\n1\n517\nUA\nUnited Air Lines Inc.\n\n\n2013\n1\n1\n533\nUA\nUnited Air Lines Inc.\n\n\n2013\n1\n1\n542\nAA\nAmerican Airlines Inc.\n\n\n2013\n1\n1\n554\nUA\nUnited Air Lines Inc.\n\n\n2013\n1\n1\n558\nAA\nAmerican Airlines Inc.\n\n\n2013\n1\n1\n558\nUA\nUnited Air Lines Inc.\n\n\n2013\n1\n1\n558\nUA\nUnited Air Lines Inc.\n\n\n2013\n1\n1\n559\nAA\nAmerican Airlines Inc.\n\n\n\n\n\nDans ce tableau on a bien une observation par ligne (un vol), et une variable par colonne. Mais on a une “infraction” à la troisième règle, qui est que chaque valeur doit être présente dans une unique case : si on regarde la colonne name, on a en effet une duplication de l’information concernant le nom des compagnies aériennes. Notre tableau mêle en fait deux types d’observations différents : des observations sur les vols, et des observations sur les compagnies aériennes.\nPour “arranger” ce tableau, il faut séparer les deux types d’observations en deux tables différentes :\n\n\n\n\n\nyear\nmonth\nday\ndep_time\ncarrier\n\n\n\n\n2013\n1\n1\n517\nUA\n\n\n2013\n1\n1\n533\nUA\n\n\n2013\n1\n1\n542\nAA\n\n\n2013\n1\n1\n554\nUA\n\n\n2013\n1\n1\n558\nAA\n\n\n2013\n1\n1\n558\nUA\n\n\n2013\n1\n1\n558\nUA\n\n\n2013\n1\n1\n559\nAA\n\n\n\n\n\n\n\n\n\n\ncarrier\nname\n\n\n\n\nUA\nUnited Air Lines Inc.\n\n\nAA\nAmerican Airlines Inc.\n\n\n\n\n\nOn a désormais deux tables distinctes, l’information n’est pas dupliquée, et on peut facilement faire une jointure si on a besoin de récupérer l’information d’une table dans une autre."
  },
  {
    "objectID": "12-tidyr.html#les-verbes-de-tidyr",
    "href": "12-tidyr.html#les-verbes-de-tidyr",
    "title": "12  Mettre en ordre avec tidyr",
    "section": "12.3 Les verbes de tidyr",
    "text": "12.3 Les verbes de tidyr\nL’objectif de tidyr est de fournir des fonctions pour arranger ses données et les convertir dans un format tidy. Ces fonctions prennent la forme de verbes qui viennent compléter ceux de dplyr et s’intègrent parfaitement dans les séries de pipes (%&gt;%), les pipelines, permettant d’enchaîner les opérations.\n\n12.3.1 pivot_longer : transformer des colonnes en lignes\nPrenons le tableau d suivant, qui liste la population de 6 pays en 2002 et 2007 :\n\n\n\n\n\ncountry\n2002\n2007\n\n\n\n\nBelgium\n10311970\n10392226\n\n\nFrance\n59925035\n61083916\n\n\nGermany\n82350671\n82400996\n\n\nItaly\n57926999\n58147733\n\n\nSpain\n40152517\n40448191\n\n\nSwitzerland\n7361757\n7554661\n\n\n\n\n\nDans ce tableau, une même variable (la population) est répartie sur plusieurs colonnes, chacune représentant une observation à un moment différent. On souhaite que la variable ne représente plus qu’une seule colonne, et que les observations soient réparties sur plusieurs lignes.\nPour cela on va utiliser la fonction pivot_longer1 :\n\nd %&gt;% pivot_longer(c(`2002`, `2007`))\n#&gt; # A tibble: 12 × 3\n#&gt;    country     name     value\n#&gt;    &lt;fct&gt;       &lt;chr&gt;    &lt;int&gt;\n#&gt;  1 Belgium     2002  10311970\n#&gt;  2 Belgium     2007  10392226\n#&gt;  3 France      2002  59925035\n#&gt;  4 France      2007  61083916\n#&gt;  5 Germany     2002  82350671\n#&gt;  6 Germany     2007  82400996\n#&gt;  7 Italy       2002  57926999\n#&gt;  8 Italy       2007  58147733\n#&gt;  9 Spain       2002  40152517\n#&gt; 10 Spain       2007  40448191\n#&gt; 11 Switzerland 2002   7361757\n#&gt; 12 Switzerland 2007   7554661\n\nLa fonction pivot_longer prend comme premier argument la liste des colonnes à rassembler (ici on a mis 2002 et 2007 entre backticks (`2002`) pour indiquer à pivot_longer qu’il s’agit d’un nom de colonne et pas d’un nombre). Ces colonnes peuvent être spécifiées avec la même syntaxe que celle de la fonction select de dplyr.\nPar exemple, il est parfois plus rapide d’indiquer à pivot_longer les colonnes qu’on ne souhaite pas “rassembler”. On peut le faire avec la syntaxe suivante :\n\nd %&gt;% pivot_longer(-country)\n#&gt; # A tibble: 12 × 3\n#&gt;    country     name     value\n#&gt;    &lt;fct&gt;       &lt;chr&gt;    &lt;int&gt;\n#&gt;  1 Belgium     2002  10311970\n#&gt;  2 Belgium     2007  10392226\n#&gt;  3 France      2002  59925035\n#&gt;  4 France      2007  61083916\n#&gt;  5 Germany     2002  82350671\n#&gt;  6 Germany     2007  82400996\n#&gt;  7 Italy       2002  57926999\n#&gt;  8 Italy       2007  58147733\n#&gt;  9 Spain       2002  40152517\n#&gt; 10 Spain       2007  40448191\n#&gt; 11 Switzerland 2002   7361757\n#&gt; 12 Switzerland 2007   7554661\n\nPar défaut, les colonnes qui contiennent les noms des colonnes d’origine et leurs valeurs sont nommées name et value. Si cela ne convient pas, on peut indiquer les noms à utiliser via les arguments names_to et values_to :\n\nd %&gt;% pivot_longer(\n    c(`2002`, `2007`), \n    names_to = \"annee\", \n    values_to = \"population\"\n)\n#&gt; # A tibble: 12 × 3\n#&gt;    country     annee population\n#&gt;    &lt;fct&gt;       &lt;chr&gt;      &lt;int&gt;\n#&gt;  1 Belgium     2002    10311970\n#&gt;  2 Belgium     2007    10392226\n#&gt;  3 France      2002    59925035\n#&gt;  4 France      2007    61083916\n#&gt;  5 Germany     2002    82350671\n#&gt;  6 Germany     2007    82400996\n#&gt;  7 Italy       2002    57926999\n#&gt;  8 Italy       2007    58147733\n#&gt;  9 Spain       2002    40152517\n#&gt; 10 Spain       2007    40448191\n#&gt; 11 Switzerland 2002     7361757\n#&gt; 12 Switzerland 2007     7554661\n\nAu final, la nom de pivot_longer s’explique par le fait qu’on fait “pivoter” notre tableau de départ d’un format “large” (avec plus de colonnes) vers un format “long” (avec plus de lignes).\n\n\n12.3.2 pivot_wider : transformer des lignes en colonnes\nLa fonction pivot_wider est l’inverse de pivot_longer.\nSoit le tableau d suivant :\n\n\n\n\n\ncountry\ncontinent\nyear\nvariable\nvalue\n\n\n\n\nBelgium\nEurope\n2002\nlifeExp\n78.320\n\n\nBelgium\nEurope\n2002\npop\n10311970.000\n\n\nBelgium\nEurope\n2007\nlifeExp\n79.441\n\n\nBelgium\nEurope\n2007\npop\n10392226.000\n\n\nFrance\nEurope\n2002\nlifeExp\n79.590\n\n\nFrance\nEurope\n2002\npop\n59925035.000\n\n\nFrance\nEurope\n2007\nlifeExp\n80.657\n\n\nFrance\nEurope\n2007\npop\n61083916.000\n\n\n\n\n\nCe tableau a le problème inverse du précédent : on a deux variables, lifeExp et pop qui, plutôt que d’être réparties en deux colonnes, sont réparties entre plusieurs lignes.\nOn va donc utiliser pivot_wider pour répartir ces lignes dans deux colonnes différentes :\n\nd %&gt;% pivot_wider(names_from = variable, values_from = value)\n#&gt; # A tibble: 4 × 5\n#&gt;   country continent  year lifeExp      pop\n#&gt;   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Belgium Europe     2002    78.3 10311970\n#&gt; 2 Belgium Europe     2007    79.4 10392226\n#&gt; 3 France  Europe     2002    79.6 59925035\n#&gt; 4 France  Europe     2007    80.7 61083916\n\npivot_wider prend deux arguments principaux :\n\nnames_from indique la colonne contenant les noms des nouvelles variables à créer\nvalues_from indique la colonne contenant les valeurs de ces variables\n\nIl peut arriver que certaines variables soient absentes pour certaines observations. Dans ce cas l’argument values_fill permet de spécifier la valeur à utiliser pour ces données manquantes (par défaut les valeurs absentes sont, logiquement, indiquées par des NA).\nExemple avec le tableau d suivant :\n\n\n\n\n\ncountry\ncontinent\nyear\nvariable\nvalue\n\n\n\n\nBelgium\nEurope\n2002\nlifeExp\n78.320\n\n\nBelgium\nEurope\n2002\npop\n10311970.000\n\n\nBelgium\nEurope\n2007\nlifeExp\n79.441\n\n\nBelgium\nEurope\n2007\npop\n10392226.000\n\n\nFrance\nEurope\n2002\nlifeExp\n79.590\n\n\nFrance\nEurope\n2002\npop\n59925035.000\n\n\nFrance\nEurope\n2007\nlifeExp\n80.657\n\n\nFrance\nEurope\n2007\npop\n61083916.000\n\n\nFrance\nEurope\n2002\ndensity\n94.000\n\n\n\n\n\n\nd %&gt;% \n  pivot_wider(names_from = variable, values_from = value)\n#&gt; # A tibble: 4 × 6\n#&gt;   country continent  year lifeExp      pop density\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 Belgium Europe     2002    78.3 10311970      NA\n#&gt; 2 Belgium Europe     2007    79.4 10392226      NA\n#&gt; 3 France  Europe     2002    79.6 59925035      94\n#&gt; 4 France  Europe     2007    80.7 61083916      NA\n\n\nd %&gt;%\n  pivot_wider(\n    names_from = variable, values_from = value,\n    values_fill = list(value = 0)\n  )\n#&gt; # A tibble: 4 × 6\n#&gt;   country continent  year lifeExp      pop density\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 Belgium Europe     2002    78.3 10311970       0\n#&gt; 2 Belgium Europe     2007    79.4 10392226       0\n#&gt; 3 France  Europe     2002    79.6 59925035      94\n#&gt; 4 France  Europe     2007    80.7 61083916       0\n\nAu final, la nom de pivot_wider s’explique par le fait qu’on fait “pivoter” notre tableau de départ d’un format “long” (avec plus de lignes) vers un format “large” (avec plus de colonnes).\n\n\n12.3.3 separate : séparer une colonne en plusieurs colonnes\nParfois on a plusieurs informations réunies en une seule colonne et on souhaite les séparer. Soit le tableau d’exemple caricatural suivant, nommé df :\n\n\n\n\n\neleve\nnote\n\n\n\n\nFélicien Machin\n5/20\n\n\nRaymonde Bidule\n6/10\n\n\nMartial Truc\n87/100\n\n\n\n\n\nseparate permet de séparer la colonne note en deux nouvelles colonnes note et note_sur :\n\ndf %&gt;% separate(note, c(\"note\", \"note_sur\"))\n#&gt; # A tibble: 3 × 3\n#&gt;   eleve           note  note_sur\n#&gt;   &lt;chr&gt;           &lt;chr&gt; &lt;chr&gt;   \n#&gt; 1 Félicien Machin 5     20      \n#&gt; 2 Raymonde Bidule 6     10      \n#&gt; 3 Martial Truc    87    100\n\nseparate prend deux arguments principaux, le nom de la colonne à séparer et un vecteur indiquant les noms des nouvelles variables à créer. Par défaut separate “sépare” au niveau des caractères non-alphanumérique (espace, symbole, etc.). On peut lui indiquer explicitement le caractère sur lequel séparer avec l’argument sep :\n\ndf %&gt;% separate(eleve, c(\"prenom\", \"nom\"), sep = \" \")\n#&gt; # A tibble: 3 × 3\n#&gt;   prenom   nom    note  \n#&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 Félicien Machin 5/20  \n#&gt; 2 Raymonde Bidule 6/10  \n#&gt; 3 Martial  Truc   87/100\n\n\n\n12.3.4 separate_rows : séparer une colonne en plusieurs lignes\nseparate_rows est également utile quand plusieurs informations différentes ont été réunies dans une seules colonne. Contrairement à separate, elle ne répartit les différentes valeurs dans plusieurs colonnes, mais dans plusieurs lignes.\nPrenons l’exemple suivant, ou la colonne notes contient plusieurs notes séparées par des virgules :\n\n\n\n\n\neleve\nclasse\nnotes\n\n\n\n\nFélicien Machin\n6e\n5,16,11\n\n\nRaymonde Bidule\n5e\n15\n\n\nMartial Truc\n6e\n11,17\n\n\n\n\n\nSi on applique separate_rows à la colonne notes, chaque note se retrouve dans une ligne différente (et les autres colonnes sont dupliquées) :\n\nseparate_rows(df, notes)\n#&gt; # A tibble: 6 × 3\n#&gt;   eleve           classe notes\n#&gt;   &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 Félicien Machin 6e     5    \n#&gt; 2 Félicien Machin 6e     16   \n#&gt; 3 Félicien Machin 6e     11   \n#&gt; 4 Raymonde Bidule 5e     15   \n#&gt; 5 Martial Truc    6e     11   \n#&gt; 6 Martial Truc    6e     17\n\nPar défaut separate_rows sépare les valeurs dès qu’elle trouve un caractère qui ne soit ni un chiffre ni une lettre, mais on peut spécifier le séparateur à l’aide de l’argument sep (qui accepte une chaîne de caractère ou même une expression régulière) :\n\nseparate_rows(df, notes, sep = \",\")\n\n\n\n12.3.5 unite : regrouper plusieurs colonnes en une seule\nunite est l’opération inverse de separate. Elle permet de regrouper plusieurs colonnes en une seule. Imaginons qu’on obtient le tableau d suivant :\n\n\n\n\n\ncode_departement\ncode_commune\ncommune\npop_tot\n\n\n\n\n01\n004\nAmbérieu-en-Bugey\n14204\n\n\n01\n007\nAmbronay\n2763\n\n\n01\n014\nArbent\n3356\n\n\n01\n024\nAttignat\n3196\n\n\n01\n025\nBâgé-Dommartin\n4078\n\n\n01\n027\nBalan\n2513\n\n\n\n\n\nOn souhaite reconstruire une colonne code_insee qui indique le code INSEE de la commune, et qui s’obtient en concaténant le code du département et celui de la commune. On peut utiliser unite pour cela :\n\nd %&gt;% unite(code_insee, code_departement, code_commune)\n#&gt; # A tibble: 6 × 3\n#&gt;   code_insee commune           pop_tot\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1 01_004     Ambérieu-en-Bugey  14204 \n#&gt; 2 01_007     Ambronay            2763 \n#&gt; 3 01_014     Arbent              3356 \n#&gt; 4 01_024     Attignat            3196 \n#&gt; 5 01_025     Bâgé-Dommartin      4078.\n#&gt; 6 01_027     Balan               2513\n\nLe résultat n’est pas idéal : par défaut unite ajoute un caractère _ entre les deux valeurs concaténées, alors qu’on ne veut aucun séparateur. De plus, on souhaite conserver nos deux colonnes d’origine, qui peuvent nous être utiles. On peut résoudre ces deux problèmes à l’aide des arguments sep et remove :\n\nd %&gt;% \n  unite(\n      code_insee, code_departement, code_commune, \n      sep = \"\", remove = FALSE\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   code_insee code_departement code_commune commune           pop_tot\n#&gt;   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1 01004      01               004          Ambérieu-en-Bugey  14204 \n#&gt; 2 01007      01               007          Ambronay            2763 \n#&gt; 3 01014      01               014          Arbent              3356 \n#&gt; 4 01024      01               024          Attignat            3196 \n#&gt; 5 01025      01               025          Bâgé-Dommartin      4078.\n#&gt; 6 01027      01               027          Balan               2513\n\n\n\n12.3.6 extract : créer de nouvelles colonnes à partir d’une colonne de texte\nextract permet de créer de nouvelles colonnes à partir de sous-chaînes d’une colonne de texte existante, identifiées par des groupes dans une expression régulière.\nPar exemple, à partir du tableau suivant :\n\n\n\n\n\neleve\nnote\n\n\n\n\nFélicien Machin\n5/20\n\n\nRaymonde Bidule\n6/10\n\n\nMartial Truc\n87/100\n\n\n\n\n\nOn peut extraire les noms et prénoms dans deux nouvelles colonnes avec :\n\ndf %&gt;% \n    extract(\n        eleve,\n        c(\"prenom\", \"nom\"),\n        \"^(.*) (.*)$\"\n    )\n#&gt; # A tibble: 3 × 3\n#&gt;   prenom   nom    note  \n#&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 Félicien Machin 5/20  \n#&gt; 2 Raymonde Bidule 6/10  \n#&gt; 3 Martial  Truc   87/100\n\nOn passe donc à extract trois arguments : la colonne d’où on doit extraire les valeurs, un vecteur avec les noms des nouvelles colonnes à créer, et une expression régulière comportant autant de groupes (identifiés par des parenthèses) que de nouvelles colonnes.\nPar défaut la colonne d’origine n’est pas conservée dans la table résultat. On peut modifier ce comportement avec l’argument remove = FALSE. Ainsi, le code suivant extrait les initiales du prénom et du nom mais conserve la colonne d’origine :\n\ndf %&gt;% \n    extract(\n        eleve,\n        c(\"initiale_prenom\", \"initiale_nom\"),\n        \"^(.).* (.).*$\",\n        remove = FALSE\n    )\n#&gt; # A tibble: 3 × 4\n#&gt;   eleve           initiale_prenom initiale_nom note  \n#&gt;   &lt;chr&gt;           &lt;chr&gt;           &lt;chr&gt;        &lt;chr&gt; \n#&gt; 1 Félicien Machin F               M            5/20  \n#&gt; 2 Raymonde Bidule R               B            6/10  \n#&gt; 3 Martial Truc    M               T            87/100\n\n\n\n12.3.7 complete : compléter des combinaisons de variables manquantes\nImaginons qu’on ait le tableau de résultats suivants :\n\n\n\n\n\neleve\nmatiere\nnote\n\n\n\n\nAlain\nMaths\n16\n\n\nAlain\nFrançais\n9\n\n\nBarnabé\nMaths\n17\n\n\nChantal\nFrançais\n11\n\n\n\n\n\nLes élèves Barnabé et Chantal n’ont pas de notes dans toutes les matières. Supposons que c’est parce qu’ils étaient absents et que leur note est en fait un 0. Si on veut calculer les moyennes des élèves, on doit compléter ces notes manquantes.\nLa fonction complete est prévue pour ce cas de figure : elle permet de compléter des combinaisons manquantes de valeurs de plusieurs colonnes.\nOn peut l’utiliser de cette manière :\n\ndf %&gt;% complete(eleve, matiere)\n#&gt; # A tibble: 6 × 3\n#&gt;   eleve   matiere   note\n#&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 Alain   Français     9\n#&gt; 2 Alain   Maths       16\n#&gt; 3 Barnabé Français    NA\n#&gt; 4 Barnabé Maths       17\n#&gt; 5 Chantal Français    11\n#&gt; 6 Chantal Maths       NA\n\nOn voit que les combinaisons manquante “Barnabé - Français” et “Chantal - Maths” ont bien été ajoutées par complete.\nPar défaut les lignes insérées récupèrent des valeurs manquantes NA pour les colonnes restantes. On peut néanmoins choisir une autre valeur avec l’argument fill, qui prend la forme d’une liste nommée :\n\ndf %&gt;% complete(eleve, matiere, fill = list(note = 0))\n#&gt; # A tibble: 6 × 3\n#&gt;   eleve   matiere   note\n#&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 Alain   Français     9\n#&gt; 2 Alain   Maths       16\n#&gt; 3 Barnabé Français     0\n#&gt; 4 Barnabé Maths       17\n#&gt; 5 Chantal Français    11\n#&gt; 6 Chantal Maths        0\n\nParfois on ne souhaite pas inclure toutes les colonnes dans le calcul des combinaisons de valeurs. Par exemple, supposons qu’on rajoute dans notre tableau une colonne avec les identifiants de chaque élève :\n\n\n\n\n\nid\neleve\nmatiere\nnote\n\n\n\n\n1001001\nAlain\nMaths\n16\n\n\n1001001\nAlain\nFrançais\n9\n\n\n1001002\nBarnabé\nMaths\n17\n\n\n1001003\nChantal\nFrançais\n11\n\n\n\n\n\nSi on applique complete comme précédemment, le résultat n’est pas bon car il contient toutes les combinaisons de id, eleve et matiere.\n\ndf %&gt;% complete(id, eleve, matiere)\n#&gt; # A tibble: 18 × 4\n#&gt;         id eleve   matiere   note\n#&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1 1001001 Alain   Français     9\n#&gt;  2 1001001 Alain   Maths       16\n#&gt;  3 1001001 Barnabé Français    NA\n#&gt;  4 1001001 Barnabé Maths       NA\n#&gt;  5 1001001 Chantal Français    NA\n#&gt;  6 1001001 Chantal Maths       NA\n#&gt;  7 1001002 Alain   Français    NA\n#&gt;  8 1001002 Alain   Maths       NA\n#&gt;  9 1001002 Barnabé Français    NA\n#&gt; 10 1001002 Barnabé Maths       17\n#&gt; 11 1001002 Chantal Français    NA\n#&gt; 12 1001002 Chantal Maths       NA\n#&gt; 13 1001003 Alain   Français    NA\n#&gt; 14 1001003 Alain   Maths       NA\n#&gt; 15 1001003 Barnabé Français    NA\n#&gt; 16 1001003 Barnabé Maths       NA\n#&gt; 17 1001003 Chantal Français    11\n#&gt; 18 1001003 Chantal Maths       NA\n\nDans ce cas, pour signifier à complete que id et eleve sont deux attributs d’un même individu et ne doivent pas être combinés entre eux, on doit les placer dans une fonction nesting :\n\ndf %&gt;% complete(nesting(id, eleve), matiere)\n#&gt; # A tibble: 6 × 4\n#&gt;        id eleve   matiere   note\n#&gt;     &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 1001001 Alain   Français     9\n#&gt; 2 1001001 Alain   Maths       16\n#&gt; 3 1001002 Barnabé Français    NA\n#&gt; 4 1001002 Barnabé Maths       17\n#&gt; 5 1001003 Chantal Français    11\n#&gt; 6 1001003 Chantal Maths       NA"
  },
  {
    "objectID": "12-tidyr.html#ressources",
    "href": "12-tidyr.html#ressources",
    "title": "12  Mettre en ordre avec tidyr",
    "section": "12.4 Ressources",
    "text": "12.4 Ressources\nChaque jeu de données est différent, et le travail de remise en forme est souvent long et plus ou moins compliqué. On n’a donné ici que les exemples les plus simples, et c’est souvent en combinant différentes opérations qu’on finit par obtenir le résultat souhaité.\nLe livre R for data science, librement accessible en ligne, contient un chapitre complet sur la remise en forme des données.\nL’article Tidy data, publié en 2014 dans le Journal of Statistical Software, présente de manière détaillée le concept éponyme (mais il utilise des extensions désormais obsolètes qui ont depuis été remplacées par dplyr ettidyr).\nLe site de l’extension est accessible à l’adresse : https://tidyr.tidyverse.org/ et contient une liste des fonctions et les pages d’aide associées."
  },
  {
    "objectID": "12-tidyr.html#footnotes",
    "href": "12-tidyr.html#footnotes",
    "title": "12  Mettre en ordre avec tidyr",
    "section": "",
    "text": "pivot_longer et pivot_wider ont été introduites dans la version 1.0 de tidyr. Elles ont alors remplacé gather et spread.↩︎"
  },
  {
    "objectID": "13-rmarkdown.html#créer-un-nouveau-document",
    "href": "13-rmarkdown.html#créer-un-nouveau-document",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.1 Créer un nouveau document",
    "text": "13.1 Créer un nouveau document\nUn document R Markdown est un simple fichier texte enregistré avec l’extension .Rmd.\nSous RStudio, on peut créer un nouveau document en allant dans le menu File puis en choisissant New file puis R Markdown…. La boîte de dialogue suivante s’affiche :\n\n\n\nCréation d’un document R Markdown\n\n\nOn peut indiquer le titre, l’auteur du document ainsi que le format de sortie par défaut (il est possible de modifier facilement ces éléments par la suite). Plutôt qu’un document classique, on verra Section 13.6 qu’on peut aussi choisir de créer une présentation sous forme de slides (entrée Presentation) ou de créer un document à partir d’un modèle (Entrée From Template).\nUn fichier comportant un contenu d’exemple s’affiche alors. Vous pouvez l’enregistrer où vous le souhaitez avec une extension .Rmd."
  },
  {
    "objectID": "13-rmarkdown.html#éléments-dun-document-r-markdown",
    "href": "13-rmarkdown.html#éléments-dun-document-r-markdown",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.2 Éléments d’un document R Markdown",
    "text": "13.2 Éléments d’un document R Markdown\nUn document R Markdown est donc un fichier texte qui ressemble à quelque chose comme ça :\n\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"10 avril 2017\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## Introduction\n\nCeci est un document RMarkdown, qui mélange :\n\n- du texte balisé selon la syntaxe Markdown\n- des bouts de code R qui seront exécutés\n\nLe code R se présente de la manière suivante :\n\n```{r}\nsummary(cars)\n```\n\n## Graphiques\n\nOn peut aussi inclure des graphiques, par exemple :\n\n```{r}\nplot(pressure)\n```\n\nOn va décomposer les différents éléments constitutifs de ce document.\n\n13.2.1 En-tête (préambule)\nLa première partie du document est son en-tête. Il se situe en tout début de document, et est délimité par trois tirets (---) avant et après :\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"10 avril 2017\"\noutput: html_document\n---\nCet en-tête contient les métadonnées du document, comme son titre, son auteur, sa date, plus tout un tas d’options possibles qui vont permettre de configurer ou personnaliser l’ensemble du document et son rendu. Ici, par exemple, la ligne output: html_document indique que le document généré doit être au format HTML.\n\n\n13.2.2 Texte du document\nLe corps du document est constitué de texte qui suit la syntaxe Markdown. Un fichier Markdown est un fichier texte contenant un balisage léger qui permet de définir des niveaux de titres ou de mettre en forme le texte. Par exemple, le texte suivant :\nCeci est du texte avec *de l'italique* et **du gras**.\n\nOn peut définir des listes à puces :\n\n- premier élément\n- deuxième élément\nGénèrera le texte mis en forme suivant :\n\nCeci est du texte avec de l’italique et du gras.\nOn peut définir des listes à puces :\n\npremier élément\ndeuxième élément\n\n\nOn voit que des mots placés entre des astérisques sont mis en italique, des lignes qui commencent par un tiret sont transformés en liste à puce, etc.\nOn peut définir des titres de différents niveaux en faisant débuter une ligne par un ou plusieurs # :\n# Titre de niveau 1\n\n## Titre de niveau 2\n\n### Titre de niveau 3\nQuand des titres ont été définis, si vous cliquez sur l’icône Show document outline totalement à droite de la barre d’outils associée au fichier R Markdown, une table des matières générée automatiquement à partir des titres s’affiche et vous permet de naviguer facilement dans le document :\n\n\n\nTable des matières dynamique\n\n\nLa syntaxe Markdown permet d’autres mises en forme, comme la possibilité d’insérer des liens ou des images. Par exemple, le code suivant :\n[Exemple de lien](https://example.com)\nDonnera le lien suivant :\n\nExemple de lien\n\nDans RStudio, le menu Help puis Markdown quick reference donne un aperçu plus complet de la syntaxe.\n\n\n13.2.3 Blocs de code R\nEn plus du texte libre au format Markdown, un document R Markdown contient, comme son nom l’indique, du code R. Celui-ci est inclus dans des blocs (chunks) délimités par la syntaxe suivante :\n\n```{r}\nx &lt;- 1:5\n```\n\nComme cette suite de caractères n’est pas très simple à saisir, vous pouvez utiliser le menu Insert de RStudio et choisir R3, ou utiliser le raccourci clavier Ctrl+Alt+i.\n\n\n\nMenu d’insertion d’un bloc de code\n\n\nDans RStudio les blocs de code R sont en général affichés avec une couleur de fond légèrement différente pour les distinguer du reste du document.\nQuand votre curseur se trouve dans un bloc, vous pouvez saisir le code R que vous souhaitez, l’exécuter, utiliser l’autocomplétion, exactement comme si vous vous trouviez dans un script R. Vous pouvez également exécuter l’ensemble du code contenu dans un bloc à l’aide du raccourci clavier Ctrl+Maj+Entrée.\nDans RStudio, par défaut, les résultats d’un bloc de code (texte, tableau ou graphique) s’affichent directement dans la fenêtre d’édition du document, permettant de les visualiser facilement et de les conserver le temps de la session 4.\nLorsque le document est “compilé” au format HTML, PDF ou docx, chaque bloc est exécuté tour à tour, et le résultat inclus dans le document final, qu’il s’agisse de texte, d’un tableau ou d’un graphique. Les blocs sont liés entre eux, dans le sens où les données importées ou calculées dans un bloc sont accessibles aux blocs suivants. On peut donc aussi voir un document R Markdown comme un script R dans lequel on aurait intercalé du texte libre au format Markdown.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter qu’avant chaque compilation, une nouvelle session R est lancée, ne contenant aucun objet. Les premiers blocs de code d’un document sont donc souvent utilisés pour importer des données, exécuter des recodages, etc.\n\n\n\n\n13.2.4 Compiler un document (Knit)\nOn peut à tout moment compiler, ou plutôt “tricoter” (Knit), un document R Markdown pour obtenir et visualiser le document généré. Pour cela, il suffit de cliquer sur le bouton Knit et de choisir le format de sortie voulu :\n\n\n\nMenu Knit\n\n\nVous pouvez aussi utiliser le raccourci Ctrl+Maj+K pour compiler le document dans le dernier format utilisé.\n\n\n\n\n\n\nAvertissement\n\n\n\nPour la génération du format PDF, vous devez avoir une installation fonctionnelle de LaTeX sur votre système.\nSi ça n’est pas le cas, l’extension tinytex de Yihui Xie vise à faciliter l’installation d’une distribution LaTeX minimale quel que soit le système d’exploitation de votre machine. Pour l’utiliser il vous faut d’abord installer l’extension avec install.packages('tinytex'), puis lancer la commande suivante dans la console (prévoir un téléchargement d’environ 200Mo) :\ntinytex::install_tinytex()\nPlus d’informations sur le site de tinytex.\n\n\nUn onglet R Markdown s’ouvre dans la même zone que l’onglet Console et indique la progression de la compilation, ainsi que les messages d’erreur éventuels. Si tout se passe bien, Le document devrait s’afficher soit dans une fenêtre Viewer de RStudio (pour la sortie HTML), soit dans le logiciel par défaut de votre ordinateur."
  },
  {
    "objectID": "13-rmarkdown.html#personnaliser-le-document-généré",
    "href": "13-rmarkdown.html#personnaliser-le-document-généré",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.3 Personnaliser le document généré",
    "text": "13.3 Personnaliser le document généré\nLa personnalisation du document généré se fait en modifiant des options dans le préambule du document. RStudio propose néanmoins une petite interface graphique permettant de changer ces options plus facilement. Pour cela, cliquez sur l’icône en forme d’engrenage à droite du bouton Knit et choisissez Output Options…\n\n\n\nOptions de sortie R Markdown\n\n\nUne boîte de dialogue s’affiche vous permettant de sélectionner le format de sortie souhaité et, selon le format, différentes options :\n\n\n\nDialogue d’options de sortie R Markdown\n\n\nPour le format HTML par exemple, l’onglet General vous permet de spécifier si vous voulez une table des matières, sa profondeur, les thèmes à appliquer pour le document et la coloration syntaxique des blocs R, etc. L’onglet Figures vous permet de changer les dimensions par défaut des graphiques générés.\n\n\n\n\n\n\nNote\n\n\n\nUne option très intéressante pour les fichiers HTML, accessible via l’onglet Advanced, est l’entrée Create standalone HTML document. Si elle est cochée (ce qui est le cas par défaut), le document HTML généré contiendra en un seul fichier le code HTML mais aussi les images et toutes les autres ressources nécessaires à son affichage. Ceci permet de générer des fichiers (parfois assez volumineux) que vous pouvez transférer très facilement à quelqu’un par mail ou en le mettant en ligne quelque part. Si la case n’est pas cochée, les images et autres ressources sont placées dans un dossier à part.\n\n\nLorsque vous changez des options, RStudio va en fait modifier le préambule de votre document. Ainsi, si vous choisissez d’afficher une table des matières et de modifier le thème de coloration syntaxique, votre en-tête va devenir quelque chose comme :\n---\ntitle: \"Test R Markdown\"\noutput:\n   html_document: \n     highlight: kate\n     toc: yes\n---\nVous pouvez modifier les options directement en éditant le préambule.\nÀ noter qu’il est possible de spécifier des options différentes selon les formats, par exemple :\n---\ntitle: \"Test R Markdown\"\noutput:\n  html_document: \n    highlight: kate\n    toc: yes\n  pdf_document: \n    fig_caption: yes\n    highlight: kate\n---\nLa liste complète des options possibles est présente sur le site de la documentation officielle (très complet et bien fait) et sur l’antisèche et le guide de référence, accessibles depuis RStudio via le menu Help puis Cheatsheets."
  },
  {
    "objectID": "13-rmarkdown.html#options-des-blocs-de-code-r",
    "href": "13-rmarkdown.html#options-des-blocs-de-code-r",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.4 Options des blocs de code R",
    "text": "13.4 Options des blocs de code R\nIl est également possible de passer des options à chaque bloc de code R pour modifier son comportement.\nOn rappelle qu’on bloc de code se présente de la manière suivante :\n\n```{r}\nx &lt;- 1:5\n```\n\nLes options d’un bloc de code sont à placer à l’intérieur des accolades {r}.\n\n13.4.1 Nom du bloc\nLa première possibilité est de donner un nom au bloc. Celui-ci est indiqué directement après le r :\n{r nom_du_bloc}\nIl n’est pas obligatoire de nommer un bloc, mais cela peut être utile en cas d’erreur à la compilation, pour identifier le bloc ayant causé le problème. Attention, on ne peut pas avoir deux blocs avec le même nom.\n\n\n13.4.2 Options\nEn plus d’un nom, on peut passer à un bloc une série d’options sous la forme option = valeur. Voici un exemple de bloc avec un nom et des options :\n\n```{r mon_bloc, echo = FALSE, warning = TRUE}\nx &lt;- 1:5\n```\n\nEt un exemple de bloc non nommé avec des options :\n\n```{r echo = FALSE, warning = FALSE}\nx &lt;- 1:5\n```\n\nUne des options utiles est l’option echo. Par défaut echo vaut TRUE, et le bloc de code R est inséré dans le document généré, de cette manière :\n\nx &lt;- 1:5\nprint(x)\n#&gt; [1] 1 2 3 4 5\n\nMais si on positionne l’option echo=FALSE, alors le code R n’est plus inséré dans le document, et seul le résultat est visible :\n\n#&gt; [1] 1 2 3 4 5\n\nVoici une liste de quelques unes des options disponibles :\n\n\n\n\n\n\n\n\nOption\nValeurs\nDescription\n\n\n\n\necho\nTRUE/FALSE\nAfficher ou non le code R dans le document\n\n\neval\nTRUE/FALSE\nExécuter ou non le code R à la compilation\n\n\ninclude\nTRUE/FALSE\nInclure ou non le code R et ses résultats dans le document\n\n\nresults\n“hide”/“asis”/“markup”/“hold”\nType de résultats renvoyés par le bloc de code\n\n\nwarning\nTRUE/FALSE\nAfficher ou non les avertissements générés par le bloc\n\n\nmessage\nTRUE/FALSE\nAfficher ou non les messages générés par le bloc\n\n\n\nIl existe de nombreuses autres options décrites notamment dans guide de référence R Markdown (PDF en anglais).\n\n\n13.4.3 Modifier les options\nIl est possible de modifier les options manuellement en éditant l’en-tête du bloc de code, mais on peut aussi utiliser une petite interface graphique proposée par RStudio. Pour cela, il suffit de cliquer sur l’icône d’engrenage située à droite sur la ligne de l’en-tête de chaque bloc :\n\n\n\nMenu d’options de bloc de code\n\n\nVous pouvez ensuite modifier les options les plus courantes, et cliquer sur Apply pour les appliquer.\n\n\n13.4.4 Options globales\nOn peut vouloir appliquer une option à l’ensemble des blocs d’un document. Par exemple, on peut souhaiter par défaut ne pas afficher le code R de chaque bloc dans le document final.\nOn peut positionner une option globalement en utilisant la fonction knitr::opts_chunk$set(). Par exemple, insérer knitr::opts_chunk$set(echo = FALSE) dans un bloc de code positionnera l’option echo = FALSE par défaut pour tous les blocs suivants.\nEn général, on place toutes ces modifications globales dans un bloc spécial nommé setup et qui est le premier bloc du document :\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\n\n\n\n\n\nNote\n\n\n\nPar défaut RStudio exécute systématiquement le contenu du bloc setup avant d’exécuter celui d’un autre bloc.\n\n\nContrairement aux autres blocs de code, quand on utilise dans RStudio le menu des paramètres du bloc setup pour modifier ses options, celles-ci modifient non pas les options de ce bloc mais les options globales, en mettant à jour l’appel de la fonction knitr::opts_chunk$set().\n\n\n13.4.5 Mise en cache des résultats\nCompiler un document R Markdown peut être long, car il faut à chaque fois exécuter l’ensemble des blocs de code R qui le constituent.\nPour accélérer cette opération, R Markdown utilise un système de mise en cache : les résultats de chaque bloc sont enregistrés dans un fichier et à la prochaine compilation, si le code et les options du bloc n’ont pas été modifiés, c’est le contenu du fichier de cache qui est utilisé, ce qui évite d’exécuter le code R.\n\n\n\n\n\n\nNote\n\n\n\nOn peut activer ou désactiver la mise en cache des résultats pour chaque bloc de code avec l’option cache = TRUE ou cache = FALSE, et on peut aussi désactiver totalement la mise en cache pour le document en ajoutant knitr::opts_chunk$set(cache = FALSE) dans le premier bloc setup.\n\n\nCe système de cache peut poser problème par exemple si les données source changent : dans ce cas les résultats de certains blocs peuvent ne pas être mis à jour s’ils sont présents en cache. Dans ce cas, on peut vider le cache du document, ce qui forcera un recalcul de tous les blocs de code à la prochaine compilation. Pour cela, vous pouvez ouvrir le menu Knit et choisir Clear Knitr Cache… :\n\n\n\nMenu Knit"
  },
  {
    "objectID": "13-rmarkdown.html#rendu-des-tableaux",
    "href": "13-rmarkdown.html#rendu-des-tableaux",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.5 Rendu des tableaux",
    "text": "13.5 Rendu des tableaux\n\n13.5.1 Tableaux croisés\nPar défaut, les tableaux issus de la fonction table sont affichés comme ils apparaissent dans la console de R, en texte brut :\n\nlibrary(questionr)\ndata(hdv2003)\ntab &lt;- lprop(table(hdv2003$qualif, hdv2003$sexe))\ntab\n#&gt;                           \n#&gt;                            Homme Femme Total\n#&gt;   Ouvrier specialise        47.3  52.7 100.0\n#&gt;   Ouvrier qualifie          78.4  21.6 100.0\n#&gt;   Technicien                76.7  23.3 100.0\n#&gt;   Profession intermediaire  55.0  45.0 100.0\n#&gt;   Cadre                     55.8  44.2 100.0\n#&gt;   Employe                   16.2  83.8 100.0\n#&gt;   Autre                     36.2  63.8 100.0\n#&gt;   All                       44.8  55.2 100.0\n\nOn peut améliorer leur présentation en utilisant la fonction kable de l’extension knitr. Celle-ci fournit un formatage adapté en fonction du format de sortie. On aura donc des tableaux “propres” que ce soit en HTML, PDF ou aux formats traitements de texte :\n\nlibrary(knitr)\nkable(tab)\n\n\n\n\n\nHomme\nFemme\nTotal\n\n\n\n\nOuvrier specialise\n47.29064\n52.70936\n100\n\n\nOuvrier qualifie\n78.42466\n21.57534\n100\n\n\nTechnicien\n76.74419\n23.25581\n100\n\n\nProfession intermediaire\n55.00000\n45.00000\n100\n\n\nCadre\n55.76923\n44.23077\n100\n\n\nEmploye\n16.16162\n83.83838\n100\n\n\nAutre\n36.20690\n63.79310\n100\n\n\nAll\n44.82759\n55.17241\n100\n\n\n\n\n\nDifférents arguments permettent de modifier la sortie de kable. digits, par exemple, permet de spécifier le nombre de chiffres significatifs à afficher dans les colonnes de nombres :\n\nkable(tab, digits = 1)\n\n\n\n\n\nHomme\nFemme\nTotal\n\n\n\n\nOuvrier specialise\n47.3\n52.7\n100\n\n\nOuvrier qualifie\n78.4\n21.6\n100\n\n\nTechnicien\n76.7\n23.3\n100\n\n\nProfession intermediaire\n55.0\n45.0\n100\n\n\nCadre\n55.8\n44.2\n100\n\n\nEmploye\n16.2\n83.8\n100\n\n\nAutre\n36.2\n63.8\n100\n\n\nAll\n44.8\n55.2\n100\n\n\n\n\n\n\n\n13.5.2 Tableaux de données et tris à plat\nEn ce qui concerne les tableaux de données (tibble ou data frame), l’affichage HTML par défaut se contente d’un affichage texte comme dans la console, très peu lisible dès que le tableau dépasse une certaine taille.\nUne alternative est d’utiliser la fonction paged_table, qui affiche une représentation HTML paginée du tableau :\n\n\n\nRendu d’une table par paged_table\n\n\nUne alternative est d’utiliser kable, comme précédemment pour les tableaux croisés, ou encore la fonction datatable de l’extension DT, qui propose encore davantage d’interactivité :\n\n\n\nRendu d’une table par DT::datatable\n\n\nDans tous les cas il est déconseillé d’afficher de cette manière un tableau de données de très grandes dimensions, car le fichier HTML résultant contiendrait l’ensemble des données et serait donc très volumineux.\n\n\n\n\n\n\nNote\n\n\n\nOn peut définir un mode d’affichage par défaut pour tous les tableaux de données en modifiant les Output options du format HTML (onglet General, Print dataframes as), ou en modifiant manuellement l’option df_print de l’entrée html_document dans le préambule.\nÀ noter que les tableaux issus de la fonction freq de questionr s’affichent comme des tableaux de données (et non comme des tableaux croisés)."
  },
  {
    "objectID": "13-rmarkdown.html#sec-templates",
    "href": "13-rmarkdown.html#sec-templates",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.6 Modèles de documents",
    "text": "13.6 Modèles de documents\nOn a vu ici la production de documents “classiques”, mais R Markdown permet de créer bien d’autres choses.\nLe site de documentation de l’extension propose une galerie des différentes sorties possibles. On peut ainsi créer des slides, des sites Web ou même des livres entiers, comme le présent document.\n\n13.6.1 Slides\nUn usage intéressant est la création de diaporamas pour des présentations sous forme de slides. Le principe reste toujours le même : on mélange texte au format Markdown et code R, et R Markdown transforme le tout en présentations au format HTML ou PDF. En général les différents slides sont séparés au niveau de certains niveaux de titre.\nCertains modèles de slides sont inclus avec R Markdown, notamment :\n\nioslides et Slidy pour des présentations HTML\nbeamer pour des présentations en PDF via LaTeX\n\nQuand vous créez un nouveau document dans RStudio, ces modèles sont accessibles via l’entrée Presentation :\n\n\n\nCréer une présentation R Markdown\n\n\nD’autres extensions, qui doivent être installées séparément, permettent aussi des diaporamas dans des formats variés. On citera notamment :\n\nxaringan pour des présentations HTML basées sur remark.js\nrevealjs pour des présentations HTML basées sur reveal.js\nrmdshower pour des diaporamas HTML basés sur shower\n\nUne fois l’extension installée, elle propose en général un template de départ lorsqu’on crée un nouveau document dans RStudio. Ceux-ci sont accessibles depuis l’entrée From Template.\n\n\n\nCréer une présentation à partir d’un template\n\n\n\n\n13.6.2 Templates\nIl existe également différents templates permettant de changer le format et la présentation des documents générés. Une liste de ces formats et leur documentation associée est accessible depuis la page formats de la documentation.\nOn notera notamment :\n\nle format Distill, adapté à des publications scientifiques ou techniques sur le Web\nle format Tufte Handouts qui permet de produire des documents PDF ou HTML dans un format proche de celui utilisé par Edward Tufte pour certaines de ses publications\nrticles, package qui propose des templates LaTeX pour plusieurs revues scientifiques\n\nEnfin, l’extension rmdformats propose plusieurs modèles HTML adaptés notamment pour des documents longs :\n\n\n\nModèle readthedown\n\n\n\n\n\nModèle downcute\n\n\n\n\n\nModèle robobook\n\n\n\n\n\nModèle material\n\n\nLà encore, la plupart du temps, ces modèles de documents proposent un template de départ lorsqu’on crée un nouveau document dans RStudio (entrée From Template) :\n\n\n\nCréer un document à partir d’un template"
  },
  {
    "objectID": "13-rmarkdown.html#ressources",
    "href": "13-rmarkdown.html#ressources",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "13.7 Ressources",
    "text": "13.7 Ressources\nLes ressources suivantes sont toutes en anglais…\nL’ouvrage R for data science, accessible en ligne, contient un chapitre dédié à R Markdown.\nLe site officiel de l’extension contient une documentation très complète, tant pour les débutants que pour un usage avancé.\nEnfin, l’aide de RStudio (menu Help puis Cheatsheets) permet d’accéder à deux documents de synthèse : une “antisèche” synthétique (R Markdown Cheat Sheet) et un “guide de référence” plus complet (R Markdown Reference Guide)."
  },
  {
    "objectID": "13-rmarkdown.html#footnotes",
    "href": "13-rmarkdown.html#footnotes",
    "title": "13  Diffuser et publier avec rmarkdown",
    "section": "",
    "text": "On peut citer les formats odt, rtf, Markdown, etc.↩︎\nSi vous n’utilisez pas ce dernier, l’extension peut être installée à part avec install.packages(\"rmarkdown\") et chargée explicitement avec library(rmarkdown).↩︎\nIl est possible d’inclure dans un document R Markdown des blocs de code d’autres langages↩︎\nCe comportement peut être modifié en cliquant sur l’icône d’engrenage de la barre d’outils et en choisissant Chunk Output in Console↩︎"
  },
  {
    "objectID": "14-fonctions.html#introduction-et-exemples",
    "href": "14-fonctions.html#introduction-et-exemples",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.1 Introduction et exemples",
    "text": "14.1 Introduction et exemples\n\n14.1.1 Structure d’une fonction\nNous avons vu lors de l’introduction à R que le langage repose sur deux grands concepts : les objets et les fonctions. Pour reprendre une citation de John Chambers, en R, tout ce qui existe est un objet, et tout ce qui se passe est une fonction.\nLe principe d’une fonction est de prendre en entrée un ou plusieurs arguments (ou paramètres), d’effectuer un certain nombre d’actions et de renvoyer un résultat :\n\nNous avons déjà rencontré et utilisé un grand nombre de fonctions, certaines assez simples (mean, max…) et d’autres beaucoup plus complexes (summary, mutate…). R, comme tout langage de programmation, offre la possibilité de créer et d’utiliser ses propres fonctions.\nVoici un exemple de fonction très simple, quoi que d’une utilité douteuse, puisqu’elle se contente d’ajouter 2 à un nombre :\n\najoute2 &lt;- function(x) {\n  res &lt;- x + 2\n  return(res)\n}\n\nEn exécutant ce code, on crée une nouvelle fonction nommée ajoute2, que l’on peut directement utiliser dans un script ou dans la console :\n\najoute2(3)\n#&gt; [1] 5\n\nOn va décomposer pas à pas la structure de cette première fonction.\nD’abord, une fonction est créée en utilisant l’instruction function. Celle-ci est suivie d’une paire de parenthèses et d’une paire d’accolades.\n\nfunction() {\n\n}\n\nDans les parenthèses, on indique les arguments de la fonction, ceux qui devront lui être passés quand nous l’appellerons. Ici notre fonction ne prend qu’un seul argument, que nous avons décidé arbitrairement de nommer x.\n\nfunction(x) {\n\n}\n\nLes accolades comprennent une série d’instructions R qui constituent le corps de notre fonction. C’est ce code qui sera exécuté quand notre fonction est appelée. On peut utiliser dans le corps de la fonction les arguments qui lui sont passés. Ici, la première ligne utilise la valeur de l’argument x, lui ajoute 2 et stocke le résultat dans un nouvel objet res.\n\nfunction(x) {\n  res &lt;- x + 2\n}\n\nPour qu’elle soit utile, notre fonction doit renvoyer le résultat qu’elle a calculé précédemment. Ceci se fait via l’instruction return à qui on passe la valeur à retourner.\n\nfunction(x) {\n  res &lt;- x + 2\n  return(res)\n}\n\nEnfin, pour que notre fonction puisse être appelée et utilisée, nous devons lui donner un nom, ou plus précisément la stocker dans un objet. Ici on la stocke dans un objet nommé ajoute2.\n\najoute2 &lt;- function(x) {\n  res &lt;- x + 2\n  return(res)\n}\n\n\n\n\n\n\n\nNote\n\n\n\nLes fonctions étant des objets comme les autres, elles suivent les mêmes contraintes pour leur nom : on a donc droit aux lettres, chiffres, point et tiret bas.\nAttention à ne pas donner à votre fonction le nom d’une fonction déjà existante : par exemple, si vous créez une fonction nommée table, la fonction du même nom de R base ne sera plus disponible (sauf à la préfixer avec base::table). Si vous “écrasez” par erreur une fonction existante, il vous suffit de relancer votre session R et de trouver un nouveau nom.\n\n\nAvec le code précédent, on a donc créé un nouvel objet ajoute2 de type function. Cette nouvelle fonction prend un seul argument x, calcule la valeur x + 2 et retourne ce résultat. On l’utilise en tapant son nom suivi de la valeur de son argument entre parenthèses, par exemple :\n\najoute2(41)\n#&gt; [1] 43\n\nOu encore :\n\ny &lt;- 5\nz &lt;- ajoute2(y)\nz\n#&gt; [1] 7\n\nÀ noter que comme x + 2 fonctionne si x est un vecteur, on peut aussi appeler notre fonction en lui passant un vecteur en argument.\n\nvec &lt;- 1:5\najoute2(vec)\n#&gt; [1] 3 4 5 6 7\n\nSi on récapitule, une fonction se définit donc de la manière suivante :\n\nUne fonction peut évidemment prendre plusieurs arguments. Dans ce cas on liste les arguments dans les parenthèses en les séparant par des virgules :\n\nsomme &lt;- function(x, y) {\n  return(x + y)\n}\n\n\nsomme(3, 5)\n#&gt; [1] 8\n\nUne fonction peut aussi n’accepter aucun argument, dans ce cas on laisse les parenthèses vides.\n\nmiaule &lt;- function() {\n  return(\"Miaou\")\n}\n\nmiaule()\n#&gt; [1] \"Miaou\"\n\nÀ noter que si on appelle une fonction avec un nombre d’arguments incorrect, cela génère une erreur.\n\nsomme(1)\n#&gt; Error in somme(1): argument \"y\" is missing, with no default\n\n\nmiaule(\"ouaf\")\n#&gt; Error in miaule(\"ouaf\"): unused argument (\"ouaf\")\n\n\n\n14.1.2 Exemple de fonction\nPrenons un exemple un peu plus élaboré : la fonction table() retourne le tri à plat en effectifs d’une variable qualitative. On souhaite créer une fonction qui calcule plutôt le tri à plat en pourcentages. Voici une manière de le faire :\n\nprop_tab &lt;- function(v) {\n  tri &lt;- table(v)\n  effectif_total &lt;- length(v)\n  tri &lt;- tri / effectif_total * 100\n  return(tri)\n}\n\nNotre fonction prend en entrée un argument nommé v, en l’occurrence un vecteur représentant une variable qualitative. On commence par faire le tri à plat de ce vecteur avec table, puis on calcule la répartition en pourcentages en divisant ce tri à plat par l’effectif total et en multipliant par 100.\nTestons avec un vecteur d’exemple :\n\nvec &lt;- c(\"rouge\", \"vert\", \"vert\", \"bleu\", \"rouge\")\nprop_tab(vec)\n#&gt; v\n#&gt;  bleu rouge  vert \n#&gt;    20    40    40\n\nTestons sur une variable du jeu de données hdv20031 :\n\nlibrary(questionr)\ndata(hdv2003)\nprop_tab(hdv2003$qualif)\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                    10.15                    14.60                     4.30 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                     8.00                    13.00                    29.70 \n#&gt;                    Autre \n#&gt;                     2.90\n\nÇa fonctionne, mais avec une petite limite : par défaut table() ignore les NA. On peut modifier ce comportement en lui ajoutant un argument useNA = \"ifany\".\n\nprop_tab &lt;- function(v) {\n  tri &lt;- table(v, useNA = \"ifany\")\n  effectif_total &lt;- length(v)\n  tri &lt;- tri / effectif_total * 100\n  return(tri)\n}\n\nprop_tab(hdv2003$qualif)\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                    10.15                    14.60                     4.30 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                     8.00                    13.00                    29.70 \n#&gt;                    Autre                     &lt;NA&gt; \n#&gt;                     2.90                    17.35\n\n\n\n\n\n\n\nAvertissement\n\n\n\nQuand on modifie une fonction existante, il faut exécuter à nouveau le code correspondant à sa définition pour la “mettre à jour”. Ici, si on ne le fait pas l’objet prop_tab contiendra toujours l’ancienne définition.\nPour “mettre à jour” une fonction après avoir modifié son code, on peut soit sélectionner le code qui la définit et l’exécuter de la manière habituelle, soit, dans RStudio, se positionner dans le corps de la fonction et utiliser le raccourci clavier Ctrl + Alt + F.\n\n\nAutre amélioration possible : on pourrait vouloir modifier le nombre de décimales affichées pour les pourcentages, par exemple en les limitant à 1. Pour cela on ajoute une instruction round().\n\nprop_tab &lt;- function(v) {\n  tri &lt;- table(v, useNA = \"ifany\")\n  effectif_total &lt;- length(v)\n  tri &lt;- tri / effectif_total * 100\n  tri &lt;- round(tri, 1)\n  return(tri)\n}\n\nprop_tab(hdv2003$qualif)\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                     10.2                     14.6                      4.3 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      8.0                     13.0                     29.7 \n#&gt;                    Autre                     &lt;NA&gt; \n#&gt;                      2.9                     17.3\n\nÇa fonctionne ! Cela dit, limiter à un chiffre après la virgule ne convient pas forcément dans tous les cas. L’idéal serait d’offrir la possibilité à la personne qui appelle la fonction de choisir elle-même la précision de l’affichage. Comment ? Tout simplement en ajoutant un deuxième argument à notre fonction, que nous nommerons decimales, et en utilisant cet argument à la place du 1 dans l’appel à round().\n\nprop_tab &lt;- function(v, decimales) {\n  tri &lt;- table(v, useNA = \"ifany\")\n  effectif_total &lt;- length(v)\n  tri &lt;- tri / effectif_total * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nDésormais, notre fonction s’utilise en lui indiquant deux arguments :\n\nprop_tab(hdv2003$qualif, 1)\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                     10.2                     14.6                      4.3 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      8.0                     13.0                     29.7 \n#&gt;                    Autre                     &lt;NA&gt; \n#&gt;                      2.9                     17.3\n\nDe la même manière, on pourrait vouloir laisser le choix à l’utilisateur d’afficher ou non les NA dans le tri à plat. C’est possible en ajoutant un troisième argument à notre fonction et en utilisant sa valeur dans le paramètre useNA de table().\n\nprop_tab &lt;- function(v, decimales, useNA) {\n  tri &lt;- table(v, useNA = useNA)\n  effectif_total &lt;- length(v)\n  tri &lt;- tri / effectif_total * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nprop_tab(hdv2003$qualif, 1, \"no\")\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                     10.2                     14.6                      4.3 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      8.0                     13.0                     29.7 \n#&gt;                    Autre \n#&gt;                      2.9\n\n\n\n14.1.3 Effets de bord et affichage de messages\nParfois une fonction n’a pas pour objectif de renvoyer un résultat mais d’accomplir une action, comme générer un graphique, afficher un message, enregistrer un fichier… Dans ce cas la fonction peut ne pas inclure d’instruction return().\n\n\n\n\n\n\nNote\n\n\n\nLes actions “visibles” dans notre session R accomplies par une fonction en-dehors du résultat renvoyé sont appelés des effets de bord.\n\n\nPar exemple la fonction suivante prend en argument un vecteur et génère un diagramme en barres du tri à plat de cette variable (en modifiant un peu la présentation au passage).\n\nmy_barplot &lt;- function(var) {\n  tri &lt;- table(var)\n  barplot(tri, col = \"skyblue\", border = NA)\n}\n\nmy_barplot(hdv2003$clso)\n\n\n\n\nUn autre effet de bord très courant consiste à afficher des informations dans la console. Pour cela on peut utiliser print, qui affiche de manière aussi lisible que possible l’objet qu’on lui passe en argument :\n\nindicateurs &lt;- function(v) {\n  print(mean(v))\n  print(sd(v))\n}\n\nindicateurs(hdv2003$age)\n#&gt; [1] 48.157\n#&gt; [1] 16.94181\n\nQuand on souhaite seulement afficher une chaîne de caractère, on peut utiliser cat() qui fournit une sortie plus lisible que print :\n\nhello &lt;- function(nom) {\n  cat(\"Bonjour,\", nom, \"!\")\n}\n\nhello(\"Pierre-Edmond\")\n#&gt; Bonjour, Pierre-Edmond !\n\nEnfin, on peut aussi utiliser message() qui, comme son nom l’indique, affiche un message dans la console, avec une mise en forme spécifique. En général on l’utilise plutôt pour afficher des informations relatives au déroulement de la fonction.\nDans l’exemple suivant, on utilise la fonction runif() pour générer aléatoirement n nombres entre 0 et 1 et on affiche avec cat() la valeur du plus petit nombre généré. Comme l’exécution du runif() peut prendre du temps si n est grand, on affiche un message avec message() pour prévenir l’utilisateur.\n\nmin_alea &lt;- function(n) {\n  message(\"Génération de \", n, \" nombres aléatoires...\")\n  v &lt;- runif(n)\n  cat(\"Le plus petit nombre généré vaut\", min(v))\n}\n\nmin_alea(50000)\n#&gt; Génération de 50000 nombres aléatoires...\n#&gt; Le plus petit nombre généré vaut 0.000009738607\n\n\n\n14.1.4 Utilité des fonctions\nOn peut se demander dans quels cas il est utile de créer une fonction.\nUne règle courante considère que dès qu’on a répété le même code plus de deux fois, il est préférable d’en faire une fonction. Celles-ci ont en effet comme avantage d’éviter la duplication du code.\nImaginons que nous avons récupéré un jeu de données avec toute une série de variables ayant les modalités \"1\" et \"2\" qui correspondent aux réponses \"Oui\" et \"Non\" à des questions. On crée un data frame fictif comportant quatre variables de ce type :\n\ndf &lt;- data.frame(\n  q1 = c(\"1\", \"1\", \"2\", \"1\"),\n  q2 = c(\"1\", \"2\", \"2\", \"2\"),\n  q3 = c(\"2\", \"2\", \"1\", \"1\"),\n  q4 = c(\"1\", \"2\", \"1\", \"1\")\n)\n\ndf\n#&gt;   q1 q2 q3 q4\n#&gt; 1  1  1  2  1\n#&gt; 2  1  2  2  2\n#&gt; 3  2  2  1  1\n#&gt; 4  1  2  1  1\n\nOn a vu Section 9.3 qu’on peut recoder l’une de ces variables à l’aide de la fonction fct_recode() de l’extension forcats :\n\ndf$q1 &lt;- fct_recode(df$q1,\n  \"Oui\" = \"1\",\n  \"Non\" = \"2\"\n)\n\nOn peut donc être tenté de dupliquer ce code autant de fois qu’on a de questions à recoder :\n\ndf$q1 &lt;- fct_recode(df$q1,\n  \"Oui\" = \"1\",\n  \"Non\" = \"2\"\n)\ndf$q2 &lt;- fct_recode(df$q2,\n  \"Oui\" = \"1\",\n  \"Non\" = \"2\"\n)\ndf$q3 &lt;- fct_recode(df$q3,\n  \"Oui\" = \"1\",\n  \"Non\" = \"2\"\n)\ndf$q4 &lt;- fct_recode(df$q4,\n  \"Oui\" = \"1\",\n  \"Non\" = \"2\"\n)\n\nMais il est plus judicieux dans ce cas de créer une fonction pour ce recodage :\n\nrecode_oui_non &lt;- function(var) {\n  var_recodee &lt;- fct_recode(var,\n    \"Oui\" = \"1\",\n    \"Non\" = \"2\"\n  )\n  return(var_recodee)\n}\n\nEn effet, il est alors très simple d’appliquer ce recodage à plusieurs variables :\n\ndf$q1 &lt;- recode_oui_non(df$q1)\ndf$q2 &lt;- recode_oui_non(df$q2)\ndf$q3 &lt;- recode_oui_non(df$q3)\ndf$q4 &lt;- recode_oui_non(df$q4)\n\nAutre avantage, si on réalise qu’on a commis une erreur et qu’en fait le code \"1\" correspondait à \"Non\" et le code \"2\" à \"Oui\", on n’a pas besoin de modifier tous les endroits où on a copié/collé notre recodage : on a juste à corriger la définition de la fonction.\nLes avantages de procéder ainsi sont donc multiples :\n\ncréer une fonction évite la répétition du code et le rend moins long et plus lisible, surtout si on donne à notre fonction un nom explicite permettant de comprendre facilement ce qu’elle fait.\ncréer une fonction évite les erreurs de copier/coller du code.\nune fonction permet de mettre à jour plus facilement son code : si on se rend compte d’une erreur ou si on souhaite améliorer son fonctionnement, on n’a qu’un seul endroit à modifier.\nenfin, créer des fonctions permet potentiellement de rendre son code réutilisable d’un script à l’autre ou même d’un projet à l’autre. Voire, à terme, de les regrouper dans un package pour soi-même ou pour diffusion à d’autres utilisateurs et utilisatrices de R."
  },
  {
    "objectID": "14-fonctions.html#arguments-et-résultat-dune-fonction",
    "href": "14-fonctions.html#arguments-et-résultat-dune-fonction",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.2 Arguments et résultat d’une fonction",
    "text": "14.2 Arguments et résultat d’une fonction\n\n14.2.1 Définition des arguments\nLes arguments (ou paramètres) d’une fonction sont ce qu’on lui donne “en entrée”, et qui vont soit lui fournir des données, soit modifier son comportement. La liste des arguments acceptés par une fonction est indiquée entre les parenthèses de l’appel de function() :\n\nma_fonction &lt;- function(arg1, arg2, arg3) {\n  print(arg1)\n  print(arg2)\n  print(arg3)\n}\n\n\n\n\n\n\n\nNote\n\n\n\nUne fonction peut aussi ne pas accepter d’arguments, dans ce cas on la définit juste avec function().\n\n\nLors de l’appel de la fonction, on peut lui passer les arguments par position :\n\nma_fonction(x, 12, TRUE)\n\nDans ce cas, arg1 vaudra x, arg2 vaudra 12 et arg3 vaudra TRUE.\nOn peut aussi passer les arguments par nom :\n\nma_fonction(arg1 = x, arg2 = 12, arg3 = TRUE)\n\nQuand on passe les arguments par nom, on peut les indiquer dans l’ordre que l’on souhaite :\n\nma_fonction(arg1 = x, arg3 = TRUE, arg2 = 12)\n\nEt on peut évidemment mélanger passage par position et passage par nom :\n\nma_fonction(x, 12, arg3 = TRUE)\n\nLe plus souvent, les premiers arguments acceptés par une fonction sont les données sur lesquelles elle va travailler, tandis que les arguments suivants sont des paramètres qui vont modifier son comportement. Par exemple, median accepte comme premier argument x, un vecteur, puis un argument na.rm qui va changer sa manière de calculer la médiane des valeurs de x.\n\n\n\n\n\n\nNote\n\n\n\nEn général on appelle la fonction en passant les paramètres correspondant aux données par position, et les autres en les nommant. C’est ainsi qu’on ne fait ni median(x = tailles, na.rm = TRUE) ni median(tailles, TRUE), mais plutôt median(tailles, na.rm = TRUE).\nEn ce qui concerne le nom des arguments, en général ceux correspondant aux données transmises à une fonction peuvent avoir des noms relativement génériques (x, y, v pour un vecteur, data ou df pour un data.frame…). Les autres doivent par contre avoir des noms à la fois courts et explicites : par exemple plutôt decimales que nd ou nombre_de_decimales.\n\n\n\n\n14.2.2 Valeurs par défaut\nAu moment de la définition de la fonction, on peut indiquer une valeur par défaut qui sera prise par l’argument si la personne qui utilise la fonction n’en fournit pas.\nSi on reprend la fonction prop_tab déjà définie plus haut :\n\nprop_tab &lt;- function(v, decimales, useNA) {\n  tri &lt;- table(v, useNA = useNA)\n  tri &lt;- tri / length(v) * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nOn peut indiquer une valeur par défaut aux arguments decimales et useNA de la manière suivante :\n\nprop_tab &lt;- function(v, decimales = 1, useNA = \"ifany\") {\n  tri &lt;- table(v, useNA = useNA)\n  tri &lt;- tri / length(v) * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nSi on appelle prop_tab en lui passant uniquement le vecteur v, on voit que decimales vaut bien 1 et useNA vaut bien `“ifany”:\n\nprop_tab(hdv2003$qualif)\n#&gt; v\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                     10.2                     14.6                      4.3 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                      8.0                     13.0                     29.7 \n#&gt;                    Autre                     &lt;NA&gt; \n#&gt;                      2.9                     17.3\n\n\n\n14.2.3 Arguments obligatoires et arguments facultatifs\nSi un argument n’a pas de valeur par défaut, il est obligatoire : si l’utilisateur essaye d’appeler la fonction sans définir cet argument, cela génère une erreur.\n\nprop_tab &lt;- function(v, decimales, useNA) {\n  tri &lt;- table(v, useNA = useNA)\n  tri &lt;- tri / length(v) * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nprop_tab(hdv2003$sexe)\n#&gt; Error in match.arg(useNA): argument \"useNA\" is missing, with no default\n\n\n\n\n\n\n\nNote\n\n\n\nPour être tout à fait précis, l’erreur est générée uniquement lorsque l’argument sans valeur par défaut est utilisé dans la fonction.\n\n\nSi à l’inverse un argument a une valeur par défaut, il devient facultatif : on peut appeler la fonction sans le définir.\n\nprop_tab &lt;- function(v, decimales = 1, useNA = \"ifany\") {\n  tri &lt;- table(v, useNA = useNA)\n  tri &lt;- tri / length(v) * 100\n  tri &lt;- round(tri, decimales)\n  return(tri)\n}\n\nprop_tab(hdv2003$sexe)\n#&gt; v\n#&gt; Homme Femme \n#&gt;    45    55\n\nParfois un argument est facultatif mais on n’a pas forcément de valeur par défaut à lui attribuer. Dans ce cas on lui attribue en général par défaut la valeur NULL, et on utilise l’instruction if() dans la fonction pour tester s’il a été défini ou pas. Ce cas de figure est détaillé Section 17.2.4.\n\n\n14.2.4 L’argument ...\nUne fonction peut prendre un argument spécial nommé ... :\n\nma_fonction &lt;- function(x, correct = TRUE, ...) {\n  \n}\n\nCet argument spécial “capture” tous les arguments présents et qui n’ont pas été définis avec la fonction. Par exemple, si on appelle la fonction précédente avec :\n\nma_fonction(1:5, correct = FALSE, title = \"Titre\", size = 12)\n\nAlors ... contiendra les arguments title et size et leurs valeurs.\n\n\n\n\n\n\nNote\n\n\n\nSi on veut accéder à la valeur de size dans ..., on utilise list(...)$size.\n\n\nEn général ... est utilisé pour passer ces arguments à d’autres fonctions. Reprenons notre fonction my_barplot définie précédemment :\n\nmy_barplot &lt;- function(var) {\n  tri &lt;- table(var)\n  barplot(tri, col = \"skyblue\", border = NA)\n}\n\nOn pourrait permettre de personnaliser les couleurs des barres et de leurs bordures en ajoutant des arguments supplémentaires :\n\nmy_barplot &lt;- function(var, col = \"skyblue\", border = NA) {\n  tri &lt;- table(var)\n  barplot(tri, col = col, border = border)\n}\n\nMais si on veut aussi permettre de personnaliser d’autres arguments de barplot comme main, xlab, xlim… il faudrait rajouter autant d’arguments supplémentaires à notre fonction, ce qui deviendrait vite ingérable. Une solution est de “capturer” tous les arguments supplémentaires avec ... et de les passer directement à barplot, de cette manière :\n\nmy_barplot &lt;- function(var, ...) {\n  tri &lt;- table(var)\n  tri &lt;- sort(tri)\n  barplot(tri, ...)\n}\n\nCe qui permet d’appeler notre fonction avec tous les arguments possibles de barplot, par exemple :\n\nmy_barplot(\n  hdv2003$clso,\n  col = \"yellowgreen\",\n  main = \"Croyez-vous en l'existence des classes sociales ?\"\n)\n\n\n\n\n\n\n14.2.5 Résultat d’une fonction\nOn l’a vu, l’objectif d’une fonction est en général de renvoyer un résultat. Lors de la définition d’une fonction, le résultat peut être retourné en utilisant la fonction return() :\n\najoute2 &lt;- function(x) {\n  res &lt;- x + 2\n  return(res)\n}\n\nEn réalité, l’utilisation de return() n’est pas obligatoire : une fonction retourne automatiquement le résultat de la dernière instruction qu’elle exécute. On aurait donc pu écrire :\n\najoute2 &lt;- function(x) {\n  res &lt;- x + 2\n  res\n}\n\nOu même, encore mieux et plus lisible :\n\najoute2 &lt;- function(x) {\n  x + 2\n}\n\n\n\n\n\n\n\nAvertissement\n\n\n\nDans la suite de ce document on utilisera, lorsque c’est possible, la syntaxe la plus “compacte” qui omet le return().\n\n\nUn point important à noter : lorsque R rencontre une instruction return() dans une fonction, il interrompt immédiatement son exécution et “sort” de la fonction en renvoyant le résultat.\nAinsi, dans la fonction suivante :\n\najoute2 &lt;- function(x) {\n  return(x + 2)\n  x * 5\n}\n\nL’instruction x * 5 ne sera jamais exécutée car R “sort” de la fonction dès qu’il évalue le return() de la ligne précédente.\nConséquence de ce comportement, on ne peut pas utiliser plusieurs return() pour renvoyer plusieurs résultats depuis une seule fonction. Est-ce à dire qu’une fonction R ne pourrait renvoyer qu’une seule valeur ? Non, car si elle ne peut retourner qu’un seul objet, celui-ci peut être complexe et comporter plusieurs valeurs.\nPar exemple, on a vu précédemment une fonction rudimentaire nommée indicateurs() qui affiche la moyenne et l’écart-type d’un vecteur numérique.\n\nindicateurs &lt;- function(v) {\n  print(mean(v))\n  print(sd(v))\n}\n\nPlutôt que de se contenter de les afficher dans la console, on pourrait vouloir retourner ces deux valeurs pour pouvoir les réutiliser par la suite. Pour cela, une première solution pourrait être de renvoyer un vecteur comportant ces deux valeurs.\n\nindicateurs &lt;- function(v) {\n  moyenne &lt;- mean(v)\n  ecart_type &lt;- sd(v)\n  c(moyenne, ecart_type)\n}\n\n\nindicateurs(hdv2003$age)\n#&gt; [1] 48.15700 16.94181\n\nMais dans ce cas de figure il est recommandé de retourner plutôt une liste nommée2, de cette manière :\n\nindicateurs &lt;- function(v) {\n  moyenne &lt;- mean(v)\n  ecart_type &lt;- sd(v)\n  list(moyenne = moyenne, ecart_type = ecart_type)\n}\n\n\nindicateurs(hdv2003$age)\n#&gt; $moyenne\n#&gt; [1] 48.157\n#&gt; \n#&gt; $ecart_type\n#&gt; [1] 16.94181\n\nOn a du coup un affichage un peu plus lisible, et on peut accéder aux éléments du résultat via leur nom :\n\nres &lt;- indicateurs(hdv2003$age)\nres$moyenne\n#&gt; [1] 48.157"
  },
  {
    "objectID": "14-fonctions.html#portée-des-variables",
    "href": "14-fonctions.html#portée-des-variables",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.3 Portée des variables",
    "text": "14.3 Portée des variables\nUn point délicat mais important quand on commence à créer ses propres fonctions concerne la portée des variables, c’est-à-dire la façon dont les objets créés dans une fonction et ceux existant en-dehors “cohabitent”. C’est une question assez complexe, mais seules quatre grandes règles sont réellement utiles au départ.\n\n14.3.1 Une fonction peut accéder à un objet extérieur\nSi on fait appel dans une fonction à un objet qui n’existe pas et n’a pas été passé comme argument, on obtient une erreur.\n\nf &lt;- function() {\n  obj\n}\n\nf()\n#&gt; Error in f(): object 'obj' not found\n\nSi on crée cet objet dans notre fonction avant de l’utiliser, on supprime évidemment l’erreur.\n\nf &lt;- function() {\n  obj &lt;- 2\n  obj\n}\n\nf()\n#&gt; [1] 2\n\nMais on peut aussi accéder depuis une fonction à un objet qui existe dans notre environnement au moment où la fonction a été appelée.\n\nf &lt;- function() {\n  obj\n}\n\nobj &lt;- 3\nf()\n#&gt; [1] 3\n\nDans cet exemple, au moment de l’exécution de f(), comme obj n’existe pas au sein de la fonction (il n’a pas été passé comme argument ni défini dans le corps de la fonction), R va chercher dans l’environnement global, celui depuis lequel la fonction a été appelée. Comme il trouve un objet obj, il utilise sa valeur au moment de l’appel de la fonction.\n\n\n14.3.2 Les arguments et les objets créés dans la fonction sont prioritaires\nQue se passe-t-il si un objet avec le même nom existe à la fois dans la fonction et dans notre environnement global ? Dans ce cas R privilégie l’objet créé dans la fonction.\n\nf &lt;- function() {\n  obj &lt;- 10\n  obj\n}\n\nobj &lt;- 3\nf()\n#&gt; [1] 10\n\nCette règle s’applique également pour les arguments passés à la fonction.\n\nf &lt;- function(obj) {\n  obj\n}\n\nobj &lt;- 3\nf(20)\n#&gt; [1] 20\n\n\n\n14.3.3 Un objet créé dans une fonction n’existe que dans cette fonction\nAutre règle importante : un objet créé à l’intérieur d’une fonction n’est pas accessible à l’extérieur de celle-ci.\n\nf &lt;- function() {\n  nouvel_objet &lt;- 15\n  nouvel_objet\n}\n\nf()\n#&gt; [1] 15\nnouvel_objet\n#&gt; Error in eval(expr, envir, enclos): object 'nouvel_objet' not found\n\nIci, nouvel_objet existe tant qu’on est dans la fonction, mais il est détruit dès qu’on en sort et donc inaccessible dans notre environnement global.\n\n\n\n\n\n\nAvertissement\n\n\n\nLes objets créés dans notre session et qui existent dans notre environnement (tel que visible dans l’onglet Environment de RStudio) sont appelés des objets globaux : ils existent et sont accessibles pour les fonctions appelées depuis cet environnement. Les objets créés lors de l’exécution d’une fonction sont à l’inverse des objets locaux : ils n’existent qu’à l’intérieur de la fonction et pour la durée de son exécution. Si deux objets du même nom coexistent, l’objet local est prioritaire par rapport à l’objet global.\n\n\n\n\n14.3.4 On ne peut pas modifier un objet global dans une fonction\nUne conséquence importante de la troisième règle est qu’il n’est pas possible de modifier un objet de notre environnement global depuis une fonction3 :\n\nf &lt;- function() {\n  obj &lt;- 10\n  message(\"Valeur dans la fonction : \", obj)\n}\n\nobj &lt;- 3\nf()\n#&gt; Valeur dans la fonction : 10\nobj\n#&gt; [1] 3\n\nPour comprendre le résultat obtenu, on peut essayer de décomposer pas à pas :\n\nAu moment du obj &lt;- 3, R crée un objet global nommé obj avec la valeur 3.\nQuand on exécute f() et qu’on rencontre l’instruction obj &lt;- 10, R crée un nouvel objet nommé obj, local celui-ci, avec la valeur 10. À ce moment-là on a donc deux objets distincts portant le même nom, l’un global avec la valeur 3, l’autre local avec la valeur 10. Comme l’objet local est prioritaire, c’est lui qui est utilisé lors de l’affichage du message.\nLorsqu’on sort de f(), l’objet local contenant la valeur 10 est détruit. Il ne reste plus que l’objet global avec la valeur 3. C’est donc lui qui est affiché lors du dernier appel à obj.\n\nPour les mêmes raisons, dans l’exemple suivant, le recodage appliqué à la variable taille du tableau df passé en argument à la fonction recode_taille() n’est pas conservé en-dehors de la fonction. Ce recodage n’existe que dans un tableau d local à la fonction, et détruit dès qu’on en est sorti.\n\ndf &lt;- data.frame(taille = c(155, 182), poids = c(65, 71))\n\nrecode_taille &lt;- function(d) {\n  d$taille &lt;- d$taille / 100\n}\n\nrecode_taille(df)\n\n# Le recodage n'est pas conservé\ndf\n#&gt;   taille poids\n#&gt; 1    155    65\n#&gt; 2    182    71\n\nSi on souhaite modifier un objet global, on doit le passer comme argument en entrée de notre fonction, et le renvoyer comme résultat en sortie. Pour que le recodage précédent soit bien répercuté dans notre tableau df, on doit faire :\n\nrecode_taille &lt;- function(d) {\n  d$taille &lt;- d$taille / 100\n  d\n}\n\ndf &lt;- recode_taille(df)\n\n# Le recodage est bien conservé\ndf\n#&gt;   taille poids\n#&gt; 1   1.55    65\n#&gt; 2   1.82    71"
  },
  {
    "objectID": "14-fonctions.html#les-fonctions-comme-objets",
    "href": "14-fonctions.html#les-fonctions-comme-objets",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.4 Les fonctions comme objets",
    "text": "14.4 Les fonctions comme objets\nQuand on crée une fonction, on la “nomme” en la stockant dans un objet. Cet objet peut être utilisé comme n’importe quel autre objet dans R. On peut ainsi copier une fonction en l’attribuant à un nouvel objet :\n\nf &lt;- function(x) {\n  x + 2\n}\n\ng &lt;- f\ng(10)\n#&gt; [1] 12\n\nOn a déjà vu à de nombreuses reprises que quand on fournit juste un nom d’objet à R, celui-ci affiche son contenu dans la console. C’est aussi le cas pour les fonctions : dans ce cas c’est le code source de la fonction qui est affiché.\n\nf\n#&gt; function(x) {\n#&gt;   x + 2\n#&gt; }\n\n\n14.4.1 Passer des fonctions comme argument\nCertaines fonctions sont prévues pour s’appliquer elles-mêmes à des fonctions. Par exemple, formals et body permettent d’afficher respectivement les arguments et le corps d’une fonction passée en argument.\n\nformals(f)\n#&gt; $x\n\n\nbody(f)\n#&gt; {\n#&gt;     x + 2\n#&gt; }\n\nIl est donc possible de passer une fonction comme argument d’une autre fonction, comme dans body(f). On a déjà vu un exemple de ce type de fonctionnement avec la fonction tapply Section 4.2.2. Celle-ci prend trois arguments : un vecteur de valeurs, un facteur, et une fonction. Elle applique ensuite la fonction aux valeurs pour chaque niveau du facteur.\nPar exemple, si on a un data frame avec une liste de fruits et leur poids :\n\ndf &lt;- data.frame(\n  fruit = c(\"Pomme\", \"Pomme\", \"Citron\", \"Citron\"),\n  poids = c(147, 189, 76, 91)\n)\n\ndf\n#&gt;    fruit poids\n#&gt; 1  Pomme   147\n#&gt; 2  Pomme   189\n#&gt; 3 Citron    76\n#&gt; 4 Citron    91\n\nOn peut utiliser tapply pour calculer le poids moyen par type de fruit.\n\ntapply(df$poids, df$fruit, mean)\n#&gt; Citron  Pomme \n#&gt;   83.5  168.0\n\nSi on souhaite plutôt calculer le poids maximal, il suffit de passer à tapply la fonction max plutôt que la fonction mean.\n\ntapply(df$poids, df$fruit, max)\n#&gt; Citron  Pomme \n#&gt;     91    189\n\nCette manière de transmettre une fonction à une autre fonction peut être un peu déroutante de prime abord, mais c’est une mécanique qu’on va retrouver très souvent dans les chapitres suivants.\n\n\n\n\n\n\nAvertissement\n\n\n\nSi f est une fonction, il est important de bien faire la différence entre f et f() :\n\nf est la fonction en elle-même\nf() est le résultat de la fonction quand on l’exécute sans lui passer d’argument\n\nQuand on passe une fonction comme argument à une autre fonction, on utilise donc toujours la notation sans les parenthèses.\n\n\n\n\n14.4.2 Fonctions anonymes\nDans le cas où on souhaite calculer quelque chose pour lequel une fonction n’existe pas déjà, on peut créer une nouvelle fonction :\n\npoids_moyen_kg &lt;- function(poids) {\n  mean(poids / 1000)\n}\n\nEt la passer en argument à tapply() :\n\ntapply(df$poids, df$fruit, poids_moyen_kg)\n#&gt; Citron  Pomme \n#&gt; 0.0835 0.1680\n\nSi on ne souhaite pas réutiliser cette fonction par la suite, on peut aussi définir cette fonction directement comme argument de tapply :\n\ntapply(df$poids, df$fruit, function(poids) {\n  mean(poids/1000)\n})\n#&gt; Citron  Pomme \n#&gt; 0.0835 0.1680\n\nDans ce cas on a créé ce qu’on appelle une fonction anonyme, qui n’a pas de nom (elle n’a pas été stockée dans un objet), et qui n’existe que le temps de l’appel à tapply."
  },
  {
    "objectID": "14-fonctions.html#ressources",
    "href": "14-fonctions.html#ressources",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.5 Ressources",
    "text": "14.5 Ressources\nL’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre complet d’introduction sur les fonctions.\nL’ouvrage Advanced R (également en anglais) aborde de manière très approfondie les fonctions ainsi que la programmation fonctionnelle.\nLe manuel officiel Introduction to R (toujours en anglais) contient une partie sur l’écriture de ses propres fonctions."
  },
  {
    "objectID": "14-fonctions.html#exercices",
    "href": "14-fonctions.html#exercices",
    "title": "14  Écrire ses propres fonctions",
    "section": "14.6 Exercices",
    "text": "14.6 Exercices\n\n14.6.1 Introduction et exemples\nExercice 1.1\nÉcrire une fonction nommée perimetre qui prend en entrée un argument nommé r et retourne le périmètre d’un cercle de rayon r, c’est-à-dire 2 * pi * r (pi est un objet R qui contient la valeur de \\(\\pi\\)).\nVérifier avec l’appel suivant :\n\nperimetre(4)\n#&gt; [1] 25.13274\n\n\n\nperimetre &lt;- function(r) {\n  resultat &lt;- 2 * pi * r\n  return(resultat)\n}\n\n\nExercice 1.2\nÉcrire une fonction etendue qui prend en entrée un vecteur numérique et retourne la différence entre la valeur maximale et la valeur minimale de ce vecteur.\nVérifier avec l’appel suivant :\n\netendue(c(18, 35, 21, 40))\n#&gt; [1] 22\n\n\n\netendue &lt;- function(v) {\n  vmax &lt;- max(v)\n  vmin &lt;- min(v)\n  return(vmax - vmin)\n}\n\n\nExercice 1.3\nÉcrire une fonction nommée alea qui accepte un argument n, génère un vecteur de n valeurs aléatoires entre 0 et 1 avec la fonction runif(n) et retourne ce vecteur comme résultat.\n\n\nalea &lt;- function(n) {\n  v &lt;- runif(n)\n  return(v)\n}\n\n\nModifier la fonction pour qu’elle accepte deux arguments supplémentaires min et max et qu’elle retourne un vecteur de n valeurs aléatoires comprises entre min et max avec la fonction runif(n, min, max).\n\n\nalea &lt;- function(n, min, max) {\n  v &lt;- runif(n, min, max)\n  return(v)\n}\n\n\nModifier à nouveau la fonction pour qu’elle retourne un vecteur de n nombres entiers aléatoires compris entre min et max en appliquant la fonction trunc() au vecteur généré par runif().\nVérifier le résultat avec :\n\nv &lt;- alea(10000, 1, 6)\ntable(v)\n#&gt; v\n#&gt;    1    2    3    4    5    6 \n#&gt; 1567 1651 1612 1710 1740 1720\n\n\n\nalea &lt;- function(n, min, max) {\n  v &lt;- runif(n, min, max + 1)\n  v &lt;- trunc(v)\n  return(v)\n}\n\n\nExercice 1.4\nÉcrire une fonction nommée meteo qui prend un argument nommé ville avec le corps suivant :\n\nout &lt;- readLines(paste0(\"https://v2.wttr.in/\", ville, \"?A\"))\ncat(out, sep = \"\\n\")\n\nTester la fonction avec par exemple meteo(\"Lyon\") (il est possible que l’affichage dans la console ne soit pas lisible si vous travaillez sous Windows).\n\n\nmeteo &lt;- function(ville) {\n  out &lt;- readLines(paste0(\"https://v2.wttr.in/\", ville, \"?A\"))\n  cat(out, sep = \"\\n\")\n}\n\n\nExercice 1.5\nSoit le code suivant, qui recode une variable du jeu de données hdv2003 en utilisant str_to_lower() puis fct_recode() :\n\nlibrary(questionr)\nlibrary(tidyverse)\ndata(hdv2003)\n\nhdv2003$hard.rock &lt;- str_to_lower(hdv2003$hard.rock)\nhdv2003$hard.rock &lt;- fct_recode(hdv2003$hard.rock, \"o\" = \"oui\", \"n\" = \"non\")\n\nTransformer ce code en une fonction nommée recode_oui_non, et appliquer cette fonction à hard.rock, lecture.bd et cuisine.\n\n\nrecode_oui_non &lt;- function(var) {\n  var_rec &lt;- str_to_lower(var)\n  var_rec &lt;- fct_recode(var_rec, \"o\" = \"oui\", \"n\" = \"non\")\n  return(var_rec)\n}\n\nhdv2003$hard.rock &lt;- recode_oui_non(hdv2003$hard.rock)\nhdv2003$lecture.bd &lt;- recode_oui_non(hdv2003$lecture.bd)\nhdv2003$cuisine &lt;- recode_oui_non(hdv2003$cuisine)\n\n\n\n\n14.6.2 Arguments et résultat\nExercice 2.1\nObserver le code de la fonction suivante pour comprendre à quoi correspondent chacun de ses trois arguments, puis réordonner et renommer ces arguments de manière plus pertinente :\n\nmoyenne_arrondie &lt;- function(d, vecteur_contenant_les_donnees, supprimer_les_na) {\n  res &lt;- mean(vecteur_contenant_les_donnees, na.rm = supprimer_les_na)\n  res &lt;- round(res, d)\n  return(res)\n}\n\n\n\nmoyenne_arrondie &lt;- function(v, decimales, na.rm) {\n  res &lt;- mean(v, na.rm = na.rm)\n  res &lt;- round(res, decimales)\n  return(res)\n}\n\n\nDonner aux arguments de la fonction une valeur par défaut.\n\n\nmoyenne_arrondie &lt;- function(v, decimales = 2, na.rm = TRUE) {\n  res &lt;- mean(v, na.rm = na.rm)\n  res &lt;- round(res, decimales)\n  return(res)\n}\n\n\nSimplifier la fonction en utilisant la syntaxe plus compacte qui ne fait pas appel à return().\n\n\nmoyenne_arrondie &lt;- function(v, decimales = 2, na.rm = TRUE) {\n  res &lt;- mean(v, na.rm = na.rm)\n  round(res, decimales)\n}\n\n\nExercice 2.2\nSimplifier la fonction suivante pour que son corps ne fasse plus qu’une seule ligne :\n\ncentrer_reduire &lt;- function(x) {\n  res &lt;- x - mean(x)\n  res &lt;- res / sd(x)\n  return(res)\n}\n\n\n\ncentrer_reduire &lt;- function(x) {\n  (x - mean(x)) / sd(x)\n}\n\n\nExercice 2.3\nLe code suivant permet de déterminer la lettre initiale et la longueur d’un mot.\n\ninitiale &lt;- str_sub(mot, 1, 1)\nlongueur &lt;- nchar(mot)\n\nUtiliser ce code pour créer une fonction caracteristiques_mot() qui prend un argument mot et retourne à la fois son initiale et sa longueur.\n\ncaracteristiques_mot(\"Bidonnage\")\n#&gt; $initiale\n#&gt; [1] \"B\"\n#&gt; \n#&gt; $longueur\n#&gt; [1] 9\n\n\n\ncaracteristiques_mot &lt;- function(mot) {\n  initiale &lt;- str_sub(mot, 1, 1)\n  longueur &lt;- nchar(mot)\n  list(initiale = initiale, longueur = longueur)\n}\n\n\nFacultatif : modifier la fonction pour qu’elle retourne un vecteur plutôt qu’une liste, et l’appliquer sur un mot de votre choix. Que constatez-vous ?\n\nComme les vecteurs atomiques ne peuvent contenir que des données du même type, le nombre correspondant à longueur a été converti en chaîne de caractères.\n\n\n\n14.6.3 Portée des variables\nExercice 3.1\nEn lisant les codes suivants, essayer de prévoir quelle va être la valeur affichée par la dernière ligne. Vérifier en exécutant le code :\n\nf &lt;- function() {\n  x &lt;- 3\n  x\n}\n\nf()\n\n\nf &lt;- function() {\n  x\n}\n\nx &lt;- 5\nf()\n\n\nf &lt;- function(x) {\n  x\n}\n\nx &lt;- 5\nf(30)\n\n\nf &lt;- function(x = 100) {\n  x\n}\n\nx &lt;- 5\nf()\n\n\nf &lt;- function(x = 100) {\n  x &lt;- 150\n  x\n}\n\nx &lt;- 5\nf(30)\n\n\nf &lt;- function() {\n  x &lt;- 5\n}\n\nx &lt;- 1000\nf()\nx\n\nExercice 3.2\nDans le code suivant, on a essayé de créer une fonction qui modifie un tableau de données passé en argument pour ne conserver que les lignes correspondant aux pommes. Est-ce que ça fonctionne ?\n\ndf &lt;- data.frame(\n  fruit = c(\"Pomme\", \"Pomme\", \"Citron\", \"Citron\"),\n  poids = c(147, 189, 76, 91)\n)\n\nfiltre_pommes &lt;- function(d) {\n  d &lt;- dplyr::filter(d, fruit == \"Pomme\")\n}\n\nfiltre_pommes(df)\ndf\n\nModifier le code pour obtenir le résultat souhaité.\n\n\nfiltre_pommes &lt;- function(d) {\n  dplyr::filter(d, fruit == \"Pomme\")\n}\n\ndf &lt;- filtre_pommes(df)\ndf\n\n\n\n\n14.6.4 Les fonctions comme objets\nExercice 4.1\nÉcrire une fonction nommée bonjour qui ne prend aucun argument et affiche juste le texte “Bonjour !” dans la console.\n\n\nbonjour &lt;- function() {\n  cat(\"Bonjour !\")\n}\n\n\nExécuter dans la console les deux commandes suivantes tour à tour :\n\nbonjour()\nbonjour\n\nComprenez-vous la différence entre les deux ?\nCopier la fonction dans un nouvel objet nommé salut. Exécuter la nouvelle fonction ainsi créée.\n\n\nsalut &lt;- bonjour\nsalut()\n\n\nExercice 4.2\nConstruire une fonction etendue() qui prend en entrée un vecteur numérique et retourne la différence entre la valeur maximale et la valeur minimale de ce vecteur (vous pouvez récupérer le code de l’exercice 1.2).\n\n\netendue &lt;- function(v) {\n  max(v) - min(v)\n}\n\n\nÀ l’aide de tapply(), appliquez la fonction etendue() à la variable age pour chaque valeur de qualif dans le jeu de données hdv2003.\n\n#&gt;       Ouvrier specialise         Ouvrier qualifie               Technicien \n#&gt;                       74                       68                       62 \n#&gt; Profession intermediaire                    Cadre                  Employe \n#&gt;                       62                       63                       72 \n#&gt;                    Autre \n#&gt;                       78\n\n\n\nlibrary(questionr)\ndata(hdv2003)\n\ntapply(hdv2003$age, hdv2003$qualif, etendue)\n\n\nRéécrire le code précédent en utilisant une fonction anonyme (ie en définissant la fonction directement dans le tapply).\n\n\ntapply(hdv2003$age, hdv2003$qualif, function(v) {\n  max(v) - min(v)\n})\n\n\nExercice 4.3\nExécutez le code suivant. Comprenez-vous les résultats obtenus ?\n\nf &lt;- function(y) {\n  y * 4\n}\n\nbody(f)\nf(5)\n\nbody(f) &lt;- quote(y + 2)\nbody(f)\nf(5)\n\nIntuitivement, comprenez-vous à quoi sert la fonction quote ?"
  },
  {
    "objectID": "14-fonctions.html#footnotes",
    "href": "14-fonctions.html#footnotes",
    "title": "14  Écrire ses propres fonctions",
    "section": "",
    "text": "Le jeu de données hdv2003 fait partie de l’extension questionr, il est décrit Section A.3.2.2.↩︎\nLes listes seront abordées un peu plus en détail Section 16.2.↩︎\nEn réalité c’est possible avec l’opérateur &lt;&lt;-, mais c’est fortement déconseillé dans la très grande majorité des cas.↩︎"
  },
  {
    "objectID": "15-dplyr-avance.html#appliquer-ses-propres-fonctions",
    "href": "15-dplyr-avance.html#appliquer-ses-propres-fonctions",
    "title": "15  dplyr avancé",
    "section": "15.1 Appliquer ses propres fonctions",
    "text": "15.1 Appliquer ses propres fonctions\n\n15.1.1 Exemple avec mutate\nSoit le jeu de données fictif suivant, dont chaque ligne représente un individu pour lequel on dispose de sa PCS, celle de ses parents, son âge et celui de ses enfants.\n\ndf &lt;- tribble(\n    ~id, ~pcs, ~pcs_pere, ~pcs_mere, ~age, ~`age enf1`, ~`age enf2`, ~`age enf3`,\n      1,  \"5\",       \"5\",       \"6\",   25,           2,          NA,          NA,\n      2,  \"3\",       \"3\",       \"2\",   45,          12,           8,           2,\n      3,  \"4\",       \"2\",       \"5\",   29,           7,          NA,          NA,\n      4,  \"2\",       \"1\",       \"4\",   32,           6,           3,          NA,\n      5,  \"1\",       \"4\",       \"3\",   65,          39,          36,          28,\n      6,  \"6\",       \"6\",       \"6\",   51,          18,          12,          NA,\n      7,  \"5\",       \"4\",       \"6\",   37,           8,           4,           1,\n      8,  \"3\",       \"3\",       \"1\",   42,          16,          10,           5\n)\n\ndf\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs   pcs_pere pcs_mere   age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1     1 5     5        6           25          2         NA         NA\n#&gt; 2     2 3     3        2           45         12          8          2\n#&gt; 3     3 4     2        5           29          7         NA         NA\n#&gt; 4     4 2     1        4           32          6          3         NA\n#&gt; 5     5 1     4        3           65         39         36         28\n#&gt; 6     6 6     6        6           51         18         12         NA\n#&gt; 7     7 5     4        6           37          8          4          1\n#&gt; 8     8 3     3        1           42         16         10          5\n\nDans ce tableau les PCS sont indiquées sous forme de codes : il serait plus lisible de les avoir sous forme d’intitulés de catégorie socio-professionnelle. On a vu Section 9.3.2 qu’on peut effectuer ce recodage avec la fonction fct_recode() de l’extension forcats.\n\ndf %&gt;%\n    mutate(\n        pcs = fct_recode(pcs,\n            \"Agriculteur\" = \"1\",\n            \"Indépendant\" = \"2\",\n            \"Cadre\" = \"3\",\n            \"Intermédiaire\" = \"4\",\n            \"Employé\" = \"5\",\n            \"Ouvrier\" = \"6\"\n        )\n    )\n\nPlutôt que d’intégrer le code du recodage directement dans le mutate(), on peut l’extraire en créant une fonction.\n\nrecode_pcs &lt;- function(v) {\n    fct_recode(v,\n        \"Agriculteur\" = \"1\",\n        \"Indépendant\" = \"2\",\n        \"Cadre\" = \"3\",\n        \"Intermédiaire\" = \"4\",\n        \"Employé\" = \"5\",\n        \"Ouvrier\" = \"6\"\n    )\n}\n\nOn peut dès lors simplifier notre mutate en appelant notre nouvelle fonction.\n\ndf %&gt;%\n    mutate(pcs = recode_pcs(pcs))\n\nPremier avantage : on gagne en lisibilité. On a déplacé le code d’une opération spécifique dans une fonction avec un nom “parlant”, ce qui permet de savoir facilement à quoi elle sert. Et on a simplifié notre mutate qui est désormais plus lisible parce qu’il fait apparaître la logique de nos opérations (on veut recoder les PCS) sans en inclure les détails.\nLe deuxième avantage évident, comme pour toute fonction, est qu’on peut la réutiliser pour appliquer ce recodage à plusieurs variables. Ainsi, si on veut recoder de la même manière pcs et pcs_mere, il suffit de faire :\n\ndf %&gt;%\n    mutate(\n        pcs = recode_pcs(pcs),\n        pcs_mere = recode_pcs(pcs_mere)\n    )\n\nLe code est plus court, plus lisible, on évite les erreurs de copier/coller, et si on souhaite modifier le recodage on n’a à intervenir qu’à un seul endroit en modifiant notre fonction.\n\n\n15.1.2 Exemple avec summarise\nAutre exemple, cette fois sur le jeu de données rp2018. Imaginons qu’on souhaite calculer, pour chaque région, le pourcentage de communes dont le nom se termine par une série de caractères donnée : par exemple, le pourcentage de communes dont le nom se termine par “ac”.\nComme il ne s’agit pas forcément d’une question triviale, on va décomposer le problème et rappeler (comme vu Section 11.6) que la fonction str_detect() de l’extension stringr permet de détecter quels éléments d’un vecteur de chaînes de caractères correspondent à une expression régulière. Ainsi, si on veut détecter si un nom de commune (variable rp2018$commune) se termine par \"ac\", on utilisera :\n\nstr_detect(rp2018$commune, \"ac$\")\n\n\n\n\n\n\n\nNote\n\n\n\nLe symbole \\$ dans l’expression régulière \"ac$\" représente la fin de la chaîne de caractères. Il permet de s’assurer qu’on ne détecte que les noms de communes se terminant par “ac” (comme “Figeac”), et pas ceux contenant “ac” à un autre endroit (comme “Arcachon”).\n\n\nSi on veut compter le nombre de communes pour lesquelles on a détecté une terminaison en “ac”, on peut utiliser un idiome courant en R et appliquer la fonction sum() au résultat précédent : les TRUE du résultat du str_detect sont alors convertis en 1, les FALSE en 0, et le sum() renverra donc le nombre de TRUE.\n\nsum(str_detect(rp2018$commune, \"ac$\"))\n#&gt; [1] 131\n\nSi on souhaite convertir ce résultat en pourcentage, il faut qu’on divise par le nombre total de communes, et qu’on multiplie par 100.\n\nsum(str_detect(rp2018$commune, \"ac$\")) / length(rp2018$commune) * 100\n#&gt; [1] 2.418313\n\nOn crée une fonction nommée prop_suffixe qui a pour objectif d’effectuer ce calcul. Elle prend en entrée deux arguments : un vecteur de chaînes de caractères et un suffixe à détecter, et retourne le pourcentage d’éléments du vecteur se terminant par le suffixe. On rajoute nous-même le “$” à la fin du suffixe en question pour faciliter l’usage de la fonction.\nLe résultat final est le suivant :\n\nprop_suffixe &lt;- function(v, suffixe) {\n    # On ajoute $ à la fin du suffixe pour capturer uniquement en fin de chaîne\n    suffixe &lt;- paste0(suffixe, \"$\")\n    # Détection du suffixe\n    nb_detect &lt;- sum(str_detect(v, suffixe))\n    # On retourne le pourcentage\n    nb_detect / length(v) * 100\n}\n\nOn peut utiliser notre fonction de la manière suivante :\n\nprop_suffixe(rp2018$commune, \"ac\")\n#&gt; [1] 2.418313\n\nOn a donc dans notre jeu de données 2.42% de communes dont le nom se termine par “ac”1.\nSi maintenant on souhaite calculer ce pourcentage pour toutes les régions françaises, il suffit d’appeler notre fonction dans un summarise :\n\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(prop_ac = prop_suffixe(commune, \"ac\")) %&gt;%\n    arrange(desc(prop_ac))\n#&gt; # A tibble: 17 × 2\n#&gt;    region                     prop_ac\n#&gt;    &lt;chr&gt;                        &lt;dbl&gt;\n#&gt;  1 Nouvelle-Aquitaine          10.8  \n#&gt;  2 Occitanie                    4.39 \n#&gt;  3 Bretagne                     4.26 \n#&gt;  4 Auvergne-Rhône-Alpes         2.25 \n#&gt;  5 Pays de la Loire             2.20 \n#&gt;  6 Bourgogne-Franche-Comté      0.995\n#&gt;  7 Provence-Alpes-Côte d'Azur   0.581\n#&gt;  8 Normandie                    0.347\n#&gt;  9 Hauts-de-France              0.185\n#&gt; 10 Centre-Val de Loire          0    \n#&gt; 11 Corse                        0    \n#&gt; 12 Grand Est                    0    \n#&gt; 13 Guadeloupe                   0    \n#&gt; 14 Guyane                       0    \n#&gt; 15 La Réunion                   0    \n#&gt; 16 Martinique                   0    \n#&gt; 17 Île-de-France                0\n\nL’avantage d’avoir créé une fonction pour effectuer cette opération et qu’on peut du coup très facilement faire le même calcul en faisant varier le suffixe recherché.\n\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(prop_ac = prop_suffixe(commune, \"ieu\")) %&gt;%\n    arrange(desc(prop_ac))\n#&gt; # A tibble: 17 × 2\n#&gt;    region                     prop_ac\n#&gt;    &lt;chr&gt;                        &lt;dbl&gt;\n#&gt;  1 Auvergne-Rhône-Alpes         2.79 \n#&gt;  2 Occitanie                    0.763\n#&gt;  3 Bourgogne-Franche-Comté      0.498\n#&gt;  4 Pays de la Loire             0.489\n#&gt;  5 Normandie                    0.347\n#&gt;  6 Nouvelle-Aquitaine           0.187\n#&gt;  7 Bretagne                     0    \n#&gt;  8 Centre-Val de Loire          0    \n#&gt;  9 Corse                        0    \n#&gt; 10 Grand Est                    0    \n#&gt; 11 Guadeloupe                   0    \n#&gt; 12 Guyane                       0    \n#&gt; 13 Hauts-de-France              0    \n#&gt; 14 La Réunion                   0    \n#&gt; 15 Martinique                   0    \n#&gt; 16 Provence-Alpes-Côte d'Azur   0    \n#&gt; 17 Île-de-France                0\n\nEn créant une fonction plutôt qu’en mettant notre code directement dans le summarise on a un script plus lisible, plus facile à maintenir, et des fonctionnalités facilement réutilisables.\n\n\n15.1.3 Exemple avec rename_with\nOn a vu Section 10.2.3 que dplyr propose la fonction rename() pour renommer des colonnes d’un tableau de données. On peut l’utiliser par exemple pour remplacer un espace par un _ dans le nom d’une variable de df.\n\ndf %&gt;% rename(\"age_enf1\" = \"age enf1\")\n\nSupposons maintenant qu’on souhaite appliquer la même transformation à l’ensemble des variables de df. Une solution pour cela est d’utiliser la fonction rename_with(), toujours fournie par dplyr, qui prend en argument non pas une correspondance \"nouveau nom\" = \"ancien nom\" mais une fonction qui sera appliquée à l’ensemble des noms de colonnes.\nPar exemple, si on souhaite convertir tous les noms de colonnes en majuscules, on peut passer comme argument la fonction str_to_upper() de stringr.\n\ndf %&gt;% rename_with(str_to_upper)\n#&gt; # A tibble: 8 × 8\n#&gt;      ID PCS   PCS_PERE PCS_MERE   AGE `AGE ENF1` `AGE ENF2` `AGE ENF3`\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1     1 5     5        6           25          2         NA         NA\n#&gt; 2     2 3     3        2           45         12          8          2\n#&gt; 3     3 4     2        5           29          7         NA         NA\n#&gt; 4     4 2     1        4           32          6          3         NA\n#&gt; 5     5 1     4        3           65         39         36         28\n#&gt; 6     6 6     6        6           51         18         12         NA\n#&gt; 7     7 5     4        6           37          8          4          1\n#&gt; 8     8 3     3        1           42         16         10          5\n\nPour remplacer les espaces par des _, on va d’abord créer une fonction ad hoc qui utilise str_replace_all.\n\nremplace_espaces &lt;- function(v) {\n    str_replace_all(v, \" \", \"_\")\n}\n\nDès lors, on peut appliquer cette fonction à l’ensemble de nos noms de variables :\n\ndf %&gt;% rename_with(remplace_espaces)\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs   pcs_pere pcs_mere   age age_enf1 age_enf2 age_enf3\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1     1 5     5        6           25        2       NA       NA\n#&gt; 2     2 3     3        2           45       12        8        2\n#&gt; 3     3 4     2        5           29        7       NA       NA\n#&gt; 4     4 2     1        4           32        6        3       NA\n#&gt; 5     5 1     4        3           65       39       36       28\n#&gt; 6     6 6     6        6           51       18       12       NA\n#&gt; 7     7 5     4        6           37        8        4        1\n#&gt; 8     8 3     3        1           42       16       10        5\n\nCertain.es lectrices et lecteurs attentives auront peut-être noté que le même résultat peut être obtenu en utilisant remplace_espaces() avec la fonction names().\n\nnames(df) &lt;- remplace_espaces(names(df))\n\nL’avantage de rename_with() c’est qu’elle peut s’intégrer dans un pipeline de dplyr, et, comme nous allons le voir un peu plus loin, permet si nécessaire de n’appliquer cette transformation qu’à certaines colonnes seulement."
  },
  {
    "objectID": "15-dplyr-avance.html#sec-across",
    "href": "15-dplyr-avance.html#sec-across",
    "title": "15  dplyr avancé",
    "section": "15.2 across() : appliquer des fonctions à plusieurs colonnes",
    "text": "15.2 across() : appliquer des fonctions à plusieurs colonnes\n\n15.2.1 Appliquer une fonction à plusieurs colonnes\nOn a défini précédemment une fonction qui recode les modalités d’une variable PCS et on a vu comment appliquer ce recodage à deux variables de df.\n\nrecode_pcs &lt;- function(v) {\n    fct_recode(v,\n        \"Agriculteur\" = \"1\",\n        \"Indépendant\" = \"2\",\n        \"Cadre\" = \"3\",\n        \"Intermédiaire\" = \"4\",\n        \"Employé\" = \"5\",\n        \"Ouvrier\" = \"6\"\n    )\n}\n\ndf %&gt;%\n    mutate(\n        pcs = recode_pcs(pcs),\n        pcs_mere = recode_pcs(pcs_mere)\n    )\n\nSupposons qu’on souhaite appliquer ce recodage à toutes les variables PCS de notre tableau. On pourrait évidemment créer autant de lignes que nécessaires dans notre mutate, mais on peut aussi utiliser la fonction across() de dplyr, qui facilite justement ce type d’opérations.\nacross() prend deux arguments principaux :\n\nla définition d’un ensemble de colonnes de notre tableau de données\nune ou plusieurs fonctions à appliquer aux colonnes sélectionnées\n\nIl existe de nombreuses manières de définir les colonnes qu’on souhaite transformer : celles-ci sont en fait les mêmes que celles offertes par des verbes de dplyr comme select().\nUne première possibilité est d’utiliser c() en lui passant les noms des variables (on notera qu’on n’est pas obligés de mettre ces noms entre guillemets).\n\ndf %&gt;%\n    mutate(\n        across(\n            c(pcs, pcs_mere),\n            recode_pcs\n        )\n    )\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs           pcs_pere pcs_mere        age `age enf1` `age enf2` age e…¹\n#&gt;   &lt;dbl&gt; &lt;fct&gt;         &lt;chr&gt;    &lt;fct&gt;         &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     1 Employé       5        Ouvrier          25          2         NA      NA\n#&gt; 2     2 Cadre         3        Indépendant      45         12          8       2\n#&gt; 3     3 Intermédiaire 2        Employé          29          7         NA      NA\n#&gt; 4     4 Indépendant   1        Intermédiaire    32          6          3      NA\n#&gt; 5     5 Agriculteur   4        Cadre            65         39         36      28\n#&gt; 6     6 Ouvrier       6        Ouvrier          51         18         12      NA\n#&gt; 7     7 Employé       4        Ouvrier          37          8          4       1\n#&gt; 8     8 Cadre         3        Agriculteur      42         16         10       5\n#&gt; # … with abbreviated variable name ¹​`age enf3`\n\nUne autre possibilité est d’utiliser :, qui permet de définir une plage de colonnes en lui indiquant la colonne de début et la colonne de fin. Ainsi dans l’exemple suivant notre recodage est appliqué à toutes les colonnes situées entre pcs et pcs_mere (incluses).\n\ndf %&gt;%\n    mutate(\n        across(\n            pcs:pcs_pere,\n            recode_pcs\n        )\n    )\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs           pcs_pere      pcs_mere   age `age enf1` `age enf2` age e…¹\n#&gt;   &lt;dbl&gt; &lt;fct&gt;         &lt;fct&gt;         &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     1 Employé       Employé       6           25          2         NA      NA\n#&gt; 2     2 Cadre         Cadre         2           45         12          8       2\n#&gt; 3     3 Intermédiaire Indépendant   5           29          7         NA      NA\n#&gt; 4     4 Indépendant   Agriculteur   4           32          6          3      NA\n#&gt; 5     5 Agriculteur   Intermédiaire 3           65         39         36      28\n#&gt; 6     6 Ouvrier       Ouvrier       6           51         18         12      NA\n#&gt; 7     7 Employé       Intermédiaire 6           37          8          4       1\n#&gt; 8     8 Cadre         Cadre         1           42         16         10       5\n#&gt; # … with abbreviated variable name ¹​`age enf3`\n\nOn peut aussi sélectionner les variables via leurs noms. On peut ainsi choisir les variables qui commencent par une certaine chaîne de caractères via la fonction starts_with(), celles qui se terminent ou qui contiennent certains caractères avec ends_with() et contains().\n\ndf %&gt;%\n    mutate(\n        across(\n            starts_with(\"pcs\"),\n            recode_pcs\n        )\n    )\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs           pcs_pere      pcs_mere        age age en…¹ age e…² age e…³\n#&gt;   &lt;dbl&gt; &lt;fct&gt;         &lt;fct&gt;         &lt;fct&gt;         &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     1 Employé       Employé       Ouvrier          25        2      NA      NA\n#&gt; 2     2 Cadre         Cadre         Indépendant      45       12       8       2\n#&gt; 3     3 Intermédiaire Indépendant   Employé          29        7      NA      NA\n#&gt; 4     4 Indépendant   Agriculteur   Intermédiaire    32        6       3      NA\n#&gt; 5     5 Agriculteur   Intermédiaire Cadre            65       39      36      28\n#&gt; 6     6 Ouvrier       Ouvrier       Ouvrier          51       18      12      NA\n#&gt; 7     7 Employé       Intermédiaire Ouvrier          37        8       4       1\n#&gt; 8     8 Cadre         Cadre         Agriculteur      42       16      10       5\n#&gt; # … with abbreviated variable names ¹​`age enf1`, ²​`age enf2`, ³​`age enf3`\n\nacross() fonctionne dans un mutate, mais aussi dans un summarise. Dans l’exemple suivant, on calcule la moyenne de toutes les variables qui contiennent “enf”.\n\ndf %&gt;%\n    summarise(\n        across(\n            contains(\"enf\"),\n            mean\n        )\n    )\n#&gt; # A tibble: 1 × 3\n#&gt;   `age enf1` `age enf2` `age enf3`\n#&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1       13.5         NA         NA\n\nDe manière similaire, la fonction num_range() permet de sélectionner des colonnes ayant un préfixe commun suivi d’un indicateur numérique, comme x1, x2… Par exemple la syntaxe suivante sélectionnerait toutes les colonnes de Q01 à Q12 :\n\nacross(num_range(\"Q\", 1:12, width = 2))\n\nOn peut également sélectionner des colonnes via une condition avec la fonction where(). Celle-ci prend elle-même en argument une fonction qui doit renvoyer TRUE ou FALSE, et ne conserve que les colonnes qui correspondent à des TRUE.\nDans l’exemple suivant, on applique la fonction mean seulement aux colonnes de df pour lesquelles la fonction is.numeric renvoie TRUE.\n\ndf %&gt;%\n    summarise(\n        across(\n            where(is.numeric),\n            mean\n        )\n    )\n#&gt; # A tibble: 1 × 5\n#&gt;      id   age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1   4.5  40.8       13.5         NA         NA\n\nPour des conditions plus complexes, on doit parfois définir soi-même la fonction passée à where(). Dans l’exemple suivant on calcule la moyenne uniquement pour les variables de df qui sont numériques et n’ont pas de valeurs manquantes.\n\nno_na &lt;- function(v) {\n    is.numeric(v) && sum(is.na(v)) == 0\n}\n\ndf %&gt;%\n    summarise(\n        across(\n            where(no_na),\n            mean\n        )\n    )\n#&gt; # A tibble: 1 × 3\n#&gt;      id   age `age enf1`\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1   4.5  40.8       13.5\n\nIl est même possible, pour les cas les plus complexes, de combiner plusieurs sélections avec les opérateurs &, | et !. L’exemple suivant applique la fonction mean() à toutes les colonnes numériques de df, sauf à la colonne id.\n\ndf %&gt;%\n    summarise(\n        across(\n            where(is.numeric) & !id,\n            mean\n        )\n    )\n#&gt; # A tibble: 1 × 4\n#&gt;     age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1  40.8       13.5         NA         NA\n\nEnfin, la fonction spéciale everything() permet de sélectionner la totalité des colonnes d’un tableau. Dans l’exemple suivant, on applique n_distinct() pour afficher le nombre de valeurs distinctes de toutes les variables de df.\n\ndf %&gt;%\n    summarise(\n        across(\n            everything(),\n            n_distinct\n        )\n    )\n#&gt; # A tibble: 1 × 8\n#&gt;      id   pcs pcs_pere pcs_mere   age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;\n#&gt; 1     8     6        6        6     8          8          7          5\n\nCes différentes manières de sélectionner un ensemble de colonnes sont appelées tidy selection. Il y a encore d’autres possibilités de sélection, pour avoir un aperçu complet on pourra se référer à la page de documentation de la fonction select().\n\n\n\n\n\n\nNote\n\n\n\nUne erreur de syntaxe fréquente est de mettre la sélection des colonnes dans l’appel à across(), mais pas la fonction qu’on souhaite appliquer.\nAinsi le code suivant génèrera une erreur :\nmutate(across(pcs:pcs_mere), recode_pcs)\nIl faut bien penser à passer la fonction comme argument du across(), donc à l’intérieur de ses parenthèses.\nmutate(across(pcs:pcs_mere, recode_pcs))\n\n\n\n\n15.2.2 Passer des arguments supplémentaires à la fonction appliquée\nPar défaut, si on passe des arguments supplémentaires à across(), ils seront automatiquement transmis comme arguments à la fonction appliquée.\nDans l’exemple vu précédemment, on appliquait mean() à toutes les variables d’âge de df. Or comme certaines colonnes ont des valeurs manquantes, leur résultat vaut NA.\n\ndf %&gt;%\n    summarise(\n        across(\n            starts_with(\"age\"),\n            mean\n        )\n    )\n\nSi on préfère que mean() soit appelée avec l’argument na.rm = TRUE, on pourrait définir explicitement une fonction à part qui utilise cet argument :\n\nmean_sans_na &lt;- function(x) {\n    max(x, na.rm = TRUE)\n}\n\ndf %&gt;%\n    summarise(\n        across(\n            starts_with(\"age\"),\n            mean_sans_na\n        )\n    )\n\nMais on peut faire plus simple, car tout argument supplémentaire passé à across() est transmis directement à la fonction appelée. Il est donc possible de faire :\n\ndf %&gt;%\n    summarise(\n        across(\n            starts_with(\"age\"),\n            max,\n            na.rm = TRUE\n        )\n    )\n#&gt; Warning: There was 1 warning in `summarise()`.\n#&gt; ℹ In argument: `across(starts_with(\"age\"), max, na.rm = TRUE)`.\n#&gt; Caused by warning:\n#&gt; ! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\n#&gt; Supply arguments directly to `.fns` through an anonymous function instead.\n#&gt; \n#&gt;   # Previously\n#&gt;   across(a:b, mean, na.rm = TRUE)\n#&gt; \n#&gt;   # Now\n#&gt;   across(a:b, \\(x) mean(x, na.rm = TRUE))\n#&gt; # A tibble: 1 × 4\n#&gt;     age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1    65         39         36         28\n\n\n\n15.2.3 Noms des colonnes créées par un mutate\nPar défaut, lorsqu’on utilise across() dans un mutate, les nouvelles colonnes portent le même nom que les colonnes d’origine, ce qui signifie que ces dernières sont “écrasées” par les nouvelles valeurs.\nAinsi dans l’exemple suivant, les valeurs d’origine des colonnes PCS ont été écrasées par le résultat du recodage.\n\ndf %&gt;%\n    mutate(\n        across(\n            starts_with(\"pcs\"),\n            recode_pcs\n        )\n    )\n\nSi on préfère créer de nouvelles colonnes, on doit indiquer la manière de les nommer en utilisant l’argument .names de across(). Celui prend comme valeur une chaîne de caractère dans laquelle le motif {.col} sera remplacé par le nom de la colonne d’origine.\nAinsi, si on souhaite plutôt que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe _rec, on peut utiliser :\n\ndf %&gt;%\n    mutate(\n        across(\n            starts_with(\"pcs\"),\n            recode_pcs,\n            .names = \"{.col}_rec\"\n        )\n    )\n#&gt; # A tibble: 8 × 11\n#&gt;      id pcs   pcs_pere pcs_mere   age `age enf1` age e…¹ age e…² pcs_rec pcs_p…³\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;fct&gt;   &lt;fct&gt;  \n#&gt; 1     1 5     5        6           25          2      NA      NA Employé Employé\n#&gt; 2     2 3     3        2           45         12       8       2 Cadre   Cadre  \n#&gt; 3     3 4     2        5           29          7      NA      NA Interm… Indépe…\n#&gt; 4     4 2     1        4           32          6       3      NA Indépe… Agricu…\n#&gt; 5     5 1     4        3           65         39      36      28 Agricu… Interm…\n#&gt; 6     6 6     6        6           51         18      12      NA Ouvrier Ouvrier\n#&gt; 7     7 5     4        6           37          8       4       1 Employé Interm…\n#&gt; 8     8 3     3        1           42         16      10       5 Cadre   Cadre  \n#&gt; # … with 1 more variable: pcs_mere_rec &lt;fct&gt;, and abbreviated variable names\n#&gt; #   ¹​`age enf2`, ²​`age enf3`, ³​pcs_pere_rec\n\n\n\n15.2.4 Appliquer plusieurs fonctions à plusieurs colonnes\nacross() offre également la possibilité d’appliquer plusieurs fonctions à un ensemble de colonnes. Dans ce cas, plutôt que de lui passer une seule fonction comme deuxième argument, on lui passe une liste nommée de fonctions.\nLe code suivant calcule le minimum et le maximum pour les variables d’âge de df.\n\ndf %&gt;%\n    summarise(\n        across(\n            starts_with(\"age\"),\n            list(minimum = min, maximum = max)\n        )\n    )\n#&gt; # A tibble: 1 × 8\n#&gt;   age_minimum age_maximum age enf1_min…¹ age e…² age e…³ age e…⁴ age e…⁵ age e…⁶\n#&gt;         &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1          25          65              2      39      NA      NA      NA      NA\n#&gt; # … with abbreviated variable names ¹​`age enf1_minimum`, ²​`age enf1_maximum`,\n#&gt; #   ³​`age enf2_minimum`, ⁴​`age enf2_maximum`, ⁵​`age enf3_minimum`,\n#&gt; #   ⁶​`age enf3_maximum`\n\nPar défaut les nouvelles variables sont nommées sous la forme {nom_variable}_{nom_fonction}, mais on peut personnaliser cette règle en ajoutant un argument .names à across(). Cet argument est une chaîne de caractères dans laquelle {.col} sera remplacé par le nom de la colonne courante, et {.fn} par le nom de la fonction.\n\ndf %&gt;%\n    summarise(\n        across(\n            starts_with(\"age\"),\n            list(minimum = min, maximum = max),\n            .names = \"{.fn}_{.col}\"\n        )\n    )\n#&gt; # A tibble: 1 × 8\n#&gt;   minimum_age maximum_age minimum_age …¹ maxim…² minim…³ maxim…⁴ minim…⁵ maxim…⁶\n#&gt;         &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1          25          65              2      39      NA      NA      NA      NA\n#&gt; # … with abbreviated variable names ¹​`minimum_age enf1`, ²​`maximum_age enf1`,\n#&gt; #   ³​`minimum_age enf2`, ⁴​`maximum_age enf2`, ⁵​`minimum_age enf3`,\n#&gt; #   ⁶​`maximum_age enf3`\n\n\n\n15.2.5 Renommer plusieurs colonnes avec une fonction\nOn a vu précédemment qu’on peut utiliser rename_with() pour renommer les colonnes d’un tableau de données à l’aide d’une fonction.\n\nremplace_espaces &lt;- function(v) {\n    str_replace_all(v, \" \", \"_\")\n}\n\ndf %&gt;% rename_with(remplace_espaces)\n\nPar défaut, rename_with() applique la fonction de renommage à l’ensemble des colonnes du tableau. Il est cependant possible de lui indiquer de ne renommer que certaines de ces colonnes. Pour cela, on peut lui ajouter un argument supplémentaire nommé .cols, dont la syntaxe est exactement la même que pour across() ou select().\nPar exemple, le code suivant convertit en majuscule uniquement les noms des colonnes id et poids.\n\ndf %&gt;%\n    rename_with(str_to_upper, .cols = starts_with(\"pcs\"))\n#&gt; # A tibble: 8 × 8\n#&gt;      id PCS   PCS_PERE PCS_MERE   age `age enf1` `age enf2` `age enf3`\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1     1 5     5        6           25          2         NA         NA\n#&gt; 2     2 3     3        2           45         12          8          2\n#&gt; 3     3 4     2        5           29          7         NA         NA\n#&gt; 4     4 2     1        4           32          6          3         NA\n#&gt; 5     5 1     4        3           65         39         36         28\n#&gt; 6     6 6     6        6           51         18         12         NA\n#&gt; 7     7 5     4        6           37          8          4          1\n#&gt; 8     8 3     3        1           42         16         10          5\n\nEt le code suivant remplace les espaces par des _ uniquement pour les colonnes dont le nom contient “enf”.\n\ndf %&gt;%\n    rename_with(remplace_espaces, .cols = contains(\"enf\"))\n#&gt; # A tibble: 8 × 8\n#&gt;      id pcs   pcs_pere pcs_mere   age age_enf1 age_enf2 age_enf3\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1     1 5     5        6           25        2       NA       NA\n#&gt; 2     2 3     3        2           45       12        8        2\n#&gt; 3     3 4     2        5           29        7       NA       NA\n#&gt; 4     4 2     1        4           32        6        3       NA\n#&gt; 5     5 1     4        3           65       39       36       28\n#&gt; 6     6 6     6        6           51       18       12       NA\n#&gt; 7     7 5     4        6           37        8        4        1\n#&gt; 8     8 3     3        1           42       16       10        5"
  },
  {
    "objectID": "15-dplyr-avance.html#sec-syntaxes-abregees",
    "href": "15-dplyr-avance.html#sec-syntaxes-abregees",
    "title": "15  dplyr avancé",
    "section": "15.3 Fonctions anonymes et syntaxes abrégées",
    "text": "15.3 Fonctions anonymes et syntaxes abrégées\nDans les sections précédentes, nous avons rencontré plusieurs fonctions, comme rename_with() ou across(), qui prennent une fonction en argument.\nPar exemple, dans l’utilisation suivante de rename_with(), on avait créé une fonction remplace_espaces().\n\nremplace_espaces &lt;- function(v) {\n    str_replace_all(v, \" \", \"_\")\n}\n\ndf %&gt;% rename_with(remplace_espaces)\n\nLe fait de créer une fonction à part pour une opération d’une seule ligne ne se justifie pas forcément, surtout si on n’utilise pas cette fonction ailleurs dans notre code. Dans, ce cas, on peut définir notre fonction directement dans l’appel à rename_with() en utilisant une fonction anonyme, déjà introduites Section 14.4.2.\n\ndf %&gt;%\n    rename_with(function(v) {\n        str_replace_all(v, \" \", \"_\")\n    })\n\nCette notation est assez pratique et souvent utilisée pour les fonctions à usage unique, ne serait-ce que pour s’économiser le fait de devoir lui trouver un nom pertinent.\nLa syntaxe étant un peu lourde, il existe deux alternatives permettant une définition plus “compacte”.\n\nLa première alternative est propre aux packages du tidyverse (notamment dplyr et purrr), et ne fonctionnera pas pour les fonctions n’appartenant pas à ces packages. Il s’agit d’utiliser une syntaxe de type “formule” : le corps de la formule contient les instructions de la fonction, et les arguments sont nommés .x (ou .) s’il n’y en a qu’un, .x et .y s’il y en a deux, et ..1, ..2, etc. s’ils sont plus nombreux.\nLa deuxième alternative est une syntaxe apparue avec la version 4.1 de R, qui permet de remplacer function(...) par le raccourci \\(...).\n\nAinsi les définitions suivantes sont équivalents :\n\n# Fonctionne partout et tout le temps\nfunction(v) { v + 2 }\n# Fonctionne uniquement dans les fonctions du tidyverse\n~ { .x + 2 }\n# Fonctionne uniquement à partir de R 4.1\n\\(v) { v + 2 }\n\nDe même que les définitions suivantes :\n\nfunction(v1, v2) {\n    res &lt;- v1 / v2\n    round(res, 1)\n}\n\n~ {\n    res &lt;- .x / .y\n    round(res, 1)\n}\n\n\\(v1, v2) {\n    res &lt;- v1 / v2\n    round(res, 1)\n}\n\nQuand la fonction anonyme est constituée d’une seule instruction, on peut supprimer les accolades dans sa définition.\n\nfunction(x) x + 2\n~ .x + 2\n\\(x) x + 2\n\nOn pourra du coup, si on le souhaite, utiliser ces syntaxes compactes dans notre rename_with() pour définir notre fonction anonyme.\n\ndf %&gt;%\n    rename_with(~ str_replace_all(.x, \" \", \"_\") )\n\ndf %&gt;%\n    rename_with( \\(x) str_replace_all(x, \" \", \"_\") )\n\nCette syntaxe peut être utilisée partout où on peut passer une fonction comme argument et donc définir des fonctions anonymes. Dans cet exemple déjà vu précédemment, on passe la fonction no_na comme argument de where().\n\nno_na &lt;- function(v) {\n    is.numeric(v) && sum(is.na(v)) == 0\n}\n\ndf %&gt;%\n    summarise(\n        across(\n            where(no_na),\n            mean\n        )\n    )\n\nOn peut donc remplacer la fonction no_na par une fonction anonyme définie directement dans le where().\n\ndf %&gt;%\n    summarise(\n        across(\n            where(function(v) { is.numeric(v) && sum(is.na(v)) == 0 }),\n            mean\n        )\n    )\n\nEt du coup utiliser une des deux syntaxes “compactes”.\n\ndf %&gt;%\n    summarise(\n        across(\n            where(~ is.numeric(.x) && sum(is.na(.x)) == 0),\n            mean\n        )\n    )\n\ndf %&gt;%\n    summarise(\n        across(\n            where(\\(v) is.numeric(v) && sum(is.na(v)) == 0),\n            mean\n        )\n    )"
  },
  {
    "objectID": "15-dplyr-avance.html#rowwise-et-c_across-appliquer-une-transformation-ligne-par-ligne",
    "href": "15-dplyr-avance.html#rowwise-et-c_across-appliquer-une-transformation-ligne-par-ligne",
    "title": "15  dplyr avancé",
    "section": "15.4 rowwise() et c_across() : appliquer une transformation ligne par ligne",
    "text": "15.4 rowwise() et c_across() : appliquer une transformation ligne par ligne\nSoit le tableau de données suivant, qui contient des évaluations de restaurants sur quatre critères différents2 :\n\nrestos &lt;- tribble(\n    ~nom,                       ~cuisine, ~decor, ~accueil, ~prix,\n    \"La bonne fourchette\",             4,      2,        5,     4,\n    \"La choucroute de l'amer\",         3,      3,        2,     3,\n    \"L'Hair de rien\",                  1,      4,        4,     3,\n    \"La blanquette de Vaulx\",          5,      4,        4,     5,\n)\n\nrestos\n#&gt; # A tibble: 4 × 5\n#&gt;   nom                     cuisine decor accueil  prix\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4\n#&gt; 2 La choucroute de l'amer       3     3       2     3\n#&gt; 3 L'Hair de rien                1     4       4     3\n#&gt; 4 La blanquette de Vaulx        5     4       4     5\n\nImaginons qu’on souhaite faire la moyenne, pour chaque restaurant, des critères decor et accueil. On pourrait être tentés d’utiliser mean() de la manière suivante :\n\nrestos %&gt;%\n    mutate(\n        decor_accueil = mean(c(decor, accueil))\n    )\n#&gt; # A tibble: 4 × 6\n#&gt;   nom                     cuisine decor accueil  prix decor_accueil\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4           3.5\n#&gt; 2 La choucroute de l'amer       3     3       2     3           3.5\n#&gt; 3 L'Hair de rien                1     4       4     3           3.5\n#&gt; 4 La blanquette de Vaulx        5     4       4     5           3.5\n\nSi on regarde le résultat, on constate qu’il ne correspond pas à ce que l’on souhaite puisque toutes les valeurs sont les mêmes.\nQue s’est-il passé ? En fait le mutate s’est appliqué sur la totalité du tableau. Ceci signifie que dans mean(c(decor, accueil)), les objets decor et accueil correspondent à la totalité des valeurs de chaque variable. On a donc concaténé ces deux vecteurs et calculé la moyenne, qui est du coup la même pour chaque ligne.\nLa valeur obtenue correspond aux résultat de :\n\nmean(c(restos$decor, restos$accueil))\n#&gt; [1] 3.5\n\nCe que nous souhaitons ici, c’est calculer la moyenne non pas pour l’ensemble du tableau mais pour chaque ligne. Pour cela, on va utiliser la fonction rowwise() : celle-ci est équivalente à un group_by() qui créerait autant de groupes qu’il y a de lignes dans notre tableau.\n\nrestos %&gt;% rowwise()\n#&gt; # A tibble: 4 × 5\n#&gt; # Rowwise: \n#&gt;   nom                     cuisine decor accueil  prix\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4\n#&gt; 2 La choucroute de l'amer       3     3       2     3\n#&gt; 3 L'Hair de rien                1     4       4     3\n#&gt; 4 La blanquette de Vaulx        5     4       4     5\n\nQuant notre tableau est groupé via un rowwise(), les opérations s’effectuent sur un tableau constitué uniquement de la ligne courante. Si on calcule la moyenne précédente, on obtient désormais le bon résultat.\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    mutate(decor_accueil = mean(c(decor, accueil)))\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   nom                     cuisine decor accueil  prix decor_accueil\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4           3.5\n#&gt; 2 La choucroute de l'amer       3     3       2     3           2.5\n#&gt; 3 L'Hair de rien                1     4       4     3           4  \n#&gt; 4 La blanquette de Vaulx        5     4       4     5           4\n\nSupposons qu’on souhaite désormais calculer la moyenne de l’ensemble des critères. On peut évidemment reprendre le code précédent en saisissant toutes les variables concernées.\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    mutate(moyenne = mean(c(decor, accueil, cuisine, prix)))\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   nom                     cuisine decor accueil  prix moyenne\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4    3.75\n#&gt; 2 La choucroute de l'amer       3     3       2     3    2.75\n#&gt; 3 L'Hair de rien                1     4       4     3    3   \n#&gt; 4 La blanquette de Vaulx        5     4       4     5    4.5\n\nLister les variables de cette manière peut vite devenir pénible si le nombre de variables est important. C’est pourquoi dplyr propose la fonction c_across() : celle-ci permet de sélectionner des colonnes de la même manière que select() ou across(), et retourne un vecteur constitué des valeurs concaténées de ces colonnes.\nL’exemple suivant calcule la moyenne de toutes les colonnes comprises entre decor et prix, en utilisant l’opérateur :.\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    mutate(\n        moyenne = mean(c_across(decor:prix))\n    )\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   nom                     cuisine decor accueil  prix moyenne\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4    3.67\n#&gt; 2 La choucroute de l'amer       3     3       2     3    2.67\n#&gt; 3 L'Hair de rien                1     4       4     3    3.67\n#&gt; 4 La blanquette de Vaulx        5     4       4     5    4.33\n\nComme pour across() ou select(), on peut utiliser la fonction where() pour calculer la moyenne sur toutes les colonnes numériques.\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    mutate(\n        moyenne = mean(\n            c_across(where(is.numeric))\n        )\n    )\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   nom                     cuisine decor accueil  prix moyenne\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 La bonne fourchette           4     2       5     4    3.75\n#&gt; 2 La choucroute de l'amer       3     3       2     3    2.75\n#&gt; 3 L'Hair de rien                1     4       4     3    3   \n#&gt; 4 La blanquette de Vaulx        5     4       4     5    4.5\n\nL’utilisation de rowwise() et c_across() est intéressante principalement quand il n’existe pas de fonction vectorisée pour la transformation qu’on souhaite appliquer. Quand elle existe, il est en général plus simple et plus rapide de l’utiliser.\nPar exemple, pour trouver la valeur la plus élevée par restaurant, on pourrait être tenté d’utiliser le code suivant :\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    summarise(note_max = max(c(decor, accueil)))\n#&gt; # A tibble: 4 × 1\n#&gt;   note_max\n#&gt;      &lt;dbl&gt;\n#&gt; 1        5\n#&gt; 2        3\n#&gt; 3        4\n#&gt; 4        4\n\nIl est cependant plus lisible et plus efficace d’utiliser la fonction pmax, qui a justement pour objectif de parcourir des vecteurs en parallèle et de ne conserver que la plus grande valeur.\n\nrestos %&gt;%\n    summarise(note_max = pmax(decor, accueil))\n#&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#&gt; dplyr 1.1.0.\n#&gt; ℹ Please use `reframe()` instead.\n#&gt; ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#&gt;   always returns an ungrouped data frame and adjust accordingly.\n#&gt; # A tibble: 4 × 1\n#&gt;   note_max\n#&gt;      &lt;dbl&gt;\n#&gt; 1        5\n#&gt; 2        3\n#&gt; 3        4\n#&gt; 4        4\n\nUne des limites de pmax cependant est qu’on ne peut pas l’utiliser avec c_across(), et qu’on ne peut donc pas faire de sélection des colonnes : on est obligés de saisir leurs noms.\n\nrestos %&gt;%\n    summarise(note_max = pmax(cuisine, decor, accueil, prix))\n#&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#&gt; dplyr 1.1.0.\n#&gt; ℹ Please use `reframe()` instead.\n#&gt; ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#&gt;   always returns an ungrouped data frame and adjust accordingly.\n#&gt; # A tibble: 4 × 1\n#&gt;   note_max\n#&gt;      &lt;dbl&gt;\n#&gt; 1        5\n#&gt; 2        3\n#&gt; 3        4\n#&gt; 4        5\n\nDans certains cas, notamment lorsque les colonnes sont nombreuses ou qu’on ne les a pas identifiées à l’avance, on pourra donc utiliser rowwise() et c_across() même quand des alternatives vectorisées existent.\n\nrestos %&gt;%\n    rowwise() %&gt;%\n    summarise(\n        note_max = max(\n            c_across(where(is.numeric))\n        )\n    )\n#&gt; # A tibble: 4 × 1\n#&gt;   note_max\n#&gt;      &lt;dbl&gt;\n#&gt; 1        5\n#&gt; 2        3\n#&gt; 3        4\n#&gt; 4        5"
  },
  {
    "objectID": "15-dplyr-avance.html#ressources",
    "href": "15-dplyr-avance.html#ressources",
    "title": "15  dplyr avancé",
    "section": "15.5 Ressources",
    "text": "15.5 Ressources\nLa page d’aide de la fonction select (en anglais) liste toutes les possibilités offertes pour spécifier des ensembles de colonnes d’un tableau de données.\nLa vignette Column-wise operations de dplyr (en anglais) présente en détail l’utilisation et les fonctionnalités de across().\nLa vignette Row-wise operations de dplyr (toujours en anglais) présente de manière approfondie l’utilisation de rowwise() et c_across() pour opérer individuellement sur les lignes d’un tableau de données."
  },
  {
    "objectID": "15-dplyr-avance.html#exercices",
    "href": "15-dplyr-avance.html#exercices",
    "title": "15  dplyr avancé",
    "section": "15.6 Exercices",
    "text": "15.6 Exercices\nPour certains des exercices qui suivent on utilisera le jeu de données starwars de dplyr. On peut le charger avec les instructions suivantes :\n\nlibrary(dplyr)\ndata(starwars)\n\nLe jeu de données contient les caractéristiques de 87 personnages présents dans les films : espèce, âge, planète d’origine, etc.\n\n15.6.1 Appliquer ses propres fonctions\nExercice 1.1\nCréer une fonction imc qui prend en argument un vecteur taille (en cm) et un vecteur poids (en kg) et retourne les valeurs correspondantes de l’indice de masse corporelle, qui se calcule en divisant le poids en kilos par la taille en mètres au carré.\n\n\nimc &lt;- function(tailles, poids) {\n    tailles_m &lt;- tailles / 100\n    poids / tailles_m ^ 2\n}\n\n\nUtiliser cette fonction pour ajouter une nouvelle variable imc au tableau starwars.\n\n\nstarwars %&gt;%\n    mutate(imc = imc(height, mass))\n\n\nÀ l’aide de group_by() et summarise(), utiliser à nouveau cette fonction pour calculer l’IMC moyen selon les valeurs de la variable species.\n\n\nstarwars %&gt;%\n    group_by(species) %&gt;%\n    summarise(\n        imc = mean(imc(height, mass), na.rm = TRUE)\n    )\n\n\nExercice 1.2\nToujours dans le jeu de données starwars, à l’aide d’un group_by() et d’un summarise(), calculer pour chaque valeur de la variable sex la valeur de l’étendue de la variable height du jeu de données starwars, c’est-à-dire la différence entre sa valeur maximale et sa valeur minimale.\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        etendue_taille = max(height, na.rm = TRUE) - min(height, na.rm = TRUE)\n    )\n\n\nEn partant du code précédent, créer une fonction etendue qui prend en argument un vecteur et retourne la différence entre sa valeur maximale et sa valeur minimale. En utilisant cette fonction, calculer pour chaque valeur de sex la valeur de l’étendue des variables height et mass.\n\n\netendue &lt;- function(v) {\n    max(v, na.rm = TRUE) - min(v, na.rm = TRUE)\n}\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        etendue_taille = etendue(height),\n        etendue_poids  = etendue(mass)\n    )\n\n\nExercice 1.3\nOn a vu que la fonction suivante permet de calculer le pourcentage des éléments d’un vecteur de chaînes de caractères se terminant par un suffixe passé en argument.\n\nprop_suffixe &lt;- function(v, suffixe) {\n    # On ajoute $ à la fin du suffixe pour capturer uniquement en fin de chaîne\n    suffixe &lt;- paste0(suffixe, \"$\")\n    # Détection du suffixe\n    nb_detect &lt;- sum(str_detect(v, suffixe))\n    # On retourne le pourcentage\n    nb_detect / length(v) * 100\n}\n\nModifier cette fonction en une fonction prop_prefixe qui retourne le pourcentage d’éléments commençant par un préfixe passé en argument. Indication : pour détecter si une chaîne commence par \"ker\", on utilise l’expression régulière \"^ker\".\n\n\nprop_prefixe &lt;- function(v, prefixe) {\n    # On ajoute $ à la fin du prefixe pour capturer uniquement en début de chaîne\n    prefixe &lt;- paste0(\"^\", prefixe)\n    # Détection du motif\n    nb_detect &lt;- sum(str_detect(v, prefixe))\n    # On retourne le pourcentage\n    nb_detect / length(v) * 100\n}\n\n\nUtiliser prop_prefixe dans un summarise appliqué à rp2018 pour calculer le pourcentage de communes commençant par “Saint” selon le département. Ordonner les résultats par pourcentage décroissant.\n\n\nrp2018 %&gt;%\n    group_by(departement) %&gt;%\n    summarise(\n        prop_saint = prop_prefixe(commune, \"Saint\")\n    ) %&gt;%\n    arrange(desc(prop_saint))\n\n\nCréer une fonction tab_prefixe qui prend un seul argument prefixe et renvoie le tableau obtenu à la question précédente pour le préfixe passé en argument. Tester avec tab_prefixe(\"Plou\") et tab_prefixe(\"Sch\")\n\n\ntab_prefixe &lt;- function(prefixe) {\n    rp2018 %&gt;%\n        group_by(departement) %&gt;%\n        summarise(\n            prop = prop_prefixe(commune, prefixe)\n        ) %&gt;%\n        arrange(desc(prop))\n}\n\n\nExercice 1.4\nLe vecteur suivant donne, pour chacun des neuf principaux films de la saga Star Wars, la date à laquelle ils se déroulent dans l’univers de la saga.\n\nc(\n    \"I\"    = -32,\n    \"II\"   = -22,\n    \"III\"  = -19,\n    \"IV\"   =   0,\n    \"V\"    =   3,\n    \"VI\"   =   4,\n    \"VII\"  =  34,\n    \"VIII\" =  34,\n    \"IX\"   =  35\n)\n\nDans le jeu de données starwars, la variable birth_year indique l’année de naissance du personnage en “années avant l’an zéro” (une valeur de 19 signifie donc une année de naissance de -19).\nCréer une fonction age_film qui prend en entrée un vecteur d’années de naissance au même format que birth_year ainsi que l’identifiant d’un film, et calcule les âges à la date du film.\nVérifier avec :\n\nage_film(starwars$birth_year, \"IV\")\n#&gt;  [1]  19.0 112.0  33.0  41.9  19.0  52.0  47.0    NA  24.0  57.0  41.9  64.0\n#&gt; [13] 200.0  29.0  44.0 600.0  21.0    NA 896.0  82.0  31.5  15.0  53.0  31.0\n#&gt; [25]  37.0  41.0  48.0    NA   8.0    NA  92.0    NA  91.0  52.0    NA    NA\n#&gt; [37]    NA    NA    NA  62.0  72.0  54.0    NA  48.0    NA    NA    NA  72.0\n#&gt; [49]  92.0    NA    NA    NA    NA    NA  22.0    NA    NA    NA  82.0    NA\n#&gt; [61]  58.0  40.0    NA 102.0  67.0  66.0    NA    NA    NA    NA    NA    NA\n#&gt; [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt; [85]    NA    NA  46.0\n\n\n\nage_film &lt;- function(annees, film) {\n    annees_films &lt;- c(\n        \"I\"    = -32,\n        \"II\"   = -22,\n        \"III\"  = -19,\n        \"IV\"   =   0,\n        \"V\"    =   3,\n        \"VI\"   =   4,\n        \"VII\"  =  34,\n        \"VIII\" =  34,\n        \"IX\"   =  35\n    )\n    annees_naissance &lt;- -annees\n    annee_ref &lt;- annees_films[film]\n    annee_ref - annees_naissance\n}\n\n\nUtiliser la fonction pour ajouter deux nouvelles variables au tableau starwars : age_iv qui correspond à l’âge (potentiel) au moment du film IV, et age_ix qui correspond à l’âge au moment du film IX.\n\n\nstarwars %&gt;%\n    mutate(\n        age_iv = age_film(birth_year, \"IV\"),\n        age_ix = age_film(birth_year, \"IX\"),\n    )\n\n\n\n\n15.6.2 across()\nExercice 2.1\nReprendre la fonction etendue de l’exercice 1.2 :\n\netendue &lt;- function(v) {\n    max(v, na.rm = TRUE) - min(v, na.rm = TRUE)\n}\n\nDans le jeu de données starwars, calculer l’étendue des variables height et mass pour chaque valeur de sex à l’aide de group_by(), summarise() et across().\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            etendue\n        )\n    )\n\n\nToujours à l’aide d’across(), appliquer etendue à toutes les variables numériques, toujours pour chaque valeur de sex.\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            where(is.numeric),\n            etendue\n        )\n    )\n\n\nEn utilisant & et !, appliquer etendue à toutes les variables numériques sauf à celles qui finissent par “year”.\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            where(is.numeric) & !ends_with(\"year\"),\n            etendue\n        )\n    )\n\n\nExercice 2.2\nDans le jeu de données starwars, appliquer en un seul summarise les fonctions min et max aux variables height et mass.\n\n\nstarwars %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            list(min = min, max = max)\n        )\n    )\n\n\nSi vous ne l’avez pas déjà fait à la question précédente, modifier le code pour que le calcul des valeurs minimales et maximales ne prennent pas en compte les valeurs manquantes.\n\n\nfuns &lt;- list(\n    min = function(v) { min(v, na.rm = TRUE) },\n    max = function(v) { max(v, na.rm = TRUE) }\n)\nstarwars %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            funs\n        )\n    )\n# Autre possibilité : les arguments supplémentaires passés à across() sont\n# transmis aux fonctions appliquées\nstarwars %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            list(min = min, max = max),\n            na.rm = TRUE\n        )\n    )\n\n\nExercice 2.3\nDans le jeu de données hdv2003, utiliser across() pour transformer les modalités “Oui” et “Non” en TRUE et FALSE pour toutes les variables de hard.rock à sport.\n\n\ndetecte_oui &lt;- function(v) {\n    v == \"Oui\"\n}\nhdv2003 %&gt;%\n    mutate(\n        across(\n            hard.rock:sport,\n            detecte_oui\n        )\n    )\n\n\nAjouter un argument .names à across() pour que les variables recodées soient stockées dans de nouvelles colonnes nommées avec le suffixe \"_true\".\n\n\ndetecte_oui &lt;- function(v) {\n    v == \"Oui\"\n}\nhdv2003 %&gt;%\n    mutate(\n        across(\n            hard.rock:sport,\n            detecte_oui,\n            .names = \"{.col}_true\"\n        )\n    )\n\n\n\n\n15.6.3 Fonctions anonymes et notations abrégées\nExercice 3.1\nDans un exercice précédent, on a vu que le code ci-dessous permet de calculer l’étendue des variables height et mass du jeu de données starwars.\n\netendue &lt;- function(v) {\n    max(v, na.rm = TRUE) - min(v, na.rm = TRUE)\n}\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            etendue\n        )\n    )\n\nModifier ce code en supprimant la définition de etendue et en utilisant à la place une fonction anonyme directement dans le across().\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            function(v) {\n               max(v, na.rm = TRUE) - min(v, na.rm = TRUE)\n            }\n        )\n    )\n\n\nModifier à nouveau ce code pour utiliser la syntaxe abrégée de type “formule” du tidyverse.\n\n\nstarwars %&gt;%\n    group_by(sex) %&gt;%\n    summarise(\n        across(\n            c(height, mass),\n            ~ max(.x, na.rm = TRUE) - min(.x, na.rm = TRUE)\n        )\n    )\n\n\nExercice 3.2\nSoit le code suivant, qui renomme les colonnes du tableau starwars de type liste en leur ajoutant le préfixe “liste_”.\n\najoute_prefixe_liste &lt;- function(nom) {\n    paste0(\"liste_\", nom)\n}\n\nstarwars %&gt;%\n    rename_with(ajoute_prefixe_liste, .cols = where(is.list))\n\nRéécrire ce code avec une fonction anonyme en utilisant les trois notations :\n\nclassique (avec function())\nformule (du tidyverse)\ncompacte (à partir de R 4.1)\n\n\n\n# Classique\nstarwars %&gt;%\n    rename_with(\n        function(nom) { paste0(\"liste_\", nom) },\n        .cols = where(is.list)\n    )\n# Formule\nstarwars %&gt;%\n    rename_with(\n        ~ paste0(\"liste_\", .x),\n        .cols = where(is.list)\n    )\n# Compacte\nstarwars %&gt;%\n    rename_with(\n        \\(nom) paste0(\"liste_\", nom),\n        .cols = where(is.list)\n    )\n\n\nExercice 3.3\nLe code suivant indique, pour chaque région du jeu de données rp2018, le nom de la commune ayant la valeur maximale pour les variables dipl_aucun et dipl_sup.\n\nnom_commune_max &lt;- function(valeurs, communes) {\n    communes[valeurs == max(valeurs)]\n}\n\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            nom_commune_max,\n            commune\n        )\n    )\n#&gt; # A tibble: 17 × 3\n#&gt;    region                     dipl_aucun                   dipl_sup             \n#&gt;    &lt;chr&gt;                      &lt;chr&gt;                        &lt;chr&gt;                \n#&gt;  1 Auvergne-Rhône-Alpes       Oyonnax                      Corenc               \n#&gt;  2 Bourgogne-Franche-Comté    Saint-Loup-sur-Semouse       Fontaine-lès-Dijon   \n#&gt;  3 Bretagne                   Louvigné-du-Désert           Saint-Grégoire       \n#&gt;  4 Centre-Val de Loire        La Loupe                     Olivet               \n#&gt;  5 Corse                      Ghisonaccia                  Ville-di-Pietrabugno \n#&gt;  6 Grand Est                  Behren-lès-Forbach           Mittelhausbergen     \n#&gt;  7 Guadeloupe                 Saint-Louis                  Le Gosier            \n#&gt;  8 Guyane                     Papaichton                   Remire-Montjoly      \n#&gt;  9 Hauts-de-France            Bohain-en-Vermandois         La Madeleine         \n#&gt; 10 La Réunion                 Cilaos                       La Possession        \n#&gt; 11 Martinique                 Basse-Pointe                 Schœlcher            \n#&gt; 12 Normandie                  Sourdeval                    Mont-Saint-Aignan    \n#&gt; 13 Nouvelle-Aquitaine         Aiguillon                    Bordeaux             \n#&gt; 14 Occitanie                  Bessèges                     Montferrier-sur-Lez  \n#&gt; 15 Pays de la Loire           Saint-Calais                 Nantes               \n#&gt; 16 Provence-Alpes-Côte d'Azur Marseille 15e Arrondissement Le Tholonet          \n#&gt; 17 Île-de-France              Clichy-sous-Bois             Paris 5e Arrondissem…\n\nRéécrire ce code en utilisant une fonction anonyme, avec la syntaxe de votre choix (classique, formule ou compacte).\n\n\n# Classique\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            function(valeurs, communes) { communes[valeurs == max(valeurs)] },\n            commune\n        )\n    )\n# Formule\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            ~ .y[.x == max(.x)],\n            commune\n        )\n    )\n# Compacte\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            \\(valeurs, communes) communes[valeurs == max(valeurs)],\n            commune\n        )\n    )\n\n\nÀ l’aide d’une fonction anonyme supplémentaire, modifier le code pour qu’il retourne également, pour les mêmes variables, le nom des communes avec les valeurs minimales.\n\n\n# Formule\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            list(\n                max = ~ .y[.x == max(.x)],\n                min = ~ .y[.x == min(.x)]\n            ),\n            commune\n        )\n    )\n# Compacte\nrp2018 %&gt;%\n    group_by(region) %&gt;%\n    summarise(\n        across(\n            c(dipl_aucun, dipl_sup),\n            list(\n                max = \\(valeurs, communes) communes[valeurs == max(valeurs)],\n                min = \\(valeurs, communes) communes[valeurs == min(valeurs)]\n            ),\n            commune\n        )\n    ) %&gt;% View()\n\n\n\n\n15.6.4 rowwise() et c_across()\nExercice 4.1\nOn repart du code final de l’exercice 2.3, qui recodait une série de variables de hdv2003 en valeurs TRUE/FALSE dans de nouvelles variables avec le suffixe \"_true\".\n\ndetecte_oui &lt;- function(v) {\n    v == \"Oui\"\n}\nhdv2003 &lt;- hdv2003 %&gt;%\n    mutate(\n        across(\n            hard.rock:sport,\n            detecte_oui,\n            .names = \"{.col}_true\"\n        )\n    )\n\nCalculer le plus simplement possible une nouvelle variable total qui contient, pour chaque ligne, le nombre de valeurs TRUE des deux variables cinema_true et sport_true (si une ligne contient TRUE pour ces deux variables, total doit valoir 2, etc.)\n\n\nhdv2003 %&gt;%\n    mutate(total = cuisine_true + sport_true)\n\n\nRecalculer la variable total pour qu’elle contienne le nombre de TRUE par ligne pour les variables bricol_true, cinema_true et sport_true.\n\n\nhdv2003 %&gt;%\n    rowwise() %&gt;%\n    mutate(total = sum(cuisine_true, sport_true, bricol_true))\n\n\nRecalculer la variable total pour qu’elle contienne le nombre de TRUE par ligne pour toutes les variables se terminant par \"_true\".\n\n\nhdv2003 %&gt;%\n    rowwise() %&gt;%\n    mutate(total = sum(c_across(ends_with(\"_true\"))))\n\n\nReprendre le code précédent pour qu’il puisse s’appliquer directement sur les variables hard.rock…sport, sans passer par le recodage en TRUE/FALSE.\n\n\ncount_oui &lt;- function(v) {\n    sum(v == \"Oui\")\n}\n\nhdv2003 %&gt;%\n    rowwise() %&gt;%\n    mutate(\n        total = count_oui(c_across(hard.rock:sport))\n    )\n\n\nExercice 4.2\nDans le jeu de données starwars, la colonne films contient la liste des films dans lesquels apparaissent les différents personnages. Cette colonne a une forme un peu particulière puisqu’il s’agit d’une “colonne-liste” : les éléments de cette colonne sont eux-mêmes des listes.\n\nhead(starwars$films, 3)\n#&gt; [[1]]\n#&gt; [1] \"The Empire Strikes Back\" \"Revenge of the Sith\"    \n#&gt; [3] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; [5] \"The Force Awakens\"      \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"The Empire Strikes Back\" \"Attack of the Clones\"   \n#&gt; [3] \"The Phantom Menace\"      \"Revenge of the Sith\"    \n#&gt; [5] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"The Empire Strikes Back\" \"Attack of the Clones\"   \n#&gt; [3] \"The Phantom Menace\"      \"Revenge of the Sith\"    \n#&gt; [5] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; [7] \"The Force Awakens\"\n\nOn essaye de calculer le nombre de films pour chaque personnage avec le code suivant. Est-ce que ça fonctionne ? Pourquoi ?\n\nstarwars %&gt;%\n    mutate(n_films = length(films))\n\nTrouver une manière d’obtenir le résultat attendu.\n\n\nstarwars %&gt;%\n    rowwise() %&gt;%\n    mutate(n_films = length(films))"
  },
  {
    "objectID": "15-dplyr-avance.html#footnotes",
    "href": "15-dplyr-avance.html#footnotes",
    "title": "15  dplyr avancé",
    "section": "",
    "text": "Attention, le jeu de données ne comporte que les communes de plus de 2000 habitants.↩︎\nUn nom de salon de coiffure s’est glissé dans cette liste de restaurants. Saurez-vous le retrouver ?↩︎"
  },
  {
    "objectID": "16-structures-donnees.html#vecteurs-atomiques",
    "href": "16-structures-donnees.html#vecteurs-atomiques",
    "title": "16  Structures de données",
    "section": "16.1 Vecteurs atomiques",
    "text": "16.1 Vecteurs atomiques\nLes vecteurs atomiques sont des structures qui regroupent ensemble plusieurs éléments constitués d’une seule valeur, avec deux contraintes : ces valeurs doivent toutes être du même type. Les vecteurs atomiques ont déjà été introduits Section 9.1.\n\n16.1.1 Création d’un vecteur\nOn peut construire un vecteur manuellement avec la fonction c().\n\nx &lt;- c(1, 3, 8)\n\nSi on souhaite générer un vecteur de valeurs entières successives, on peut utiliser l’opérateur : ou la fonction seq_len().\n\n2:8\n#&gt; [1] 2 3 4 5 6 7 8\nseq_len(5)\n#&gt; [1] 1 2 3 4 5\n\nLa fonction seq() permet de générer des séquences régulière plus complexes.\n\nseq(0.5, 2.5, by = 0.5)\n#&gt; [1] 0.5 1.0 1.5 2.0 2.5\nseq(0, 4, length.out = 6)\n#&gt; [1] 0.0 0.8 1.6 2.4 3.2 4.0\n\nUne autre variante de seq(), nommée seq_along(), permet de générer un vecteur d’entiers correspondant à la longueur d’un objet passé en argument :\n\nx &lt;- c(\"Pomme\", \"Poire\")\nseq_along(x)\n#&gt; [1] 1 2\ny &lt;- runif(10)\nseq_along(y)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nEnfin, la fonction rep() permet de répéter un élément ou un vecteur.\n\nrep(\"Pomme\", 6)\n#&gt; [1] \"Pomme\" \"Pomme\" \"Pomme\" \"Pomme\" \"Pomme\" \"Pomme\"\nrep(1:4, 2)\n#&gt; [1] 1 2 3 4 1 2 3 4\n\nSi on souhaite connaître le nombre d’éléments d’un vecteur, on peut utiliser la fonction length().\n\nv &lt;- rep(1:4, 2)\nlength(v)\n#&gt; [1] 8\n\nIl peut parfois être utile de créer des vecteurs “vides”. Dans ce cas on peut les initialiser avec les fonctions vector(), character() ou numeric(). Par défaut ces fonctions renvoient un vecteur sans élément, mais on peut aussi leur indiquer en argument le nombre d’éléments souhaités (qui seront alors initialisés avec une valeur par défaut).\n\nnumeric()\n#&gt; numeric(0)\ncharacter(2)\n#&gt; [1] \"\" \"\"\n\n\n\n16.1.2 Vecteurs nommés\nLes éléments d’un vecteur peuvent être nommés. Ces noms peuvent êtré définis au moment de la création du vecteur.\n\nx &lt;- c(e1 = 1, e2 = 3, e3 = 8)\nx\n#&gt; e1 e2 e3 \n#&gt;  1  3  8\n\nOn peut utiliser names() pour récupérer les noms des éléments d’un vecteur.\n\nnames(x)\n#&gt; [1] \"e1\" \"e2\" \"e3\"\n\nOn peut aussi utiliser names() pour créer ou modifier les noms d’un vecteur existant.\n\nnames(x) &lt;- c(\"brouette\", \"moto\", \"igloo\")\nx\n#&gt; brouette     moto    igloo \n#&gt;        1        3        8\n\n\n\n16.1.3 Types de vecteurs\nOn peut déterminer le type d’un vecteur avec l’instruction typeof.\n\nx &lt;- c(1, 3, 8)\ntypeof(x)\n#&gt; [1] \"double\"\ny &lt;- c(\"foo\", \"bar\", \"baz\")\ntypeof(y)\n#&gt; [1] \"character\"\nz &lt;- c(TRUE, FALSE, FALSE)\ntypeof(z)\n#&gt; [1] \"logical\"\n\nParmi les principaux types de données on notera1 :\n\nles chaînes de caractères (character)\nles nombres flottants (double)\nles nombres entiers (integer)\nles valeurs logiques (logical)\n\nÀ noter que par défaut les nombres sont considérés comme des nombres flottants (des nombres décimaux avec une virgule) : pour les définir explicitement comme nombres entiers on peut leur ajouter le suffixe L.\n\nx &lt;- c(1L, 3L, 8L)\ntypeof(x)\n#&gt; [1] \"integer\"\n\nOn peut tester le type d’un vecteur avec les fonctions is.character, is.double, is.logical… Autre fonction utile, is.numeric teste si un vecteur est de type double ou integer.\n\nx &lt;- c(1, 3, 8)\nis.numeric(x)\n#&gt; [1] TRUE\nx &gt; 2\n#&gt; [1] FALSE  TRUE  TRUE\nis.logical(x &gt; 2)\n#&gt; [1] TRUE\ny &lt;- c(\"foo\", \"bar\", \"baz\")\nis.character(y)\n#&gt; [1] TRUE\n\nPetite spécificité, les facteurs (voir Section 9.3.1) ne sont pas considérés par R comme des character, même s’ils comportent des chaînes de caractères. Pour tester si un vecteur est de type facteur, on utilise is.factor().\n\nfac &lt;- factor(c(\"rouge\", \"vert\", \"rouge\"))\nis.character(fac)\n#&gt; [1] FALSE\nis.factor(fac)\n#&gt; [1] TRUE\n\nTous les éléments d’un vecteur doivent être du même type. Si ça n’est pas le cas, les éléments seront convertis au type le plus “général” présent dans le vecteur, sachant que les character sont plus généraux que les numeric, qui sont eux-mêmes plus généraux que les logical.\nDans l’exemple suivant, le nombre 1 est transformé en chaîne de caractère \"1\".\n\nc(1, \"foo\")\n#&gt; [1] \"1\"   \"foo\"\n\nSi on mélange nombres et valeurs logiques, les TRUE sont convertis en 1 et les FALSE en 0.\n\nc(TRUE, 2, FALSE)\n#&gt; [1] 1 2 0\n\n\n\n\n\n\n\nNote\n\n\n\nSi la valeur NA, comme on l’a vu, permet d’indiquer une valeur manquante (Not Available), il existe en réalité plusieurs types de NA, même si cette distinction est la plupart du temps transparente pour l’utilisateur. On a ainsi notamment des valeurs NA_integer_, NA_character_, NA_real_.\n\n\nLa conversion automatique d’un type en un autre est à l’origine d’un idiome courant en R. Quand on applique une fonction qui attend un vecteur de nombres à un vecteur de valeurs logiques, celles-ci sont automatiquement converties, les TRUE devenant 1 et les FALSE devenant 0. Du coup, si on applique sum() à un vecteur de valeurs logiques, le résultat est égal au nombre de valeurs TRUE.\n\nsum(c(TRUE, FALSE, TRUE))\n#&gt; [1] 2\n\nOn peut donc appliquer sum() à un test, et on obtiendra le nombre de valeurs pour lesquelles le test est vrai.\n\nx &lt;- c(1, 5, 8, 12, 14)\nsum(x &gt; 10)\n#&gt; [1] 2\n\nCeci fournit un raccourci très pratique. Dans l’exemple suivant, on tire 1000 nombres au hasard entre 0 et 1 et on calcule le nombre de valeurs obtenues qui sont inférieures à 0.5.\n\nx &lt;- runif(1000)\nsum(x &lt; 0.5)\n#&gt; [1] 501\n\nAutre raccourci moins utilisé, appliquer mean() au résultat d’un test donne la proportion de valeurs pour lesquelles le test est vrai.\n\nx &lt;- c(1, 5, 8, 12, 14)\nmean(x &gt; 10)\n#&gt; [1] 0.4\nx &lt;- runif(1000)\nmean(x &lt; 0.5)\n#&gt; [1] 0.492\n\nOn peut convertir un vecteur d’un type à un autre avec les fonctions as.character(), as.numeric() et as.logical(). Si une valeur ne peut pas être convertie, elle est remplacée par un NA, et R affiche un avertissement.\n\nas.character(1:3)\n#&gt; [1] \"1\" \"2\" \"3\"\nas.logical(c(0, 2, 4))\n#&gt; [1] FALSE  TRUE  TRUE\nas.numeric(c(\"foo\", \"23\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1] NA 23\n\n\n\n16.1.4 Sélection d’éléments\nOn a vu Section 9.1 que l’opérateur [] peut être utilisé pour sélectionner des éléments d’un vecteur. Cet opérateur peut comporter :\n\ndes nombres (qui sélectionnent par position)\ndes chaînes de caractères (qui sélectionnent par nom)\nun test ou des valeurs logiques (qui sélectionnent les éléments correspondant à TRUE)\n\n\nx &lt;- c(e1 = 1, e2 = 2, e3 = 8, e4 = 12)\nx[c(1, 4)]\n#&gt; e1 e4 \n#&gt;  1 12\nx[c(\"e2\", \"e4\")]\n#&gt; e2 e4 \n#&gt;  2 12\nx[x &lt; 10]\n#&gt; e1 e2 e3 \n#&gt;  1  2  8\n\nSi on fournit à [] un ou plusieurs nombres négatifs, les valeurs correspondantes seront supprimées plutôt que sélectionnées.\n\nx[-1]\n#&gt; e2 e3 e4 \n#&gt;  2  8 12\nx[c(-2, -4)]\n#&gt; e1 e3 \n#&gt;  1  8\n\nSi on souhaite afficher les premières ou dernières valeurs d’un vecteur, les fonctions head() et tail() peuvent être utiles.\n\nhead(x, 2)\n#&gt; e1 e2 \n#&gt;  1  2\ntail(x, 1)\n#&gt; e4 \n#&gt; 12\n\n\n\n16.1.5 Modification\nUtilisé conjointement avec l’opérateur d’assignation &lt;-, l’opérateur [] permet de remplacer des éléments.\n\nx &lt;- c(e1 = 1, e2 = 2, e3 = 8, e4 = 12)\nx[1] &lt;- -1000\nx\n#&gt;    e1    e2    e3    e4 \n#&gt; -1000     2     8    12\nx[\"e2\"] &lt;- 0\nx\n#&gt;    e1    e2    e3    e4 \n#&gt; -1000     0     8    12\nx[x &gt; 10] &lt;- NA\nx\n#&gt;    e1    e2    e3    e4 \n#&gt; -1000     0     8    NA\n\nUtilisé sans arguments, [] se contente de renvoyer le vecteur entier. Mais couplé à une assignation, il remplace chacun des éléments du vecteur plutôt que le vecteur lui-même.\n\nx[] &lt;- 3\nx\n#&gt; e1 e2 e3 e4 \n#&gt;  3  3  3  3"
  },
  {
    "objectID": "16-structures-donnees.html#sec-listes",
    "href": "16-structures-donnees.html#sec-listes",
    "title": "16  Structures de données",
    "section": "16.2 Listes",
    "text": "16.2 Listes\nLes listes sont une généralisation des vecteurs : elles regroupent également plusieurs éléments ensemble, mais ceux-ci peuvent être de n’importe quel type, y compris des objets complexes. Une liste peut donc contenir des vecteurs, des listes, des tableaux de données, des fonctions, des graphiques ggplot2 stockés dans un objet, etc.\n\n16.2.1 Création\nOn construit une liste avec la fonction list.\n\nlist(1, \"foo\", c(\"Pomme\", \"Citron\"))\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"foo\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"Pomme\"  \"Citron\"\n\nL’affichage du contenu d’une liste dans la console diffère de celui d’un vecteur. Dans le cas d’une liste les éléments sont affichés les uns en dessous des autres, et séparés par leur indice numérique entre une paire de crochets. Dans l’affichage ci-dessus, il faut bien distinguer les [[1]], [[2]] et [[3]], qui correspondent au numéro de l’élément de la liste, et les [1] qui font partie de l’affichage du contenu de ces éléments.\nComme pour les vecteurs, on peut nommer les éléments à la création de la liste.\n\nliste &lt;- list(nombre = 1, char = \"foo\", vecteur = c(\"Pomme\", \"Citron\"))\nliste\n#&gt; $nombre\n#&gt; [1] 1\n#&gt; \n#&gt; $char\n#&gt; [1] \"foo\"\n#&gt; \n#&gt; $vecteur\n#&gt; [1] \"Pomme\"  \"Citron\"\n\nDans ce cas l’affichage de la liste dans la console montre ces noms plutôt que les indices numériques des éléments.\nComme pour les vecteurs atomiques, on peut utiliser names() pour afficher ou modifier les noms des éléments.\n\nnames(liste)\n#&gt; [1] \"nombre\"  \"char\"    \"vecteur\"\n\nQuand la liste est plus complexe, l’affichage peut vite devenir illisible.\n\nliste &lt;- list(\n    l2 = list(x = 1:10, y = c(\"Pomme\", \"Citron\")),\n    df = data.frame(v1 = 2:5, v2 = LETTERS[2:5]),\n    y = runif(10)\n)\nliste\n#&gt; $l2\n#&gt; $l2$x\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n#&gt; \n#&gt; $l2$y\n#&gt; [1] \"Pomme\"  \"Citron\"\n#&gt; \n#&gt; \n#&gt; $df\n#&gt;   v1 v2\n#&gt; 1  2  B\n#&gt; 2  3  C\n#&gt; 3  4  D\n#&gt; 4  5  E\n#&gt; \n#&gt; $y\n#&gt;  [1] 0.14345225 0.55216969 0.29222186 0.61694200 0.06517306 0.47422530\n#&gt;  [7] 0.15118192 0.14939243 0.35664022 0.08050226\n\nDans ce cas la fonction str peut être utile pour afficher de manière plus compacte la structure de la liste. Dans cet exemple elle permet de voir un peu plus clairement que x et y sont des éléments d’une sous-liste l2.\n\nstr(liste)\n#&gt; List of 3\n#&gt;  $ l2:List of 2\n#&gt;   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10\n#&gt;   ..$ y: chr [1:2] \"Pomme\" \"Citron\"\n#&gt;  $ df:'data.frame':  4 obs. of  2 variables:\n#&gt;   ..$ v1: int [1:4] 2 3 4 5\n#&gt;   ..$ v2: chr [1:4] \"B\" \"C\" \"D\" \"E\"\n#&gt;  $ y : num [1:10] 0.1435 0.5522 0.2922 0.6169 0.0652 ...\n\n\n\n16.2.2 Ajout d’éléments\nAttention, si on souhaite ajouter un nouvel élément à une liste, il ne faut pas utiliser à nouveau list(), car dans ce cas notre liste de départ est insérée comme une “sous-liste”.\n\nliste &lt;- list(e1 = 1:3, e2 = \"Chihuhua\")\nliste2 &lt;- list(liste, nouveau = 100)\nstr(liste2)\n#&gt; List of 2\n#&gt;  $        :List of 2\n#&gt;   ..$ e1: int [1:3] 1 2 3\n#&gt;   ..$ e2: chr \"Chihuhua\"\n#&gt;  $ nouveau: num 100\n\nIl faut à la place utiliser c(), comme pour les vecteurs.\n\nliste3 &lt;- c(liste, nouveau = 100)\nstr(liste3)\n#&gt; List of 3\n#&gt;  $ e1     : int [1:3] 1 2 3\n#&gt;  $ e2     : chr \"Chihuhua\"\n#&gt;  $ nouveau: num 100\n\nc() permet aussi de “concaténer” deux listes existantes en une seule.\n\nliste1 &lt;- list(a = 1, b = 2)\nliste2 &lt;- list(x = 3, y = 4)\nc(liste1, liste2)\n#&gt; $a\n#&gt; [1] 1\n#&gt; \n#&gt; $b\n#&gt; [1] 2\n#&gt; \n#&gt; $x\n#&gt; [1] 3\n#&gt; \n#&gt; $y\n#&gt; [1] 4\n\n\n\n16.2.3 Sélection d’éléments\nIl y a deux opérateurs différents qui permettent de sélectionner les éléments d’une liste : les crochets simples [] et les crochets doubles [[]]. La différence entre ces deux opérateurs est souvent source de confusion.\nPartons de la liste suivante :\n\nliste &lt;- list(1:5, \"foo\", c(\"Pomme\", \"Citron\"))\nliste\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4 5\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"foo\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"Pomme\"  \"Citron\"\n\nSi on utilise les crochets simples pour sélectionner le premier élément de cette liste, on obtient le résultat suivant :\n\nliste[1]\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4 5\n\nOn notera que le résultat est une liste à un seul élément.\nSi on utilise les crochets doubles :\n\nliste[[1]]\n#&gt; [1] 1 2 3 4 5\n\nOn obtient cette fois-ci non pas une liste composée du premier élément, mais le contenu de ce premier élément.\n\n\n\n\n\n\nAvertissement\n\n\n\nLa différence est importante, mais pas toujours facile à retenir. On peut utiliser deux petites astuces mnémotechniques :\n\nsi une liste est un train composé de plusieurs wagons, [1] retourne le premier wagon du train, tandis que [[1]] renvoie le contenu du premier wagon.\nune alternative est de considérer que [[]] va chercher “plus profondément” que [].\n\n\n\nUn autre point important est que si on passe plusieurs éléments à [[]], la sélection se fait d’une manière récursive peu intuitive et source d’erreurs. Il est donc conseillé de toujours utiliser [[]] avec un seul argument, et d’utiliser [] si on souhaite sélectionner plusieurs éléments d’une liste.\n\nliste[c(1, 2)]\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4 5\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"foo\"\n\n\n\n\n\n\n\nAvertissement\n\n\n\nEn résumé :\n\nsi on souhaite récupérer uniquement le contenu d’un élément d’une liste, on utilise [[]] avec un seul argument.\nsi on souhaite récupérer une nouvelle liste en sélectionnant des éléments de notre liste actuelle, on utilise [] avec un ou plusieurs arguments.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nComme pour les vecteurs, on peut utiliser des nombres négatifs avec [] pour exclure des éléments plutôt que les sélectionner, et on peut également utiliser les fonctions head() et tail().\n\n\nSi la liste est nommée, on peut sélectionner des éléments par noms avec les deux opérateurs.\n\nliste &lt;- list(nombre = 1, char = \"foo\", vecteur = c(\"Pomme\", \"Citron\"))\nliste[c(\"nombre\", \"char\")]\n#&gt; $nombre\n#&gt; [1] 1\n#&gt; \n#&gt; $char\n#&gt; [1] \"foo\"\nliste[[\"vecteur\"]]\n#&gt; [1] \"Pomme\"  \"Citron\"\n\nOn peut aussi utiliser l’opérateur $, qui équivaut à [[]] :\n\nliste$vecteur\n#&gt; [1] \"Pomme\"  \"Citron\"\n\n\n\n16.2.4 Modification\nComme pour les vecteurs, on peut utiliser l’opérateur [] et l’opérateur d’assignation &lt;- pour modifier des éléments d’une liste.\n\nliste &lt;- list(nombre = 1:5, char = \"foo\", vecteur = c(\"Pomme\", \"Citron\"))\nliste[\"nombre\"] &lt;- \"first\"\nliste\n#&gt; $nombre\n#&gt; [1] \"first\"\n#&gt; \n#&gt; $char\n#&gt; [1] \"foo\"\n#&gt; \n#&gt; $vecteur\n#&gt; [1] \"Pomme\"  \"Citron\"\n\n\nliste[c(1, 3)] &lt;- 0\nliste\n#&gt; $nombre\n#&gt; [1] 0\n#&gt; \n#&gt; $char\n#&gt; [1] \"foo\"\n#&gt; \n#&gt; $vecteur\n#&gt; [1] 0\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention à ne pas utiliser les crochets doubles pour modifier des éléments d’une liste car ceux-ci peuvent avoir un comportement inattendu si on veut modifier plusieurs éléments d’un coup.\n\n\nEnfin, on peut supprimer un ou plusieurs éléments d’une liste, en leur attribuant la valeur NULL2.\n\nliste &lt;- list(nombre = 1:5, char = \"foo\", vecteur = c(\"Pomme\", \"Citron\"))\nliste$char &lt;- NULL\nliste\n#&gt; $nombre\n#&gt; [1] 1 2 3 4 5\n#&gt; \n#&gt; $vecteur\n#&gt; [1] \"Pomme\"  \"Citron\"\n\n\n\n16.2.5 Utilisation\nEn tant que généralisation des vecteurs atomiques, les listes sont utiles dès qu’on souhaite regrouper des éléments complexes ou hétérogènes.\nOn les utilisera par exemple pour retourner plusieurs résultats depuis une fonction.\n\nindicateurs &lt;- function(x) {\n    list(\n        moyenne = mean(x),\n        variance = var(x)\n    )\n}\n\nx &lt;- 1:10\nres &lt;- indicateurs(x)\nres$moyenne\n#&gt; [1] 5.5\nres$variance\n#&gt; [1] 9.166667\n\nOn utilise également les listes pour stocker des objets complexes et leur appliquer des fonctions. Ce fonctionnement sera abordé en détail dans la Chapitre 18, mais en guise de petit aperçu, l’exemple fictif suivant récupère les noms de tous les fichiers CSV du répertoire courant et les importe tous dans une liste à l’aide de purrr::map() et de read_csv().\n\nfiles &lt;- list.files(pattern = \"*.csv\")\ndfs &lt;- purrr::map(files, read_csv)\n\nOn pourra ensuite utiliser cette liste de tableaux pour leur appliquer des transformations ou les fusionner."
  },
  {
    "objectID": "16-structures-donnees.html#sec-data-frame-tibbles",
    "href": "16-structures-donnees.html#sec-data-frame-tibbles",
    "title": "16  Structures de données",
    "section": "16.3 Tableaux de données (data frame et tibble)",
    "text": "16.3 Tableaux de données (data frame et tibble)\nOn a déjà utilisé les tableaux de données à de nombreux reprises en manipulant des data frames ou des tibbles. Les seconds sont une variante des premiers, les différences entre les deux ayant été abordées Section 6.4.\nUn tableau de données est en réalité une liste nommée de vecteurs atomiques avec une contrainte spécifique : ces vecteurs doivent tous être de même longueur, ce qui garantit le format “tabulaire” des données.\n\n16.3.1 Création\nUn tableau de données est le plus souvent créé en important des données depuis un fichier au format CSV, tableur ou autre. On peut cependant créer un data frame manuellement via la fonction data.frame() :\n\ndf &lt;- data.frame(\n    fruit = c(\"Pomme\", \"Pomme\", \"Citron\"),\n    poids = c(154, 167, 92),\n    couleur = c(\"vert\", \"vert\", \"jaune\")\n)\n\nOn peut aussi créer un tibble manuellement avec la fonction tibble(). La syntaxe est la même que celle de data.frame(), mais avec un comportement un peu différent : notamment, les noms comportant des espaces ou des caractères spéciaux sont conservés tels quels.\nLa fonction tribble() permet de créer un tibble manuellement avec une syntaxe “par ligne” qui peut être un peu plus lisible.\n\ndf_trib &lt;- tribble(\n    ~fruit,   ~poids, ~couleur,\n    \"Pomme\",  154,    \"vert\",\n    \"Pomme\",  167,    \"vert\",\n    \"Citron\", 92,     \"jaune\"\n)\n\nOn peut convertir un data frame en tibble avec la fonction as_tibble().\n\ndf_tib &lt;- as_tibble(df)\ndf_tib\n#&gt; # A tibble: 3 × 3\n#&gt;   fruit  poids couleur\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1 Pomme    154 vert   \n#&gt; 2 Pomme    167 vert   \n#&gt; 3 Citron    92 jaune\n\n\n\n16.3.2 Noms de colonnes et de lignes\nOn peut lister et modifier les noms des colonnes d’un tableau avec les fonctions names() ou colnames() (qui sont équivalentes).\n\nnames(df)\n#&gt; [1] \"fruit\"   \"poids\"   \"couleur\"\ncolnames(df)\n#&gt; [1] \"fruit\"   \"poids\"   \"couleur\"\n\nOn peut attribuer des noms aux lignes d’un data frame à l’aide de la fonction rownames(). Attention cependant, les noms de ligne ne sont (volontairement) pas pris en charge par les tibbles.\n\nrownames(df) &lt;- c(\"fruit1\", \"fruit2\", \"fruit3\")\nrownames(df)\n#&gt; [1] \"fruit1\" \"fruit2\" \"fruit3\"\n\n\nrownames(df_tib) &lt;- c(\"fruit1\", \"fruit2\", \"fruit3\")\n#&gt; Warning: Setting row names on a tibble is deprecated.\n\nSi on souhaite conserver des noms de ligne en passant d’un data frame à un tibble, il faut les stocker dans une nouvelle colonne, soit en la créant manuellement soit avec la fonction rownames_to_column() (qui a l’avantage de placer la nouvelle colonne en première position du tableau).\n\nrownames_to_column(df, \"name\")\n#&gt;     name  fruit poids couleur\n#&gt; 1 fruit1  Pomme   154    vert\n#&gt; 2 fruit2  Pomme   167    vert\n#&gt; 3 fruit3 Citron    92   jaune\n\n\n\n16.3.3 Sélection de lignes et de colonnes\nOn a déjà vu dans les parties précédentes plusieurs manières de sélectionner des éléments dans un tableau de données.\nAinsi, on peut sélectionner une colonne via l’opérateur $.\n\ndf$fruit\n#&gt; [1] \"Pomme\"  \"Pomme\"  \"Citron\"\n\nComme un tableau de données est en réalité une liste de colonnes, on peut aussi utiliser l’opérateur [[]] pour sélectionner l’une de ses colonnes, par position ou par nom3.\n\ndf[[\"fruit\"]]\n#&gt; [1] \"Pomme\"  \"Pomme\"  \"Citron\"\ndf[[2]]\n#&gt; [1] 154 167  92\n\nOn peut utiliser head() et tail() avec un tableau de données : dans ce cas ces fonctions retourneront les premières ou dernières lignes du tableau.\n\nhead(df, 2)\n#&gt;        fruit poids couleur\n#&gt; fruit1 Pomme   154    vert\n#&gt; fruit2 Pomme   167    vert\n\n\ntail(df, 1)\n#&gt;         fruit poids couleur\n#&gt; fruit3 Citron    92   jaune\n\nOn peut également utiliser l’opérateur [,] pour sélectionner à la fois des lignes et des colonnes, en lui passant deux arguments séparés par une virgule : d’abord la sélection des lignes puis celle des colonnes. Dans les deux cas on peut sélectionner par position, nom ou condition. Si on laisse un argument vide, on sélectionne l’intégralité des lignes ou des colonnes.\n\n# Lignes 1 et 3 et colonne \"poids\"\ndf[c(1, 3), \"poids\"]\n#&gt; [1] 154  92\n\n\n# Toutes les lignes et colonnes \"poids\" et \"fruit\"\ndf[, c(\"poids\", \"fruit\")]\n#&gt;        poids  fruit\n#&gt; fruit1   154  Pomme\n#&gt; fruit2   167  Pomme\n#&gt; fruit3    92 Citron\n\n\n# Lignes pour lesquelles poids &gt; 150, et toutes les colonnes\ndf[df$poids &gt; 150, ]\n#&gt;        fruit poids couleur\n#&gt; fruit1 Pomme   154    vert\n#&gt; fruit2 Pomme   167    vert\n\n\nlibrary(stringr)\n# Colonnes dont le nom contient un \"o\", et toutes les lignes\ndf[, str_detect(names(df), \"o\")]\n#&gt;        poids couleur\n#&gt; fruit1   154    vert\n#&gt; fruit2   167    vert\n#&gt; fruit3    92   jaune\n\nAttention, le comportement de [,] est différent entre les tibbles et les data frame lorsqu’on ne sélectionne qu’une seule colonne. Dans le cas d’un data frame, le résultat est un vecteur, dans le cas d’un tibble le résultat est un tableau à une colonne.\n\ndf[, \"fruit\"]\n#&gt; [1] \"Pomme\"  \"Pomme\"  \"Citron\"\n\n\ndf_tib[, \"fruit\"]\n#&gt; # A tibble: 3 × 1\n#&gt;   fruit \n#&gt;   &lt;chr&gt; \n#&gt; 1 Pomme \n#&gt; 2 Pomme \n#&gt; 3 Citron\n\nCette différence peut parfois être source d’erreurs, notamment quand on développe une fonction qui prend un tableau de données en argument.\n\n\n16.3.4 Modification\nOn peut utiliser [[]] et [,] avec l’opérateur d’assignation &lt;- pour modifier tout ou partie d’un tableau de données.\n\n# Création d'une nouvelle colonne poids_kg\ndf[[\"poids_kg\"]] &lt;- df$poids / 1000\ndf\n#&gt;         fruit poids couleur poids_kg\n#&gt; fruit1  Pomme   154    vert    0.154\n#&gt; fruit2  Pomme   167    vert    0.167\n#&gt; fruit3 Citron    92   jaune    0.092\n\n\n# Remplacement de la valeur de la colonne \"fruit\" pour les lignes \n# pour lesquelles \"fruit\" vaut \"Citron\"\ndf[df$fruit == \"Citron\", \"fruit\"] &lt;- \"Agrume\"\ndf\n#&gt;         fruit poids couleur poids_kg\n#&gt; fruit1  Pomme   154    vert    0.154\n#&gt; fruit2  Pomme   167    vert    0.167\n#&gt; fruit3 Agrume    92   jaune    0.092\n\nPour conclure, on peut noter que l’utilisation des opérateurs [[]] et [,] sur un tableau de données peut sembler redondante et moins pratique que l’utilisation des verbes de dplyr comme select() ou filter(). Ils peuvent cependant être utiles lorsqu’on souhaite éviter les complications liées à l’utilisation du tidyverse à l’intérieur de fonctions, comme indiqué Chapitre 19. Ils peuvent également être plus rapides, et il est important de les connaître car on les rencontrera très fréquemment dans du code R sur le Web ou dans des packages."
  },
  {
    "objectID": "16-structures-donnees.html#ressources",
    "href": "16-structures-donnees.html#ressources",
    "title": "16  Structures de données",
    "section": "16.4 Ressources",
    "text": "16.4 Ressources\nL’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre sur les vecteurs atomiques et les listes, et un chapitre dédié aux tibbles.\nPour aller encore plus loin, l’ouvrage Advanced R (également en anglais) aborde de manière approfondie les structures de données et les opérateurs de sélection [], [[]] et $."
  },
  {
    "objectID": "16-structures-donnees.html#exercices",
    "href": "16-structures-donnees.html#exercices",
    "title": "16  Structures de données",
    "section": "16.5 Exercices",
    "text": "16.5 Exercices\n\n16.5.1 Vecteurs atomiques\nExercice 1.1\nÀ l’aide de seq(), créer un vecteur v contenant tous les nombres pairs entre 10 et 20.\n\n\nv &lt;- seq(10, 20, by = 2)\n\n\nSélectionner les 3 premières valeurs de v.\n\n\nv[1:3]\nhead(v, 3)\n\n\nSélectionner toutes les valeurs de v strictement inférieures à 15.\n\n\nv[v &lt; 15]\n\n\nCréer une fonction derniere() qui prend en paramètre un vecteur et retourne son dernier élément (la fonction doit pouvoir s’appliquer à n’importe quel vecteur, quelle que soit sa longueur).\n\nderniere(v)\n#&gt; [1] 20\n\n\n\nderniere &lt;- function(v) {\n    v[length(v)]\n}\n\n# Ou bien\n\nderniere &lt;- function(v) {\n    tail(v, 1)\n}\n\n\nCréer une fonction sauf_derniere() qui prend en paramètre un vecteur et retourne ce vecteur sans son dernier élément.\n\nsauf_derniere(v)\n#&gt; [1] 10 12 14 16 18\n\n\n\nsauf_derniere &lt;- function(v) {\n    v[-length(v)]\n}\n\n# Ou bien\n\nsauf_derniere &lt;- function(v) {\n    head(v, -1)\n}\n\n\nExercice 1.2\nSoit le vecteur vn suivant :\n\nvn &lt;- c(val1 = 10, val2 = 0, val3 = 14)\n\nSélectionner les valeurs nommées “val1” et “val3”.\n\n\nvn[c(\"val1\", \"val3\")]\n\n\nCréer une fonction select_noms() qui prend en argument un vecteur v et un ou plusieurs noms, et retourne uniquement les éléments de v correspondant à ces noms.\n\nselect_noms(vn, c(\"val2\", \"val3\"))\n#&gt; val2 val3 \n#&gt;    0   14\n\n\n\nselect_noms &lt;- function(v, noms) {\n    v[noms]\n}\n\n\nFacultatif : créer une fonction sauf_nom() qui prend en argument un vecteur v et un nom, et retourne tous les éléments de v sauf celui correspondant à ce nom.\n\nsauf_nom(vn, \"val2\")\n#&gt; val1 val3 \n#&gt;   10   14\n\n\n\nsauf_nom &lt;- function(v, nom) {\n    v[names(v) != nom]\n}\n\n\nFacultatif : comparer les résultats des deux instructions suivantes.\n\nvn[\"val1\"]\nvn[[\"val1\"]]\n\nExercice 1.3\nSoit les vecteurs x et y suivants :\n\nx &lt;- c(1, NA, 3, 4, NA)\ny &lt;- c(10, 20, 30, 40, 50)\n\nÀ l’aide de l’opérateur [], sélectionner uniquement les valeurs NA de x.\n\n\nx[is.na(x)]\n\n\nDe la même manière, sélectionner les valeurs de y correspondant aux valeurs NA de x (c’est-à-dire les valeurs 20 et 50).\n\n\ny[is.na(x)]\n\n\nEn utilisant les deux instructions précédentes et l’opérateur d’assignation &lt;-, remplacer les valeurs manquantes de x par les valeurs correspondantes de y.\n\n\nx[is.na(x)] &lt;- y[is.na(x)]\n\n\nExercice 1.4\nCréer une fonction problemes_conversion qui :\n\nprend en argument un vecteur v\nle convertit en vecteur numérique\nretourne les valeurs de v qui n’ont pas été converties correctement, c’est-à-dire celles qui ne valaient pas NA dans v mais valent NA après la conversion.\n\nVérifier avec :\n\nx &lt;- c(\"igloo\", \"20\", NA, \"3.5\", \"4,8\")\nproblemes_conversion(x)\n#&gt; Warning in problemes_conversion(x): NAs introduced by coercion\n#&gt; [1] \"igloo\" \"4,8\"\n\n\n\nproblemes_conversion &lt;- function(v) {\n    conv &lt;- as.numeric(v)\n    v[!is.na(v) & is.na(conv)]\n}\n\n\n\n\n16.5.2 Listes\nExercice 2.1\nCréer une liste liste ayant la structure suivante :\n\n#&gt; List of 3\n#&gt;  $ : num 1\n#&gt;  $ : chr \"oui\"\n#&gt;  $ : int [1:3] 10 11 12\n\n\n\nliste &lt;- list(1, \"oui\", 10:12)\n\n\nDonner les noms suivants aux éléments de la liste : num, reponse et vec.\n\n\nnames(liste) &lt;- c(\"num\", \"reponse\", \"vec\")\n\n\nAjouter un élément nommé chat et ayant pour valeur “Ronron” à la fin de liste.\n\n\nliste &lt;- c(liste, chat = \"Ronron\")\n\n\nModifier l’élément chat pour lui donner la valeur “Ronpchi”.\n\n\nliste$chat &lt;- \"Ronpchi\"\n# Ou bien\nliste[\"chat\"] &lt;- \"Ronpchi\"\n\n\nSupprimer l’élément vec de liste.\n\n\nliste$vec &lt;- NULL\n# Ou bien\nliste[\"vec\"] &lt;- NULL\n\n\nExercice 2.2\nCréer une fonction nommée extremes qui prend en argument un vecteur et retourne une liste nommée comportant sa valeur minimale et sa valeur maximale.\n\n\nextremes &lt;- function(x) {\n    list(min = min(x), max = max(x))\n}\n\n\nAppliquer cette fonction à un vecteur de votre choix et utiliser le résultat pour calculer l’étendue (soit la différence entre la valeur maximale et la valeur minimale).\n\n\nv &lt;- runif(10)\nres &lt;- extremes(v)\nres$max - res$min\n\n\nExercice 2.3\nSoit la liste suivante :\n\nliste &lt;- list(1:3, runif(5), \"youpi\")\n\nSélectionner la sous liste composée des éléments 1 et 3 de liste.\n\n\nliste[c(1, 3)]\n\n\nSélectionner la sous-liste composée du premier élément de liste.\n\n\nliste[1]\n\n\nSélectionner le contenu du premier élément de liste.\n\n\nliste[[1]]\n\n\nEn enchaînant deux opérations de sélection, sélectionner le deuxième élément du premier élément de liste.\n\n\nliste[[1]][2]\n\n\nExercice 2.4\nCréer une fonction description_liste qui prend en argument une liste et retourne :\n\nson premier élément\nson dernier élément\nle nombre d’éléments qu’elle contient\n\nVérifier avec :\n\nliste &lt;- list(1:3, runif(5), \"youpi\")\ndescription_liste(liste)\n#&gt; $premier_element\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $dernier_element\n#&gt; [1] \"youpi\"\n#&gt; \n#&gt; $nb_elements\n#&gt; [1] 3\n\n\n\ndescription_liste &lt;- function(liste) {\n    list(\n        premier_element = liste[[1]],\n        dernier_element = liste[[length(liste)]],\n        nb_elements = length(liste)\n    )\n}\n\n\n\n\n16.5.3 Tableaux de données\nExercice 3.1\nCréer le tableau df suivant :\n\ndf &lt;- tribble(\n    ~fruit,   ~poids, ~couleur,\n    \"Pomme\",  154,    \"vert\",\n    \"Pomme\",  167,    \"vert\",\n    \"Citron\", 92,     \"jaune\"\n)\n\nÀ l’aide de l’opérateur $, sélectionner la colonne fruit de df.\n\n\ndf$fruit\n\n\nFaire de même avec l’opérateur [[]].\n\n\ndf[[\"fruit\"]]\n\n\nÀ l’aide de l’opérateur [[]] et de la fonction str_to_upper() de stringr, transformer la colonne fruit en passant ses valeurs en majuscules.\n\n\nlibrary(stringr)\ndf[[\"fruit\"]] &lt;- str_to_upper(df[[\"fruit\"]])\n\n\nCréer une fonction colonne_maj qui prend en argument un tableau de données d et un nom de colonne colonne, et retourne le tableau avec la colonne correspondante convertie en majuscules. Vérifier avec :\n\ncolonne_maj(df, \"couleur\")\n#&gt; # A tibble: 3 × 3\n#&gt;   fruit  poids couleur\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1 Pomme    154 VERT   \n#&gt; 2 Pomme    167 VERT   \n#&gt; 3 Citron    92 JAUNE\n\n\n\ncolonne_maj &lt;- function(d, colonne) {\n    d[[colonne]] &lt;- str_to_upper(d[[colonne]])\n    d\n}\n\n\nExercice 3.2\nCréer le tableau df suivant :\n\ndf &lt;- tribble(\n    ~fruit,   ~poids, ~couleur,\n    \"Pomme\",  154,    \"vert\",\n    \"Pomme\",  167,    \"vert\",\n    \"Citron\", 92,     \"jaune\"\n)\n\nÀ l’aide de l’opérateur [,], sélectionner :\n\nles citrons\nles pommes et les colonnes fruit et couleur\nla première colonne des lignes ayant un poids inférieur à 100\n\n\n\ndf[df$fruit == \"Citron\",]\ndf[df$fruit == \"Pomme\", c(\"fruit\", \"couleur\")]\ndf[df$poids &lt; 100, 1]\n\n\nCréer une fonction filtre_valeur() qui prend un seul argument nommé valeur et retourne les lignes de df pour lesquelles la colonne fruit vaut valeur. Vérifier avec :\n\nfiltre_valeur(\"Pomme\")\n#&gt; # A tibble: 2 × 3\n#&gt;   fruit poids couleur\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1 Pomme   154 vert   \n#&gt; 2 Pomme   167 vert\n\n\n\nfiltre_valeur &lt;- function(valeur) {\n    df[df$fruit == valeur,]\n}\n\n\nModifier la fonction pour qu’elle accepte également un argument d contenant le tableau à filtrer. Vérifier avec :\n\nfiltre_valeur(df, \"Pomme\")\n#&gt; # A tibble: 2 × 3\n#&gt;   fruit poids couleur\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1 Pomme   154 vert   \n#&gt; 2 Pomme   167 vert\n\n\n\nfiltre_valeur &lt;- function(d, valeur) {\n    d[d$fruit == valeur,]\n}\n\n\nModifier à nouveau la fonction pour qu’elle accepte aussi un argument colonne qui contient le nom de la colonne à utiliser pour filtrer les lignes. Vérifier avec :\n\nfiltre_valeur(df, colonne = \"couleur\", valeur = \"jaune\")\n#&gt; # A tibble: 1 × 3\n#&gt;   fruit  poids couleur\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1 Citron    92 jaune\n\n\n\nfiltre_valeur &lt;- function(d, colonne, valeur) {\n    d[d[colonne] == valeur,]\n}\n\n\nVérifier que cette fonction marche aussi sur un autre jeu de données :\n\nlibrary(questionr)\ndata(hdv2003)\nfiltre_valeur(hdv2003, \"sexe\", \"Femme\")\n\nExercice 3.3\nReprendre le tableau df des exercices précédents :\n\ndf &lt;- tribble(\n    ~fruit,   ~poids, ~couleur,\n    \"Pomme\",  154,    \"vert\",\n    \"Pomme\",  167,    \"vert\",\n    \"Citron\", 92,     \"jaune\"\n)\n\nÀ l’aide de l’opérateur [,], effectuer les opérations suivantes :\n\nCréer une nouvelle colonne id avec les valeurs 1, 2, 3\nRemplacer la valeur “jaune” de la variable couleur par “jaune citron”\nCréer une nouvelle colonne poids_rec qui vaut “léger” si poids est inférieur à 100, et “lourd” sinon\n\n\n\ndf[, \"id\"] &lt;- 1:3\ndf[df$couleur == \"jaune\", \"couleur\"] &lt;- \"jaune citron\"\n\ndf[df$poids &lt; 100, \"poids_rec\"] &lt;- \"léger\"\ndf[df$poids &gt;= 100, \"poids_rec\"] &lt;- \"lourd\"\n# Ou bien :\ndf[, \"poids_rec\"] &lt;- ifelse(df$poids &lt; 100, \"léger\", \"lourd\")\n\n\nFacultatif : effectuer les mêmes opérations en utilisant les verbes de dplyr.\n\n\ndf &lt;- df %&gt;% mutate(id = 1:3)\n\ndf &lt;- df %&gt;%\n    mutate(\n        couleur = ifelse(couleur == \"jaune\", \"jaune_citron\", couleur)\n    )\n# Ou bien :\nlibrary(forcats)\ndf &lt;- df %&gt;%\n    mutate(\n        couleur = fct_recode(couleur, \"jaune_citron\" = \"jaune\")\n    )\n\ndf &lt;- df %&gt;%\n    mutate(\n        poids_rec = ifelse(poids &lt; 100, \"léger\", \"lourd\")\n    )"
  },
  {
    "objectID": "16-structures-donnees.html#footnotes",
    "href": "16-structures-donnees.html#footnotes",
    "title": "16  Structures de données",
    "section": "",
    "text": "Il en existe d’autres, comme complex ou raw, mais qui sont moins fréquemment utilisés.↩︎\nSi on veut ajouter un élément NULL à une liste, il faut utiliser les crochets simples avec la syntaxe liste[\"foo\"] &lt;- list(NULL).↩︎\nAttention, comme pour les listes, à ne pas utiliser [[]] avec un argument de longueur supérieur à 1, car cela mène soit à des erreurs soit à des résultats contre-intuitifs.↩︎"
  },
  {
    "objectID": "17-if-boucles.html#if-et-else-exécuter-du-code-sous-certaines-conditions",
    "href": "17-if-boucles.html#if-et-else-exécuter-du-code-sous-certaines-conditions",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "17.1 if et else : exécuter du code sous certaines conditions",
    "text": "17.1 if et else : exécuter du code sous certaines conditions\n\n17.1.1 if\nL’instruction if permet de n’exécuter du code que si une condition est remplie.\nif est suivie d’une condition (entre parenthèses) puis d’un bloc de code (entre accolades). Ce bloc de code n’est exécuté que si la condition est vraie.\n\nPar exemple, dans le code suivant, le message Bonjour ! ne sera affiché que si la valeur de l’objet prenom vaut \"Pierre-Edmond\" :\n\nprenom &lt;- \"Pierre-Edmond\"\nif (prenom == \"Pierre-Edmond\") {\n    message(\"Bonjour !\")\n}\n#&gt; Bonjour !\n\nOn peut utiliser ce code pour créer une passionnante fonction qui a pour objectif de ne dire bonjour qu’aux personnes qui s’appellent Pierre-Edmond :\n\nbonjour_pierre_edmond &lt;- function(prenom) {\n    if (prenom == \"Pierre-Edmond\") {\n        message(\"Bonjour !\")\n    }\n}\n\nbonjour_pierre_edmond(\"Pierre-Edmond\")\n#&gt; Bonjour !\n\nbonjour_pierre_edmond(\"Valérie-Charlotte\")\n\nUne autre utilisation possible (et un peu plus utile) dans le cadre d’une fonction est de n’exécuter certaines instructions que si la valeur d’un argument vaut une valeur donnée. Dans l’exemple suivant, on n’applique la fonction round() que si l’argument arrondir vaut TRUE.\n\nmoyenne &lt;- function(x, arrondir = TRUE) {\n    res &lt;- mean(x)\n    if (arrondir == TRUE) {\n        res &lt;- round(res)\n    }\n    res\n}\n\nv &lt;- c(1.4, 2.3, 8.9)\nmoyenne(v)\n#&gt; [1] 4\nmoyenne(v, arrondir = FALSE)\n#&gt; [1] 4.2\n\n\n\n\n\n\n\nAvertissement\n\n\n\nOn notera que le test x == TRUE est en fait redondant, car son résultat est le même que la valeur de x :\n\nsi x vaut TRUE, x == TRUE vaut TRUE\nsi x vaut FALSE, x == TRUE vaut FALSE\n\nOn remplacera donc en général if (x == TRUE) par if (x).\nDe la même manière, on pourra remplacer if (x == FALSE) par if (!x).\n\n\nDans notre fonction moyenne ci-dessus, on peut donc remplacer :\n\nif (arrondir == TRUE) {\n    res &lt;- round(res)\n}\n\nPar :\n\nif (arrondir) {\n    res &lt;- round(res)\n}\n\nÀ noter également que quand le bloc de code qui suit une instruction if ne comporte qu’une seule instruction, on peut omettre les accolades qui l’entourent. Les syntaxe suivantes sont donc équivalentes :\n\nif (arrondir) {\n    res &lt;- round(res)\n}\n\nif (arrondir) res &lt;- round(res)\n\n\n\n17.1.2 if / else\nOn utilise souvent if en le faisant suivre par une instruction else. else précède un autre bloc de code R qui ne s’exécute que si la condition donnée au if est fausse :\n\nOn peut ainsi utiliser if / else pour une nouvelle fonction fort utile qui nous évitera bien des désagréments météorologiques.\n\nconseil_vestimentaire &lt;- function(temperature) {\n    if (temperature &gt; 15) {\n        message(\"La polaire n'est pas forcément nécessaire.\")\n    } else {\n        message(\"Vous devriez prendre une petite laine.\")\n    }\n}\n\nconseil_vestimentaire(-5)\n#&gt; Vous devriez prendre une petite laine.\n\nPlus utile, on peut l’utiliser pour effectuer deux actions différentes en fonction de la valeur d’un argument. La fonction suivante génère deux graphiques différents selon le type du vecteur passé en argument :\n\ngraph_var &lt;- function(x) {\n    if (is.character(x)) {\n        barplot(table(x))\n    } else {\n        hist(x)\n    }\n}\n\ngraph_var(c(\"Pomme\", \"Pomme\", \"Citron\"))\n\n\n\ngraph_var(c(1, 5, 10, 3, 1, 4))\n\n\n\n\n\n\n17.1.3 “if” / “else if” / “else”\nUne possibilité complémentaire est d’ajouter des blocs else if qui permettent d’ajouter des conditions supplémentaires. Dès qu’une condition est vraie, le bloc de code correspondant est exécuté. Le dernier bloc else est exécuté si aucune des conditions n’est vraie.\nOn peut donc améliorer encore notre fonction graph_var() pour tester plusieurs types explicitement et afficher un message si aucun type géré n’a été reconnu.\n\ngraph_var &lt;- function(x) {\n    if (is.character(x)) {\n        barplot(table(x))\n    } else if (is.numeric(x)) {\n        hist(x)\n    } else {\n        message(\"Le type de x n'est pas géré par la fonction\")\n    }\n}\n\ngraph_var(c(TRUE, FALSE, TRUE))\n#&gt; Le type de x n'est pas géré par la fonction\n\nAttention, seul le bloc de la première condition vraie est exécuté, l’ordre des conditions est donc important. Dans l’exemple suivant, le second bloc n’est jamais exécuté et donc le second message jamais affiché.\n\ntest_x &lt;- function(x) {\n    if (x &lt; 100) {\n        message(\"x est inférieur à 100\")\n    } else if (x &lt; 10) {\n        message(\"x est inférieur à 10\")\n    }\n}\n\ntest_x(5)\n#&gt; x est inférieur à 100\n\nIl est donc important d’ordonner les conditions de la plus spécifique à la plus générale.\n\n\n17.1.4 Construction de conditions complexes\nOn peut combiner plusieurs tests avec les opérateurs logiques classiques :\n\n&& est l’opérateur “et”, qui est vrai si les deux conditions qu’il réunit sont vraies\n|| est l’opérateur “ou”, qui est vrai si au moins l’une des deux conditions qu’il réunit sont vraies\n! est l’opérateur “not”, qui teste si la condition qu’il précède est fausse\n\nAinsi, si on veut qu’une variable temperature soit comprise entre 15 et 25, on écrira :\n\nverifie_temperature &lt;- function(temperature) {\n    if (temperature &gt;= 15 && temperature &lt;= 25) {\n        message(\"Température ok\")\n    }\n}\nverifie_temperature(20)\n\nSi on souhaite tester que temperature est inférieure à 15 ou supérieure à 25 :\n\nverifie_temperature &lt;- function(temperature) {\n    if (temperature &lt; 15 || temperature &gt; 25) {\n        message(\"Température pas glop\")\n    }\n}\nverifie_temperature(10)\n\nSi on veut tester si temperature vaut NULL, on peut utiliser is.null().\n\nverifie_temperature &lt;- function(temperature = NULL) {\n    if (is.null(temperature)) {\n        message(\"Merci d'indiquer une température\")\n    }\n}\nverifie_temperature()\n\nMais si à l’inverse on veut tester si temperature n’est pas NULL, on inverse le test précédent en utilisant !.\n\nverifie_temperature &lt;- function(temperature = NULL) {\n    if (!is.null(temperature)) {\n        message(\"Merci d'avoir indiqué une température\")\n    }\n}\nverifie_temperature(15)\n\nOn pourra noter qu’il existe deux types d’opérateurs “et” et “ou” dans R :\n\nLes opérateurs simples & et | sont des opérateurs vectorisés. Ils peuvent s’appliquer à des vecteurs et retourneront un vecteur de TRUE et FALSE.\nLes opérateurs doubles && et || ne peuvent retourner qu’une seule valeur, et si on leur fournit des vecteurs ils n’utiliseront que la première valeur de chacun d’entre eux.\n\n\nx &lt;- 1:5\nx &gt; 0 & x &lt;= 2\n#&gt; [1]  TRUE  TRUE FALSE FALSE FALSE\nx &gt; 0 && x &lt;= 2\n#&gt; Warning in x &gt; 0 && x &lt;= 2: 'length(x) = 5 &gt; 1' in coercion to 'logical(1)'\n\n#&gt; Warning in x &gt; 0 && x &lt;= 2: 'length(x) = 5 &gt; 1' in coercion to 'logical(1)'\n#&gt; [1] TRUE\n\nQuand on passe un test à un if, celui-ci est censé retourner une unique valeur TRUE ou FALSE. Une erreur fréquente, notamment quand on est dans une fonction, est de passer à if une condition appliquée à un vecteur. Dans ce cas R a la bonne idée d’afficher une erreur1.\n\nsuperieur_a_5 &lt;- function(x) {\n    if (x &gt;= 5) {\n        message(\"&gt;=5\")\n    }\n}\n\nsuperieur_a_5(1:10)\n#&gt; Error in if (x &gt;= 5) {: the condition has length &gt; 1\n\n\n\n\n\n\n\nAvertissement\n\n\n\nÀ retenir : quand on utilise l’instruction if, la condition qui lui est passée entre parenthèses ne doit renvoyer qu’une seule valeur TRUE ou FALSE. Si on utilise une condition complexe, on utilisera donc plutôt les opérateurs doubles && et ||.\n\n\n\n\n17.1.5 Différence entre if / else et ifelse\nUne source fréquente de confusion concerne la différence entre les instructions if / else et la fonction ifelse() de R base (ou son équivalent if_else() de dplyr, voir Section 9.4.1). Les deux sont pourtant très différentes :\n\nif / else s’utilisent quand on teste une seule condition et qu’on veut exécuter des blocs de code différents selon son résultat\nifelse applique un test à tous les éléments d’un vecteur et retournent un vecteur dont les éléments dépendent du résultat de chaque test\n\nPremier cas de figure : un objet x contient une seule valeur et on veut afficher un message différent selon si celle-ci est inférieure ou supérieure à 10. Dans ce cas on utilise if / else.\n\nx &lt;- 5\n\nif (x &gt;= 10) {\n    message(\"&gt;=10\")\n} else {\n    message(\"&lt;10\")\n}\n#&gt; &lt;10\n\nDeuxième cas de figure : x est un vecteur et on souhaite recoder chacune de ses valeurs selon le même critère que ci-dessus. Dans ce cas on utilise ifelse.\n\nx &lt;- 5:15\nx_rec &lt;- ifelse(x &gt;= 10, \"&gt;=10\", \"&lt;10\")\nx_rec\n#&gt;  [1] \"&lt;10\"  \"&lt;10\"  \"&lt;10\"  \"&lt;10\"  \"&lt;10\"  \"&gt;=10\" \"&gt;=10\" \"&gt;=10\" \"&gt;=10\" \"&gt;=10\"\n#&gt; [11] \"&gt;=10\""
  },
  {
    "objectID": "17-if-boucles.html#contrôle-de-lexécution-et-gestion-des-erreurs",
    "href": "17-if-boucles.html#contrôle-de-lexécution-et-gestion-des-erreurs",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "17.2 Contrôle de l’exécution et gestion des erreurs",
    "text": "17.2 Contrôle de l’exécution et gestion des erreurs\nL’instruction if est souvent utilisée dans des fonctions pour valider les valeurs passées en arguments, ou plus généralement pour contrôler que l’exécution du code se déroule comme prévu.\n\n17.2.1 Utilisation de return pour sortir de la fonction\nOn peut utiliser un return pour interrompre l’exécution de la fonction et retourner un résultat. On a en effet vu Section 14.2.5 que dès que R rencontre un return dans une fonction, il interrompt immédiatement l’exécution de celle-ci.\nLa fonction suivante retourne la longueur du mot le plus long dans un vecteur de chaînes de caractères.\n\nlongueur_max &lt;- function(x) {\n    max(nchar(x))\n}\n\nlongueur_max(c(\"Pomme\", \"Pamplemousse\"))\n#&gt; [1] 12\n\nCette fonction n’a pas trop de sens si on lui passe en entrée un vecteur qui n’est pas un vecteur de chaînes de caractères. On peut donc rajouter un test qui, si x n’est pas de type character, retourne directement la valeur NA.\n\nlongueur_max &lt;- function(x) {\n    if (!is.character(x)) {\n        return(NA)\n    }\n    max(nchar(x))\n}\n\nlongueur_max(1:5)\n#&gt; [1] NA\n\n\n\n17.2.2 warning\nLa fonction warning fonctionne comme message mais permet d’afficher un avertissement. Celui-ci est présenté un peu différemment dans la console de manière à attirer l’attention, et il indique quelle fonction a déclenché l’avertissement, ce qui peut être utile pour retrouver l’origine du problème.\nDans la fonction précédente, on peut ajouter un avertissement dans le cas où le vecteur passé en argument n’est pas de type character.\n\nlongueur_max &lt;- function(x) {\n    if (!is.character(x)) {\n        warning(\"x n'est pas de type character, le résultat vaut NA.\")\n        return(NA)\n    }\n    max(nchar(x))\n}\n\nlongueur_max(1:5)\n#&gt; Warning in longueur_max(1:5): x n'est pas de type character, le résultat vaut\n#&gt; NA.\n#&gt; [1] NA\n\n\n\n17.2.3 stop et stopifnot\nstop fonctionne comme warning mais déclenche une erreur qui interrompt totalement l’exécution du code. Quand R le rencontre dans une fonction, il sort immédiatement de la fonction, ne retourne aucun résultat, et il interrompt également toutes les autres instructions en attente d’exécution.\nOn peut ainsi considérer, toujours dans la fonction longueur_max, que le fait de ne pas fournir en argument un vecteur de type character est suffisamment “grave” pour interrompre l’exécution en cours et forcer la personne qui utilise la fonction à régler le problème.\n\nlongueur_max &lt;- function(x) {\n    if (!is.character(x)) {\n        stop(\"x doit être de type character.\")\n    }\n    max(nchar(x))\n}\n\nlongueur_max(1:5)\n#&gt; Error in longueur_max(1:5): x doit être de type character.\n\n\n\n\n\n\n\nNote\n\n\n\nSavoir si un problème doit être traité comme un avertissement ou comme une erreur relève du choix de la personne qui développe la fonction : chaque cas est particulier.\n\n\nstopifnot est une syntaxe alternative plus compacte qui combine test et message d’erreur. On lui passe en premier argument une condition, et en deuxième argument un message à afficher si la condition est fausse.\nOn peut donc réécrire notre fonction longueur_max ci-dessus de la manière suivante :\n\nlongueur_max &lt;- function(x) {\n    stopifnot(is.character(x))\n    max(nchar(x))\n}\n\nlongueur_max(1:5)\n#&gt; Error in longueur_max(1:5): is.character(x) is not TRUE\n\nSi on souhaite un message d’erreur personnalisé il faut le passer comme nom de la condition.\n\nlongueur_max &lt;- function(x) {\n    stopifnot(\n        \"x doit être de type character\" = is.character(x)\n    )\n    max(nchar(x))\n}\n\nlongueur_max(1:5)\n#&gt; Error in longueur_max(1:5): x doit être de type character\n\n\n\n17.2.4 Tester la présence d’un argument facultatif\nOn a vu Section 14.2.3 que pour rendre un argument de fonction “facultatif”, on doit lui attribuer une valeur par défaut. Parfois cependant, on n’a pas de valeur par défaut évidente à lui attribuer directement : dans ce cas on lui attribue la valeur NULL et on utilise un if() dans la fonction pour déterminer s’il a été défini ou non par l’utilisateur.\nPar exemple, soit une fonction qui génère un graphique avec un argument titre qui permet de définir son titre.\n\nhisto &lt;- function(x, titre) {\n    hist(x, main = titre)\n}\n\nSi l’utilisateur ne donne pas de titre, on souhaite ajouter un titre qui indique la valeur de la moyenne de la variable représentée. Dans ce cas on attribue à titre la valeur par défaut NULL, et on vérifie dans le corps de la fonction que l’utilisateur n’a pas fourni de valeur avec if (is.null(titre)). On peut alors calculer la valeur “par défaut” souhaitée :\n\nhisto &lt;- function(x, titre = NULL) {\n    if (is.null(titre)) {\n        titre &lt;- paste(\"Moyenne :\", mean(x))\n    }\n    hist(x, main = titre)\n}\n\n\nx &lt;- c(1, 15, 8, 10, 12, 18, 8, 4)\nhisto(x)\n\n\n\n\n\nhisto(x, titre = \"Quel bel histogramme\")"
  },
  {
    "objectID": "17-if-boucles.html#for-et-while-répéter-des-instructions-dans-une-boucle",
    "href": "17-if-boucles.html#for-et-while-répéter-des-instructions-dans-une-boucle",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "17.3 for et while : répéter des instructions dans une boucle",
    "text": "17.3 for et while : répéter des instructions dans une boucle\nLes boucles permettent de répéter du code plusieurs fois, soit en fonction d’une condition soit selon les éléments d’un vecteur2.\n\n17.3.1 for\nLe premier type de boucle est défini par l’instruction for. Sa structure est la suivante :\n\nLe principe est le suivant : on fournit à for entre parenthèses une expression du type item in vecteur, puis un bloc de code entre accolades. for va exécuter le bloc de codes pour chacune des valeurs de vecteur, et affectera tour à tour à item la valeur courante de vecteur.\nPrenons tout de suite un exemple pour mieux comprendre.\n\nfor (item in 1:5) {\n    print(item)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\nIci notre vecteur “source” est constitué des entiers de 1 à 5. for va donc exécuter l’instruction print(item) 5 fois, en remplaçant la première fois item par 1, la seconde fois par 2, etc.\nOn peut itérer sur différents types d’objets, et le nom item peut être remplacé par ce que l’on souhaite :\n\nfor (prenom in c(\"Pierre-Edmond\", \"Valérie-Charlotte\")) {\n    message(\"Bonjour \", prenom, \" !\")\n}\n#&gt; Bonjour Pierre-Edmond !\n#&gt; Bonjour Valérie-Charlotte !\n\nExemple un peu plus complexe, la fonction suivante prend en entrée un tableau de données et un vecteur de noms de variables, et affiche le résultat de summary pour chacune de ces variables.\n\nsummaries &lt;- function(d, vars) {\n    for (var in vars) {\n        message(\"--- \", var, \" ---\")\n        print(summary(d[, var]))\n    }\n}\n\nsummaries(hdv2003, c(\"sexe\", \"age\", \"heures.tv\"))\n#&gt; --- sexe ---\n#&gt; Homme Femme \n#&gt;   899  1101\n#&gt; --- age ---\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;   18.00   35.00   48.00   48.16   60.00   97.00\n#&gt; --- heures.tv ---\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n#&gt;   0.000   1.000   2.000   2.247   3.000  12.000       5\n\nParfois on souhaite itérer sur les éléments par leur position plutôt que par leur valeur. Dans l’exemple suivant, la fonction affiche_dimensions affiche le nombre de lignes et de colonnes des tableaux de données contenus dans une liste :\n\naffiche_dimensions &lt;- function(dfs) {\n    for (df in dfs) {\n        message(\"Dimensions : \", nrow(df), \"x\", ncol(df))\n    }\n}\n\nl &lt;- list(\n    hdv = hdv2003,\n    rp = rp2018\n)\n\naffiche_dimensions(l)\n#&gt; Dimensions : 2000x20\n#&gt; Dimensions : 5417x62\n\nSi on souhaite afficher le nom du tableau en plus de ses dimensions afin de rendre les résultats plus lisibles, on doit itérer sur la position des éléments pour pouvoir récupérer à la fois leur nom (dans names(dfs)) et leur valeur (dans dfs). Dans ces cas-là on peut utiliser la fonction seq_along() qui génère une liste d’entiers correspondant au nombre d’éléments de l’objet qu’on lui passe en argument.\n\nx &lt;- c(\"rouge\", \"vert\", \"bleu\")\nseq_along(x)\n#&gt; [1] 1 2 3\n\nOn peut du coup réécrire affiche_dimensions de la façon suivante.\n\naffiche_dimensions &lt;- function(dfs) {\n    for (i in seq_along(dfs)) {\n        name &lt;- names(dfs)[[i]]\n        df &lt;- dfs[[i]]\n        message(\"Dimensions de \", name, \" : \", nrow(df), \"x\", ncol(df))\n    }\n}\n\naffiche_dimensions(l)\n#&gt; Dimensions de hdv : 2000x20\n#&gt; Dimensions de rp : 5417x62\n\n\n\n\n\n\n\nNote\n\n\n\nIl est assez naturel d’utiliser for (i in 1:length(x)) plutôt que for (i in seq_along(x)). L’utilisation de seq_along(x) est cependant préférable, notamment lorsqu’on est dans une fonction, car elle n’essaie pas d’exécuter le bloc de code si jamais x est de longueur nulle.\nEn effet, si length(x) vaut 0 alors 1:length(x) vaut 1:0, c’est-à-dire le vecteur c(1, 0), ce qui signifie que la boucle sera exécutée et risque de générer une erreur. De son côté, seq_along(x) garantit dans ces cas-là qu’aucune itération du for n’est exécutée.\n\n\nÀ noter que quand on sort d’une boucle for, l’objet utilisé pour itérer sur les valeurs du vecteur existe toujours, et contient la dernière valeur qu’il a prise.\n\nfor (i in 1:3) {\n    print(\"a\")\n}\n#&gt; [1] \"a\"\n#&gt; [1] \"a\"\n#&gt; [1] \"a\"\nprint(i)\n#&gt; [1] 3\n\n\n\n17.3.2 while\nwhile prend en argument une condition et est suivi d’un bloc de code entre accolades. Elle exécute le bloc tant que la condition est vraie :\n\nPar exemple, la fonction suivante simule un tirage à pile ou face à l’aide de la fonction sample(). La simulation de tirage s’exécute et affiche le résultat tant qu’on obtient “Pile” (et interrompt la boucle au premier “Face”) :\n\nresultat &lt;- \"\"\nwhile (resultat != \"Face\") {\n    resultat &lt;- sample(c(\"Pile\", \"Face\"), size = 1)\n    print(resultat)\n}\n\n[1] \"Pile\"\n[1] \"Pile\"\n[1] \"Face\"\nLe déroulement de la boucle est le suivant :\n\nla première instruction initialise la valeur de la variable resultat avec une chaîne vide\nà la première entrée dans le while, resultat vaut \"\", elle est donc différente de \"Face\" et le bloc de code est donc exécuté\nà la fin de cette exécution, resultat vaut soit \"Pile\" soit \"Face\". On entre alors une deuxième fois dans le while. Si resultat vaut \"Pile\", la condition du while n’est pas vraie, on n’exécute donc pas le bloc de code et on sort de la boucle. Si resultat vaut \"Face\", la condition est vraie, on exécute le bloc de code et on rentre ensuite une troisième fois dans le while, etc.\n\n\n\n17.3.3 next et break\nLes instructions next et break permettent de modifier les itérations d’une boucle for ou while.\nnext permet de sortir de l’itération courante et de passer directement à l’itération suivante sans exécuter le reste du code.\nReprenons la fonction summaries, vue plus haut, qui affiche le résumé de plusieurs variables d’un tableau de données.\n\nsummaries &lt;- function(d, vars) {\n    for (var in vars) {\n        message(\"--- \", var, \" ---\")\n        print(summary(d[, var]))\n    }\n}\n\nsummaries(hdv2003, c(\"sexe\", \"age\"))\n#&gt; --- sexe ---\n#&gt; Homme Femme \n#&gt;   899  1101\n#&gt; --- age ---\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;   18.00   35.00   48.00   48.16   60.00   97.00\n\nSi on passe à la fonction un nom de colonne qui n’existe pas, on obtient une erreur et les autres variables ne sont pas affichées.\n\nsummaries(hdv2003, c(\"sexe\", \"igloo\", \"age\"))\n#&gt; --- sexe ---\n#&gt; Homme Femme \n#&gt;   899  1101\n#&gt; --- igloo ---\n#&gt; Error in `[.data.frame`(d, , var): undefined columns selected\n\nOn pourrait dans ce cas vouloir afficher les résultats pour les “bonnes” colonnes, et ignorer les autres. C’est possible si on ajoute une instruction next quand la valeur courante de var ne fait pas partie des noms de colonnes (on pourrait aussi ajouter un warning() juste avant le next pour informer l’utilisateur).\n\nsummaries &lt;- function(d, vars) {\n    for (var in vars) {\n        if (!(var %in% names(d))) {\n            next\n        }\n        message(\"--- \", var, \" ---\")\n        print(summary(d[, var]))\n    }\n}\n\nsummaries(hdv2003, c(\"sexe\", \"igloo\", \"age\"))\n#&gt; --- sexe ---\n#&gt; Homme Femme \n#&gt;   899  1101\n#&gt; --- age ---\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;   18.00   35.00   48.00   48.16   60.00   97.00\n\nL’instruction break est un peu plus radicale : non seulement elle sort de l’itération courante sans exécuter la suite du code, mais elle interrompt carrément la boucle toute entière et n’exécute pas les itérations restantes.\nDans l’exemple précédent, si on remplace next par break, on voit bien qu’on sort de la boucle et que seule la première itération est totalement exécutée.\n\nsummaries &lt;- function(d, vars) {\n    for (var in vars) {\n        if (!(var %in% names(d))) {\n            break\n        }\n        message(\"--- \", var, \" ---\")\n        print(summary(d[, var]))\n    }\n}\n\nsummaries(hdv2003, c(\"sexe\", \"igloo\", \"age\"))\n#&gt; --- sexe ---\n#&gt; Homme Femme \n#&gt;   899  1101\n\n\n\n17.3.4 Quand (ne pas) utiliser des boucles\nLe mécanisme des boucles, assez intuitif, peut être utilisé pour beaucoup d’opérations. Il y a cependant sous R des alternatives souvent plus rapides, qu’il est préférable de privilégier.\nAvant tout, de nombreuses fonctions R sont “vectorisées” et s’appliquent directement à tous les éléments d’un vecteur. Dans le cas où une fonction vectorisée existe déjà, elle propose en général une syntaxe plus compacte et une exécution (beaucoup) plus rapide.\nPour prendre un exemple caricatural, si on souhaite ajouter 10 à chaque élément d’un vecteur on évitera absolument de faire :\n\nfor (i in seq_along(x)) {\n    x[i] &lt;- x[i] + 10\n}\n\nEt on se contentera d’un beaucoup plus simple x + 10.\nAutre exemple, si on souhaite remplacer dans tous les éléments d’un vecteur de chaînes de caractères le caractère “X” par le caractère “o”, on pourrait être tenter de faire une boucle du type :\n\nmots &lt;- c(\"brXuette\", \"mXtX\", \"iglXX\")\nfor (i in seq_along(mots)) {\n    mots[i] &lt;- str_replace_all(mots[i], \"X\", \"o\")\n}\n\nOr c’est tout à fait inutile car str_replace_all() étant vectorisée, on peut l’appliquer directement à un vecteur sans utiliser de boucle.\n\nmots &lt;- str_replace_all(mots, \"X\", \"o\")\n\nDernier exemple, la boucle suivante remplace les valeurs manquantes d’un vecteur par les valeurs correspondantes d’un deuxième vecteur.\n\nx &lt;- c(1, NA, 4, 110, NA)\ny &lt;- c(20, 30, 40, 50, 60)\n\nfor (i in seq_along(x)) {\n    if (is.na(x[i])) {\n        x[i] &lt;- y[i]\n    }\n}\n\nCette boucle sera avantageusement remplacée par une utilisation plus compacte et plus rapide de l’opérateur [].\n\nx[is.na(x)] &lt;- y[is.na(x)]\n\nEn dehors des questions de performance, une boucle peut aussi être moins lisible que certaines alternatives. Soit la fonction suivante, qui prend en entrée un vecteur de mots et retourne le nombre total de voyelles qu’il contient.\n\nlibrary(stringr)\nn_voyelles &lt;- function(mots) {\n    nb &lt;- str_count(mots, \"[aeiou]\")\n    sum(nb)\n}\n\nn_voyelles(c(\"le\", \"chat\", \"roupille\"))\n#&gt; [1] 6\n\nSupposons qu’on souhaite appliquer cette fonction à une série de vecteurs de mots contenus dans une liste. On pourrait utiliser une boucle for parcourant cette liste, appliquant la fonction, et ajoutant le résultat à un vecteur numérique vide préalablement créé avec numeric().\n\nphrases &lt;- list(\n    c(\"le\", \"chat\", \"roupille\"),\n    c(\"l'autre\", \"chat\", \"roupille\", \"aussi\")\n)\n\nres &lt;- numeric()\nfor (i in seq_along(phrases)) {\n    res[i] &lt;- n_voyelles(phrases[[i]])\n}\nres\n#&gt; [1]  6 11\n\nOn verra cependant Chapitre 18 que des fonctions permettent de faire ce genre de choses de manière beaucoup plus simple et plus lisible. Ici par exemple on obtiendrait le même résultat avec un simple :\n\nphrases %&gt;% map_int(n_voyelles)\n#&gt; [1]  6 11\n\nAu final, entre les fonctions vectorisées existantes et les possibilités fournies par purrr, il est assez rare de devoir utiliser une boucle directement dans R. Pour autant, il ne faut pas non plus tomber dans l’excès inverse et considérer que tout usage de for ou while doit être évité : ces fonctions sont parfaitement justifiées dans certains cas de figure, et si vous trouvez une solution qui fonctionne de manière efficace avec une boucle for, il n’est pas forcément utile de chercher à la remplacer."
  },
  {
    "objectID": "17-if-boucles.html#sec-ressources-boucles",
    "href": "17-if-boucles.html#sec-ressources-boucles",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "17.4 Ressources",
    "text": "17.4 Ressources\nL’ouvrage R for Data Science (en anglais), accessible en ligne, contient un chapitre sur les boucles for, et un chapitre sur les blocs if / else.\nL’ouvrage Advanced R (également en anglais) aborde de manière approfondie les tests et les boucles.\nSur le blog de ThinkR, un article détaillé sur l’utilisation des boucles et les alternatives possibles.\nSur le blog de Florian Privé, un billet approfondi sur les raisons pour lesquelles les boucles peuvent être lentes et sur les cas où il est préférable de ne pas les utiliser."
  },
  {
    "objectID": "17-if-boucles.html#exercices",
    "href": "17-if-boucles.html#exercices",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "17.5 Exercices",
    "text": "17.5 Exercices\n\n17.5.1 if et else\nExercice 1.1\nÉcrire une fonction gel qui prend un argument nommé temperature et effectue les actions suivantes :\n\nsi temperature est négative, affiche le message “ça gèle” avec la fonction message()\nsinon, affiche le message “ça gèle pas” avec la fonction message()\n\n\n\ngel &lt;- function(temperature) {\n    if (temperature &lt;= 0) {\n        message(\"ça gèle\")\n    } else {\n        message(\"ça gèle pas\")\n    }\n}\n\n\nExercice 1.2\nÉcrire une fonction meteo qui prend un argument nommé temperature et effectue les actions suivantes :\n\nsi temperature est inférieure à 0, affiche le message “ça caille” avec la fonction message()\nsi temperature est comprise entre 0 et 15, affiche le message “fais pas chaud”\nsi temperature est comprise entre 15 et 30, affiche le message “on est pas mal”\nsi temperature est supérieure à 30, affiche le message “tous à Miribel”\n\n\n\nmeteo &lt;- function(temperature) {\n    if (temperature &lt; 0) {\n        message(\"ça caille\")\n    } else if (temperature &lt; 15) {\n        message(\"fais pas chaud\")\n    } else if (temperature &lt; 30) {\n        message(\"on est pas mal\")\n    } else {\n        message(\"tous à Miribel\")\n    }\n}\n# Ou bien\nmeteo &lt;- function(temperature) {\n    if (temperature &lt; 0) {\n        message(\"ça caille\")\n    }\n    if (temperature &gt;= 0 && temperature &lt; 15) {\n        message(\"fais pas chaud\")\n    }\n    if (temperature &gt;= 15 && temperature &lt; 30) {\n        message(\"on est pas mal\")\n    }\n    if (temperature &gt;= 30) {\n        message(\"tous à Mriribel\")\n    }\n}\n\n\nExercice 1.3\nÉcrire une fonction avertissement qui prend deux arguments pluie et parapluie et qui effectue les opérations suivantes :\n\nsi pluie vaut TRUE et parapluie vaut FALSE, affiche “mouillé” avec la fonction message()\nsi pluie vaut TRUE et parapluie vaut TRUE, affiche “bien vu”\nsi pluie vaut FALSE, affiche “RAS”\n\n\n\navertissement &lt;- function(pluie, parapluie) {\n    if (pluie && !parapluie) {\n        message(\"mouillé\")\n    }\n    if (pluie && parapluie) {\n        message(\"bien vu\")\n    }\n    if (!pluie) {\n        message(\"RAS\")\n    }\n}\n\n\n\n\n17.5.2 Contrôle de l’exécution\nExercice 2.1\nCréer une fonction moyenne_arrondie, qui prend en argument un vecteur x et un argument facultatif decimales. La fonction doit effectuer les opérations suivantes :\n\ncalculer la moyenne du vecteur\nsi decimales est défini, arrondir la moyenne au nombre de décimales correspondant avec la fonction round()\nretourner le résultat\n\n\n\nmoyenne_arrondie &lt;- function(x, decimales = NULL) {\n    moyenne &lt;- mean(x)\n    if (!is.null(decimales)) {\n        moyenne &lt;- round(moyenne, decimales)\n    }\n    moyenne\n}\n\n\nExercice 2.2\nCréer une fonction etendue qui retourne la différence entre la plus grande et la plus petite valeur d’un vecteur.\n\n\netendue &lt;- function(x) {\n    max(x) - min(x)\n}\n\n\nModifier la fonction pour qu’elle retourne NA si le vecteur passé en argument n’est pas numérique.\n\n\netendue &lt;- function(x) {\n    if (!is.numeric(x)) {\n        return(NA)\n    }\n    max(x) - min(x)\n}\n\n\nModifier à nouveau la fonction pour qu’elle affiche un avertissement avant de renvoyer la valeur NA.\n\n\netendue &lt;- function(x) {\n    if (!is.numeric(x)) {\n        warning(\"x doit être numérique\")\n        return(NA)\n    }\n    max(x) - min(x)\n}\n\n\nExercice 2.3\nCréer une fonction proportion qui prend en argument un vecteur et retourne les valeurs de ce vecteur divisée par leur somme.\n\n\nproportion &lt;- function(x) {\n    x / sum(x)\n}\n\n\nEssayer d’exécuter proportion(c(-2, 1, 1)). Pourquoi obtient-on ce résultat ?\n\nComme la somme des éléments du vecteur vaut 0, lorsqu’on divise chaque élément par cette valeur on obtient l’infini (Inf), soit négatif soit positif selon le signe de l’élément divisé.\n\nModifier la fonction pour qu’elle retourne un message d’erreur si la somme des éléments du vecteur vaut 0.\n\n\nproportion &lt;- function(x) {\n    if (sum(x) == 0) {\n        stop(\"la somme des éléments de x vaut zéro\")\n    }\n    x / sum(x)\n}\n\n\n\n\n17.5.3 Boucles\nExercice 3.1\nCharger le jeu de données hdv2003 de l’extension questionr avec :\n\nlibrary(questionr)\ndata(hdv2003)\n\nÀ l’aide d’une boucle for, parcourir les noms des variables de hdv2003. Si la variable en question est numérique, faire l’histogramme de la variable avec la fonction hist().\n\n\nfor (name in names(hdv2003)) {\n    variable &lt;- hdv2003[, name]\n    if (is.numeric(variable)) {\n        hist(variable)\n    }\n}\n\n\nAjouter le nom de la variable comme titre du graphique en utilisant l’argument main de hist().\n\n\nfor (name in names(hdv2003)) {\n    variable &lt;- hdv2003[, name]\n    if (is.numeric(variable)) {\n        hist(variable, main = name)\n    }\n}\n\n\nExercice 3.2\nLa fonction readline() permet de lire une chaîne de caractère saisie au clavier de la manière suivante :\n\nreponse &lt;- readline(\"Quelle est votre réponse ?\")\n\nÉcrire le code qui effectue les opérations suivantes :\n\nAfficher le message “Quel est le plus grand sociologue de tous les temps ?” et demander la réponse à l’utilisateur\nSi la réponse saisie est “Tonton Michel”, afficher “Bingo !”\nSinon, afficher “Nope”\n\n\n\nreponse &lt;- readline(\"Quel est le plus grand sociologue de tous les temps ?\")\nif (reponse == \"Tonton Michel\") {\n    message(\"Bingo !\")\n} else {\n    message(\"Nope !\")\n}\n\n\nÀ l’aide d’une boucle while(), modifier le code précédent pour que la question soit répétée jusqu’à ce que l’utilisateur saisisse “Tonton Michel”.\n\n\nreponse &lt;- \"\"\nwhile (reponse != \"Tonton Michel\") {\n    reponse &lt;- readline(\"Quel est le plus grand sociologue de tous les temps ?\")\n    if (reponse == \"Tonton Michel\") {\n        message(\"Bingo !\")\n    } else {\n        message(\"Nope !\")\n    }\n}\n\n\nExercice 3.3\nÀ l’aide d’une boucle for, écrire une fonction somme_positifs qui prend en argument un vecteur et retourne la somme de tous les nombres positifs qu’il contient.\n\n\nsomme_positifs &lt;- function(x) {\n    somme &lt;- 0\n    for (item in x) {\n        if (item &gt; 0) {\n            somme &lt;- somme + item\n        }\n    }\n    somme\n}\n\n\nRéécrire cette fonction pour qu’elle retourne le même résultat mais sans utiliser de boucle.\n\n\nsomme_positifs &lt;- function(x) {\n    sum(x[x &gt; 0])\n}\n\n\nExercice 3.4\nEn utilisant une boucle for, créer une fonction somme_premiers_positifs qui prend en argument un vecteur et retourne la somme de tous les nombres positifs qu’il contient en partant du début du vecteur et en s’arrêtant au premier élément négatif (on pourra recopier et modifier la première fonction somme_positifs de l’exercice précédent).\n\n\nsomme_premiers_positifs &lt;- function(x) {\n    somme &lt;- 0\n    for (item in x) {\n        if (item &lt; 0) {\n            break\n        }\n        somme &lt;- somme + item\n    }\n    somme\n}\n\n\nFacultatif : réécrire la fonction pour qu’elle retourne le même résultat sans utiliser de boucle for.\n\n\nsomme_premiers_positifs &lt;- function(x) {\n    negatifs &lt;- which(x &lt; 0)\n    if (length(negatifs) == 0) {\n        return(sum(x))\n    }\n    premier_negatif &lt;- min(negatifs)\n    sum(head(x, premier_negatif - 1))\n}\n\n\nExercice 3.5\nSoit la fonction pile_ou_face suivante, qui simule un jet de pièce :\n\npile_ou_face &lt;- function() {\n    alea &lt;- runif(1)\n    if (alea &lt; 0.5) {\n        result &lt;- \"pile\"\n    } else {\n        result &lt;- \"face\"\n    }\n    result\n}\n\nModifier cette fonction en utilisant une boucle for pour qu’elle accepte un argument n et retourne un vecteur comprenant le résultat de n tirages.\n\npile_ou_face(4)\n#&gt; [1] \"face\" \"pile\" \"face\" \"face\"\n\n\n\npile_ou_face &lt;- function(n) {\n    tirages &lt;- character()\n    for (i in seq_len(n)) {\n        alea &lt;- runif(1)\n        if (alea &lt; 0.5) {\n            tirages &lt;- c(tirages, \"pile\")\n        } else {\n            tirages &lt;- c(tirages, \"face\")\n        }\n    }\n    tirages\n}\n\n\nRéécrire la fonction pour qu’elle retourne le même résultat sans utiliser de boucle for.\n\n\npile_ou_face &lt;- function(n) {\n    alea &lt;- runif(n)\n    result &lt;- ifelse(alea &lt; 0.5, \"pile\", \"face\")\n    result\n}\n# Ou bien, encore plus simple\npile_ou_face &lt;- function(n) {\n    sample(c(\"pile\", \"face\"), size = n, replace = TRUE)\n}"
  },
  {
    "objectID": "17-if-boucles.html#footnotes",
    "href": "17-if-boucles.html#footnotes",
    "title": "17  Exécution conditionnelle et boucles",
    "section": "",
    "text": "Pour les versions de R antérieures à la 4.2, seul un avertissement est affiché et R n’utilise alors que la première valeur du vecteur pour déterminer si le bloc de code doit être exécuté ou non.↩︎\nEn complément, on verra également Chapitre 18 d’autres fonctions tirées de l’extension purrr qui permettent d’appliquer une fonction en itérant sur les éléments de plusieurs objets.↩︎"
  },
  {
    "objectID": "18-purrr.html#exemple-dapplication",
    "href": "18-purrr.html#exemple-dapplication",
    "title": "18  Itérer avec purrr",
    "section": "18.1 Exemple d’application",
    "text": "18.1 Exemple d’application\nPour mieux appréhender de quoi il s’agit, on part du vecteur suivant, qui contient des extraits (fictifs ?) de discours politiques.\n\ndiscours &lt;- c(\n    \"nous privilégierons une intergouvernementalisation sans agir anticonstitutionnellement\",\n    \"le souffle de la nation est le vent qui agite les drapeaux de nos libertés\",\n    \"nous devons faire preuve de plus de pédagogie pour cette réforme\",\n    \"mon compte twitter a été piraté\"\n)\n\nOn souhaite calculer la longueur de chaque extrait, en nombre de mots.\nOn commence par découper grossièrement chaque extrait en mots en utilisant la fonction str_split() de stringr1.\n\nmots &lt;- str_split(discours, \" \")\nstr(mots)\n#&gt; List of 4\n#&gt;  $ : chr [1:7] \"nous\" \"privilégierons\" \"une\" \"intergouvernementalisation\" ...\n#&gt;  $ : chr [1:15] \"le\" \"souffle\" \"de\" \"la\" ...\n#&gt;  $ : chr [1:11] \"nous\" \"devons\" \"faire\" \"preuve\" ...\n#&gt;  $ : chr [1:6] \"mon\" \"compte\" \"twitter\" \"a\" ...\n\nL’objet mots est une liste de vecteurs de chaînes de caractères qui contiennent les mots des différents extraits.\nCalculer le nombre de mots de chaque extrait revient à calculer la longueur de chaque élément de mots. Pour cela on pourrait vouloir utiliser la fonction length() directement :\n\nlength(mots)\n#&gt; [1] 4\n\nCeci ne fonctionne pas, car length() nous retourne le nombre d’éléments de mots, pas celui de chacun de ses éléments : ce qu’on veut, ça n’est pas length(mots) mais length(mots[[1]]), length(mots[[2]]), etc.\nOn a vu Section 17.3.4 qu’on peut pour cela utiliser une boucle for, par exemple de la manière suivante.\n\nresultat &lt;- list()\nfor (item in mots) {\n    resultat &lt;- c(resultat, length(item))\n}\nresultat\n#&gt; [[1]]\n#&gt; [1] 7\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 15\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 11\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 6\n\nÇa fonctionne, mais la syntaxe est un peu “lourde”.\nLa fonction map() de purrr propose exactement cette fonctionnalité. Elle prend deux arguments principaux :\n\nun vecteur ou une liste\nune fonction\n\net elle retourne une liste contenant le résultat de la fonction appliquée à chaque élément du vecteur ou de la liste.\nEn utilisant map() on peut remplacer notre boucle for par un simple :\n\nmap(mots, length)\n#&gt; [[1]]\n#&gt; [1] 7\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 15\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 11\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 6\n\nmap va itérer sur les éléments de mots, leur appliquer tour à tour la fonction length passée en argument, et regrouper les résultats dans une liste.\nÀ noter qu’on peut évidemment utiliser le pipe.\n\nmots %&gt;% map(length)\n#&gt; [[1]]\n#&gt; [1] 7\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 15\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 11\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 6\n\nIci notre résultat est une liste. Or il pourrait être simplifié sous forme de vecteur atomique, puisque tous ses éléments sont des nombres.\nSi on souhaitait obtenir un vecteur numérique avec une boucle for, il faut soit convertir le résultat de la boucle précédente en vecteur atomique (avec unlist() ou purrr::flatten_int()), soit modifier cette boucle pour qu’elle génère plutôt un vecteur numérique :\n\nresultat &lt;- numeric(length(discours))\nfor (i in seq_along(mots)) {\n    resultat[i] &lt;- length(mots[[i]])\n}\nresultat\n#&gt; [1]  7 15 11  6\n\nMais purrr propose des variantes de la fonction map qui permettent justement de s’assurer du type de résultat obtenu. Ainsi, map_dbl() renverra toujours un vecteur de nombres flottants, et map_int() un vecteur de nombres entiers. En remplacement de la boucle for ci-dessus, on peut donc utiliser :\n\nmots %&gt;% map_int(length)\n#&gt; [1]  7 15 11  6"
  },
  {
    "objectID": "18-purrr.html#map-et-ses-variantes",
    "href": "18-purrr.html#map-et-ses-variantes",
    "title": "18  Itérer avec purrr",
    "section": "18.2 map et ses variantes",
    "text": "18.2 map et ses variantes\n\n18.2.1 Modes d’appel de map\nL’objectif de map est donc d’appliquer une fonction à l’ensemble des éléments d’un vecteur ou d’une liste.\nOn a vu qu’on pouvait l’utiliser pour appliquer la fonction length à chacun des vecteurs contenus par la liste mots. En utilisant map_int on s’assure de récupérer un simple vecteur numérique, plus facile à utiliser par la suite si on souhaite par exemple calculer une moyenne.\n\nmots %&gt;% map_int(length)\n#&gt; [1]  7 15 11  6\n\nSi on souhaitait plutôt extraire le dernier mot de chaque vecteur, on pourrait créer une fonction spécifique et l’appliquer avec map().\n\ndernier_mot &lt;- function(v) {\n    tail(v, 1)\n}\n\nmots %&gt;% map(dernier_mot)\n#&gt; [[1]]\n#&gt; [1] \"anticonstitutionnellement\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"libertés\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"réforme\"\n#&gt; \n#&gt; [[4]]\n#&gt; [1] \"piraté\"\n\nComme notre résultat est une liste de chaînes de caractères simples, on peut forcer le résultat à être plutôt un vecteur de type character en utilisant map_chr() :\n\nmots %&gt;% map_chr(dernier_mot)\n#&gt; [1] \"anticonstitutionnellement\" \"libertés\"                 \n#&gt; [3] \"réforme\"                   \"piraté\"\n\nComme notre fonction est très courte, on peut aussi préférer utiliser une fonction anonyme, introduites Section 14.4.2.\n\nmots %&gt;% map_chr(function(v) { tail(v, 1) })\n#&gt; [1] \"anticonstitutionnellement\" \"libertés\"                 \n#&gt; [3] \"réforme\"                   \"piraté\"\n\nOn peut aussi utiliser la notation abrégée sous forme de formule, propre aux fonctions du tidyverse, présentée Section 15.3.\n\nmots %&gt;% map_chr(~ tail(.x, 1) )\n#&gt; [1] \"anticonstitutionnellement\" \"libertés\"                 \n#&gt; [3] \"réforme\"                   \"piraté\"\n\nOn peut également utiliser la notation compacte pour les fonctions anonymes disponible sous R à partir de la version 4.1.\n\nmots %&gt;% map_chr(\\(v) tail(v, 1))\n#&gt; [1] \"anticonstitutionnellement\" \"libertés\"                 \n#&gt; [3] \"réforme\"                   \"piraté\"\n\nEnfin, si on fournit des arguments supplémentaires à map, ils sont passés comme argument à la fonction qu’il applique, on peut donc également utiliser la notation suivante :\n\nmots %&gt;% map_chr(tail, 1)\n#&gt; [1] \"anticonstitutionnellement\" \"libertés\"                 \n#&gt; [3] \"réforme\"                   \"piraté\"\n\nDans ce qui suit on utilisera de préférence la notation “formule”, mais toutes les versions ci-dessus sont équivalentes et donnent le même résultat.\n\n\n\n\n\n\nNote\n\n\n\nPetite astuce à noter, si on transmet à map() autre chose qu’une fonction, elle utilisera cette information pour extraire des éléments. Ainsi, v %&gt;% map(1) extraiera le premier élément de chaque élément du vecteur v, v %&gt;% map(\"foo\") extraiera les éléments nommés “foo”, etc.\n\n\n\n\n18.2.2 Variantes de map\nOn a vu que map propose plusieurs variantes qui permettent de contrôler le type de résultat qu’elle retourne :\n\nmap() retourne une liste\nmap_int() retourne un vecteur atomique d’entiers\nmap_dbl() retourne un vecteur atomique de nombres flottants\nmap_chr() retourne un vecteur atomique de chaînes de caractères\nmap_lgl() retourne un vecteur atomique de TRUE / FALSE\n\nAttention, ces variantes sont très strictes : si la fonction appelée retourne un résultat qui n’est pas compatible avec le résultat attendu, elle génère une erreur. C’est le cas si dans le code précédent on essaie de récupérer chaque dernier mot sous forme d’un vecteur de nombres :\n\nmots %&gt;% map_dbl(tail, 1)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a character vector to a double vector.\n\nPour pouvoir utiliser ces variantes et obtenir un vecteur atomique, chaque résultat retourné par la fonction appliquée doit être de longueur 1. Ainsi, si on souhaitait extraire plutôt la liste des mots contenant un “f”, certains résultats ne contiennent aucun élément, et d’autres en contiennent deux :\n\nmots %&gt;% map(~ str_subset(.x, \"f\") )\n#&gt; [[1]]\n#&gt; character(0)\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"souffle\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"faire\"   \"réforme\"\n#&gt; \n#&gt; [[4]]\n#&gt; character(0)\n\nDans ce cas on ne peut pas utiliser map_chr() : si on essaie on obtient un message d’erreur nous indiquant que certains résultats de str_subset() ne sont pas au bon format.\n\nmots %&gt;% map_chr(~ str_subset(.x, \"f\") )\n#&gt; Error in `map_chr()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\nDans ce cas, on doit donc utiliser map() et conserver le résultat sous forme de liste, qui elle peut contenir des éléments de longueurs différentes.\n\nmots %&gt;%\n    map(~ str_subset(.x, \"f\") )\n#&gt; [[1]]\n#&gt; character(0)\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"souffle\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"faire\"   \"réforme\"\n#&gt; \n#&gt; [[4]]\n#&gt; character(0)\n\nOn notera qu’on peut tout à fait enchaîner les map() si on veut effectuer des opérations supplémentaires.\n\nmots %&gt;%\n    map(~ str_subset(.x, \"f\") ) %&gt;%\n    map_int(length)\n#&gt; [1] 0 1 2 0\n\n\n\n18.2.3 map_dfr() et map_dfc()\nLa page suivante contient les données du jeu de données rp2018 sous la forme de fichiers CSV, avec un fichier par département :\nhttps://github.com/juba/tidyverse/tree/main/resources/data/rp2018\nÀ partir de cette page, on peut télécharger les fichiers CSV en utilisant des adresses de la forme :\nhttps://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_01.csv\nEn remplaçant “01” par le code du département souhaité.\nOn peut créer une fonction genere_url() qui, à partir d’une liste de codes de départements, retourne les adresses des fichiers correspondant.\n\ngenere_url &lt;- function(codes) {\n    paste0(\n        \"https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_\",\n        codes,\n        \".csv\"\n    )\n}\n\ngenere_url(c(\"42\", \"69\"))\n#&gt; [1] \"https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_42.csv\"\n#&gt; [2] \"https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_69.csv\"\n\nGrâce à la fonction read_csv(), on peut charger directement dans notre session R un fichier en indiquant son URL.\n\ndata69 &lt;- read_csv(genere_url(\"69\"))\n\nComment faire si l’on souhaite charger les fichiers de plusieurs départements ? La fonction read_csv() n’accepte qu’une seule URL à la fois, elle n’est pas vectorisée.\nDans ce cas on peut utiliser map() pour l’appliquer tour à tour à plusieurs URL.\n\ndepartements &lt;- c(\"38\", \"42\", \"69\")\nurls &lt;- genere_url(departements)\n\ndfs &lt;- urls %&gt;% map(read_csv)\n\nLe résultat dfs est une liste de trois tableaux de données. Chacun de ces éléments est un tibble : d’abord celui du fichier CSV des données de l’Isère, puis celui de la Loire, et enfin celui du Rhône.\nOn peut itérer sur cette liste dfs pour appliquer une fonction à chacun de ces tableaux.\n\n# Affichage des dimensions de chaque tableau\ndfs %&gt;% map(dim)\n#&gt; [[1]]\n#&gt; [1] 146  37\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 56 37\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 132  37\n\n\n# Calcul de la moyenne de la variable dipl_aucun\ndfs %&gt;% map_dbl(~ mean(.x$dipl_aucun))\n#&gt; [1] 19.24298 23.57400 17.74882\n\n\n# Calcul du coefficient associé à la variable dipl_sup dans\n# la régression linéaire de cadres en fonction de dipl_sup\ndfs %&gt;% map_dbl(~ {\n    reg &lt;- lm(cadres ~ dipl_sup, data = .x)\n    reg$coefficients[\"dipl_sup\"]\n})\n#&gt; [1] 1.132317 1.264469 1.027263\n\nSi on souhaite réunir ces trois tibbles en un seul, on peut utiliser la fonction bind_rows() de dplyr.\n\ndepartements &lt;- c(\"38\", \"42\", \"69\")\nurls &lt;- genere_url(departements)\n\ndf &lt;- urls %&gt;%\n    map(read_csv) %&gt;%\n    bind_rows()\n\nMais on peut aussi utiliser une autre variante de map(), nommée map_dfr(), qui considère les résultats obtenus par l’application de la fonction comme les lignes d’un tableau de données qu’elle va automatiquement rassembler en un seul tableau, de la même manière qu’avec un bind_rows().\n\ndf &lt;- urls %&gt;% map_dfr(read_csv)\n\ndf\n#&gt; # A tibble: 334 × 37\n#&gt;    code_…¹ commune code_…² region depar…³ log_rp log_p…⁴ log_loc log_hlm log_sec\n#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1   38001 Les Ab…      84 Auver… Isère    2630.   1773.    812.   238.     82.4\n#&gt;  2   38006 Alleva…      84 Auver… Isère    1845.   1157.    644.   162.    912. \n#&gt;  3   38012 Aoste        84 Auver… Isère    1158.    762.    378.   149.     31.9\n#&gt;  4   38013 Apprieu      84 Auver… Isère    1316.   1086.    211.    45.6    39.8\n#&gt;  5   38022 Les Av…      84 Auver… Isère    3388.   2452.    885.   376.    185. \n#&gt;  6   38034 Beaure…      84 Auver… Isère    2116.   1189.    885.   217.     39.4\n#&gt;  7   38039 Bernin       84 Auver… Isère    1244.   1028.    199.    75.2    18.1\n#&gt;  8   38045 Biviers      84 Auver… Isère    1015.    870.    126.    18.4    17.1\n#&gt;  9   38052 Le Bou…      84 Auver… Isère    1438.    890.    494.   132.    436. \n#&gt; 10   38053 Bourgo…      84 Auver… Isère   13150.   5273.   7569.  3445.    184. \n#&gt; # … with 324 more rows, 27 more variables: log_maison &lt;dbl&gt;, log_appart &lt;dbl&gt;,\n#&gt; #   age_0_14 &lt;dbl&gt;, age_15_29 &lt;dbl&gt;, age_75p &lt;dbl&gt;, femmes &lt;dbl&gt;, chom &lt;dbl&gt;,\n#&gt; #   agric &lt;dbl&gt;, indep &lt;dbl&gt;, cadres &lt;dbl&gt;, interm &lt;dbl&gt;, empl &lt;dbl&gt;,\n#&gt; #   ouvr &lt;dbl&gt;, etud &lt;dbl&gt;, dipl_aucun &lt;dbl&gt;, dipl_bepc &lt;dbl&gt;,\n#&gt; #   dipl_capbep &lt;dbl&gt;, dipl_bac &lt;dbl&gt;, dipl_sup2 &lt;dbl&gt;, dipl_sup34 &lt;dbl&gt;,\n#&gt; #   dipl_sup &lt;dbl&gt;, resid_sec &lt;dbl&gt;, proprio &lt;dbl&gt;, locataire &lt;dbl&gt;, hlm &lt;dbl&gt;,\n#&gt; #   maison &lt;dbl&gt;, appart &lt;dbl&gt;, and abbreviated variable names ¹​code_insee, …\n\nLes deux lignes de code ci-dessus partent donc d’une liste d’identifiants de départements, génèrent les URL des fichiers CSV correspondant, les importent dans R et assemblent le résultat en un seul tableau. Plutôt efficace !\nUne fonction utile en complément de map_dfr() est la fonction list.files(), qui peut lister les fichiers ayant une certaine extension dans un dossier spécifique. Par exemple, l’instruction suivante liste tous les fichiers se terminant par .csv du sous-dossier data.\n\nfichiers &lt;- list.files(\"data\", \"*.csv\", full.names = TRUE)\n\nOn peut dès lors utiliser map_dfr() et read_csv() pour lire tous ces fichiers en une seule fois et les concaténer en un seul tableau de données.\n\nd &lt;- fichiers %&gt;% map_dfr(read_csv)\n\n\n\n\n\n\n\nNote\n\n\n\nIl existe également une variante map_dfc() qui considère les résultats comme des colonnes d’un tableau de données et les rassemble en un seul tableau comme le ferait la fonction bind_cols() de dplyr."
  },
  {
    "objectID": "18-purrr.html#itérer-sur-les-colonnes-dun-tableau-de-données",
    "href": "18-purrr.html#itérer-sur-les-colonnes-dun-tableau-de-données",
    "title": "18  Itérer avec purrr",
    "section": "18.3 Itérer sur les colonnes d’un tableau de données",
    "text": "18.3 Itérer sur les colonnes d’un tableau de données\nOn a vu Section 16.3 que les tableaux de données (data frame ou tibble) sont en fait des listes dont les éléments sont les colonnes du tableau. Si on applique map() à un tableau, celle-ci itérera donc sur ses colonnes.\nPar exemple, on peut appliquer n_distinct au jeu de données starwars et obtenir le nombre de valeurs distinctes de chacune de ses colonnes.\n\nstarwars %&gt;% map_int(n_distinct)\n#&gt;       name     height       mass hair_color skin_color  eye_color birth_year \n#&gt;         87         46         39         13         31         15         37 \n#&gt;        sex     gender  homeworld    species      films   vehicles  starships \n#&gt;          5          3         49         38         24         11         17\n\nLe résultat est équivalent à celui qu’on obtient en faisant un summarise() sur l’ensemble des colonnes, comme vu Section 15.2, sauf que map_int() retourne un vecteur numérique tandis que summarise() renvoie un tibble à une ligne.\n\nstarwars %&gt;%\n    summarise(\n        across(everything(), n_distinct)\n    )\n#&gt; # A tibble: 1 × 14\n#&gt;    name height  mass hair_color skin_color eye_co…¹ birth…²   sex gender homew…³\n#&gt;   &lt;int&gt;  &lt;int&gt; &lt;int&gt;      &lt;int&gt;      &lt;int&gt;    &lt;int&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;   &lt;int&gt;\n#&gt; 1    87     46    39         13         31       15      37     5      3      49\n#&gt; # … with 4 more variables: species &lt;int&gt;, films &lt;int&gt;, vehicles &lt;int&gt;,\n#&gt; #   starships &lt;int&gt;, and abbreviated variable names ¹​eye_color, ²​birth_year,\n#&gt; #   ³​homeworld\n\nDe la même manière, si on veut connaître le nombre de valeurs manquantes pour chaque variable :\n\nstarwars %&gt;% map_int(~ sum(is.na(.x)) )\n#&gt;       name     height       mass hair_color skin_color  eye_color birth_year \n#&gt;          0          6         28          5          0          0         44 \n#&gt;        sex     gender  homeworld    species      films   vehicles  starships \n#&gt;          4          4         10          4          0          0          0\n\nContrairement à across(), on ne peut pas spécifier directement une sélection de colonnes à map(). On peut par contre utiliser des fonctions comme keep() ou discard() qui “filtrent” les éléments d’une liste via une fonction qui renvoie TRUE ou FALSE.\nOn peut par exemple utiliser discard() après map() pour ne conserver que les colonnes ayant au moins une valeur NA.\n\nstarwars %&gt;%\n    map_int(~ sum(is.na(.x)) ) %&gt;%\n    discard(~ .x == 0 )\n#&gt;     height       mass hair_color birth_year        sex     gender  homeworld \n#&gt;          6         28          5         44          4          4         10 \n#&gt;    species \n#&gt;          4\n\nOu bien utiliser keep() pour n’appliquer mean() qu’aux variables numériques.\n\nstarwars %&gt;%\n    keep(is.numeric) %&gt;%\n    map_dbl(mean, na.rm = TRUE)\n#&gt;     height       mass birth_year \n#&gt;  174.35802   97.31186   87.56512"
  },
  {
    "objectID": "18-purrr.html#modify",
    "href": "18-purrr.html#modify",
    "title": "18  Itérer avec purrr",
    "section": "18.4 modify",
    "text": "18.4 modify\nmodify() est une variante de map() qui a pour particularité de renvoyer un résultat du même type que la liste ou le vecteur donné en entrée.\nAinsi, si on l’applique à un vecteur de chaînes de caractères, le résultat sera aussi un vecteur de chaînes de caractères.\n\nv &lt;- c(\"brouette\", \"moto\", \"igloo\")\nv %&gt;% modify(~ paste(\"incroyable\", .x))\n#&gt; [1] \"incroyable brouette\" \"incroyable moto\"     \"incroyable igloo\"\n\nSi on l’applique à une liste, le résultat sera aussi une liste.\n\nv &lt;- list(\"brouette\", \"moto\", \"igloo\")\nv %&gt;% modify(~ paste(\"incroyable \", .x))\n#&gt; [[1]]\n#&gt; [1] \"incroyable  brouette\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"incroyable  moto\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"incroyable  igloo\"\n\nL’objectif de modify() est de permettre de “modifier” une liste ou un vecteur en lui appliquant une fonction tout en étant sûr qu’on ne va pas modifier son type.\nL’intérêt principal de modify() est qu’elle propose deux variantes, modify_if() et modify_at(), qui sélectionnent les éléments respectivement via une fonction et via leur nom ou leur position, et qui n’appliquent la fonction de transformation qu’aux éléments sélectionnés.\nCela peut être particulièrement utile quand on l’applique à un tableau de données. Par exemple le code suivant utilise modify_if() pour transformer uniquement les colonnes de type factor de hdv2003 en character, et laisser les autres inchangées.\n\nhdv2003 %&gt;% modify_if(is.factor, as.character)\n\nOn notera qu’on obtient le même résultat avec le code suivant qui utilise across() de dplyr.\n\nhdv2003 %&gt;%\n    mutate(\n        across(\n            where(is.factor),\n            as.character\n        )\n    )\n\nmodify_at permet d’appliquer une fonction à certaines variables à partir de leurs noms.\n\nhdv2003 %&gt;%\n    modify_at(c(\"sexe\", \"qualif\"), as.character)\n\nEn utilisant vars(), on peut sélectionner les variables avec toutes les possibilités offertes par la tidy selection.\n\nhdv2003 %&gt;%\n    modify_at(vars(hard.rock:sport), as.character)\n#&gt; Warning: Using `vars()` in .at was deprecated in purrr 1.0.0.\n\nLà aussi, on peut obtenir le même résultat en utilisant across().\n\nhdv2003 %&gt;%\n    mutate(\n        across(\n            hard.rock:sport,\n            as.character\n        )\n    )"
  },
  {
    "objectID": "18-purrr.html#imap",
    "href": "18-purrr.html#imap",
    "title": "18  Itérer avec purrr",
    "section": "18.5 imap",
    "text": "18.5 imap\nImaginons que nous avons récupéré les données suivantes, qui représentent des évaluations obtenues par quatre restaurants, sous la forme d’une liste.\n\nrestos &lt;- list(\n    \"La bonne fourchette\"     = c(3, 3, 2, 5, 2, 3, 2, 4, 1, 3),\n    \"La choucroute de l'amer\" = c(4, 1, 2, 4, 2, 5, 2),\n    \"L'Hair de rien\"          = c(1, 5, 5, 1, 5, 3, 1, 5, 2),\n    \"La blanquette de Vaulx\"  = c(4, 1, 3, 1, 3, 3, 1, 4, 2, 5)\n)\n\nÀ partir de cette liste, on souhaite créer un tableau de données comportant la moyenne et l’écart-type des notes de chaque restaurant. Comme on l’a vu précédemment, cela peut se faire avec l’aide de map_dfr().\n\nrestos %&gt;% map_dfr(~ tibble(moyenne = mean(.x), ecart_type = sd(.x)) )\n#&gt; # A tibble: 4 × 2\n#&gt;   moyenne ecart_type\n#&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1    2.8        1.14\n#&gt; 2    2.86       1.46\n#&gt; 3    3.11       1.90\n#&gt; 4    2.7        1.42\n\nOn obtient le tableau souhaité, mais il manque une information : le nom du restaurant correspondant à chaque ligne. Cette information est incluse dans les noms des éléments de la liste restos, or la fonction passée à map_dfr n’y a pas accès, elle n’a accès qu’à leurs valeurs.\nC’est pour ce type de cas de figure que purrr propose la famille de fonctions imap(). Celle-ci fonctionne de la même manière que map(), sauf que la fonction appliquée prend deux arguments : d’abord la valeur de l’élément courant, puis son nom.\nDans l’exemple suivant, on applique imap() à une liste simple et on affiche un message avec le nom et la valeur de chaque élément.\n\nl &lt;- list(nom1 = 1, nom2 = 3)\n\nl2 &lt;- l %&gt;% imap(function(valeur, nom) {\n   message(\"La valeur de \", nom, \" est \", valeur)\n})\n#&gt; La valeur de nom1 est 1\n#&gt; La valeur de nom2 est 3\n\nOn peut évidemment utiliser la notation “formule” de purrr, il faut juste se souvenir que dans ce cas .x correspond à la valeur, et .y au nom.\n\nl2 &lt;- l %&gt;% imap(~ {\n   message(\"La valeur de \", .y, \" est \", .x)\n})\n#&gt; La valeur de nom1 est 1\n#&gt; La valeur de nom2 est 3\n\nTout comme map() proposait les variantes map_int(), map_chr() ou map_dfr(), on peut également utiliser imap_dbl(), imap_chr() et autres imap_dfc() pour forcer le type de résultat retourné.\nPour reprendre notre exemple de départ, on peut donc, en utilisant imap, récupérer le nom de l’élément courant de la liste restos et l’utiliser pour rajouter le nom du restaurant dans notre tibble de résultats.\nOn peut le faire avec une fonction anonyme “classique” :\n\nrestos %&gt;% imap_dfr(function(notes, nom) {\n    tibble(resto = nom, moyenne = mean(notes), ecart_type = sd(notes))\n})\n#&gt; # A tibble: 4 × 3\n#&gt;   resto                   moyenne ecart_type\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 La bonne fourchette        2.8        1.14\n#&gt; 2 La choucroute de l'amer    2.86       1.46\n#&gt; 3 L'Hair de rien             3.11       1.90\n#&gt; 4 La blanquette de Vaulx     2.7        1.42\n\nOn peut aussi utiliser la notation compacte de type formule, en se souvenant à nouveau que .x correspond à la valeur de l’élément courant, et .y à son nom.\n\nrestos %&gt;% imap_dfr(~ {\n    tibble(resto = .y, moyenne = mean(.x), ecart_type = sd(.x))\n})\n#&gt; # A tibble: 4 × 3\n#&gt;   resto                   moyenne ecart_type\n#&gt;   &lt;chr&gt;                     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 La bonne fourchette        2.8        1.14\n#&gt; 2 La choucroute de l'amer    2.86       1.46\n#&gt; 3 L'Hair de rien             3.11       1.90\n#&gt; 4 La blanquette de Vaulx     2.7        1.42\n\n\n\n\n\n\n\nNote\n\n\n\nSi on utilise imap() sur une liste ou un vecteur qui n’a pas de noms, le deuxième argument passé à la fonction appliquée sera l’indice de l’élément courant : 1 pour le premier, 2 pour le deuxième, etc."
  },
  {
    "objectID": "18-purrr.html#walk",
    "href": "18-purrr.html#walk",
    "title": "18  Itérer avec purrr",
    "section": "18.6 walk",
    "text": "18.6 walk\nwalk() est une variante de map() qui a pour particularité de ne pas retourner de résultat. On l’utilise lorsqu’on souhaite parcourir un vecteur ou une liste et appliquer à ses éléments une fonction dont on ne souhaite conserver que les “effets de bord” : afficher un message, générer un graphique, enregistrer un fichier…\nPar exemple, le code suivant génère quatre diagrammes en barre indiquant la répartition des notes des différents restaurants vus dans la section précédente.\n\nwalk(restos, ~ barplot(table(.x)) )\n\n\n\n\n\n\nComme pour map(), la variante iwalk() permet d’itérer à la fois sur les valeurs et sur les noms des éléments du vecteur ou de la liste. Ceci permet par exemple d’afficher le nom du restaurant comme titre de chaque graphique.\n\niwalk(restos, ~ barplot(table(.x), main = .y) )\n\n\n\n\n\n\nAu final, on notera que l’utilisation de walk(), comme elle ne retourne pas de résultats, est très proche de celle d’une boucle for."
  },
  {
    "objectID": "18-purrr.html#map2-et-pmap-itérer-sur-plusieurs-vecteurs-en-parallèle",
    "href": "18-purrr.html#map2-et-pmap-itérer-sur-plusieurs-vecteurs-en-parallèle",
    "title": "18  Itérer avec purrr",
    "section": "18.7 map2 et pmap : itérer sur plusieurs vecteurs en parallèle",
    "text": "18.7 map2 et pmap : itérer sur plusieurs vecteurs en parallèle\nSupposons qu’un.e collègue, qui travaille avec nous sur le jeu de données rp2018, nous a envoyé une liste de variables dont elle voudrait connaître les corrélations. Cette liste a été saisie dans un tableur sur deux colonnes, chaque ligne indiquant deux variables pour lesquelles elle souhaite qu’on effectue ce calcul.\nAprès importation dans R on obtient le tableau de données suivant.\n\ncorrelations &lt;- tribble(\n    ~var1,       ~var2,\n    \"dipl_sup\", \"dipl_aucun\",\n    \"dipl_sup\", \"cadres\",\n    \"hlm\",      \"cadres\",\n    \"hlm\",      \"ouvr\",\n    \"proprio\",  \"hlm\"\n)\n\ncorrelations\n#&gt; # A tibble: 5 × 2\n#&gt;   var1     var2      \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     \n#&gt; 1 dipl_sup dipl_aucun\n#&gt; 2 dipl_sup cadres    \n#&gt; 3 hlm      cadres    \n#&gt; 4 hlm      ouvr      \n#&gt; 5 proprio  hlm\n\nPour pouvoir calculer les corrélations souhaitées, on doit itérer sur les deux vecteurs var1 et var2 en parallèle, et calculer la corrélation entre la colonne de rp2018 correspondant à la valeur courante de var1 et celle correspondant à la valeur courante de var2.\nC’est précisément ce que fait la fonction map2(). Celle-ci prend trois arguments en entrée :\n\ndeux listes ou vecteurs qui seront itérés en parallèle\nune fonction qui accepte deux arguments : ceux-ci prendront tour à tour les deux valeurs courantes des deux listes ou vecteurs itérés\n\nOn peut donc utiliser map2 pour itérer parallèlement sur les deux colonnes var1 et var2 de notre tableau correlations, et calculer la corrélation des deux colonnes correspondantes de rp2018.\n\nmap2(\n    correlations$var1,\n    correlations$var2, \n    ~ cor(rp2018[[.x]], rp2018[[.y]])\n)\n#&gt; [[1]]\n#&gt; [1] -0.6146729\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 0.9291504\n#&gt; \n#&gt; [[3]]\n#&gt; [1] -0.1067832\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 0.2126366\n#&gt; \n#&gt; [[5]]\n#&gt; [1] -0.7786399\n\nmap2() propose les mêmes variantes map2_int(), mapr2_chr(), etc. que map(). On peut donc utiliser map2_dbl() pour récupérer un vecteur numérique plutôt qu’une liste, et l’utiliser par exemple pour rajouter une colonne à notre tableau de départ.\n\ncorrelations$corr &lt;- map2_dbl(\n    correlations$var1,\n    correlations$var2,\n    ~ cor(rp2018[[.x]], rp2018[[.y]])\n)\n\ncorrelations\n#&gt; # A tibble: 5 × 3\n#&gt;   var1     var2         corr\n#&gt;   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 dipl_sup dipl_aucun -0.615\n#&gt; 2 dipl_sup cadres      0.929\n#&gt; 3 hlm      cadres     -0.107\n#&gt; 4 hlm      ouvr        0.213\n#&gt; 5 proprio  hlm        -0.779\n\nSi on souhaite uniquement capturer les effets de bord sans récupérer les résultats de la fonctions appliquée, on peut aussi utiliser la variante walk2().\nSupposons maintenant que notre collègue nous a envoyé, toujours sous la même forme, une liste de variables dont elle souhaite obtenir un nuage de points, mais en fournissant également un titre à ajouter au graphique. On obtient le tableau suivant :\n\nnuages &lt;- tribble(\n    ~var1,       ~var2,       ~titre,\n    \"dipl_sup\", \"dipl_aucun\", \"Diplômés du supérieur x sans diplôme\",\n    \"dipl_sup\", \"cadres\",     \"Pourcentage de cadres x diplômés du supérieur\",\n    \"hlm\",      \"cadres\",     \"Pas facile de trouver un titre\",\n    \"proprio\",  \"cadres\",     \"Oui non vraiment c'est pas simple\"\n)\n\nnuages\n#&gt; # A tibble: 4 × 3\n#&gt;   var1     var2       titre                                        \n#&gt;   &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;                                        \n#&gt; 1 dipl_sup dipl_aucun Diplômés du supérieur x sans diplôme         \n#&gt; 2 dipl_sup cadres     Pourcentage de cadres x diplômés du supérieur\n#&gt; 3 hlm      cadres     Pas facile de trouver un titre               \n#&gt; 4 proprio  cadres     Oui non vraiment c'est pas simple\n\nOn est dans une situation similaire à la précédente, sauf que cette fois on doit itérer sur trois vecteurs en parallèle. On va donc utiliser la fonction pmap() qui permet d’itérer sur autant de listes ou vecteurs que l’on souhaite. Plus précisément, comme on souhaite générer des graphiques on va utiliser la variante pwalk() qui ne retourne pas de résultat.\npmap() et pwalk() prennent deux arguments principaux :\n\nles vecteurs et listes sur lesquels itérer, eux-mêmes regroupés dans une liste\nune fonction acceptant autant d’arguments que de vecteur ou listes sur lesquels on itère\n\nDans notre exemple on aurait donc un appel de la forme suivante.\n\npwalk(\n    list(nuages$var1, nuages$var2, nuages$titre),\n    function(var1, var2, titre) {\n        plot(\n            rp2018[[var1]], rp2018[[var2]],\n            xlab = var1, ylab = var2, main = titre\n        )\n    }\n)\n\n\n\n\n\n\nPetite précision, si la liste est nommée, il faut que les noms des arguments de la fonction correspondent aux noms de la liste.\n\npwalk(\n    list(v1 = nuages$var1, v2 = nuages$var2, titre = nuages$titre),\n    function(v1, v2, titre) {\n        plot(\n            rp2018[[v1]], rp2018[[v2]],\n            xlab = v1, ylab = v2, main = titre\n        )\n    }\n)\n\nÀ noter que comme nuages est un tableau de données, donc une liste dont les éléments sont ses colonnes, on obtient le même résultat avec :\n\npwalk(\n    nuages,\n    function(var1, var2, titre) {\n        plot(\n            rp2018[[var1]], rp2018[[var2]],\n            xlab = var1, ylab = var2, main = titre\n        )\n    }\n)\n\nOn peut utiliser la syntaxe “formule” pour la fonction anonyme, dans ce cas les arguments sont accessibles avec la notation ..1, ..2, etc. On notera que dans ce cas la syntaxe “formule” est sans doute moins lisible que la syntaxe classique avec function() qui permet de nommer les paramètres.\n\npwalk(\n    nuages,\n    ~ {\n        plot(\n            rp2018[[..1]], rp2018[[..2]],\n            xlab = ..1, ylab = ..2, main = ..3\n        )\n    }\n)\n\nComme pour map() et map2(), pmap() propose aussi les variantes pmap_int(), pmap_chr(), etc."
  },
  {
    "objectID": "18-purrr.html#répéter-une-opération",
    "href": "18-purrr.html#répéter-une-opération",
    "title": "18  Itérer avec purrr",
    "section": "18.8 Répéter une opération",
    "text": "18.8 Répéter une opération\nLes fonctions de purrr peuvent être utilisées quand on souhaite juste répéter une opération un certain nombre de fois, à la place d’une boucle for.\nPar exemple si on souhaite générer 10 vecteurs de 100 nombre aléatoires, on pourra remplacer la boucle suivante :\n\nres &lt;- list()\nfor (i in 1:10) {\n    res &lt;- c(res, rnorm(100))\n}\n\nPar un appel à map() :\n\nres &lt;- map(1:10, ~ rnorm(100))\n\nCe qui donne un code un peu plus compact et plus lisible.\n\n\n\n\n\n\nNote\n\n\n\nDe la même manière, si on s’intéresse juste aux effets de bord, on pourra éventuellement remplacer une boucle for par un appel à walk()."
  },
  {
    "objectID": "18-purrr.html#quand-ne-pas-utiliser-map",
    "href": "18-purrr.html#quand-ne-pas-utiliser-map",
    "title": "18  Itérer avec purrr",
    "section": "18.9 Quand (ne pas) utiliser map",
    "text": "18.9 Quand (ne pas) utiliser map\nUne fois qu’on a compris la logique de map() et de ses variantes, on peut être tenté.es de l’appliquer un peu systématiquement. Il faut cependant garder en tête que son usage n’est pas toujours conseillé notamment dans les cas où il existe déjà une fonction vectorisée qui permet d’obtenir le même résultat.\nAinsi cela n’aurait pas de sens de faire :\n\nv &lt;- 1:5\nmap_dbl(v, ~ .x + 10)\n#&gt; [1] 11 12 13 14 15\n\nQuand on peut simplement faire :\n\nv + 10\n#&gt; [1] 11 12 13 14 15\n\nPour prendre un exemple un peu moins caricatural, de nombreuses fonctions de stringr sont vectorisées, il n’est donc pas utile de faire :\n\ntextes &lt;- c(\"fantastique\", \"effectivement\", \"igloo\")\nmap_int(textes, ~ str_count(.x, \"f\"))\n#&gt; [1] 1 2 0\n\nQuand on peut faire simplement :\n\nstr_count(textes, \"f\")\n#&gt; [1] 1 2 0\n\nPar contre map() est utile quand on souhaite appliquer une fonction qui n’est pas vectorisée à plusieurs valeurs, comme c’est le cas par exemple avec read_csv(), qui ne permet pas de charger plusieurs fichiers d’un coup :\n\nfichiers &lt;- c(\"fichier1.csv\", \"fichier2.csv\")\nl &lt;- fichiers %&gt;% map(read_csv)\n\nOu quand on veut itérer sur un argument non vectorisé, par exemple ici sur l’argument pattern de str_count() :\n\nvoyelle &lt;- c(a = \"a\", e = \"e\", i = \"i\")\ntextes &lt;- c(\"brouette\", \"moto\", \"igloo\")\nvoyelle %&gt;% map(~ str_count(textes, pattern = .x))\n#&gt; $a\n#&gt; [1] 0 0 0\n#&gt; \n#&gt; $e\n#&gt; [1] 2 0 0\n#&gt; \n#&gt; $i\n#&gt; [1] 0 0 1\n\nOn l’utilise également quand on veut appliquer une fonction non pas à une liste, mais aux éléments qu’elle contient :\n\nl &lt;- list(1:3, c(2, 5))\nl %&gt;% map_int(length)\n#&gt; [1] 3 2\n\nÀ noter qu’en termes de performance, map() n’est pas forcément plus rapide qu’une boucle for, puisque dans les deux cas on itère sur un ensemble de valeurs. Par contre une fonction vectorisée existante sera toujours (beaucoup) plus rapide."
  },
  {
    "objectID": "18-purrr.html#purrr-vs-apply",
    "href": "18-purrr.html#purrr-vs-apply",
    "title": "18  Itérer avec purrr",
    "section": "18.10 purrr vs *apply",
    "text": "18.10 purrr vs *apply\nLes fonctions de purrr ont des équivalents dans R “de base”, ce sont notamment les fonctions de la famille apply : lapply, sapply, mapply…\nL’avantage de map() et des autres fonctions fournies par purrr et qu’elles sont plus explicites : on a des fonctions différentes selon qu’on veut seulement appliquer une fonction (map()), générer des effets de bord (walk), modifier une liste sans changer son type (modify()), etc. purrr propose également de nombreuses fonctions utiles qui facilite le travail avec les vecteurs et listes.\nMais un des avantages principaux des fonctions de la famille map() est qu’elles sont consistantes et cohérentes dans le type de résultat qu’elles retournent : on est certain que map() ou imap() retourneront une liste, que map_chr() ou map2_chr() retourneront un vecteur de chaînes de caractères, etc.\nLà encore, il n’est pas question de dire qu’il ne faut pas utiliser les fonctions *apply. Si vous en avez l’habitude et qu’elles fonctionnent pour vous, il n’y a pas spécialement de raison de changer. Mais si vous n’avez pas l’habitude de ce type d’opérations ou si vous préférez une syntaxe plus cohérente et plus facile à retenir, les fonctions de purrr peuvent être intéressantes.\nSi vous souhaitez en savoir plus, l’ouvrage en ligne R for data science contient une comparaison plus détaillée des deux familles de fonctions."
  },
  {
    "objectID": "18-purrr.html#ressources",
    "href": "18-purrr.html#ressources",
    "title": "18  Itérer avec purrr",
    "section": "18.11 Ressources",
    "text": "18.11 Ressources\nAu-delà de celles présentées ici, purrr propose de nombreuses autres fonctions facilitant la manipulation et les itérations sur les listes et les vecteurs. On peut en trouver la liste complète et la documentation associée (en anglais) sur le site de l’extension.\nLa section Iteration de l’ouvrage en ligne R for data science (en anglais) propose une présentation de plusieurs fonctions de purrr.\nRStudio propose une antisèche (en anglais, format PDF) qui résume les différentes fonctions de purrr.\nSur le blog en français de Lise Vaudor, on trouvera un billet Itérer des fonctions avec purrr et une suite practice makes purrr-fect."
  },
  {
    "objectID": "18-purrr.html#exercices",
    "href": "18-purrr.html#exercices",
    "title": "18  Itérer avec purrr",
    "section": "18.12 Exercices",
    "text": "18.12 Exercices\n\n18.12.1 map et ses variantes\nExercice 1.1\nLa liste suivante rassemble les notes obtenues par un élève dans différentes matières.\n\nnotes &lt;- list(\n    maths = c(12, 15, 8, 10),\n    anglais = c(18, 11, 9),\n    sport = c(5, 13),\n    musique = 14\n)\n\nEn utilisant map(), calculer une liste indiquant la moyenne dans chaque matière.\n\n\nnotes %&gt;% map(mean)\n\n\nEn utilisant une variante de map(), simplifier le résultat pour obtenir un vecteur numérique.\n\n\nnotes %&gt;% map_dbl(mean)\n\n\nOn a rajouté à la liste les notes obtenues en technologie, parmi lesquelles une note est manquante.\n\nnotes &lt;- list(\n    maths = c(12, 15, 8, 10),\n    anglais = c(18, 11, 9),\n    sport = c(5, 13),\n    musique = 14,\n    techno = c(12, NA)\n)\n\nCalculer à nouveau un vecteur numérique des moyennes par matière, mais sans tenir compte de la valeur manquante.\n\n\nnotes %&gt;% map_dbl(~ mean(.x, na.rm = TRUE) )\n# Ou bien\nnotes %&gt;% map_dbl(mean, na.rm = TRUE)\n\n\nCalculer une liste qui contient pour chaque matière la moyenne, la note minimale et la note maximale.\n\n\n# On peut aussi utiliser list() plutôt que c()\nnotes %&gt;%\n    map(~ c(\n            moyenne = mean(.x, na.rm = TRUE),\n            min = min(.x, na.rm = TRUE),\n            max = max(.x, na.rm = TRUE)\n        )\n    )\n\n\nExercice 1.2\nLa liste suivante comporte les parcours biographiques de 5 personnes sous la forme de vecteurs indiquant leurs communes de résidence successives.\n\nparcours &lt;- list(\n    c(\"Lyon\", \"F1ixevi11e\", \"Saint-Dié-en-Poui11y\"),\n    c(\"Sainte-Gabelle-sur-Sarthe\"),\n    c(\"Décines\", \"Meyzieu\", \"Demptezieu\"),\n    c(\"Meyzieu\", \"Lyon\", \"Paris\", \"F1ixevi11e\", \"Lyon\"),\n    c(\"La Bâtie-Divisin\", \"Versai11es\")\n)\n\nÀ l’aide de map(), calculer une nouvelle liste comportant le nombre de villes de résidence pour chaque parcours.\n\n\nparcours %&gt;% map(length)\n\n\nUtiliser une variante de map() pour simplifier le résultat et obtenir un vecteur numérique plutôt qu’une liste.\n\n\nparcours %&gt;% map_int(length)\n\n\nDéterminer pour chaque parcours le nombre de fois où la personne a résidé à Lyon.\n\n\nparcours %&gt;% map_int(~ sum(.x == \"Lyon\"))\n\n\nOn vient de repérer un problème dans les données : des caractères “l” ont été remplacés par des “1”. Utiliser map() pour corriger l’objet parcours en remplaçant tous les “1” par des “l”.\n\n\nparcours &lt;- parcours %&gt;%\n    map(~ str_replace_all(.x, \"1\", \"l\"))\n\n\nExercice 1.3\nLe vecteur suivant contient les adresses de deux fichiers CSV contenant les données de rp2018 pour les départements de l’Ain et du Rhône :\n\nurls &lt;- c(\n    \"https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_01.csv\",\n    \"https://raw.githubusercontent.com/juba/tidyverse/main/resources/data/rp2018/rp2018_69.csv\"\n)\n\nUtiliser map() pour charger ces deux tableaux de données dans une liste nommée dfs.\n\n\ndfs &lt;- urls %&gt;% map(read_csv)\n\n\nUtiliser map_dfr() pour charger ces deux tableaux de données et les regrouper en une seule table d. Que constatez-vous ?\n\n\n# Génère une erreur !\nd &lt;- urls %&gt;% map_dfr(read_csv)\n\n\nÀ l’aide de map(), afficher la variable code_insee des deux tableaux de dfs. D’où vient le problème ?\n\n\n# Une variable a été importée en character, l'autre en numérique\ndfs %&gt;% map(~ .x$code_insee)\n\n\nTrouver une solution pour corriger le problème.\n\n\n# En convertissant manuellement code_insee en character\nd &lt;- urls %&gt;%\n    map_dfr(~{\n        tab &lt;- read_csv(.x)\n        tab$code_insee &lt;- as.character(tab$code_insee)\n        tab\n    })\n\n# Ou bien en utilisant l'option col_types de read_csv\nd &lt;- urls %&gt;%\n    map_dfr(read_csv, col_types = c(\"code_insee\" = \"character\"))\n\n\n\n\n18.12.2 modify et itération sur les colonnes d’un tableau\nExercice 2.1\nSoit le tableau de données d suivant :\n\nd &lt;- tribble(\n    ~prenom,              ~nom,               ~age, ~taille,\n    \"pierre-edmond\",      \"multinivo\",        19,   151,\n    \"YVONNE-HENRI\",       \"QUIDEU\",           73,   182,\n    \"jean-adélaïde\",      \"hacépé\",           27,   NA\n)\n\nUtliser typeof() et map() pour afficher le type de toutes les colonnes de d.\n\n\nd %&gt;% map(typeof)\n\n\nEn utilisant keep() et map(), calculer la moyenne de toutes les variables numériques de d.\n\n\nd %&gt;%\n    keep(is.numeric) %&gt;%\n    map(mean, na.rm = TRUE)\n\n\nEn utilisant modify_if(), appliquer str_to_title() à toutes les colonnes de type character pour corriger la capitalisation des noms et prénoms.\n\n\nd &lt;- d %&gt;% modify_if(is.character, str_to_title)\n\n\nÀ l’aide de la fonction discard(), supprimer de d les colonnes qui comportent des NA.\n\n\nd %&gt;% discard(~ sum(is.na(.x)) &gt; 0)\n# Ou bien\nd %&gt;% discard(~ any(is.na(.x)))\n\n\n\n\n18.12.3 imap et walk\nExercice 3.1\nOn reprend la liste de notes vue dans un exercice précédent.\n\nnotes &lt;- list(\n    maths = c(12, 15, 8, 10),\n    anglais = c(18, 11, 9),\n    sport = c(5, 13),\n    musique = 14,\n    techno = c(12, NA)\n)\n\nSans utiliser de boucle for, afficher avec la fonction message() les valeurs de chaque moyenne tour à tour de manière à obtenir le résultat suivant :\n\n#&gt; 11.25\n#&gt; 12.6666666666667\n#&gt; 9\n#&gt; 14\n#&gt; 12\n\n\n\nnotes %&gt;% walk(~ message(mean(.x, na.rm = TRUE)))\n\n\nDe la même manière afficher pour chaque matière les messages suivants :\n\n#&gt; Votre moyenne en maths est 11.25\n#&gt; Votre moyenne en anglais est 12.6666666666667\n#&gt; Votre moyenne en sport est 9\n#&gt; Votre moyenne en musique est 14\n#&gt; Votre moyenne en techno est 12\n\n\n\nnotes %&gt;% iwalk(function(notes, matiere) {\n    message(\"Votre moyenne en \", matiere, \" est \", mean(notes, na.rm = TRUE))\n})\n\n\nConstruire un tableau de données avec une matière par ligne et deux colonnes contenant le nom de la matière et la valeur de la moyenne.\n\n#&gt; # A tibble: 5 × 2\n#&gt;   matiere moyenne\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;\n#&gt; 1 maths      11.2\n#&gt; 2 anglais    12.7\n#&gt; 3 sport       9  \n#&gt; 4 musique    14  \n#&gt; 5 techno     12\n\n\n\nnotes %&gt;% \n    imap_dfr(function(notes, matiere) {\n        tibble(\n            matiere = matiere,\n            moyenne = mean(notes, na.rm = TRUE)\n        )\n    })\n\n\nExercice 3.2\nLors de la présentation des boucles for, on a vu la fonction suivante qui affiche les dimensions de chaque tableau de données contenu dans une liste.\n\naffiche_dimensions &lt;- function(dfs) {\n    for (i in seq_along(dfs)) {\n        name &lt;- names(dfs)[[i]]\n        df &lt;- dfs[[i]]\n        message(\"Dimensions de \", name, \" : \", nrow(df), \"x\", ncol(df))\n    }\n}\n\nl &lt;- list(\n    hdv = hdv2003,\n    rp = rp2018\n)\n\naffiche_dimensions(l)\n#&gt; Dimensions de hdv : 2000x20\n#&gt; Dimensions de rp : 5417x62\n\nRéécrire affiche_dimensions() en utilisant iwalk().\n\n\naffiche_dimensions &lt;- function(dfs) {\n    iwalk(dfs, function(df, name) {\n        message(\"Dimensions de \", name, \" : \", nrow(df), \"x\", ncol(df))\n    })\n}\n\n\nExercice 3.3\nLors de la présentation des boucles, on a vu la fonction summaries suivante, qui prend en paramètre un tableau de données et une liste de noms de colonnes, et applique la fonction summary() à ces colonnes.\n\nsummaries &lt;- function(d, vars) {\n    for (var in vars) {\n        message(\"--- \", var, \" ---\")\n        print(summary(d[, var]))\n    }\n}\n\nsummaries(hdv2003, c(\"sexe\", \"age\"))\n\nRéécrire la fonction sans utiliser de boucle for.\n\n\nsummaries &lt;- function(d, vars) {\n    vars %&gt;%\n        walk(~{\n            message(\"--- \", .x, \" ---\")\n            print(summary(d[, .x]))\n        })\n}\n\n\nModifier cette nouvelle fonction en utilisant keep() ou discard(), pour qu’elle fonctionne sans erreur même si l’une des variables passées en arguments n’existe pas.\n\nsummaries(hdv2003, c(\"sexe\", \"igloo\", \"age\"))\n#&gt; --- sexe ---\n#&gt;     sexe     \n#&gt;  Homme: 899  \n#&gt;  Femme:1101\n#&gt; --- age ---\n#&gt;       age       \n#&gt;  Min.   :18.00  \n#&gt;  1st Qu.:35.00  \n#&gt;  Median :48.00  \n#&gt;  Mean   :48.16  \n#&gt;  3rd Qu.:60.00  \n#&gt;  Max.   :97.00\n\n\n\nsummaries &lt;- function(d, vars) {\n    vars %&gt;%\n        keep(~ .x %in% names(d) ) %&gt;%\n        walk(~{\n            message(\"--- \", .x, \" ---\")\n            print(summary(d[, .x]))\n        })\n}\n\n\n\n\n18.12.4 map2 et pmap\nExercice 4.1\nSoit le tableau de données suivant, qui indique des couples de variables du jeu de données hdv2003.\n\ncroisements &lt;- tribble(\n    ~v1,      ~v2,\n    \"qualif\", \"clso\",\n    \"qualif\", \"cinema\",\n    \"sexe\",   \"clso\",\n    \"sexe\",   \"cinema\"\n)\n\ncroisements\n#&gt; # A tibble: 4 × 2\n#&gt;   v1     v2    \n#&gt;   &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 qualif clso  \n#&gt; 2 qualif cinema\n#&gt; 3 sexe   clso  \n#&gt; 4 sexe   cinema\n\nÀ l’aide de map2(), calculer une liste qui contient les tableaux croisés des quatre couples de variables de croisements.\n\n\nmap2(croisements$v1, croisements$v2,\n    ~table(hdv2003[[.x]], hdv2003[[.y]])\n)\n\n\nModifier le code précédent pour obtenir une liste comportant, pour chaque couple de variables :\n\nles noms des deux variables croisées\nle résultat du test du \\(\\chi^2\\) appliqué aux deux variables\n\n\n\nkhi2 &lt;- map2(croisements$v1, croisements$v2,\n    ~list(\n        variables = paste(.x, .y),\n        chisq = chisq.test(hdv2003[[.x]], hdv2003[[.y]])\n    )\n)\n\n\nFacultatif : filtrer la liste obtenue à l’étape précédente pour ne conserver que les éléments dont la p-value du test du \\(\\chi^2\\) est inférieure à 0.001.\n\n\nkhi2 &lt;- map2(croisements$v1, croisements$v2,\n    ~list(\n        variables = paste(.x, .y),\n        chisq = chisq.test(hdv2003[[.x]], hdv2003[[.y]])\n    )\n) %&gt;%\nkeep(~ .x$chisq$p.value &lt; 0.001)\n\n\nExercice 4.2\nPour rappel, on peut simuler un tirage au sort de type “pile ou face” avec la fonction sample() de la manière suivante :\n\nsample(\n    c(\"pile\", \"face\"),\n    size = 10,\n    replace = TRUE,\n    prob = c(0.5, 0.5)\n)\n#&gt;  [1] \"face\" \"pile\" \"pile\" \"face\" \"face\" \"pile\" \"face\" \"face\" \"face\" \"face\"\n\nLe tableau de données suivant définit trois types de tirages aléatoires différents. elements contient les éléments parmi lesquels on tire, probas les probabilités de chaque élément d’être tiré, et n le nombre de tirages.\n\ntirages &lt;- tribble(\n    ~elements,           ~probas,     ~n,\n    c(\"pile\", \"face\"),   c(0.5, 0.5), 1000,\n    c(\"rouge\", \"noire\"), c(0.1, 0.9), 500,\n    1:6,                 rep(1/6, 6), 800\n)\n\nÀ l’aide de pmap() et de sample(), créer une liste contenant les résultats des simumations de ces trois séries de tirages.\n\n\nresultats &lt;- tirages %&gt;%\n    pmap(\n        function(elements, probas, n) {\n            sample(elements, size = n, replace = TRUE, prob = probas)\n        }\n    )\n\n\nReprésenter avec barplot() les résultats obtenus.\n\n\nresultats %&gt;% walk(~barplot(table(.x)))\n\n\n\n\n18.12.5 Répéter une opération\nExercice 5.1\nLa fonction suivante simule le lancer de n dés à 6 faces.\n\nlancer_des &lt;- function(n) {\n    sample(1:6, size = n, replace = TRUE)\n}\n\nlancer_des(3)\n#&gt; [1] 4 2 4\n\nOn souhaite utiliser cette fonction pour générer 10 lancers de 4 dés. On essaie avec le code suivant :\n\nmap(1:10, lancer_des, 4)\n\nEst-ce que cela fonctionne ? Pourquoi ?\n\nÇa ne fonctionne pas car lancer_des() est appelée à chaque itération avec deux arguments : la valeur courante de l’itérateur, et 4. Ainsi dans sa première itération, map() exécute lancer_des(1, 4), ce qui génère un message d’erreur puisque lancer_des() n’accepte qu’un argument.\n\nTrouver une solution en corrigeant le code.\n\n\nmap(1:10, ~lancer_des(4))\n\n\nExercice 5.2\nComme vu précédemment, la fonction suivante permet de simuler 20 lancers de pièces et de stocker le résultat dans un vecteur de chaînes de caractères.\n\nsample(c(\"pile\", \"face\"), size = 20, replace = TRUE)\n#&gt;  [1] \"face\" \"face\" \"face\" \"face\" \"pile\" \"pile\" \"pile\" \"pile\" \"pile\" \"pile\"\n#&gt; [11] \"face\" \"pile\" \"face\" \"face\" \"face\" \"pile\" \"face\" \"pile\" \"pile\" \"face\"\n\nÀ l’aide de map() et de ce code, créer une liste nommée sims contenant le résultat de 100 simulations de 20 lancers.\n\n\nsims &lt;- map(\n    1:100,\n    ~ sample(c(\"pile\", \"face\"), size = 20, replace = TRUE)\n)\n\n\nToujours à l’aide de map(), calculer le nombre de “pile” obtenus pour chaque simulation de sims.\n\n\nn_piles &lt;- sims %&gt;% map_int(~ sum(.x == \"pile\"))\n\n\nDéterminer le nombre minimal et le nombre maximal de “pile” obtenus parmi toutes les simulations de sims.\n\n\nrange(n_piles)\n\n\nFacultatif : à l’aide de la fonction head_while(), déterminer pour chaque simulation de sims le nombre de “pile” consécutifs obtenus avant le premier “face”.\n\n\nsims %&gt;% map_int(\n    ~ length(head_while(.x, ~ .x == \"pile\"))\n)\n\n\nFacultatif : la fonction rle() permet de calculer les run length encoding d’un vecteur.\n\nrle(c(\"pile\", \"face\", \"face\", \"face\", \"pile\", \"pile\"))\n#&gt; Run Length Encoding\n#&gt;   lengths: int [1:3] 1 3 2\n#&gt;   values : chr [1:3] \"pile\" \"face\" \"pile\"\n\nÀ l’aide de cette fonction et de map_int(), calculer pour chaque simulation la longueur de la plus grande série consécutive de “pile”.\n\n\nsims %&gt;% map_int(~{\n    r &lt;- rle(.x)\n    longueurs_pile &lt;- r$lengths[r$values == \"pile\"]\n    max(longueurs_pile)\n})"
  },
  {
    "objectID": "18-purrr.html#footnotes",
    "href": "18-purrr.html#footnotes",
    "title": "18  Itérer avec purrr",
    "section": "",
    "text": "Pour une application sérieuse on utilisera des fonctions spécifiques de “tokenization” d’extensions dédiées à l’analyse textuelle, comme quanteda.↩︎"
  },
  {
    "objectID": "19-programmer-tidyverse.html#spécificités-du-tidyverse",
    "href": "19-programmer-tidyverse.html#spécificités-du-tidyverse",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.1 Spécificités du tidyverse",
    "text": "19.1 Spécificités du tidyverse\nLes extensions du tidyverse fournissent une syntaxe lisible et agréable à utiliser lorsqu’on les utilise de manière interactive. Par exemple, si on veut filtrer les lignes et les colonnes d’un tableau de données en base R, on utilise quelque chose comme :\n\nstarwars[starwars$species == \"Droid\" & starwars$eye_color == \"red\", c(\"height\", \"mass\")]\n\nTandis qu’avec dplyr on peut faire :\n\nstarwars %&gt;%\n    filter(species == \"Droid\" & eye_color == \"red\") %&gt;%\n    select(height, mass)\n\nL’avantage de dplyr est double :\n\ndans filter, on sait qu’on travaille à l’intérieur du tableau de données, on indique donc juste species et pas starwars$species\ndans select, on peut indiquer les noms de colonnes en omettant les guillemets\n\nCette simplification pour une utilisation interactive, la plus fréquente, entraîne cependant une complexification lorsqu’on souhaite utiliser ces fonctions pour programmer, notamment quand on veut les utiliser à l’intérieur d’autres fonctions.\n\n19.1.1 data masking\nOn part du tableau de données d’exemple suivant1.\n\nrestos &lt;- tibble(\n    nom = c(\"Chez Jojo\", \"Vertige des sens\", \"Le Crousse\", \"Le bouchon coréen\", \"Le lampad'hair\"),\n    style = c(\"tradi\", \"gastro\", \"tradi\", \"gastro\", \"coiffure\"),\n    ville = c(\"Ecully\", \"Lyon\", \"Lyon\", \"Lyon\", \"Ecully\"),\n    evaluation = c(4.6, 3.2, 3.3, 4.1, 1.2),\n    places = c(28, 32, 94, 18, 8),\n    note = c(\"Pas mal\", \"Cher\", \"Ambiance jeune\", \"Original\", \"Euh ?\")\n)\n\nrestos\n#&gt; # A tibble: 5 × 6\n#&gt;   nom               style    ville  evaluation places note          \n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;         \n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal       \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher          \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune\n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original      \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?\n\nAvec dplyr, on peut sélectionner une colonne du tableau avec :\n\nrestos %&gt;% select(note)\n#&gt; # A tibble: 5 × 1\n#&gt;   note          \n#&gt;   &lt;chr&gt;         \n#&gt; 1 Pas mal       \n#&gt; 2 Cher          \n#&gt; 3 Ambiance jeune\n#&gt; 4 Original      \n#&gt; 5 Euh ?\n\nDans cette expression, note ne se réfère pas à un objet note de notre environnement, mais à une variable du tableau de données restos.\nQue se passe-t-il si on passe à select non pas une colonne du tableau mais bien un objet de notre environnement ?\n\nx &lt;- \"note\"\nrestos %&gt;% select(x)\n#&gt; Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\n#&gt; ℹ Please use `all_of()` or `any_of()` instead.\n#&gt;   # Was:\n#&gt;   data %&gt;% select(x)\n#&gt; \n#&gt;   # Now:\n#&gt;   data %&gt;% select(all_of(x))\n#&gt; \n#&gt; See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n#&gt; # A tibble: 5 × 1\n#&gt;   note          \n#&gt;   &lt;chr&gt;         \n#&gt; 1 Pas mal       \n#&gt; 2 Cher          \n#&gt; 3 Ambiance jeune\n#&gt; 4 Original      \n#&gt; 5 Euh ?\n\nÇa fonctionne aussi : en l’absence de colonne nommée x, select va aller chercher le x de notre environnement et utiliser sa valeur pour sélectionner la colonne par nom.\nMais que se passe-t-il s’il existe à la fois une colonne du tableau et un objet de notre environnement du même nom ?\n\nnote &lt;- \"nom\"\nrestos %&gt;% select(note)\n#&gt; # A tibble: 5 × 1\n#&gt;   note          \n#&gt;   &lt;chr&gt;         \n#&gt; 1 Pas mal       \n#&gt; 2 Cher          \n#&gt; 3 Ambiance jeune\n#&gt; 4 Original      \n#&gt; 5 Euh ?\n\nDans ce cas, c’est la colonne du tableau qui a la priorité. On dit que dplyr fait du data masking : les objets de notre environnement sont “masqués” par les colonnes du même nom de notre tableau de données. On retrouve ce data masking dans d’autres fonctions comme filter(), mutate() ou summarise(), mais aussi dans la sélection des variables avec aes() pour les fonctions de ggplot2.\nDans certains cas de figure, on peut vouloir outrepasser ce data masking. Par exemple, dans le cas suivant, la nouvelle colonne note_michelin n’est pas créée à partir des nouvelles données de l’objet note, mais à partir de celles de la colonne note.\n\nnote &lt;- c(12, 14, 9, 15, NA)\nrestos %&gt;% mutate(note_michelin = note)\n#&gt; # A tibble: 5 × 7\n#&gt;   nom               style    ville  evaluation places note           note_mich…¹\n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;      \n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal        Pas mal    \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher           Cher       \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune Ambiance j…\n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original       Original   \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?          Euh ?      \n#&gt; # … with abbreviated variable name ¹​note_michelin\n\n“Il suffit de changer le nom de l’objet note pour qu’il ne corresponde à aucune colonne !”, s’exclamera la lectrice ou le lecteur attentif.ve. Mais, outre que cela peut être source d’erreur, il est des cas où on ne connaît pas le nom des colonnes du tableau, par exemple quand l’opération se déroule dans une fonction et que le tableau est passé en paramètre :\n\nfiltre_nom &lt;- function(df, valeurs) {\n    df %&gt;% filter(nom %in% valeurs)\n}\n\nRien ne nous assure dans ce cas que le tableau df ne contient pas déjà une colonne nommée valeurs qui “masquerait” l’objet valeurs passé en argument…\nPour pallier à ce problème, à chaque fois qu’on est dans un environnement où du data masking se produit, on peut utiliser deux “pronoms” spécifiques nommés .data et .env :\n\n.data$var ou .data[[\"var\"]] pointe vers l’objet var correspondant à une colonne du tableau de données\n.env$var ou .env[[\"var\"]] pointe vers l’objet var correspondant à un objet de notre environnement\n\nAvec ces deux outils, on peut donc explicitement choisir d’où viennent les données qu’on utilise.\n\nnote &lt;- c(12, 14, 9, 15, NA)\nrestos %&gt;% mutate(note_michelin = .env$note)\n#&gt; # A tibble: 5 × 7\n#&gt;   nom               style    ville  evaluation places note           note_mich…¹\n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal                 12\n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher                    14\n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune           9\n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original                15\n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?                   NA\n#&gt; # … with abbreviated variable name ¹​note_michelin\nrestos %&gt;% mutate(note = str_to_upper(.data$note))\n#&gt; # A tibble: 5 × 6\n#&gt;   nom               style    ville  evaluation places note          \n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;         \n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 PAS MAL       \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 CHER          \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 AMBIANCE JEUNE\n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 ORIGINAL      \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 EUH ?\n\nEn utilisant .env, on peut donc s’assurer que notre fonction filtre_nom() ci-dessus va bien prendre les valeurs dans notre environnement, donc dans l’argument passé à la fonction, et pas dans une éventuelle colonne qui porterait le même nom.\n\nfiltre_nom &lt;- function(df, valeurs) {\n    df %&gt;% filter(nom %in% .env$valeurs)\n}\n\nfiltre_nom(restos, c(\"Chez Jojo\", \"Le Crousse\"))\n#&gt; # A tibble: 2 × 6\n#&gt;   nom        style ville  evaluation places note          \n#&gt;   &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;         \n#&gt; 1 Chez Jojo  tradi Ecully        4.6     28 Pas mal       \n#&gt; 2 Le Crousse tradi Lyon          3.3     94 Ambiance jeune\n\n\n\n19.1.2 tidy selection\nUne autre spécificité de certaines fonctions du tidyverse réside dans le mode de sélection des colonnes basé sur un “mini-langage” permettant des expressions comme :\n\nc(height, mass)\nq1:q10\nwhere(is.numeric) & !contains(id)\n\nCette méthode de sélection de colonnes est appelée tidy selection et on la retrouve dans plusieurs fonctions de dplyr et tidyr, comme select(), across(), c_across(), pull(), pivot_longer(), etc.\n\n\n\n\n\n\nNote\n\n\n\nLa tidy selection est implémentée par le package tidyselect et on peut retrouver les différentes possibilités de ce mini-langage dans la vignette Selection language.\n\n\nOn notera que la tidy selection fait appel au data masking, tout en y ajoutant des fonctions spécifiques.\n\n\n19.1.3 Utilisation dans des fonctions\nUne difficulté liée au data masking survient quand les colonnes du tableau ne sont pas saisies directement mais proviennent d’un argument de fonction.\nSoit la fonction suivante qui prend en entrée un tableau de données et une colonne et retourne le résultat d’un summmarise.\n\nsummarise_min &lt;- function(df, col) {\n    df %&gt;% summarise(min = min(col))\n}\n\nOn voudrait pouvoir appeler cette fonction de la même manière qu’on utilise summarise, mais cela ne fonctionne pas :\n\nsummarise_min(restos, evaluation)\n#&gt; Error in `summarise()`:\n#&gt; ℹ In argument: `min = min(col)`.\n#&gt; Caused by error:\n#&gt; ! object 'evaluation' not found\n\nLe message d’erreur nous dit que l’objet evaluation est introuvable. La raison n’est pas triviale, elle repose sur plusieurs mécanismes assez complexes liés à l’évaluation des expressions dans R, mais on pourrait résumer en disant que les fonctions du tidyverse utilisent leur propre mécanisme d’évaluation qui tient compte notamment du data masking. Or, quand on utilise l’argument col dans le summarise de notre fonction, c’est l’évaluation “normale” de R qui est utilisée : le data masking n’étant pas pris en compte, l’objet evaluation est recherché dans notre environnement plutôt que dans notre tableau, ce qui génère une erreur puisqu’aucun objet de ce nom n’existe en-dehors du tableau.\nComme la tidy selection fait appel au data masking, elle génère le même type d’erreur :\n\nselect_col &lt;- function(df, col) {\n    df %&gt;% select(col)\n}\n\nselect_col(restos, evaluation)\n#&gt; Error in env_get(env, name, default = missing_arg(), inherit = TRUE): object 'evaluation' not found\n\nC’est pourquoi les packages du tidyverse fournissent un opérateur permettant de “forcer” l’évaluation d’expressions selon la manière qu’elles attendent. Cet opérateur prend la forme de double accolades {{ }} et se nomme curly curly.\nPour résoudre le problème de notre fonction summarise_min(), on peut donc simplement faire passer notre argument col dans l’opérateur curly curly :\n\nsummarise_min &lt;- function(df, col) {\n    df %&gt;% summarise(min = min({{ col }}))\n}\n\nsummarise_min(restos, evaluation)\n#&gt; # A tibble: 1 × 1\n#&gt;     min\n#&gt;   &lt;dbl&gt;\n#&gt; 1   1.2\n\nÀ noter que curly curly permet de passer en argument toute expression qui serait acceptée directement par les fonctions appelées. On peut donc combiner plusieurs colonnes, effectuer des opérations, etc.\n\nsummarise_min(restos, evaluation * 4)\n#&gt; # A tibble: 1 × 1\n#&gt;     min\n#&gt;   &lt;dbl&gt;\n#&gt; 1   4.8\n\nEt on peut même utiliser les pronoms .data et .env :\n\nevaluation &lt;- 0:5\nsummarise_min(restos, .env$evaluation)\n#&gt; # A tibble: 1 × 1\n#&gt;     min\n#&gt;   &lt;int&gt;\n#&gt; 1     0"
  },
  {
    "objectID": "19-programmer-tidyverse.html#programmer-avec-dplyr-et-tidyr",
    "href": "19-programmer-tidyverse.html#programmer-avec-dplyr-et-tidyr",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.2 Programmer avec dplyr et tidyr",
    "text": "19.2 Programmer avec dplyr et tidyr\n\n19.2.1 Utiliser une colonne passée en argument\nUne opération courante quand on utilise les fonctions de dplyr ou tidyr dans une fonction est de prendre en argument une colonne à laquelle on souhaite accéder. Dans ce cas on doit utiliser l’opérateur curly curly et entourer les utilisations de l’argument contenant la colonne par une paire d’accolades.\nOn a déjà vu un exemple précédemment avec summarise().\n\nresume &lt;- function(df, col) {\n    df %&gt;% summarise(\n        moyenne = mean({{ col }}),\n        min = min({{ col }}),\n        max = max({{ col }})\n    )\n}\n\nresume(restos, evaluation)\n#&gt; # A tibble: 1 × 3\n#&gt;   moyenne   min   max\n#&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    3.28   1.2   4.6\n\nC’est le cas dans toutes les fonctions qui font du data masking, comme group_by() :\n\nresume_groupe &lt;- function(df, col_group, col_var) {\n    df %&gt;%\n        group_by({{ col_group }}) %&gt;%\n        summarise(\n            moyenne = mean({{col_var}}),\n            min = min({{ col_var }}),\n            max = max({{ col_var }})\n        )\n}\n\nresume_groupe(restos, style, evaluation)\n#&gt; # A tibble: 3 × 4\n#&gt;   style    moyenne   min   max\n#&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 coiffure    1.2    1.2   1.2\n#&gt; 2 gastro      3.65   3.2   4.1\n#&gt; 3 tradi       3.95   3.3   4.6\n\n\n\n19.2.2 Utiliser une sélection de colonnes passée en argument\nDans la section précédente, on a utilisé à chaque fois une seule colonne. Si on souhaite grouper ou appliquer une fonction sur une série de colonnes, il faut alors utiliser across().\n\nresume_groupe &lt;- function(df, cols_group, cols_var) {\n    df %&gt;%\n        group_by(\n            across({{ cols_group }})\n        ) %&gt;%\n        summarise(\n            across(\n                {{ cols_var }},\n                mean\n            )\n        )\n}\n\nOn peut du coup utiliser tous les modes de sélection de colonnes permises par la tidy selection.\n\nresume_groupe(restos, c(style, ville), where(is.numeric))\n#&gt; `summarise()` has grouped output by 'style'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 4 × 4\n#&gt; # Groups:   style [3]\n#&gt;   style    ville  evaluation places\n#&gt;   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 coiffure Ecully       1.2       8\n#&gt; 2 gastro   Lyon         3.65     25\n#&gt; 3 tradi    Ecully       4.6      28\n#&gt; 4 tradi    Lyon         3.3      94\n\nDe la même manière, si on utilise un argument de fonction pour sélectionner des variables avec select(), on doit l’entourer avec l’opérateur curly curly, et on peut dès lors utiliser toutes les possibilités de la tidy selection.\n\nselect_cols &lt;- function(df, cols) {\n    df %&gt;% select({{ cols }})\n}\n\nrestos %&gt;% select_cols(where(is.character) & !c(nom, note))\n#&gt; # A tibble: 5 × 2\n#&gt;   style    ville \n#&gt;   &lt;chr&gt;    &lt;chr&gt; \n#&gt; 1 tradi    Ecully\n#&gt; 2 gastro   Lyon  \n#&gt; 3 tradi    Lyon  \n#&gt; 4 gastro   Lyon  \n#&gt; 5 coiffure Ecully\n\n\n\n19.2.3 Nommer de nouvelles colonnes à partir d’un argument\nOn a vu comment utiliser des colonnes passées en argument pour accéder à leur contenu. On peut aussi vouloir passer en argument des noms de colonnes qu’on souhaite créer, par exemple avec un mutate() ou un summarise().\nOn pourrait essayer directement de la manière suivante, mais cela ne fonctionne pas car dans ce cas la colonne créée s’appelle “col_new”, et pas la valeur de l’argument col_new.\n\ncalcule_pourcentage &lt;- function(df, col_new, col_var) {\n    df %&gt;% \n        mutate(\n            col_new = {{ col_var }} / sum({{ col_var }}) * 100\n        )\n}\n\ncalcule_pourcentage(restos, prop_places, places)\n#&gt; # A tibble: 5 × 7\n#&gt;   nom               style    ville  evaluation places note           col_new\n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal          15.6 \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher             17.8 \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune   52.2 \n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original         10   \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?             4.44\n\nDans ce cas de figure, la syntaxe à utiliser est un peu plus complexe :\n\non remplace l’opérateur = du mutate() par l’opérateur := (appelé walrus operator)\non place à gauche du := une chaîne de caractères dans laquelle notre argument contenant le nom de la nouvelle variable est entouré d’une paire d’accolades.\n\nVoici ce que ça donne pour l’exemple ci-dessus :\n\ncalcule_pourcentage &lt;- function(df, col_new, col_var) {\n    df %&gt;% \n        mutate(\n            \"{{col_new}}\" := {{ col_var }} / sum({{ col_var }}) * 100\n        )\n}\n\ncalcule_pourcentage(restos, prop_places, places)\n#&gt; # A tibble: 5 × 7\n#&gt;   nom               style    ville  evaluation places note           prop_places\n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal              15.6 \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher                 17.8 \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune       52.2 \n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original             10   \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?                 4.44\n\nCette syntaxe est un peu complexe de prime abord, mais elle à l’avantage d’être souple : en particulier, on peut placer le texte que l’on souhaite dans la chaîne de caractères en plus des noms de variables entre double accolades.\nCela permet par exemple de générer le nom d’une nouvelle variable automatiquement à partir de l’ancienne.\n\ncalcule_pourcentage &lt;- function(df, col_var) {\n    df %&gt;%\n        mutate(\n            \"prop_{{col_var}}\" := {{ col_var }} / sum({{ col_var }}) * 100\n        )\n}\n\ncalcule_pourcentage(restos, places)\n#&gt; # A tibble: 5 × 7\n#&gt;   nom               style    ville  evaluation places note           prop_places\n#&gt;   &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 Chez Jojo         tradi    Ecully        4.6     28 Pas mal              15.6 \n#&gt; 2 Vertige des sens  gastro   Lyon          3.2     32 Cher                 17.8 \n#&gt; 3 Le Crousse        tradi    Lyon          3.3     94 Ambiance jeune       52.2 \n#&gt; 4 Le bouchon coréen gastro   Lyon          4.1     18 Original             10   \n#&gt; 5 Le lampad'hair    coiffure Ecully        1.2      8 Euh ?                 4.44\n\nOu de personnaliser les noms de colonnes dans un summarise().\n\nresume &lt;- function(df, col) {\n    df %&gt;% summarise(\n        \"{{col}}_moyenne\" := mean({{ col }}),\n        \"{{col}}_min\" := min({{ col }}),\n        \"{{col}}_max\" := max({{ col }})\n    )\n}\n\nresume(restos, places)\n#&gt; # A tibble: 1 × 3\n#&gt;   places_moyenne places_min places_max\n#&gt;            &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1             36          8         94\n\n\n\n19.2.4 Désambiguïser data et env\nLorsqu’on utilise des fonctions de dplyr ou tidyr dans d’autres fonctions, il peut être utile de préciser, quand on accède à un objet dont on connaît le nom (c’est-à-dire dont le nom n’est pas passé en argument), si c’est un objet de type “data” (une colonne du tableau de données dans lequel on travaille) ou de type “env” (un objet de l’environnement dans lequel on travaille).\nDans la fonction suivante, on calcule la moyenne d’une colonne numérique de restos selon les valeurs de la colonne ville, et on ne conserve que les villes pour lesquelles cette moyenne est supérieure à un certain seuil.\n\nstat_par_ville &lt;- function(col_var, seuil = NULL) {\n    res &lt;- restos %&gt;%\n        group_by(.data$ville) %&gt;%\n        summarise(moyenne = mean({{col_var}})) %&gt;%\n        filter(moyenne &gt; .env$seuil)\n}\n\nstat_par_ville(evaluation, seuil = 0)\nstat_par_ville(evaluation, seuil = 3)\n\nOn veut que l’objet ville du group_by soit toujours la colonne du tableau restos nommée ville, on peut donc s’assurer que c’est bien le cas en l’explicitant avec .data$ville. À l’inverse, on veut que la valeur seuil du filter soit celle de l’argument du même nom, donc d’un objet de l’environnement. On peut s’en assurer en indiquant .env$seuil.\nCette explicitation ne paraît pas forcément utile à première vue, mais elle peut éviter des problèmes à terme, notamment si on ajoute de nouvelles colonnes à un tableau de données et qu’on finit par avoir des objets “data” et des objets “env” avec le même nom.\n\n\n19.2.5 Quand les arguments sont des chaînes de caractères\nJusqu’ici, on a passé les arguments de fonction sous la forme d’expressions ou de symboles.\n\nresume(restos, places)\nsummarise_min(restos, evaluation * 4)\n\nMais il arrive que des noms de colonnes soient passés plutôt sous forme de chaînes de caractères.\n\nresume(restos, \"places\")\nsummarise_min(restos, \"evaluation\")\n\nOn ne peut pas dans ce cas utiliser l’opérateur curly curly, par contre on peut utiliser le pronom .data pour accéder aux colonnes à partir de leur nom.\n\nsummarise_min &lt;- function(df, col) {\n    df %&gt;% summarise(min = min(.data[[col]]))\n}\n\nsummarise_min(restos, \"evaluation\")\n#&gt; # A tibble: 1 × 1\n#&gt;     min\n#&gt;   &lt;dbl&gt;\n#&gt; 1   1.2\n\nSi dans l’exemple précédent on souhaite personnaliser le nom de la colonne créée en utilisant la valeur de notre paramètre evaluation, on place le nom de notre objet dans une chaîne de caractère en l’entourant d’accolades simples, et on utilise le walrus operator :=.\n\nsummarise_min &lt;- function(df, col) {\n    df %&gt;% summarise(\"min_{col}\" := min(.data[[col]]))\n}\n\nsummarise_min(restos, \"evaluation\")\n#&gt; # A tibble: 1 × 1\n#&gt;   min_evaluation\n#&gt;            &lt;dbl&gt;\n#&gt; 1            1.2\n\nQuand on veut plutôt sélectionner des colonnes avec select() ou across() et qu’on récupère les noms de ces colonnes dans un vecteur de chaînes de caractères, on doit utiliser les fonctions all_of() ou any_of().\n\nevaluation_par_groupe &lt;- function(cols_group) {\n    restos %&gt;%\n        group_by(\n            across(all_of(cols_group))\n        ) %&gt;%\n        summarise(evaluation = mean(.data$evaluation))\n}\n\nevaluation_par_groupe(\"ville\")\n#&gt; # A tibble: 2 × 2\n#&gt;   ville  evaluation\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 Ecully       2.9 \n#&gt; 2 Lyon         3.53\n\nevaluation_par_groupe(c(\"ville\", \"style\"))\n#&gt; `summarise()` has grouped output by 'ville'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 4 × 3\n#&gt; # Groups:   ville [2]\n#&gt;   ville  style    evaluation\n#&gt;   &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n#&gt; 1 Ecully coiffure       1.2 \n#&gt; 2 Ecully tradi          4.6 \n#&gt; 3 Lyon   gastro         3.65\n#&gt; 4 Lyon   tradi          3.3\n\nLa différence entre all_of() et any_of() est que all_of() produira une erreur si l’une des variables n’est pas trouvée.\n\nselect_all_cols &lt;- function(cols) {\n    restos %&gt;% select(all_of(cols))\n}\n\nselect_all_cols(c(\"ville\", \"evaluation\", \"igloo\"))\n#&gt; Error in `select()`:\n#&gt; ! Problem while evaluating `all_of(cols)`.\n#&gt; Caused by error in `all_of()`:\n#&gt; ! Can't subset elements that don't exist.\n#&gt; ✖ Element `igloo` doesn't exist.\n\nTandis qu’any_off() renverra uniquement les colonnes existantes, sans générer d’erreur.\n\nselect_any_cols &lt;- function(cols) {\n    restos %&gt;% select(any_of(cols))\n}\n\nselect_any_cols(c(\"ville\", \"evaluation\", \"igloo\"))\n#&gt; # A tibble: 5 × 2\n#&gt;   ville  evaluation\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 Ecully        4.6\n#&gt; 2 Lyon          3.2\n#&gt; 3 Lyon          3.3\n#&gt; 4 Lyon          4.1\n#&gt; 5 Ecully        1.2"
  },
  {
    "objectID": "19-programmer-tidyverse.html#programmer-avec-ggplot2",
    "href": "19-programmer-tidyverse.html#programmer-avec-ggplot2",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.3 Programmer avec ggplot2",
    "text": "19.3 Programmer avec ggplot2\n\n19.3.1 Sélection de colonnes avec aes()\nLes règles pour sélectionner des colonnes dans un graphique ggplot2 à partir d’arguments passés à une fonction sont les mêmes que celles vues précédemment pour dplyr et tidyr :\n\nsi les noms sont passés sous forme de symboles ou d’expressions, on utilise l’opérateur curly curly ({{ }})\n\n\nbar_graph &lt;- function(df, col) {\n    ggplot(df) +\n        geom_bar(aes(x = {{ col }}), fill = \"skyblue\")\n}\n\nbar_graph(restos, ville)\n\n\n\n\n\nsi les noms sont passés sous forme de chaînes de caractères, on utilise le pronom .data\n\n\nbar_graph &lt;- function(df, col) {\n    ggplot(df) +\n        geom_bar(aes(x = .data[[col]]), fill = \"skyblue\")\n}\n\nbar_graph(restos, \"ville\")\n\n\n\n\n\n\n19.3.2 Faceting\nQuand on utilise facet_wrap() ou facet_grid(), si la variable de faceting est donnée sous forme d’un symbole, on utilise vars() en conjonction avec l’opérateur curly curly.\n\nfacet_points &lt;- function(facet) {\n    ggplot(restos) +\n        geom_point(aes(x = .data$evaluation, y = .data$places)) +\n        facet_wrap(vars({{ facet }}))\n}\n\nfacet_points(ville)\n\n\n\n\nSi la variable de faceting est donnée sous forme d’une chaîne de caractères , on utilise vars() en conjonction avec le pronom .data.\n\nfacet_points &lt;- function(facet) {\n    ggplot(restos) +\n        geom_point(aes(x = .data$evaluation, y = .data$places)) +\n        facet_wrap(vars(.data[[facet]]))\n}\n\nfacet_points(\"ville\")\n\n\n\n\nSi on utilise facet_grid(), la fonction doit accepter deux variables de faceting comme arguments. Celles-ci peuvent ensuite être passées à facet_grid() via ses paramètres rows et cols.\n\nfacet_points &lt;- function(facet_row, facet_col) {\n    ggplot(restos) +\n        geom_point(aes(x = .data$evaluation, y = .data$places)) +\n        facet_grid(\n            rows = vars({{ facet_row }}),\n            cols = vars({{ facet_col }})\n        )\n}\n\nfacet_points(ville, style)"
  },
  {
    "objectID": "19-programmer-tidyverse.html#aide-mémoire",
    "href": "19-programmer-tidyverse.html#aide-mémoire",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.4 Aide-mémoire",
    "text": "19.4 Aide-mémoire\nOn essaie de récapituler ici les points importants pour pouvoir les retrouver facilement.\n\n\n\n\n\n\nAvertissement\n\n\n\nPremier point important : les spécificités vues ici ne s’appliquent que quand on veut utiliser certaines fonctions du tidyverse (dplyr, tidyr, ggplot2) à l’intérieur d’autres fonctions. Plus spécifiquement, elles sont à prendre en compte quand on souhaite passer en argument d’une fonction des noms de colonnes qui seront utilisées par des fonctions du tidyverse.\nElles ne s’appliquent pas si on passe en arguments d’autres paramètres comme le tableau de données qu’on souhaite utiliser, des valeurs numériques ou des chaînes de caractères qu’on souhaite récupérer telles quelles, etc.\n\n\n\nDans le cas où deux objets du même nom pourraient exister à la fois comme colonne de notre tableau de données (objet data) et comme objet de notre environnement (objet env), on peut expliciter lequel on souhaite utiliser avec les pronoms .data$var et .env$var\nSi un argument est une colonne passée sous la forme d’un symbole (var), on doit l’encadrer de l’opérateur curly curly.\n\n\nsummarise_col &lt;- function(df, col) {\n    df %&gt;% summarise(moyenne = mean({{ col }}, na.rm = TRUE))\n}\n\nsummarise_col(starwars, height)\n\n\nSi un argument est un nom de colonne passé sous la forme d’une chaîne de caractères (\"var\"), on y accède avec le pronom .data :\n\n\nsummarise_col &lt;- function(df, col_name) {\n    df %&gt;% summarise(moyenne = mean(.data[[col_name]], na.rm = TRUE))\n}\n\nsummarise_col(starwars, \"height\")\n\n\nSi on utilise la tidy selection dans un select(), un across() ou une autre fonction, on l’encadre de l’opérateur curly curly :\n\n\nselect_cols &lt;- function(df, cols) {\n    df %&gt;% select({{ cols }})\n}\n\nselect_cols(starwars, !where(is.list))\n\n\nSi on indique les noms de plusieurs colonnes sous la forme d’un vecteur de chaînes de caractères pour utilisation dans un select(), un across() ou une autre fonction acceptant la tidy selection, on utilise all_of() ou any_of() :\n\n\nselect_cols &lt;- function(df, col_names) {\n    df %&gt;% select(all_of(col_names))\n}\n\nselect_cols(starwars, c(\"height\", \"mass\"))\n\n\nSi on souhaite créer une nouvelle colonne à partir de la valeur d’un argument, on l’utilise sous la forme d’une chaîne de caractères avec l’opérateur walrus :=. Si l’argument est un symbole on l’entoure avec {{ }}, si c’est une chaîne de caractères on l’entoure avec {} :\n\n\nadd_mean_by_species &lt;- function(col_var) {\n    starwars %&gt;%\n        group_by(species) %&gt;%\n        mutate(\"moyenne_{{col_var}}\" := mean({{ col_var}}))\n}\n\nadd_mean_by_species(height)\n\nLe schéma suivant récapitule les points précédents :"
  },
  {
    "objectID": "19-programmer-tidyverse.html#ressources",
    "href": "19-programmer-tidyverse.html#ressources",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.5 Ressources",
    "text": "19.5 Ressources\nPour plus de détails sur la programmation avec les fonctions de dplyr, on pourra se reporter à la vignette Programming with dplyr.\nPour l’utilisation de ggplot2 dans des fonctions, on trouvera plus de détails dans la vignette Using ggplot2 in packages.\nLes mécanismes d’évaluation et de métaprogrammation propres aux packages du tidyverse sont implémentés en grande partie dans le package rlang.\nEnfin, pour une présentation approfondie des possibilités de métaprogrammation dans R en général, on pourra consulter le chapitre Metaprogramming de l’ouvrage en ligne Advanced R."
  },
  {
    "objectID": "19-programmer-tidyverse.html#exercices",
    "href": "19-programmer-tidyverse.html#exercices",
    "title": "19  Programmer avec le tidyverse",
    "section": "19.6 Exercices",
    "text": "19.6 Exercices\n\n19.6.1 dplyr et tidyr\nExercice 1.1\nCréer une fonction my_table qui prend en arguments un tableau de données df et une variable var et qui renvoie le résultat de count() sur cette variable.\nVérifier avec :\n\nmy_table(starwars, gender)\n#&gt; # A tibble: 3 × 2\n#&gt;   gender        n\n#&gt;   &lt;chr&gt;     &lt;int&gt;\n#&gt; 1 feminine     17\n#&gt; 2 masculine    66\n#&gt; 3 &lt;NA&gt;          4\n\n\n\nmy_table &lt;- function(df, var) {\n    df %&gt;% count({{ var }})\n}\n\n\nModifier my_table pour qu’elle accepte trois arguments df, var1 et var2, et qu’elle retourne le résultat du count appliqué à var1 et à var2.\n\nmy_table(starwars, gender, sex)\n#&gt; # A tibble: 6 × 3\n#&gt;   gender    sex                n\n#&gt;   &lt;chr&gt;     &lt;chr&gt;          &lt;int&gt;\n#&gt; 1 feminine  female            16\n#&gt; 2 feminine  none               1\n#&gt; 3 masculine hermaphroditic     1\n#&gt; 4 masculine male              60\n#&gt; 5 masculine none               5\n#&gt; 6 &lt;NA&gt;      &lt;NA&gt;               4\n\n\n\nmy_table &lt;- function(df, var1, var2) {\n    df %&gt;% count({{ var1 }}, {{ var2 }})\n}\n\n\nModifier my_table pour qu’elle accepte deux arguments df et vars, et qu’elle applique le count à toutes les variables indiquées dans vars en utilisant la tidy selection.\n\nmy_table(starwars, c(gender, sex))\n#&gt; # A tibble: 6 × 3\n#&gt;   gender    sex                n\n#&gt;   &lt;chr&gt;     &lt;chr&gt;          &lt;int&gt;\n#&gt; 1 feminine  female            16\n#&gt; 2 feminine  none               1\n#&gt; 3 masculine hermaphroditic     1\n#&gt; 4 masculine male              60\n#&gt; 5 masculine none               5\n#&gt; 6 &lt;NA&gt;      &lt;NA&gt;               4\n\n\n\nmy_table &lt;- function(df, vars) {\n    df %&gt;%\n        count(across({{ vars }}))\n}\n\n\nExercice 1.2\nLe code suivant ajoute une nouvelle colonne diff_height au tableau starwars, qui contient la différence entre la valeur de height et sa moyenne selon les valeurs de species.\n\nstarwars %&gt;%\n    group_by(species) %&gt;%\n    mutate(diff_height = height - mean(height, na.rm = TRUE))\n\nEn utilisant ce code, créer une fonction diff_mean_height qui accepte un seul argument by et qui ajoute à starwars une colonne diff_height calculée de la même manière, mais en appliquant le group_by au by passé en paramètre.\n\n\ndiff_mean_height &lt;- function(by) {\n    starwars %&gt;%\n        group_by({{ by }}) %&gt;%\n        mutate(diff_height = height - mean(height, na.rm = TRUE))\n}\n\n\nModifier la fonction précédente en une nouvelle fonction diff_mean, qui prend deux arguments by et var, et qui applique la même transformation non pas à height mais à la variable passée dans var.\n\n\ndiff_mean &lt;- function(by, var) {\n    starwars %&gt;%\n        group_by({{ by }}) %&gt;%\n        mutate(diff_mean = {{ var }} - mean({{ var }}, na.rm = TRUE))\n}\n\n\nModifier la fonction pour que le nom de la colonne ajoutée ne soit pas diff_mean mais le nom de la variable passée dans var suivi du suffixe “_diff_mean”.\n\n\ndiff_mean &lt;- function(by, var) {\n    starwars %&gt;%\n        group_by({{ by }}) %&gt;%\n        mutate(\"{{var}}_diff_mean\" := {{ var }} - mean({{ var }}, na.rm = TRUE))\n}\n\n\nModifier à nouveau diff_mean pour pouvoir passer à by plusieurs variables en utilisant la tidy selection.\n\n\ndiff_mean &lt;- function(by, var) {\n    starwars %&gt;%\n        group_by(across({{ by }})) %&gt;%\n        mutate(\"{{var}}_diff_mean\" := {{ var }} - mean({{ var }}, na.rm = TRUE))\n}\n\n\nExercice 1.3\nLa fonction unnest() de tidyr permet de transformer une colonne contenant des valeurs de type liste en colonne “normale” en dupliquant les lignes autant de fois qu’il y a d’éléments dans chaque liste :\n\nstarwars %&gt;% \n    unnest(films) %&gt;%\n    select(name, films)\n#&gt; # A tibble: 173 × 2\n#&gt;    name           films                  \n#&gt;    &lt;chr&gt;          &lt;chr&gt;                  \n#&gt;  1 Luke Skywalker The Empire Strikes Back\n#&gt;  2 Luke Skywalker Revenge of the Sith    \n#&gt;  3 Luke Skywalker Return of the Jedi     \n#&gt;  4 Luke Skywalker A New Hope             \n#&gt;  5 Luke Skywalker The Force Awakens      \n#&gt;  6 C-3PO          The Empire Strikes Back\n#&gt;  7 C-3PO          Attack of the Clones   \n#&gt;  8 C-3PO          The Phantom Menace     \n#&gt;  9 C-3PO          Revenge of the Sith    \n#&gt; 10 C-3PO          Return of the Jedi     \n#&gt; # … with 163 more rows\n\nCréer une fonction freq_liste() qui prend en entrée un argument var et retourne grâce à count le tri à plat de toutes les valeurs de la variable correspondant à var dans starwars, même si cette variable contient des listes.\n\nfreq_liste(films)\n#&gt; # A tibble: 7 × 2\n#&gt;   films                       n\n#&gt;   &lt;chr&gt;                   &lt;int&gt;\n#&gt; 1 A New Hope                 18\n#&gt; 2 Attack of the Clones       40\n#&gt; 3 Return of the Jedi         20\n#&gt; 4 Revenge of the Sith        34\n#&gt; 5 The Empire Strikes Back    16\n#&gt; 6 The Force Awakens          11\n#&gt; 7 The Phantom Menace         34\n\n\n\nfreq_liste &lt;- function(var) {\n    starwars %&gt;%\n        unnest({{ var }}) %&gt;%\n        count({{ var }})\n}\n\n\n\n\n19.6.2 Noms de colonnes en chaînes de caractères\nExercice 2.1\nLa fonction readline() permet de lire une chaîne de caractères entrée au clavier par l’utilisateur :\n\nv &lt;- readline(\"Votre choix : \")\n\nCréer une fonction affiche_planete qui affiche le message “Nom de la planète”, lit la réponse de l’utilisateur, et affiche à l’aide d’un filter() les lignes du tableau starwars pour lesquelles la variable homeworld correspond au nom saisi.\n\n\naffiche_planete &lt;- function() {\n    var &lt;- readline(\"Nom de la planète : \")\n    starwars %&gt;% filter(homeworld == var)\n}\n\n\nCréer une fonction affiche_barplot qui affiche le message “Nom de la variable”, lit la réponse de l’utilisateur, et affiche avec ggplot2 le diagramme en barres de la variable correspondante du tableau starwars.\n\n\naffiche_barplot &lt;- function() {\n    var &lt;- readline(\"Nom de la variable : \")\n    ggplot(starwars) +\n        geom_bar(aes(x = .data[[var]]))\n}\n\n\nCréer une fonction affiche_colonnes qui affiche le message “Noms des variables séparés par des virgules”, lit la réponse de l’utilisateur, et affiche uniquement les colonnes saisies du tableau starwars.\nConseil : pour récupérer un vecteur de colonnes à partir de la saisie de l’utilisateur, on pourra utiliser les fonctions str_split() et str_trim() de stringr.\n\n\naffiche_colonnes &lt;- function() {\n    vars &lt;- readline(\"Noms des variables séparés par des virgules : \")\n    vars &lt;- str_split(vars, \",\")[[1]]\n    vars &lt;- str_trim(vars)\n    starwars %&gt;% select(all_of(vars))\n}\n\n\n\n\n19.6.3 Ambiguïté data / env\nExercice 3.1\nCréer une fonction filter_height() qui accepte un argument nommé height, et qui retourne les lignes de starwars pour lesquelles les valeurs de la variable height sont supérieures à celles de l’argument height. Créer cette fonction sans utiliser dplyr mais avec l’opérateur [,].\n\nfilter_height(200)\n#&gt; # A tibble: 16 × 14\n#&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n#&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  \n#&gt;  1 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n#&gt;  2 Chewbacca      228   112 brown   unknown blue      200   male  mascu… Kashyy…\n#&gt;  3 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt;  4 Roos Tarpa…    224    82 none    grey    orange     NA   male  mascu… Naboo  \n#&gt;  5 Rugor Nass     206    NA none    green   orange     NA   male  mascu… Naboo  \n#&gt;  6 Yarael Poof    264    NA none    white   yellow     NA   male  mascu… Quermia\n#&gt;  7 Lama Su        229    88 none    grey    black      NA   male  mascu… Kamino \n#&gt;  8 Taun We        213    NA none    grey    black      NA   fema… femin… Kamino \n#&gt;  9 Grievous       216   159 none    brown,… green,…    NA   male  mascu… Kalee  \n#&gt; 10 Tarfful        234   136 brown   brown   blue       NA   male  mascu… Kashyy…\n#&gt; 11 Tion Medon     206    80 none    grey    black      NA   male  mascu… Utapau \n#&gt; 12 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt; 13 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt; 14 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt; 15 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt; 16 &lt;NA&gt;            NA    NA &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;       NA   &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   \n#&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,\n#&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\n\nfilter_height &lt;- function(height) {\n    starwars[starwars$height &gt; height, ]\n}\n\n\nAméliorer la fonction pour qu’elle ne retourne pas les lignes pour lesquelles la variable correspondant à height_var vaut NA.\n\nfilter_height(200)\n#&gt; # A tibble: 10 × 14\n#&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n#&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  \n#&gt;  1 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n#&gt;  2 Chewbacca      228   112 brown   unknown blue      200   male  mascu… Kashyy…\n#&gt;  3 Roos Tarpa…    224    82 none    grey    orange     NA   male  mascu… Naboo  \n#&gt;  4 Rugor Nass     206    NA none    green   orange     NA   male  mascu… Naboo  \n#&gt;  5 Yarael Poof    264    NA none    white   yellow     NA   male  mascu… Quermia\n#&gt;  6 Lama Su        229    88 none    grey    black      NA   male  mascu… Kamino \n#&gt;  7 Taun We        213    NA none    grey    black      NA   fema… femin… Kamino \n#&gt;  8 Grievous       216   159 none    brown,… green,…    NA   male  mascu… Kalee  \n#&gt;  9 Tarfful        234   136 brown   brown   blue       NA   male  mascu… Kashyy…\n#&gt; 10 Tion Medon     206    80 none    grey    black      NA   male  mascu… Utapau \n#&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,\n#&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\n\nfilter_height &lt;- function(height) {\n    starwars[starwars$height &gt; height & !is.na(starwars$height), ]\n}\n\n\nÉcrire la même fonction, cette fois en utilisant filter() à la place de [,].\n\n\nfilter_height &lt;- function(height) {\n    starwars %&gt;%\n        filter(.data$height &gt; .env$height)\n}\n\n\nQuels sont les avantages et inconvénients des deux méthodes ?\n\nLa fonction utilisant filter() est plus compacte et plus lisible, et elle gère les NA de la manière attendue sans condition supplémentaire.\nLa fonction utilisant [,] évite l’ambiguïté liée à la présence simultanée d’un argument height et d’une colonne height.\n\n\n\n19.6.4 ggplot2\nExercice 4.1\nCréer une fonction graph_bar qui prend en argument un tableau de données df et une variable var et qui retourne le diagramme en barre de la variable correspondante généré avec ggplot2.\n\ngraph_bar(starwars, gender)\n\n\n\n\n\n\ngraph_bar &lt;- function(df, var) {\n    ggplot(df) +\n        geom_bar(aes(x = {{ var }}))\n}\n\n\nModifier la fonction graph_bar pour qu’elle accepte un troisième argument nommé facet_var et qu’elle retourne le diagramme en barre de var pour chaque valeur de facet_var.\n\ngraph_bar(starwars, sex, gender)\n\n\n\n\n\n\ngraph_bar &lt;- function(df, var, facet_var) {\n    ggplot(df) +\n        geom_bar(aes(x = {{ var }})) +\n        facet_wrap(vars({{ facet_var }}))\n}\n\n\nExercice 4.2\nCréer une fonction graph_points qui prend en arguments un tableau de données et deux variables, et affiche le nuage de points de ces deux variables généré avec ggplot2.\n\ngraph_points(starwars, height, mass)\n#&gt; Warning: Removed 28 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngraph_points &lt;- function(df, var_x, var_y) {\n    ggplot(df) +\n        geom_point(aes(x = {{var_x}}, y = {{var_y}}))\n}\n\n\nAjouter un quatrième argument color à la fonction graph_points(), qui permet de spécifier la couleur des points (la même couleur pour tous).\n\ngraph_points(starwars, height, mass, color = \"red\")\n#&gt; Warning: Removed 28 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngraph_points &lt;- function(df, var_x, var_y, color) {\n    ggplot(df) +\n        geom_point(aes(x = {{var_x}}, y = {{var_y}}), color = color)\n}\n\n\nModifier graph_points() pour que l’argument color corresponde non pas à une couleur fixe mais à une variable dont les valeurs déterminent la couleur des points.\n\ngraph_points(starwars, height, mass, color = sex)\n#&gt; Warning: Removed 28 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngraph_points &lt;- function(df, var_x, var_y, color) {\n    ggplot(df) +\n        geom_point(aes(x = {{var_x}}, y = {{var_y}}, color = {{color}}))\n}\n\n\nFacultatif : modifier graph_points() pour que l’argument color puisse accepter aussi bien une variable qu’une couleur fixe.\nIndication : en s’aidant du résultat de la fonction suivante, on pourra tester si la valeur passée à color est bien une colonne du tableau de données.\n\nf &lt;- function(x) {\n    deparse(substitute(x))\n}\nf(igloo)\n#&gt; [1] \"igloo\"\n\n\n\ngraph_points &lt;- function(df, var_x, var_y, color) {\n    color_value &lt;- deparse(substitute(color))\n    g &lt;- ggplot(df)\n    if (color_value %in% names(df)) {\n        g &lt;- g +\n            geom_point(aes(x = {{var_x}}, y = {{var_y}}, color = {{color}}))\n    } else {\n        g &lt;- g +\n            geom_point(aes(x = {{var_x}}, y = {{var_y}}), color = color)\n    }\n    g\n}"
  },
  {
    "objectID": "19-programmer-tidyverse.html#footnotes",
    "href": "19-programmer-tidyverse.html#footnotes",
    "title": "19  Programmer avec le tidyverse",
    "section": "",
    "text": "Effectivement, un salon de coiffure s’est à nouveau glissé dans ce jeu de données.↩︎"
  },
  {
    "objectID": "20-debuggage-performance.html#débugguer-une-fonction",
    "href": "20-debuggage-performance.html#débugguer-une-fonction",
    "title": "20  Débuggage et performance",
    "section": "20.1 Débugguer une fonction",
    "text": "20.1 Débugguer une fonction\nLorsqu’on commence à écrire des fonctions un peu complexes, avec des if, des for, et autres joyeusetés, arrive forcément un moment où ça ne fonctionne pas comme on le souhaiterait et où on ne comprend pas pourquoi. Bref, il y a un bug.\nTrouver la cause d’un bug n’est pas toujours évident, mais il existe plusieurs méthodes et outils permettant de faciliter un peu les choses.\nOn commence par charger les extensions et les jeux de données dont on aura besoin par la suite.\n\nlibrary(tidyverse)\nlibrary(questionr)\ndata(hdv2003)\ndata(rp2018)\ndata(starwars)\n\n\n20.1.1 print()\nL’outil le plus simple, rudimentaire et parfois décrié mais qui reste efficace, est de rajouter un print() dans le code de notre fonction pour examiner le contenu d’un objet à un moment donné.\nPrenons un exemple. La fonction suivante prend en argument un tableau de données df et un nom de variable var, et retourne la moyenne et l’écart-type de cette variable.\n\nindicateurs &lt;- function(df, var) {\n    valeurs &lt;- df[, var]\n    if (!is.numeric(valeurs)) return(NA)\n    list(\n        moyenne = mean(valeurs, na.rm = TRUE),\n        sd = sd(valeurs, na.rm = TRUE)\n    )\n}\n\nOn teste notre fonction sur une variable du jeu de données hdv2003. Tout semble fonctionner.\n\nindicateurs(hdv2003, \"age\")\n#&gt; $moyenne\n#&gt; [1] 48.157\n#&gt; \n#&gt; $sd\n#&gt; [1] 16.94181\n\nOn teste à nouveau, cette fois sur une variable du jeu de données starwars de dplyr.\n\nindicateurs(starwars, \"height\")\n#&gt; [1] NA\n\nSapristi, on obtient NA en résultat alors que notre variable height est bien numérique : on devrait donc obtenir la moyenne et l’écart-type. Comment expliquer ce résultat ?\nComme on n’a pas d’explication immédiate juste en relisant le code de notre fonction, on va ajouter temporairement une instruction print() qui va afficher le contenu de valeurs juste après qu’elle soit calculée.\n\nindicateurs &lt;- function(df, var) {\n    valeurs &lt;- df[, var]\n    print(valeurs)\n    if (!is.numeric(valeurs)) return(NA)\n    list(\n        moyenne = mean(valeurs, na.rm = TRUE),\n        sd = sd(valeurs, na.rm = TRUE)\n    )\n}\n\nOn lance cette fonction modifiée sur starwars :\n\nindicateurs(starwars, \"height\")\n#&gt; # A tibble: 87 × 1\n#&gt;    height\n#&gt;     &lt;int&gt;\n#&gt;  1    172\n#&gt;  2    167\n#&gt;  3     96\n#&gt;  4    202\n#&gt;  5    150\n#&gt;  6    178\n#&gt;  7    165\n#&gt;  8     97\n#&gt;  9    183\n#&gt; 10    182\n#&gt; # … with 77 more rows\n#&gt; [1] NA\n\nLe print() nous indique que valeurs n’est pas un vecteur mais un tableau de données à une seule colonne. Or dans ce cas, le test is.numeric, qui est sensé s’appliquer à un vecteur atomique, renvoie FALSE.\n\nis.numeric(starwars[, \"height\"])\n#&gt; [1] FALSE\n\nC’est donc la raison pour laquelle on obtient NA comme résultat.\nCertes, mais alors pourquoi cela fonctionne-t-il dans notre exemple avec hdv2003 ?\n\nindicateurs(hdv2003, \"age\")\n#&gt;   [1] 28 23 59 34 71 35 60 47 20 28 65 47 63 67 76 49 62 20 70 39 30 30 37 79 20\n#&gt;  [26] 74 31 35 35 30 54 29 49 59 41 41 53 19 77 56 54 35 40 62 68 77 39 57 43 34\n#&gt;  [51] 60 41 54 23 26 23 74 60 23 57 55 71 39 56 54 27 40 42 44 41 30 48 59 46 33\n#&gt;  [76] 70 67 75 22 51 41 53 70 79 31 34 72 59 63 77 48 25 62 23 66 90 43 32 54 19\n#&gt; [101] 61 57 54 31 33 86 84 74 49 47 25 52 71 56 58 66 70 51 54 73 35 64 51 68 42\n#&gt; [126] 49 55 49 60 71 75 36 78 19 23 81 41 58 37 49 55 51 58 29 47 78 31 55 42 35\n#&gt; [151] 50 78 56 40 35 46 50 69 73 32 38 18 43 62 35 28 51 65 47 66 48 27 71 38 61\n#&gt; [176] 39 69 79 57 64 59 47 24 54 50 32 60 57 50 23 48 49 70 27 52 19 54 45 64 71\n#&gt;  [ reached getOption(\"max.print\") -- omitted 1800 entries ]\n#&gt; $moyenne\n#&gt; [1] 48.157\n#&gt; \n#&gt; $sd\n#&gt; [1] 16.94181\n\nAh ! Dans ce cas là valeurs est bien un vecteur, et on obtient donc le résultat attendu. Pourquoi cette différence ? On est en fait tombé sur une différence de comportement entre les data frames et les tibbles, mentionnée Section 16.3.3 : lorsqu’on sélectionne une seule colonne avec l’opérateur [,], un data frame retourne un vecteur tandis qu’un tibble retourne un tableau à une colonne. Or, ici, hdv2003 est un data frame, et starwars un tibble.\nComment résoudre ce problème ? Il y a différentes manières, mais la plus simple est sans doute de remplacer [,] par [[]], qui lui a le même comportement dans les deux cas. On peut donc modifier notre fonction (en n’oubliant pas d’enlever le print()) et vérifier que ça fonctionne désormais.\n\nindicateurs &lt;- function(df, var) {\n    valeurs &lt;- df[[var]]\n    if (!is.numeric(valeurs)) return(NA)\n    list(\n        moyenne = mean(valeurs, na.rm = TRUE),\n        sd = sd(valeurs, na.rm = TRUE)\n    )\n}\n\nindicateurs(hdv2003, \"age\")\n#&gt; $moyenne\n#&gt; [1] 48.157\n#&gt; \n#&gt; $sd\n#&gt; [1] 16.94181\nindicateurs(starwars, \"height\")\n#&gt; $moyenne\n#&gt; [1] 174.358\n#&gt; \n#&gt; $sd\n#&gt; [1] 34.77043\n\n\n\n\n\n\n\nAvertissement\n\n\n\nQuand on ajoute des print() pour essayer d’identifier un problème, il faut bien penser à les supprimer une fois ce problème résolu, sinon on risque de se retrouver avec des messages “parasites” dans la console.\n\n\n\n\n20.1.2 Localiser une erreur\nprint() peut aussi être utile pour savoir à quel moment une erreur se produit, notamment lorsqu’on utilise une boucle.\nDans l’exemple suivant, on crée une fonction min_freq_values() qui prend en argument un tableau de données df et un effectif n_min et retourne une liste des modalités de variables qui apparaissent dans au moins n_min lignes de df (on utilise ici une boucle for, mais on aurait aussi pu utiliser map()).\n\nmin_freq_values &lt;- function(df, n_min) {\n    res &lt;- list()\n    for (col in names(df)) {\n        # Tri à plat des valeurs de la colonne\n        freq &lt;- table(df[[col]])\n        # On conserve les modalités avec effectif &gt;= n\n        freq &lt;- freq[freq &gt;= n_min]\n        # On ajoute la colonne au résultat s'il y a au moins une modalité\n        if (length(freq) &gt; 0) res[[col]] &lt;- freq\n    }\n    res\n}\n\nSi on applique min_freq_values() à hdv2003 avec une valeur de n à 1500, on obtient toutes les modalités correspondant à au moins 1500 observations.\n\nmin_freq_values(hdv2003, 1500)\n#&gt; $hard.rock\n#&gt;  Non \n#&gt; 1986 \n#&gt; \n#&gt; $lecture.bd\n#&gt;  Non \n#&gt; 1953 \n#&gt; \n#&gt; $peche.chasse\n#&gt;  Non \n#&gt; 1776\n\nEssayons maintenant d’appliquer min_freq_values() au jeu de données starwars de dplyr.\n\nmin_freq_values(starwars, 50)\n#&gt; Error in table(df[[col]]): all arguments must have the same length\n\nOn obtient un message quelque peu sybillin : apparemment une erreur se produit au moment de faire le tri à plat des valeurs avec table(). Mais comme ce tri à plat s’effectue dans une boucle, on ne sait pas quelle variable de starwars est à l’origine du problème.\nOn va donc rajouter un print(col) comme première instruction de la boucle for.\n\nmin_freq_values &lt;- function(df, n_min) {\n    res &lt;- list()\n    for (col in names(df)) {\n        print(col)\n        # Tri à plat des valeurs de la colonne\n        freq &lt;- table(df[[col]])\n        # On conserve les modalités avec effectif &gt;= n\n        freq &lt;- freq[freq &gt;= n_min]\n        # On ajoute la colonne au résultat s'il y a au moins une modalité\n        if (length(freq) &gt; 0) res[[col]] &lt;- freq\n    }\n    res\n}\n\nmin_freq_values(starwars, 50)\n#&gt; [1] \"name\"\n#&gt; [1] \"height\"\n#&gt; [1] \"mass\"\n#&gt; [1] \"hair_color\"\n#&gt; [1] \"skin_color\"\n#&gt; [1] \"eye_color\"\n#&gt; [1] \"birth_year\"\n#&gt; [1] \"sex\"\n#&gt; [1] \"gender\"\n#&gt; [1] \"homeworld\"\n#&gt; [1] \"species\"\n#&gt; [1] \"films\"\n#&gt; Error in table(df[[col]]): all arguments must have the same length\n\nCe print(col) nous permet de voir que tout se passe bien pour les premières variables du tableau, et que l’erreur survient au moment de traiter la variable films. On regarde donc à quoi ressemble cette variable.\n\nhead(starwars$films, 3)\n#&gt; [[1]]\n#&gt; [1] \"The Empire Strikes Back\" \"Revenge of the Sith\"    \n#&gt; [3] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; [5] \"The Force Awakens\"      \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"The Empire Strikes Back\" \"Attack of the Clones\"   \n#&gt; [3] \"The Phantom Menace\"      \"Revenge of the Sith\"    \n#&gt; [5] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"The Empire Strikes Back\" \"Attack of the Clones\"   \n#&gt; [3] \"The Phantom Menace\"      \"Revenge of the Sith\"    \n#&gt; [5] \"Return of the Jedi\"      \"A New Hope\"             \n#&gt; [7] \"The Force Awakens\"\n\nDamn, cette variable n’est pas un vecteur atomique mais une liste ! Un tableau de données peut en effet contenir ce que l’on appelle des colonnes-listes. Comme ça n’est pas courant, on ne l’avait clairement pas prévu au moment de la création de la fonction.\nOn a désormais identifié le problème, on peut donc le corriger par exemple en ignorant les colonnes de type liste. Pour cela on utilise is.list() et l’instruction next.\n\nmin_freq_values &lt;- function(df, n_min) {\n    res &lt;- list()\n    for (col in names(df)) {\n        # On passe à la colonne suivante si la colonne est une colonne-liste\n        if (is.list(df[[col]])) next\n        # Tri à plat des valeurs de la colonne\n        freq &lt;- table(df[[col]])\n        # On conserve les modalités avec effectif &gt;= n\n        freq &lt;- freq[freq &gt;= n_min]\n        # On ajoute la colonne au résultat s'il y a au moins une modalité\n        if (length(freq) &gt; 0) res[[col]] &lt;- freq\n    }\n    res\n}\n\nmin_freq_values(starwars, 50)\n#&gt; $sex\n#&gt; male \n#&gt;   60 \n#&gt; \n#&gt; $gender\n#&gt; masculine \n#&gt;        66\n\nÇa fonctionne ! Et cela nous permet de repérer au passage une “légère” sur-représentation des personnages masculins…\n\n\n20.1.3 browser()\nIl existe des alternatives à print() plus efficaces pour identifier et résoudre des bugs. La plus utilisée est la fonction browser() : celle-ci peut s’insérer à n’importe quel endroit du code, et lorsqu’elle est rencontrée par R celui-ci s’interrompt et affiche une invite de commande permettant notamment d’inspecter des objets.\nOn reprend l’exemple précédent en remplaçant le print(col) que nous avions inséré pour débugguer la fonction min_freq_values par un appel à browser().\n\nmin_freq_values &lt;- function(df, n_min) {\n    res &lt;- list()\n    for (col in names(df)) {\n        browser()\n        # Tri à plat des valeurs de la colonne\n        freq &lt;- table(df[[col]])\n        # On conserve les modalités avec effectif &gt;= n\n        freq &lt;- freq[freq &gt;= n_min]\n        # On ajoute la colonne au résultat s'il y a au moins une modalité\n        if (length(freq) &gt; 0) res[[col]] &lt;- freq\n    }\n    res\n}\n\nmin_freq_values(starwars, 50)\n\nLorsqu’on lance ce code, R s’interrompt et affiche l’invite de commande suivant :\nCalled from: min_freq_values(starwars, 50)\n\nBrowse[1]&gt;\nCette invite de commande offre plusieurs possibilités. La première est d’indiquer du code R qui sera exécuté dans le contexte au moment de l’interruption : si on indique un nom d’objet, on pourra donc afficher sa valeur. Ainsi, si on tape col, R nous affiche la valeur actuelle de col, donc au moment de la première itération de la boucle.\nBrowse[1]&gt; col                                       \n[1] \"name\"\nOn peut également fournir des commandes spécifiques : si on tape n, R va passer à l’instruction suivante puis s’interrompre à nouveau1.\nBrowse[1]&gt; n                                           \ndebug à #6 : freq &lt;- table(df[[col]])\nSi on tape c, R va relancer l’exécution jusqu’à la fin, ou jusqu’à la prochaine rencontre d’un browser(). Dans notre cas, cela signifie qu’on va continuer jusqu’au browser() de la deuxième itération de la boucle.\nBrowse[2]&gt; c                                           \nCalled from: min_freq_values(starwars, 50)\n\nBrowse[1]&gt; col                                         \n[1] \"height\"\nSi on souhaite sortir de cette invite de commande et tout interrompre, il suffit de taper Q.\nbrowser() est donc un peu plus complexe à utiliser que des print() ajoutés manuellement, mais c’est aussi un outil plus souple et plus puissant.\n\n\n\n\n\n\nNote\n\n\n\nCette section n’offre qu’un petit aperçu des possibilités de débuggage. R propose d’autres fonctionnalités, et les environnements de développement comme RStudio ou Visual Studio Code proposent également leurs propres outils.\nPour plus d’informations on pourra se reporter aux ressources en fin de chapitre."
  },
  {
    "objectID": "20-debuggage-performance.html#benchmarking-mesurer-et-comparer-les-temps-dexécution",
    "href": "20-debuggage-performance.html#benchmarking-mesurer-et-comparer-les-temps-dexécution",
    "title": "20  Débuggage et performance",
    "section": "20.2 benchmarking : mesurer et comparer les temps d’exécution",
    "text": "20.2 benchmarking : mesurer et comparer les temps d’exécution\nLorsqu’on commence à créer ses propres fonctions et de manière générale à écrire du code de plus en plus complexe ou à travailler sur des données de plus en plus volumineuses, on peut arriver sur des problèmes de performance : les temps d’exécution deviennent longs et on aimerait essayer de les optimiser.\nIl est alors parfois utile de faire du benchmarking, c’est-à-dire comparer plusieurs manières différentes de faire la même chose en mesurant leurs différences de vitesse d’exécution.\nL’intruction la plus simple pour cela est sans doute system.time(). Celle-ci prend en argument une expression R, et affiche en retour le temps d’exécution en secondes.\n\nsystem.time(runif(1000000))\n#&gt;    user  system elapsed \n#&gt;   0.035   0.000   0.034\n\nL’expression peut comporter plusieurs instructions, dans ce cas on les entoure d’accolades.\n\nsystem.time({\n    v &lt;- runif(1000000)\n    moy &lt;- mean(v)\n})\n#&gt;    user  system elapsed \n#&gt;   0.035   0.004   0.039\n\nsystem.time() est cependant très limitée : on ne peut exécuter qu’une expression à la fois, on ne peut donc pas en comparer plusieurs directement, et surtout le temps d’exécution peut varier assez sensiblement selon l’utilisation du processeur de la machine au moment où on lance la commande.\nIl existe donc en complément plusieurs extensions dédiées au benchmarking. On va utiliser ici l’extension bench, installable avec :\n\ninstall.packages(\"bench\")\n\nbench propose une fonction principale, nommée mark(), qu’on peut donc appeler directement avec bench::mark()2. On passe à cette fonction plusieurs expressions, et bench::mark() va effectuer les actions suivante :\n\nelle vérifie que les expressions retournent bien le même résultat (si on souhaite comparer des expressions qui renvoient des résultats différents, il faut ajouter l’argument check = FALSE)\nelle lance chacune de ces expressions plusieurs fois et mesure à chaque fois leur temps d’exécution\nelle affiche un résumé de ces temps d’exécution en indiquant notamment leur minimum et leur médiane\n\nExécuter chaque expression plusieurs fois permet de prendre en compte les fluctuations liées à l’activité du processeur de la machine. Par défaut, bench::mark() exécute chaque instruction au minimum une fois et au moins suffisamment de fois pour atteindre 0,5s d’exécution (ces valeurs peuvent être modifiées via les paramètres min_iterations et min_time).\nDans l’exemple suivant, on crée deux fonctions qui font la même chose : ajouter 10 à tous les éléments d’un vecteur passé en argument. Dans la première fonction plus10_for on utilise une boucle for qui ajoute 10 à tous les éléments l’un après l’autre (ce qu’il ne faut évidemment pas faire !), tandis que la deuxième fonction plus10_vec utilise la forme vectorisée x + 10.\n\nplus10_for &lt;- function(x) {\n    for (i in seq_along(x)) {\n        x[i] &lt;- x[i] + 10\n    }\n    x\n}\n\nplus10_vec &lt;- function(x) {\n    x + 10\n}\n\nOn lance un benchmark avec bench::mark() et on stocke le résultat dans un objet.\n\nx &lt;- 1:10000\nbnch &lt;- bench::mark(\n    plus10_for(x),\n    plus10_vec(x)\n)\n\nOn affiche les résultats obtenus :\n\nbnch\n#&gt; # A tibble: 2 × 6\n#&gt;   expression         min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 plus10_for(x)  700.7µs  757.2µs     1224.    97.5KB     2.03\n#&gt; 2 plus10_vec(x)   18.1µs   20.4µs    44277.   117.3KB    88.7\n\nLa colonne la plus importante est sans doute la colonne median, qui affiche le temps médian d’exécution des deux expressions. Attention, l’unité de temps n’est pas forcément la même, ici l’exécution de plus10_for est affichée en millisecondes (“ms”), tandis que celle de plus10_vec l’est en microsecondes (“µs”) donc avec une unité mille fois plus petite.\nSi on préfère, on peut afficher les performances relatives des deux fonctions avec :\n\nsummary(bnch, relative = TRUE)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;    &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 plus10_for(x)  38.7   37.1       1        1         1  \n#&gt; 2 plus10_vec(x)   1      1        36.2      1.20     43.8\n\nCes résultats nous permettent de voir que la version vec est très nettement plus rapide que la version for ! Ce qui confirme le fait qu’il faut toujours prioriser l’utilisation de fonctions vectorisées lorsqu’elles existent.\nOn prend un second exemple : on souhaite mesurer si l’utilisation de map est plus rapide ou non qu’une boucle for pour une tâche équivalente.\nPour cela on commence par créer artificiellement une liste de 200 tableaux de données en dupliquant 100 fois une liste composée des tableaux rp2018 et hdv2003.\n\ndfs &lt;- list(rp2018, hdv2003)\ndfs &lt;- rep(dfs, 100)\n\nPuis on lance un benchmark sur une boucle for et un map qui retournent chacun les nombres de ligne des 200 tableaux. Cette-fois on ne crée pas de fonctions : on passe le code directement à bench::mark(), avec des noms permettant de les identifier plus facilement dans les résultats.\n\nbench::mark(\n    boucle_for = {\n        res &lt;- list()\n        for (df in dfs) {\n            res &lt;- c(res, nrow(df))\n        }\n        res\n    },\n    map = map(dfs, ~ nrow(.x) )\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 boucle_for   3.56ms   3.96ms      248.  199.02KB     6.42\n#&gt; 2 map        965.81µs   1.13ms      875.    6.75KB    10.8\n\nLa lecture du résultat indique que le map est environ 4 fois plus rapide que la boucle for.\nAttention cependant en lisant ces résultats : dans la comparaison précédente les temps d’exécution étant en millisecondes, même une différence du type “4 fois plus rapide” peut être quasiment imperceptible. Dans l’exemple suivant on compare de la même manière for et map, mais cette fois en effectuant une action plus coûteuse en temps de calcul (on génère des vecteurs de nombres aléatoires).\n\nbench::mark(\n    boucle_for = {\n        res &lt;- numeric()\n        for (i in 1:100) {\n            res &lt;- c(res, mean(runif(50000)))\n        }\n        res\n    },\n    map = map_dbl(1:100, ~ mean(runif(50000))),\n    check = FALSE\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 boucle_for    208ms    210ms      4.76    38.5MB        0\n#&gt; 2 map           201ms    202ms      4.88    38.4MB        0\n\nDans ce cas la différence entre for et map devient négligeable par rapport aux temps de calcul des opérations effectuées dans les boucles : au final les temps d’exécution sont presque identiques."
  },
  {
    "objectID": "20-debuggage-performance.html#quelques-conseils-doptimisation",
    "href": "20-debuggage-performance.html#quelques-conseils-doptimisation",
    "title": "20  Débuggage et performance",
    "section": "20.3 Quelques conseils d’optimisation",
    "text": "20.3 Quelques conseils d’optimisation\n\n20.3.1 Privilégier les fonctions vectorisées\nOn l’a déjà dit, redit et reredit, une des forces de R est de proposer un grand nombre de fonctions vectorisées, c’est-à-dire prévues et optimisées pour s’appliquer à tous les éléments d’un vecteur. Quand une fonction vectorisée existe, il est donc toujours préférable de l’utiliser plutôt qu’une boucle ou un map.\n\nv &lt;- rep(c(\"Pomme\", \"Poire\", \"Fraise\"), 100)\nbench::mark(\n    boucle = {\n        map_int(v, str_count, \"m\")\n    },\n    vec = str_count(v, \"m\")\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 boucle       7.21ms   7.67ms      126.   112.4KB     4.22\n#&gt; 2 vec          76.9µs   85.3µs    11104.    1.48KB     2.03\n\n\n\n20.3.2 Mettre le minimum d’opérations dans les boucles\nSi vous utilisez une boucle, toute opération qu’elle contient, comme elle va être répétée, peut devenir rapidement très coûteuse. Il ne faut donc y mettre que les opérations réellement nécessaires.\nLa fonction suivante prend en entrée un tableau de données d et une chaîne de caractères chr, et retourne un vecteur nommé indiquant le nombre de fois ou cette valeur apparaît dans chaque colonne du tableau. On a décidé de convertir en minuscules à la fois la valeur de chr et l’ensemble des colonnes du tableau pour que le comptage ne prenne pas en compte les différences de majuscules/minuscules.\n\nnb_chaine1 &lt;- function(d, chr) {\n    res &lt;- numeric()\n    for (var in names(d)) {\n        # Conversion de chr et des colonnes de d en minuscules\n        d &lt;- d %&gt;% modify(str_to_lower)\n        chr &lt;- str_to_lower(chr)\n        # Comptage des occurrences de chr dans la colonne var\n        res[[var]] &lt;- sum(d[[var]] == chr, na.rm = TRUE)\n    }\n    res\n}\n\nd &lt;- hdv2003[, c(\"hard.rock\", \"qualif\", \"clso\", \"bricol\")]\nnb_chaine1(d, \"oui\")\n#&gt; hard.rock    qualif      clso    bricol \n#&gt;        14         0       936       853\n\nÇa fonctionne, mais si on regarde un peu plus attentivement le code de la fonction on peut vite se rendre compte d’un problème : les conversions en minuscules sont faites à l’intérieur de la boucle, et sont donc répétées pour chaque colonne de d. Or ceci n’est absolument pas nécessaire puisque cette conversion ne dépend pas des colonnes et qu’elle peut être faite une seule et unique fois en début de fonction.\nOn décide donc de sortir les conversions en minuscules de la boucle.\n\nnb_chaine2 &lt;- function(d, chr) {\n    res &lt;- numeric()\n\n    # Conversion de chr et des colonnes de d en minuscules\n    d &lt;- d %&gt;% modify(str_to_lower)\n    chr &lt;- str_to_lower(chr)\n\n    for (var in names(d)) {\n        # Comptage des occurrences de chr dans la colonne var\n        res[[var]] &lt;- sum(d[[var]] == chr, na.rm = TRUE)\n    }\n    res\n}\n\nnb_chaine2(d, \"oui\")\n#&gt; hard.rock    qualif      clso    bricol \n#&gt;        14         0       936       853\n\nLe résultat des deux fonctions est identique. On compare leur temps d’exécution à l’aide de bench::mark().\n\nbench::mark(\n    nb_chaine1(d, \"oui\"),\n    nb_chaine2(d, \"oui\"),\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression                min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 nb_chaine1(d, \"oui\")   4.21ms   4.86ms      200.     345KB     2.05\n#&gt; 2 nb_chaine2(d, \"oui\")   1.24ms   1.47ms      656.     157KB     0\n\nCe qui permet de constater que la deuxième version est quatre fois plus rapide (et elle sera d’autant plus rapide que le nombre de colonnes du tableau sera grand).\n\n\n20.3.3 Choisir un format de fichier adapté\nSi on travaille sur des fichiers de données volumineux, les temps de chargement et de sauvegarde des données peuvent devenir importants.\nIl existe différents formats de fichiers qui peuvont être plus ou moins rapides et pratiques selon l’utilisation qu’on en fait. Il n’est malheureusement pas toujours simple de s’y retrouver d’autant que les formats et les performances peuvent évoluer assez rapidement, mais on peut quand même donner quelques indications :\nLe format CSV est pratique pour échanger des données tabulaires d’un système ou d’un logiciel à un autre, mais il présente plusieurs inconvénients :\n\nles fichiers sont volumineux\nles temps de lecture/écriture sont assez longs\nils n’incluent pas de métadonnées comme les types des colonnes, et nécessitent donc des opérations de conversion plus ou moins “risquées”\n\nÀ noter que plusieurs extensions et fonctions existent pour lire et/ou écrire les fichiers CSV. Outre read.csv de R base et read_csv de readr, on pourra mentionner fread de data.table, particulièrement rapide, ou l’extension vroom, qui ne charge pas toutes les informations d’un coup mais y accède “à la demande”.\nLes formats Rdata (utilisé par load() et save()) et RDS (utilisé par readRDS() et saveRDS()), propres à R, permettent de sauvegarder des objets dans un fichier. Ils ont des temps de lecture et d’écriture rapides, et permettent d’enregistrer n’importe quel objet R et d’être sûr de le retrouver à peu près à l’identique. À noter que ces formats permettent de faire varier le niveau de compression des données et donc jouer sur le rapport entre espace disque utilisé et temps d’accès. Ces formats sont intéressants notamment pour enregistrer des résultats intermédiaires. À noter que le format fst, proposé par l’extension du même nom, offre des performances encore supérieures mais ne gère que les données tabulaires.\nPour des données vraiment volumineuses, le package arrow permet la lecture et l’enregistrement dans différents formats, dont arrow et parquet. Très optimisés mais limités aux données tabulaires, ils permettent également des échanges avec d’autres langages de programmation comme Python, JavaScript, etc.\nÀ titre indicatif, le billet a shallow benchmark of R data frame export/import methods propose un comparatif entre les performances de différents formats de fichiers pour des données tabulaires. Attention cependant, il date de 2019 et les performances des fonctions testées ont pu évoluer depuis.\n\n\n20.3.4 Repérer les opérations coûteuses avec du profiling\nQuand on commence à écrire du code un peu long, il n’est pas toujours évident de savoir quelles sont les opérations qui sont les plus coûteuses en termes de performance. Il peut alors être utile d’utiliser un outil de profiling, qui consiste à exécuter du code tout en mesurant les temps d’exécution de chaque instruction, ce qui permet ensuite de visualiser et repérer les opérations qui prennent le plus de temps et qui seraient donc les plus intéressantes à optimiser (si c’est possible).\nL’extension profvis fournit un outil de profiling sous R pratique et utile. On passe des instructions ou un script entier à la fonction profvis(), et celle-ci fournit une visualisation interactive des différentes opérations, de leur temps d’exécution, de leur utilisation de la mémoire…\n\n\n\nExemple de visualisation générée par profvis()\n\n\nL’utilisation de profvis() dépasse le cadre de ce document, mais on pourra trouver des explications (en anglais) dans la partie profiling d’Advanced R.\n\n\n20.3.5 Mettre en cache des résultats intermédiaires\nSelon la taille des données et le type d’opérations réalisées, les temps de calculs même optimisés peuvent demeurer longs. Dans ce cas il peut être intéressant de “mettre en cache” des résultats intermédiaires dans des fichiers pour pouvoir les charger directement sans avoir à tout recalculer.\nPar exemple, si on travaille sur un corpus de données textuelles, on peut enregistrer dans un fichier RDS ou Rdata le résultat de toutes les opérations de prétraitement du corpus : si on souhaite faire des analyses par la suite on aura juste à charger les données depuis ce fichier sans avoir à relancer le calcul de tous les prétraitements.\nL’extension targets, présentée Chapitre 21, est particulièrement adaptée pour les projets de ce type car elle gère automatiquement les dépendances entre les étapes d’un projet et la mise en cache des résultats, et permet ainsi d’optimiser les temps de traitement.\n\n\n20.3.6 Utiliser d’autres extensions\nEnfin, si ce document est basé sur les extensions du tidyverse, qui offrent une syntaxe cohérente et plus facile d’accès, il existe d’autres extensions notamment dans le domaine de la manipulation des données qui permettent des opérations plus rapides.\nC’est en particulier le cas de l’extension data.table, qui utilise une syntaxe moins accessible que celle de dplyr, mais propose des performances en général assez nettement supérieures. On trouvera la documentation détaillée de data.table (en anglais) sur le site de l’extension."
  },
  {
    "objectID": "20-debuggage-performance.html#ressources",
    "href": "20-debuggage-performance.html#ressources",
    "title": "20  Débuggage et performance",
    "section": "20.4 Ressources",
    "text": "20.4 Ressources\nL’ouvrage Advanced R (en anglais) consacre un chapitre entier au debuggage, un autre à la mesure de la performance, et un dernier à différentes techniques d’optimisation du code.\nLe site de RStudio propose une page entière détaillant ses fonctionnalités de debugging (en anglais). Pour les utilisateurs de Visual Studio Code, on pourra se référer à l’extension VSCode-R-Debugger."
  },
  {
    "objectID": "20-debuggage-performance.html#footnotes",
    "href": "20-debuggage-performance.html#footnotes",
    "title": "20  Débuggage et performance",
    "section": "",
    "text": "Si on a un objet n dont on souhaite afficher le contenu, on doit faire print(n).↩︎\nL’avantage d’utiliser bench::mark() est qu’on n’a pas besoin d’ajouter un library(bench) dans notre script.↩︎"
  },
  {
    "objectID": "21-targets.html#définition-du-pipeline",
    "href": "21-targets.html#définition-du-pipeline",
    "title": "21  Organiser un projet avec targets",
    "section": "21.1 Définition du pipeline",
    "text": "21.1 Définition du pipeline\n\n21.1.1 Projet d’exemple\nOn part d’un projet très simple : à partir du fichier national des prénoms donnés à la naissance, diffusé par l’INSEE, on souhaite produire un document indiquant les prénoms ayant les évolutions les plus fortes (à la hausse ou à la baisse) entre 2019 et 2020.\nLe dossier de notre projet s’organise de la manière suivante :\ndata/\n└── nat2020.csv\nR/\n├── fonctions_recode.R\n└── fonctions_calculs.R\n_targets.R\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que targets n’impose aucune structure de projet particulière en-dehors de la présence du fichier _targets.R. On aurait donc pu avoir une organisation tout à fait différente.\n\n\nLe fichier data/nat2020.csv contient les données brutes téléchargées depuis le site de l’INSEE.\nLe fichier R/fonctions_recode.R contient deux fonctions de traitement et de remise en forme des données.\n\n# On conserve uniquement 2019 et 2020 et on\n# filtre les lignes des prénoms rares regroupés\nfilter_data &lt;- function(df) {\n    df %&gt;%\n        filter(annais %in% c(\"2019\", \"2020\")) %&gt;%\n        filter(preusuel != \"_PRENOMS_RARES\")\n}\n\n# Passage d'un format avec les années en ligne à un\n# format avec les années en colonnes\npivot_2019_2020 &lt;- function(df) {\n    df %&gt;%\n        tidyr::pivot_wider(names_from = annais, values_from = nombre) %&gt;%\n        relocate(`2020`, .after = `2019`)\n}\n\nLe fichier R/fonctions_calculs.R contient une seule fonction qui calcule les variables d’évolution 2019-2020.\n\n# Calcul des indicateurs d'évolution en effectifs et pourcentages\n# pour les prénoms dont la fréquence est &gt; à min_n\ncalcule_evo &lt;- function(df, min_n = 200) {\n    df %&gt;%\n        filter(`2020` &gt; min_n | `2019` &gt; min_n) %&gt;%\n        mutate(\n            evo = (`2020` - `2019`),\n            `evo%` = round(evo / `2019` * 100, 2)\n        ) %&gt;%\n        drop_na(evo)\n}\n\n\n\n21.1.2 _targets.R\nC’est dans le fichier _targets.R, situé à la racine du dossier, qu’on va définir le pipeline constitué de toutes les étapes de notre traitement : chargement et manipulation des données, calculs, génération de rapports, etc. Ces étapes sont également appelées cibles (targets).\n\n\n\n\n\n\nNote\n\n\n\nLa syntaxe présentée ici est celle proposée par l’extension tarchetypes, qui est un peu plus facile à prendre en main et plus lisible que la syntaxe native de targets.\n\n\nLe fichier _targets.R commence par charger à la fois targets et tarchetypes.\n\n# Packages nécessaires pour ce script\nlibrary(targets)\nlibrary(tarchetypes)\n\nOn va ensuite utiliser source() pour charger le contenu des deux fichiers R/fonctions_recode.R et R/fonctions_calculs.R, et pouvoir utiliser par la suite les fonctions qu’ils définissent.\n\n# Chargement des fonctions\nsource(\"R/fonctions_recode.R\")\nsource(\"R/fonctions_calculs.R\")\n\nOn définit ensuite des options globales pour le pipeline. L’option packages de tar_option_set(), permet de spécifier une liste d’extensions à charger systématiquement avant le lancement de chaque étape. Ici on s’assure que l’extension tidyverse est bien chargée et disponible, et on positionne l’option tidyverse.quiet à TRUE pour supprimer le message qu’elle affiche systématiquement au chargement.\n\n# Options pour les différentes étapes\noptions(tidyverse.quiet = TRUE)\ntar_option_set(packages = \"tidyverse\")\n\nVient enfin la définition du pipeline proprement dit. Celle-ci se fait via la fonction tar_plan() de tarchetypes.\n\ntar_plan(\n\n)\n\nLa première opération que l’on souhaite effectuer est de charger les données contenues dans data/nat2020.csv. Pour cela on va d’abord créer une première étape qui consiste à référencer notre fichier CSV à l’aide de la fonction tar_file().\n\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\")\n)\n\nCette première étape définit une cible (target), nommée csv_file, qui pointe vers notre fichier CSV.\nOn ajoute une seconde étape qui charge les données à l’aide de read_csv2().\n\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\"),\n    donnees_brutes = read_csv2(csv_file),\n)\n\nCette nouvelle étape définit une deuxième cible nommée donnees_brutes. Cette cible correspond au nom d’une étape, mais aussi à un objet : dans ce qui suit, donnees_brutes correspond au tableau de données résultat du read_csv2().\nOn va utiliser cet objet donnees_brutes dans une troisième étape nommée donnees qui lui applique les deux fonctions de filtrage et transformation définies dans R/fonctions_recode.R.\n\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\"),\n    donnees_brutes = read_csv2(csv_file),\n\n    # Mise en forme des données\n    donnees = donnees_brutes %&gt;%\n        filter_data() %&gt;%\n        pivot_2019_2020()\n)\n\nIci aussi, donnees est à la fois le nom d’une cible et un objet contenant nos données retravaillées. On utilise cet objet dans une étape supplémentaire qui utilise la fonction de R/fonctions_calculs.R pour calculer les variables d’évolution.\n\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\"),\n    donnees_brutes = read_csv2(csv_file),\n\n    # Mise en forme des données\n    donnees = donnees_brutes %&gt;%\n        filter_data() %&gt;%\n        pivot_2019_2020(),\n\n    # Calcul indicateurs\n    donnees_evo = donnees %&gt;%\n        calcule_evo(min_n = 1000)\n)\n\n\n\n\n\n\n\nAvertissement\n\n\n\nOn notera que les cibles doivent toutes avoir des noms différents. Si on exécute plusieurs étapes de transformation ou de calcul sur un tableau de données, on devra donner un nom distinct à ces cibles et aux objets qui correspondent.\n\n\nAu final, notre fichier _targets.R est donc le suivant :\n\n# Packages nécessaires pour ce script\nlibrary(targets)\nlibrary(tarchetypes)\n\n# Chargement des fonctions\nsource(\"R/fonctions_recode.R\")\nsource(\"R/fonctions_calculs.R\")\n\n# Options pour les différentes étapes\noptions(tidyverse.quiet = TRUE)\ntar_option_set(packages = \"tidyverse\")\n\n# Définition du pipeline\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\"),\n    donnees_brutes = read_csv2(csv_file),\n\n    # Mise en forme des données\n    donnees = donnees_brutes %&gt;%\n        filter_data() %&gt;%\n        pivot_2019_2020(),\n\n    # Calcul indicateurs\n    donnees_evo = donnees %&gt;%\n        calcule_evo(min_n = 1000)\n\n)\n\n\n\n\n\n\n\nNote\n\n\n\ntargets offre aussi la possibilité de définir notre pipeline directement dans un fichier RMarkdown, ce qui peut permettre notamment de mieux le documenter. Pour plus d’information on pourra se référer au chapitre Target Markdown du manuel en ligne."
  },
  {
    "objectID": "21-targets.html#exécution-du-pipeline",
    "href": "21-targets.html#exécution-du-pipeline",
    "title": "21  Organiser un projet avec targets",
    "section": "21.2 Exécution du pipeline",
    "text": "21.2 Exécution du pipeline\nUne fois notre pipeline défini, targets fournit des outils permettant de visualiser sa structure et son état, notamment la fonction tar_visnetwork().\n\ntar_visnetwork()\n\n\n\n\n\n\n\nLes différentes cibles apparaissent sous forme de cercles, et les fonctions qui leur sont appliquées sous forme de triangles. Les flèches indiquent que targets a automatiquement créé un réseau de dépendances entre cibles et fonctions : ainsi la cible donnees dépend des fonctions filter_data, pivot_2019_2020 et de la cible donnees_brutes, qui elle-même dépend de la cible csv_file.\nLa couleur des différents éléments montrent que ceux-ci sont à l’état outdated : ils ne sont pas à jour.\nOn va donc exécuter notre pipeline, en utilisant la fonction tar_make().\n\ntar_make()\n#&gt; • start target csv_file\n#&gt; • built target csv_file [0.658 seconds]\n#&gt; • start target donnees_brutes\n#&gt; ℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n#&gt; Rows: 667364 Columns: 4\n#&gt; ── Column specification ────────────────────────────────────────────────────────\n#&gt; Delimiter: \";\"\n#&gt; chr (2): preusuel, annais\n#&gt; dbl (2): sexe, nombre\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; • built target donnees_brutes [0.771 seconds]\n#&gt; • start target donnees\n#&gt; • built target donnees [0.165 seconds]\n#&gt; • start target donnees_evo\n#&gt; • built target donnees_evo [0.021 seconds]\n#&gt; • end pipeline [2.701 seconds]\n\nLorsqu’on utilise tar_make(), targets lance une nouvelle session R (pour éviter tout problème ou conflit lié à l’état de notre session actuelle), charge les extensions définies via tar_option_set(), et exécute les cibles définies avec tar_plan().\nOn visualise le nouvel état de notre pipeline, et on voit que toutes les cibles sont passées à l’état up to date.\n\ntar_visnetwork()\n\n\n\n\n\n\n\nÀ chaque étape, targets crée et stocke dans un cache chacun des objets correspondants aux différentes cibles (donnees_brutes, donnees, etc.). On peut charger à tout moment ces objets dans notre session avec la fonction tar_load()2.\n\ntar_load(donnees_evo)\ndonnees_evo\n#&gt; # A tibble: 128 × 6\n#&gt;     sexe preusuel  `2019` `2020`   evo `evo%`\n#&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1     1 AARON       2443   2312  -131  -5.36\n#&gt;  2     1 ADAM        3670   3386  -284  -7.74\n#&gt;  3     1 ALEXANDRE   1154   1039  -115  -9.97\n#&gt;  4     1 AMIR        1588   1360  -228 -14.4 \n#&gt;  5     1 ANTOINE     1786   1455  -331 -18.5 \n#&gt;  6     1 ARTHUR      4008   3800  -208  -5.19\n#&gt;  7     1 AUGUSTIN    1546   1379  -167 -10.8 \n#&gt;  8     1 AXEL        1809   1683  -126  -6.97\n#&gt;  9     1 AYDEN       1524   1786   262  17.2 \n#&gt; 10     1 BAPTISTE    1403   1202  -201 -14.3 \n#&gt; # … with 118 more rows\n\nOn peut aussi utiliser tar_read(), qui lit et retourne les résultats d’une des cibles, permettant de les stocker dans un nouvel objet.\n\nevo &lt;- tar_read(donnees_evo)"
  },
  {
    "objectID": "21-targets.html#modification-du-pipeline",
    "href": "21-targets.html#modification-du-pipeline",
    "title": "21  Organiser un projet avec targets",
    "section": "21.3 Modification du pipeline",
    "text": "21.3 Modification du pipeline\nEssayons de lancer à nouveau notre pipeline :\n\ntar_make()\n#&gt; ✔ skip target csv_file\n#&gt; ✔ skip target donnees_brutes\n#&gt; ✔ skip target donnees\n#&gt; ✔ skip target donnees_evo\n#&gt; ✔ skip pipeline [0.095 seconds]\n\nOn voit que toutes les cibles ont été “skippées” : quand on lance tar_make(), seules les cibles qui sont à l’état outdated sont recalculées. Les résultats des autres sont conservés tels quels.\nOn va maintenant modifier légèrement notre fichier R/fonctions_calculs.R : plutôt que d’arrondir les évolutions en pourcentages à deux décimale, on n’en conserve plus qu’une.\n\n# Calcul des indicateurs d'évolution en effectifs et pourcentages\n# pour les prénoms dont la fréquence est &gt; à min_n\ncalcule_evo &lt;- function(df, min_n = 200) {\n    df %&gt;%\n        filter(`2020` &gt; min_n | `2019` &gt; min_n) %&gt;%\n        mutate(\n            evo = (`2020` - `2019`),\n            `evo%` = round(evo / `2019` * 100, 1)\n        ) %&gt;%\n        drop_na(evo)\n}\n\nOn visualise à nouveau l’état de notre pipeline :\n\ntar_visnetwork()\n\n\n\n\n\n\n\nGrâce à sa gestion interne des dépendances entre les cibles, targets a vu que la fonction calcule_evo a été modifiée (elle est passée en statut outdated), et comme la cible donnees_evo dépend de cette fonction, celle-ci a également été placée en outdated. On peut obtenir directement une liste des cibles qui ne sont plus à jour à l’aide de la fonction tar_outdated() :\n\ntar_outdated()\n#&gt; [1] \"donnees_evo\"\n\nOn relance notre pipeline :\n\ntar_make()\n#&gt; ✔ skip target csv_file\n#&gt; ✔ skip target donnees_brutes\n#&gt; ✔ skip target donnees\n#&gt; • start target donnees_evo\n#&gt; • built target donnees_evo [0.112 seconds]\n#&gt; • end pipeline [0.869 seconds]\n\nOn voit que les cibles csv_file, donnees_brutes et donnees ont été “skippées” : targets est allé prendre directement leurs valeurs déjà stockées en cache. Par contre donnees_evo a bien été recalculée.\nOn peut vérifier que notre pipeline est désormais entièrement à jour :\n\ntar_visnetwork()\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que targets gère aussi les modifications des fichiers externes. Ainsi, si on modifie le contenu de nat2020.csv, la cible csv_file passerait en outdated, tout comme l’ensemble des autres cibles puisqu’elles dépendent directement ou indirectement de celle-ci. Dans ce cas, un tar_make() aurait pour effet de recalculer l’intégralité du pipeline."
  },
  {
    "objectID": "21-targets.html#rmarkdown",
    "href": "21-targets.html#rmarkdown",
    "title": "21  Organiser un projet avec targets",
    "section": "21.4 RMarkdown",
    "text": "21.4 RMarkdown\nImaginons maintenant qu’on souhaite générer un rapport à partir d’un document RMarkdown en utilisant les données d’évolution calculées par notre pipeline. On crée donc un nouveau fichier evolution.Rmd dans un dossier reports.\ndata/\n└── nat2020.csv\nR/\n├── fonctions_recode.R\n└── fonctions_calculs.R\nreports/\n└── evolution.Rmd\n_targets.R\nQuand on utilise un document RMarkdown dans un pipeline, on doit accéder aux données en utilisant les fonctions tar_read() ou tar_load() : ceci permet de s’assurer qu’on récupère les données “à jour”, et cela permet aussi à targets de déterminer un lien de dépendance entre le document et les données.\nComme on souhaite utiliser les données de donnees_evo, on devra donc utiliser quelque chose comme :\n\nd &lt;- tar_read(donnees_evo)\n\nAu final, le contenu de notre fichier RMarkdown est le suivant :\n\n---\ntitle: \"Évolutions des prénoms 2019-2020\"\ndate: \"`r Sys.Date()`\"\noutput: \n    html_document:\n        df_print: paged\n---\n\n```{r setup, include = FALSE}\nknitr::opts_chunk$set(echo = FALSE)\nd &lt;- tar_read(donnees_evo)\n```\n\n\n## Plus fortes hausses\n\n```{r}\nd %&gt;%\n    arrange(desc(`evo%`)) %&gt;%\n    head(10)\n```\n\n## Plus fortes baisses\n\n```{r}\nd %&gt;%\n    arrange(`evo%`) %&gt;%\n    head(10)\n```\n\nPour ajouter ce rapport à notre pipeline, on crée une nouvelle cible dans le tar_plan() de _targets.R. Comme il s’agit d’un document RMarkdown, on utilise la fonction tar_render().\n\n# Packages nécessaires pour ce script\nlibrary(targets)\nlibrary(tarchetypes)\n\n# Chargement des fonctions\nsource(\"R/fonctions_recode.R\")\nsource(\"R/fonctions_calculs.R\")\n\n# Options pour les différentes étapes\noptions(tidyverse.quiet = TRUE)\ntar_option_set(packages = \"tidyverse\")\n\n# Définition du pipeline\ntar_plan(\n    # Chargement du fichier CSV\n    tar_file(csv_file, \"data/nat2020.csv\"),\n    donnees_brutes = read_csv2(csv_file),\n\n    # Mise en forme des données\n    donnees = donnees_brutes %&gt;%\n        filter_data() %&gt;%\n        pivot_2019_2020(),\n\n    # Calcul indicateurs\n    donnees_evo = donnees %&gt;%\n        calcule_evo(min_n = 1000),\n\n    # Génération rapport\n    tar_render(report_evo, \"reports/evolution.Rmd\")\n)\n\nVisualisons notre pipeline modifié :\n\ntar_visnetwork()\n\n\n\n\n\n\n\nOn voit que notre nouvelle cible report_evo a bien été prise en compte, qu’elle dépend bien de donnees_evo et qu’elle est à l’état outdated.\nSi on exécute notre pipeline :\n\ntar_make()\n#&gt; ✔ skip target csv_file\n#&gt; ✔ skip target donnees_brutes\n#&gt; ✔ skip target donnees\n#&gt; ✔ skip target donnees_evo\n#&gt; • start target report_evo\n#&gt; • built target report_evo [0.578 seconds]\n#&gt; • end pipeline [1.483 seconds]\n\nLa cible report_evo a bien été calculée, et on devrait retrouver notre rapport compilé au format HTML dans le dossier reports."
  },
  {
    "objectID": "21-targets.html#gestion-des-données-en-cache",
    "href": "21-targets.html#gestion-des-données-en-cache",
    "title": "21  Organiser un projet avec targets",
    "section": "21.5 Gestion des données en cache",
    "text": "21.5 Gestion des données en cache\ntargets garde une copie des objets correspondant aux cibles du pipeline dans un cache, en fait sous forme de fichiers placés dans un sous-dossier _targets.\nOn a vu qu’on peut récupérer ces objets dans notre session via les fonctions tar_read() et tar_load(). targets propose également plusieurs fonctions pour gérer les données et métadonnées en cache :\n\ntar_destroy() supprime la totalite du répertoire _targets. Elle permet donc de “repartir de zéro”, sans aucun cache et avec toutes les cibles à recalculer.\ntar_delete(donnees) supprime l’objet donnees du cache et place l’état de la cible correspondante à outdated. Elle permet de forcer le recalcul d’une cible et de celles qui en dépendent. À noter qu’on peut sélectionner plusieurs cibles en utilisant la syntaxe de la tidy selection.\ntar_prune() permet de supprimer les cibles qui ne sont plus présentes dans le pipeline. Elle permet donc de “faire le ménage” quand on a supprimé des étapes dans _targets.R."
  },
  {
    "objectID": "21-targets.html#avantages-et-limites",
    "href": "21-targets.html#avantages-et-limites",
    "title": "21  Organiser un projet avec targets",
    "section": "21.6 Avantages et limites",
    "text": "21.6 Avantages et limites\n\n21.6.1 Avantages\nOn peut voir dans cette introduction rapide que l’utilisation de targets présente de nombreux avantages :\n\nle fichier _targets.R fournit une description détaillée des étapes du projet. Cela facilite les choses quand on revient dessus après un certain temps et qu’on n’a plus tous les détails en tête, ou si on le partage avec quelqu’un.\nchaque cible du pipeline est définie via des fonctions, ce qui garantit une séparation et une encapsulation des différentes étapes.\nl’utilisation de tar_make() garantit que toutes les cibles du pipeline sont recalculées dans le bon ordre : pas de risque de lancer un script sur des données qui ne seraient pas complètement à jour parce qu’on a oublié de relancer certains recodages par exemple.\ntar_make() s’exécute toujours dans un environnement vide, ce qui élimine les problèmes liés à l’état de notre session en cours et garantit la reproductibilité des résultats.\ncomme targets conserve une copie des résultats des cibles en cache, pas besoin de tout recalculer quand on relance le projet, on peut récupérer directement les résultats et savoir si ils sont à jour.\ntar_make() ne recalcule que les cibles qui le nécessitent, les temps de calcul et d’exécution sont optimisés.\n\nParmi les inconvénients liés à l’utilisation de targets, on notera que le débuggage est un peu plus complexe, même si l’extension fournit plusieurs outils pour faciliter le travail.\n\n\n21.6.2 Interactivité et développement du pipeline\nUne des limitations de targets est que le pipeline ne permet pas l’utilisation de fonctions “interactives”. Par exemple, on pourrait ajouter une étape affichant un graphique dans tar_plan() :\n\ngraphique = ggplot(donnees_evo) + geom_histogram(aes(x = evo))\n\nCeci fonctionne, mais ne provoque pas l’affichage du graphique. Il faut faire un tar_read(graphique) pour pouvoir le visualiser.\nDe la même manière, on ne peut pas utiliser d’interfaces interactives comme celles vues pour faciliter les recodages de variables (par exemple Section 9.3.2.1). Il est donc souvent pratique de commencer à développer des transformations, calculs ou analyses de façon “interactive”, via un script classique dans lequel on importe les données nécessaires via tar_read(). Une fois qu’on obtient le résultat souhaité, on transforme ce code en une ou plusieurs fonctions et on les intègre au pipeline de targets.\n\n\n\n\n\n\nNote\n\n\n\nOn notera que les documents RMarkdown s’utilisent très bien avec targets : du moment qu’on charge les données avec tar_read() ou tar_load(), ils permettent à la fois une utilisation “interactive” pendant leur écriture, et une intégration directe dans un pipeline avec tar_render() sans avoir besoin de les modifier."
  },
  {
    "objectID": "21-targets.html#ressources",
    "href": "21-targets.html#ressources",
    "title": "21  Organiser un projet avec targets",
    "section": "21.7 Ressources",
    "text": "21.7 Ressources\nNous n’avons vu ici qu’un petit aperçu des fonctionnalités de targets, qui est une extension extrêmement riche et qui propose de nombreuses autres possibilités, comme la parallélisation des calculs, la gestion des versions de paquets via renv, la création programmatique de cibles…\nLe package bénéficie d’une excellente documentation en anglais. On pourra donc se référer aux sites officiels de targets et tarchetypes, mais surtout à l’ouvrage en ligne The targets R Package User Manual, très clair et très complet.\nLe groupe des utilisateurs de R de Lille a accueilli une intervention (toujours en anglais) de Will Landau, l’auteur de targets. Celle-ci est disponible en vidéo sur YouTube."
  },
  {
    "objectID": "21-targets.html#footnotes",
    "href": "21-targets.html#footnotes",
    "title": "21  Organiser un projet avec targets",
    "section": "",
    "text": "Pour les personnes habituées au développement, il s’agit d’un équivalent à GNU Make pour R.↩︎\nCes données sont stockées dans le répertoire _targets à la racine du projet.↩︎"
  },
  {
    "objectID": "22-ressources.html#aide",
    "href": "22-ressources.html#aide",
    "title": "Annexe A — Ressources",
    "section": "A.1 Aide",
    "text": "A.1 Aide\n\nA.1.1 Aide de R et RStudio\nIl est possible d’obtenir à tout moment de l’aide (en anglais) sur une fonction en tapant help() avec comme argument le nom de la fonction dans la console :\n\nhelp(\"mean\")\n\nVous pouvez aussi aller dans l’onglet Help de l’interface de RStudio (dans le quart de l’écran en bas à droite) et utiliser le moteur de recherche intégré.\nChaque page d’aide est très complète mais pas toujours très accessible. Elle est structurée selon différentes sections, notamment :\n\nDescription : donne un résumé en une phrase de ce que fait la fonction\nUsage : indique la ou les manières de l’utiliser\nArguments : détaille les arguments possibles et leur signification\nValue : indique la forme du résultat renvoyé par la fonction\nDetails : apporte des précisions sur le fonctionnement de la fonction\nSee Also : renvoie vers d’autres fonctions semblables ou liées, ce qui peut être très utile pour découvrir ou retrouver une fonction dont on a oublié le nom\nExamples : donne une série d’exemples d’utilisation\n\nLes exemples d’une page d’aide peuvent être exécutés directement dans la console avec la fonction example :\n\nexample(\"mean\")\n\nL’onglet Help de RStudio permet d’afficher mais aussi de naviguer dans les pages d’aide de R et dans d’autres ressources :\n\n\n\nOnglet Help de Rstudio\n\n\nCette page permet d’accéder aux manuels officiels de R (section Manuals), qui abordent différents aspects plus ou moins techniques du langage et du logiciel, en anglais. On citera notamment les documents An Introduction to R et R Data Import/Export. Elle propose également un lien vers la FAQ officielle.\n\n\nA.1.2 Aide en ligne\nPlusieurs sites proposent une interface permettant de naviguer et rechercher dans l’aide de R et de l’ensemble des extensions existantes.\nC’est notamment le cas de rdrr.io.\n\n\nA.1.3 Antisèches\nRStudio propose plusieurs cheat sheets (antisèches) en anglais qui proposent sur deux pages une synthèse compacte de fonctions et de leur usage selon différentes thématiques, notamment :\n\nManipulation des données avec dplyr\nVisualisation avec ggplot2\nCréation de documents avec RMarkdown\netc.\n\nLa liste complète est disponible en ligne :\nhttps://www.rstudio.com/resources/cheatsheets/\nOu directement depuis RStudio, via le menu Help, puis Cheatsheets.\n\n\nA.1.4 Où poser des questions\nOutre l’aide intégrée au logiciel, il existe de nombreuses ressources en ligne, forums, listes de discussions, pour poser ses questions et échanger avec des utilisateurs et utilisatrices de R.\nLe meilleur moyen d’obtenir une réponse est de poser la question de manière à ce qu’il soit aussi facile que possible d’y répondre. Ce qui implique de donner le maximum d’informations possibles et, si possible, de fournir un exemple de reproductible (un extrait de code et de données permettant de reproduire un problème ou de montrer le résultat qu’on souhaite obtenir). Pour des conseils sur les bonnes pratiques pour poser une question, on pourra se référer au billet Reprex, ou comment demander de l’aide efficacement sur le blog de ThinkR.\n\nA.1.4.1 Discussion instantanée\nGrrr (“pour quand votre R fait Grrr”) est un groupe Slack (plateforme de discussion instantanée) francophone dédié aux échanges et à l’entraide autour de R. Il est ouvert à tous et se veut accessible aux débutants. Vous pouvez même utiliser un pseudonyme si vous préférez.\nPour rejoindre la discussion, il suffit de suivre le lien d’invitation suivant :\nhttps://join.slack.com/t/r-grrr/shared_invite/zt-46utbgb9-uvo_bg5cbuxOV~H10YUX8w\n\n\nA.1.4.2 Listes de discussion\nLa liste R-soc est une liste francophone spécialement dédiée aux utilisateurs et utilisatrices de R en sciences sociales. Toutes les questions y sont les bienvenues, et les réponses sont en général assez rapides. Il suffit de s’y abonner pour pouvoir ensuite poster sa question :\n\nhttps://groupes.renater.fr/sympa/subscribe/r-soc\n\nLa liste semin-r est la liste de discussion du groupe des utilisateurs et utilisatrices de R animé par le Muséum national d’Histoire naturelle. Elle est ouverte à tous et les questions y sont bienvenues :\n\nhttps://listes.mnhn.fr/wws/subscribe/semin-r\n\nIl existe aussi une liste officielle anglophone baptisée R-help. Elle est cependant à réserver aux questions les plus pointues, et dans tous les cas il est nécessaire d’avoir en tête et de respecter les bonnes pratiques avant de poster sur la liste :\n\nhttps://stat.ethz.ch/mailman/listinfo/r-help\n\n\n\nA.1.4.3 Sur le Web\nPour les anglophones, la ressource la plus riche concernant R est certainement le site StackOverflow. Sous forme de questions/réponses, il comporte un très grand nombre d’informations sur R et les réponses y sont très rapides. Avant de poster une question il est fortement recommandé de faire une recherche sur le site, car il y a de fortes chances que celle-ci ait déjà été posée :\n\nhttps://stackoverflow.com/questions/tagged/r\n\nPour les francophones, on pourra citer le forum du CIRAD, qui comporte une section questions en cours assez active. Là aussi, pensez à faire une recherche sur le forum avant de poser votre question :\n\nhttp://forums.cirad.fr/logiciel-R/"
  },
  {
    "objectID": "22-ressources.html#ouvrages-blogs-moocs",
    "href": "22-ressources.html#ouvrages-blogs-moocs",
    "title": "Annexe A — Ressources",
    "section": "A.2 Ouvrages, blogs, MOOCs…",
    "text": "A.2 Ouvrages, blogs, MOOCs…\n\nA.2.1 Francophones\nParmi les ouvrages en français, on peut citer notamment :\n\nLes formations R très complètes développées par les agents de plusieurs ministère.\nR et espace, manuel d’initiation à la programmation avec R appliqué à l’analyse de l’information géographique, librement téléchargeable en ligne.\nutilitR, un ouvrage en ligne de formation à R à destination principalement des agents de l’INSEE mais qui aborde un grand nombre de sujets.\n\nLe pôle bioinformatique lyonnais (PBIL) propose depuis longtemps une somme très importante de documents, qui comprend des cours complets de statistiques utilisant R :\n\nhttps://pbil.univ-lyon1.fr/R/\n\nPlusieurs blogs francophones autour de R sont également actifs, parmi lesquels :\n\nElementR, le blog du groupe du même nom, qui propose de nombreuses ressources sur R en général et en particulier sur la cartographie ou l’analyse de réseaux.\nR-atique, blog animé par Lise Vaudor, propose régulièrement des articles intéressants et accessibles sur des méthodes d’analyse ou sur des extensions R.\n\nPour des formations en ligne, le site France Université Numérique propose régulièrement des sessions de cours, parmi lesquels une Introduction à la statistique avec R et un cours sur l’Analyse des données multidimensionnelles.\nEnfin, le projet Rzine effectue un important travail de recensement des ressources sur R en particulier pour les sciences humaines et sociales.\n\n\nA.2.2 Anglophones\nLes ressources anglophones sont évidemment très nombreuses.\nOn citera essentiellement l’ouvrage en ligne R for data science, très complet, et qui fournit une introduction très complète et progressive à R, et aux packages du tidyverse. Il existe également en version papier.\nPour aborder des aspects beaucoup plus avancés, l’ouvrage également en ligne Advanced R, d’Hadley Wickham, est extrêmement bien et fait et très complet.\nOn notera également l’existence du R journal, revue en ligne consacrée à R, et qui propose régulièrement des articles sur des méthodes d’analyse, des extensions, et l’actualité du langage.\nLa plateforme R-bloggers agrège les contenus de plusieurs centaines de blogs parlant de R, très pratique pour suivre l’actualité de la communauté.\nEnfin, sur Twitter, les échanges autour de R sont regroupés autour du hashtag #rstats."
  },
  {
    "objectID": "22-ressources.html#extensions",
    "href": "22-ressources.html#extensions",
    "title": "Annexe A — Ressources",
    "section": "A.3 Extensions",
    "text": "A.3 Extensions\n\nA.3.1 Où trouver des extensions intéressantes ?\nIl existe plusieurs milliers d’extensions pour R, et il n’est pas toujours facile de savoir laquelle choisir pour une tâche donnée.\nSi un des meilleurs moyens reste le bouche à oreille, on peut aussi se reporter à la page CRAN Task view qui liste un certain nombre de domaines (classification, sciences sociales, séries temporelles…) et indique, pour chacun d’entre eux, une liste d’extensions potentiellement intéressantes accompagnées d’une courte description.\nUne autre possibilité est de consulter la page listant l’ensemble des packages existant. S’il n’est évidemment pas possible de passer en revue les milliers d’extensions une à une, on peut toujours effectuer une recherche dans la page avec des mots-clés correspondant aux fonctionnalités recherchées.\nUn autre site intéressant est Awesome R, une liste élaborée collaborativement des extensions les plus utiles ou les plus populaires classées par grandes catégories : manipulation des données, graphiques interactifs, etc.\nLa page frrrenchies liste des packages pouvant être utiles pour des utilisateurs et utilisatrices francophones (géolocalisation, traitement du langage, accès à des API…), ainsi que des ressources en français.\nEnfin, certaines extensions fournissent des “galeries” permettant de repérer ou découvrir certains packages. C’est notamment le cas de R Markdown ou de htmlwidgets, qui propose une galerie d’extensions proposant des graphiques interactifs.\n\n\nA.3.2 L’extension questionr\nquestionr est une extension utilisée régulièrement dans ce document et comprenant quelques fonctions utiles pour l’utilisation du logiciel en sciences sociales, ainsi que différents jeux de données. Elle est développée en collaboration avec François Briatte et Joseph Larmarange.\nL’installation se fait soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande suivante dans la console :\n\ninstall.packages(\"questionr\")\n\nIl est possible d’installer la version de développement à l’aide de la fonction install_github de l’extension remotes :\n\nremotes::install_github(\"juba/questionr\")\n\nquestionr propose à la fois des fonctions, des interfaces interactives et des jeux de données d’exemple.\n\nA.3.2.1 Fonctions et utilisation\nPour plus de détails sur la liste des fonctions de l’extension et son utilisation, on pourra se reporter au site Web de l’extension, hébergé sur GitHub.\nL’onglet Reference liste l’ensemble des fonctions de questionr, tandis que l’onglet Articles propose une présentation des trois interfaces interactives (Addins) visant à faciliter le recodage de certaines variables.\nCes interfaces sont également abordées Chapitre 9.\n\n\nA.3.2.2 Jeu de données hdv2003\nhdv2003 est un extrait comportant 2000 individus et 20 variables provenant de l’enquête Histoire de Vie réalisée par l’INSEE en 2003.\nL’extrait est tiré du fichier détail mis à disposition librement (ainsi que de nombreux autres) par l’INSEE. On trouvera une documentation complète à la même adresse.\nLes variables retenues ont été parfois partiellement recodées. La liste des variables est la suivante :\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nIdentifiant (numéro de ligne)\n\n\npoids\nVariable de pondération\n\n\nage\nÂge\n\n\nsexe\nSexe\n\n\nnivetud\nNiveau d’études atteint\n\n\noccup\nOccupation actuelle\n\n\nqualif\nQualification de l’emploi actuel\n\n\nfreres.soeurs\nNombre total de frères, sœurs, demi-frères et demi-sœurs\n\n\nclso\nSentiment d’appartenance à une classe sociale\n\n\nrelig\nPratique et croyance religieuse\n\n\ntrav.imp\nImportance accordée au travail\n\n\ntrav.satisf\nSatisfaction ou insatisfaction au travail\n\n\nhard.rock\nÉcoute du Hard rock ou assimilés\n\n\nlecture.bd\nLecture de bandes dessinées\n\n\npeche.chasse\nPêche ou chasse pour le plaisir au cours des 12 derniers mois\n\n\ncuisine\nCuisine pour le plaisir au cours des 12 derniers mois\n\n\nbricol\nBricolage ou mécanique pour le plaisir au cours des 12 derniers mois\n\n\ncinema\nCinéma au cours des 12 derniers mois\n\n\nsport\nSport ou activité physique pour le plaisir au cours des 12 derniers mois\n\n\nheures.tv\nNombre moyen d’heures passées à regarder la télévision par jour\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nComme il s’agit d’un extrait du fichier, la variable de pondération n’a en toute rigueur aucune valeur statistique. Elle a été tout de même incluse à des fins “pédagogiques”.\n\n\n\n\nA.3.2.3 Jeu de données rp2018\nrp2018 est un jeu de données issu du recensement de la population de 2018 de l’INSEE. Il comporte une petite partie des résultats pour l’ensemble des communes françaises de plus de 2000 habitants, soit au final 5417 communes et 62 variables.\nListe de quelques variables du fichier :\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\ncommune\nnom de la commune\n\n\ncode_insee\nCode de la commune\n\n\npop_tot\nPopulation totale\n\n\npop_act_15p\nPopulation active de 15 ans et plus\n\n\nlog_rp\nNombre de résidences principales\n\n\nagric\nPart des agriculteurs dans la population active\n\n\nindep\nPart des artisans, commerçants et chefs d’entreprises\n\n\ncadres\nPart des cadres\n\n\ninterm\nPart des professions intermédiaires\n\n\nempl\nPart des employés\n\n\nouvr\nPart des ouvriers\n\n\nchom\nPart des chômeurs\n\n\netud\nPart des étudiants\n\n\ndipl_sup\nPart des diplômés de niveau Bac+5 ou plus\n\n\ndipl_aucun\nPart des personnes sans diplôme\n\n\nproprio\nPart des propriétaires parmi les résidences principales\n\n\nhlm\nPart des logements HLM parmi les résidences principales\n\n\nlocataire\nPart des locataires parmi les résidences principales\n\n\nmaison\nPart des maisons parmi les résidences principales"
  }
]