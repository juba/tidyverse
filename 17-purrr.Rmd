# Itérer avec `purrr` {#purrr}

`purrr` est une extension du *tidyverse* qui fournit des outils pour travailler avec les vecteurs et les fonctions, et notamment pour appliquer des fonctions à l'ensemble des éléments de vecteurs ou de listes.

Dans cette section on aura besoin des extensions du *tidyverse* (dont `purrr` fait partie), que nous chargeons donc immédiatement, de même que les jeux de données `rp2012` et `hdv2003` de `questionr`.

```{r message=FALSE}
library(tidyverse)
library(questionr)
data(hdv2003)
data(rp2012)
```



## Exemple d'application

Pour mieux appréhender de quoi il s'agit, supposons que nous avons le vecteur suivant, qui contient des extraits de discours politiques.

```{r}
discours <- c(
    "nous privilégierons une intergouvernementalisation sans agir anticonstitutionnellement",
    "le souffle de la nation est le vent qui agite les drapeaux de nos libertés",
    "nous devons faire preuve de plus de pédagogie pour cette réforme",
    "mon compte twitter a été piraté"
)
```

On souhaite calculer la longueur de chaque extrait, en nombre de mots. 

On commence par découper chaque extrait en mots en utilisant la fonction `str_split()` de `stringr`.

```{r}
mots <- str_split(discours, " ")
str(mots)
```

L'objet `mots` qui contient le résultat du découpage est une liste constituée de vecteurs de chaînes de caractères qui contiennent les mots des différents discours.

Calculer le nombre de mots de chaque discours, revient à calculer la longueur de chaque élément de `mots`. Pour cela on pourrait vouloir utiliser la fonction `length()` directement :

```{r}
length(mots)
```

Ceci ne fonctionne pas, car `length()` nous retourne le nombre d'éléments de `mots`, pas celui de chacun de ses éléments. On a en fait besoin d'appliquer `length()` tour à tour à chacun des éléments de `mots`.

On a vu section \@ref(no-boucles) qu'on peut pour cela utiliser une boucle `for`, par exemple de la manière suivante.

```{r}
resultat <- list()
for (item in mots) {
    resultat <- append(resultat, length(item))
}
resultat
```

Cela fonctionne, mais la syntaxe est un peu "lourde".

La fonction `map()` de `purrr` propose exactement cette fonctionnalité. Elle prend deux arguments principaux :

1. un vecteur ou une liste
2. une fonction

et elle retourne une liste contenant le résultat de la fonction appliquée à chaque élément du vecteur ou de la liste.

En utilisant `map()` on peut du coup remplacer notre boucle `for` par un simple :

```{r}
map(mots, length)
```

À noter qu'on peut évidemment utiliser le *pipe*.

```{r}
mots %>% map(length)
```

Ici notre résultat est donné sous forme de liste. Or il pourrait être simplifié sous forme de vecteur atomique, puisque tous ses éléments sont des nombres. Si on souhaitait faire ceci avec une boucle `for`, il faudrait soit convertir le résultat de la boucle précédente en vecteur atomique (avec `unlist()` ou `purrr::flatten_int()`), soit modifier cette boucle pour qu'elle génère plutôt un vecteur numérique. C'est ce que fait le code suivant, en n'oubliant pas de "pré-allouer" le nombre d'éléments nécessaires au vecteur résultat pour éviter des problèmes de performance.

```{r}
resultat <- numeric(length(discours))
for (i in seq_along(mots)) {
    resultat[i] <- length(mots[[i]])
}
resultat
```

`purrr` propose des variantes de la fonction `map` qui permettent justement de s'assurer du type de résultat obtenu. Ainsi, `map_dbl()` renverra toujours un vecteur de nombres flottants, et `map_int()` un vecteur de nombres entiers. Plutôt que la boucle `for` ci-dessus, on peut plutôt utiliser :

```{r}
mots %>% map_int(length)
```


## `map` et ses variantes

### Modes d'appel de `map`

L'objectif de `map` est donc d'appliquer une fonction à l'ensemble des éléments d'un vecteur ou d'une liste.

On a vu qu'on pouvait l'utiliser pour appliquer la fonction `length` à chacun des vecteurs contenus par la liste `mots`. En utilisant `map_int` on s'assure de récupérer un simple vecteur numérique, plus facile à utiliser par la suite si on souhaite par exemple calculer une moyenne.

```{r}
mots %>% map_int(length)
```

Si on souhaitait plutôt extraire le dernier mot de chaque vecteur, on pourrait créer une fonction spécifique et l'appliquer avec `map()`.

```{r}
dernier_mot <- function(v) {
    tail(v, 1)
}

mots %>% map(dernier_mot)
```

Comme notre résultat est une liste de chaînes de caractères simples, on peut forcer le résultat à être plutôt un vecteur de type *character* en utilisant `map_chr()` :

```{r}
mots %>% map_chr(dernier_mot)
```

Comme notre fonction est très courte, on peut aussi préférer utiliser une *fonction anonyme*, introduites section \@ref(fonctions-anonymes).

```{r}
mots %>% map_chr(function(v) { tail(v, 1) })
```

On peut aussi utiliser la notation abrégée sous forme de formule, présentée section \@ref(syntaxes-abregees) propre aux fonctions du *tidyverse*.

```{r}
mots %>% map_chr(~ tail(.x, 1) )
```

On peut également utiliser la notation compacte pour les fonctions anonymes propre aux versions de R à partir de la 4.1.

```{r}
mots %>% map_chr(\(v) tail(v, 1))
```

Enfin, si on fournit des arguments supplémentaires à `map`, ils sont passés comme argument à la fonction qu'il applique, on peut donc également utiliser la notation suivante :

```{r}
mots %>% map_chr(tail, 1)
```

Dans ce qui suit on utilisera de préférence la notation "formule", mais toutes les versions ci-dessus sont équivalentes et donnent le même résultat.

```{block type='rmdnote'}
Petite astuce à noter, si on transmet à `map()` autre chose qu'une fonction, elle utilisera cette information pour extraire des éléments. Ainsi, `map(v, 1)` extraiera le premier élément de chaque élément du vecteur `v`, `map(v, "foo")` extraiera les éléments nommés "foo", etc.
```

### Variantes de `map`

On a vu que `map` propose plusieurs variantes qui permettent de contrôler le type de résultat qu'elle retourne :

- `map()` retourne une liste
- `map_int()` retourne un vecteur atomique d'entiers
- `map_dbl()` retourne un vecteur atomique de nombres flottants
- `map_chr()` retourne un vecteur atomique de chaînes de caractères
- `map_lgl()` retourne un vecteur atomique de `TRUE` / `FALSE`

Attention, ces variantes sont très strictes dans le sens où si la fonction appelée retourne un résultat qui n'est pas compatible avec le résultat attendu, elle génère une erreur. Ainsi, si dans le code précédent on souhaitait récupérer chaque dernier mot sous forme d'un vecteur de nombres :

```{r error=TRUE}
mots %>% map_dbl(tail, 1)
```

Pour pouvoir utiliser ces variantes, chaque résultat retourné par la fonction appliquée doit être de longueur 1. Par exemple, si on souhaitait extraire plutôt la liste des mots contenant un "f" :

```{r}
mots %>% map(~ str_subset(.x, "f") )
```

Dans ce cas on ne peut utiliser `map_chr()`  puisque certains vecteurs contiennent plusieurs mots avec un "f", et donc le résultat de `str_subset()` est lui-même un vecteur.

```{r error=TRUE}
mots %>% map_chr(~ str_subset(.x, "f") )
```

Dans ce cas, on doit utiliser `map()` et conserver le résultat sous forme de liste. Et, pourquoi pas, enchaîner les `map()` si on veut effectuer des opérations supplémentaires.

```{r}
mots %>% 
    map(~ str_subset(.x, "f") ) %>%
    map_int(length)
```

### `map_dfr()` et `map_dfc()`

La page suivante contient les données du jeu de données `rp2012` sous la forme de fichiers CSV, avec un fichier par département :

TODO: Mettre à jour avec la branche master
https://github.com/juba/tidyverse/tree/aller-plus-loin/data/rp2012

À partir de cette page, on peut télécharger les fichiers CSV en utilisant des adresses de la forme :

https://raw.githubusercontent.com/juba/tidyverse/aller-plus-loin/data/rp2012/rp2012_01.csv

En remplaçant "01" par le code du département souhaité.

On peut facilement créer une fonction `genere_url()` qui, à partir d'une liste de codes de départements, retourne les adresses des fichiers correspondant.

```{r}
genere_url <- function(codes) {
    paste0(
        "https://raw.githubusercontent.com/juba/tidyverse/aller-plus-loin/data/rp2012/rp2012_",
        codes,
        ".csv"
    )
}

genere_url(c("42", "69"))
```

Grâce à la fonction `read_csv()`, on peut charger directement dans notre session R un fichier en indiquant son URL.

```{r eval=FALSE}
data69 <- read_csv(genere_url("69"))
```

Comment faire si l'on souhaite charger les fichiers de plusieurs départements ? La fonction `read_csv()` n'accepte qu'une seule URL à la fois, mais on peut très bien utiliser `map()` pour l'appliquer tour à tour à plusieurs URL.

```{r eval=FALSE}
departements <- c("38", "42", "69")

l <- genere_url(departements) %>%
    map(read_csv)
```

`l` ici est donc une liste de tableaux de données, chacun de ces éléments étant un *tibble* : d'abord celui du fichier CSV correspondant aux données de l'Ain, puis celui de la Loire, etc.

Si on souhaite réunir ces trois *tibbles* en un seul, on peut utiliser la fonction `bind_rows()` de `dplyr`.

```{r}
departements <- c("38", "42", "69")

df <- genere_url(departements) %>%
    map(read_csv) %>%
    bind_rows()
```

Mais on peut aussi utiliser la variante `map_dfr()` de `map()`, qui considère les résultats obtenus par l'application de la fonction comme les lignes d'un tableau de données qu'elle va automatiquement rassembler en un seul tableau, de la même manière qu'avec un `bind_rows()`.

```{r}
df <- genere_url(departements) %>%
    map_dfr(read_csv)

df
```

Les deux lignes de code ci-dessus partent d'une liste d'identifiants de départements, génèrent les URL des fichiers CSV correspondant, les importent dans R et assemblent le résultat en un seul tableau. Plutôt efficace !

```{block type='rmdnote'}
Il existe également une variante `map_dfc()`, un peu moins fréquemment utilisée, qui considère les résultats comme des colonnes d'un tableau de données et les rassemble en un seul tableau comme le ferait la fonction `bind_cols()` de `dplyr`.
```


## Itérer sur les colonnes d'un tableau de données

On a vu section \@ref(data-frame-tibbles) que les tableaux de données (*data frame* ou *tibble*) sont en fait des listes dont les éléments sont les colonnes du tableau. On peut donc tout à fait appliquer `map()` et ses variantes à un tableau, et celle-ci itèrera sur ses colonnes.

Par exemple, on peut appliquer `n_distinct` au jeu de données `starwars` et obtenir le nombre de valeurs distinctes de chacune de ses colonnes.

```{r}
starwars %>% map_int(n_distinct)
```

Le résultat est équivalent à celui qu'on obtient en faisant un `summarise()` sur l'ensemble des colonnes, comme vu section \@ref(across), sauf que `map_int()` retourne un vecteur numérique tandis que `summarise()` renvoie un *tibble* à une ligne.

```{r}
starwars %>%
    summarise(across(everything(), n_distinct))
```

De la même manière, si on veut connaître le nombre de valeurs manquantes pour chaquae variables :

```{r}
starwars %>% map_int(~ sum(is.na(.x)) )
```

Contrairement à `across()`, on ne peut pas spécifier directement une sélection de colonnes à `map()`. On peut par contre utiliser des fonctions comme `keep()` ou `discard()` qui "filtrent" les éléments d'une liste via une fonction qui renvoie `TRUE` ou `FALSE`.

Dans l'exemple suivant, on utilise `keep()` pour n'appliquer `mean` que sur les variables numériques.

```{r}
starwars %>%
    keep(is.numeric) %>%
    map(mean, na.rm = TRUE)
```

Ici, on applique `discard()` après le `map()` pour ne conserver que les colonnes ayant au moins une valeur `NA`.

```{r}
starwars %>%
    map_int(~ sum(is.na(.x)) ) %>%
    discard(~ .x == 0 )
```


## `modify`

`modify()` est une variante de `map()` qui a pour particularité de renvoyer un résultat du même type que la liste ou le vecteur donné en entrée.

Ainsi, si on l'applique à un vecteur de chaînes de caractères, le résultat sera aussi un vecteur de chaînes de caractères même si la fonction appliquée retourne un résultat numérique.

```{r}
v <- c("brouette", "moto", "igloo")
v %>% modify(length)
```

Si on l'applique à une liste, le résultat sera aussi une liste.

```{r}
v <- list("brouette", "moto", "igloo")
v %>% modify(length)
```

L'objectif de `modify()` est de permettre de "modifier" une liste ou un vecteur en lui appliquant une fonction tout en étant sûr qu'on ne va pas modifier son type.

L'intérêt est que `modify` propose deux variantes, `modify_if` et `modify_at`, qui permettent de sélectionner les éléments soit via une fonction soit par leur nom ou leur position, et n'appliquent la fonction de transformation qu'aux éléments sélectionnés.

Cela peut être particulièrement utile quand on l'applique à un tableau de données. Par exemple le code suivant transforme uniquement les colonnes de type `factor` de `hdv2003` en `character`, et laisse les autres inchangées.

```{r include=FALSE}
hdv2003 <- as_tibble(hdv2003)
```

```{r}
hdv2003 %>% modify_if(is.factor, as.character)
```

On notera qu'on obtient le même résultat avec le code suivant qui utilise `across()` de `dplyr`.

```{r}
hdv2003 %>%
    mutate(
        across(
            where(is.factor),
            as.character
        )
    )
```

## `imap`

Imaginons que nous avons récupéré les données suivantes, qui représentent les notes obtenues par quatre restaurants sur quatre critères différents, sous la forme d'une liste.

```{r}
restos <- list(
    "La bonne fourchette"     = c(3, 3, 2, 5, 2, 3, 2, 4, 1, 3),
    "La choucroute de l'amer" = c(4, 1, 2, 4, 2, 5, 2, 4, 3, 4),
    "L'Hair de rien"          = c(1, 5, 5, 1, 5, 3, 1, 5, 2, 4),
    "La blanquette de Vaulx"  = c(4, 1, 3, 1, 3, 3, 1, 4, 2, 5)
)
```

À partir de cette liste, on souhaite créer un tableau de données comportant la moyenne et l'écart-type de chaque restaurant. Comme on l'a vu précédemment, cela peut se faire avec l'aide de `map_dfr()`.

```{r}
restos %>% map_dfr(~ tibble(moyenne = mean(.x), ecart_type = sd(.x)) )
```

On obtient le tableau souhaité, mais il manque une information : le nom du restaurant correspondant à chaque ligne. Or, cette information est incluse dans les noms des éléments de la liste `restos`, or la fonction passée à `map_dfr` n'y a pas accès, elle n'a accès qu'à leurs valeurs.

C'est pour ce type de cas de figure que `purrr` propose la famille de fonctions `imap()`. Celle-ci fonctionne de la même manière que `map()`, sauf que la fonction appliquée prend deux arguments : d'abord la valeur de l'élément courant, puis son nom.

Dans l'exemple suivant, on applique `imap()` à une liste simple et on affiche un message avec le nom et la valeur de chaque élément.

```{r}
l <- list(nom1 = 1, nom2 = 3)

l2 <- l %>% imap(function(valeur, nom) {
   message("La valeur de ", nom, " est ", valeur)
})
```

On peut évidemment utiliser la notation "formule" de `purrr`, il faut juste se souvenir que dans ce cas `.x` correspond à la valeur, et `.y` au nom.

```{r}
l2 <- l %>% imap(~ {
   message("La valeur de ", .y, " est ", .x)
})
```

Tout comme `map()` proposait les variantes `map_int()`, `map_chr()` ou `map_dfr()`, on peut également utiliser `imap_dbl()`, `imap_chr()` et autres `imap_dfc()` pour forcer le type de résultat retourné.

Pour reprendre notre exemple de départ, on peut donc, en utilisant `imap` récupérer le nom de l'élément de la liste courant et l'utiliser pour rajouter le nom du restaurant dans notre *tibble* de résultats.

```{r}
restos %>% imap_dfr(~ {
    tibble(nom = .y, moyenne = mean(.x), ecart_type = sd(.x))
})
```

```{block type='rmdnote'}
Si on utilise `imap()` sur une liste ou un vecteur qui n'a pas de nom, le deuxième argument passé à la fonction appliquée sera l'indice de l'élément courant : 1 pour le premier, 2 pour le deuxième, etc.
```

## `walk`

`walk()` est une variante de `map()` qui a pour particularité de ne pas retourner de résultat. On l'utilise lorsqu'on souhaite parcourir un vecteur ou une liste et appliquer à ses éléments une fonction dont on ne souhaite conserver que les "effets de bord" : afficher un message, générer un graphique, enregistrer un fichier...

Par exemple, le code suivant génère quatre diagrammes en barre indiquant la répartition des notes des différents restaurants vus dans la section précédente.

```{r}
walk(restos, ~{
    barplot(table(.x))
})
```

Comme pour `map()`, la variante `iwalk()` permet d'itérer à la fois sur les valeurs et sur les noms des éléments du vecteur ou de la liste. Ceci permet par exemple d'afficher le nom du restaurant comme titre de chaque graphique.

```{r}
iwalk(restos, ~{
    barplot(table(.x), main = .y)
})
```

Au final, on notera que l'utilisation de `walk()`, comme elle ne retourne pas de résultats, est très proche de celle d'une boucle `for`.

```{block type='rmdnote'}
Comme `walk()` ne retourne pas de résultats, il n'existe pas de variantes du type `map_chr()` ou `imap_int()`.
```

## `map2` et `pmap` : itérer sur plusieurs vecteurs en parallèle

Supposons qu'un.e collègue, qui travaille avec nous sur le jeu de données `rp2012`, nous a envoyé une liste de variables dont elle souhaite qu'on calcule la corrélation. Cette liste a été saisie dans un tableur sur deux colonnes, chaque ligne indiquant les deux variables dont on souhaite la corrélation.

Au final après importation dans R on obtient le tableau de données suivant.

```{r}
correlations <- tibble(
    var1 = c("dipl_sup",   "dipl_sup", "hlm",    "hlm",  "proprio"),
    var2 = c("dipl_aucun", "cadres",   "cadres", "ouvr", "hlm"),
)
```

Pour pouvoir calculer les corrélations souhaitées, on doit itérer sur les deux vecteurs `var1` et `var2` *en parallèle*, et calculer la corrélation entre le vecteur correspondant à la valeur courante de `var1` et celui correspondant à la valeur courante de `var2`.

C'est précisément ce que fait la fonction `map2()`. Celle-ci prend trois arguments en entrée : deux listes ou vecteurs qui seront itérées en parallèle, et une fonction qui accepte elle-même deux arguments, qui seront remplacés par les valeurs courantes.

```{r}
map2_dbl(correlations$var1, correlations$var2, ~ cor(rp2012[[.x]], rp2012[[.y]]))
```

`map2()` propose les mêmes variantes `map2_int()`, `mapr2_chr()`, etc. que `map()`. Ici on a utilisé `map2_dbl()` pour récupérer un vecteur numérique plutôt qu'une liste. Si on souhaite uniquement capturer les effets de bord sans récupérer les résultats de la fonctions appliquée, on peut aussi utiliser la variante `walk2()`.

Supposons maintenant que notre collègue nous a envoyé, toujours sous la même forme, une liste de variables dont elle souhaite obtenir un nuage de points, mais aussi un titre à ajouter au graphique. On obtient le tableau suivant.

```{r}
nuages <- tibble(
    var1 = c("dipl_sup",   "dipl_sup", "hlm"),
    var2 = c("dipl_aucun", "cadres",   "cadres"),
    titre = c(
        "Relation entre la proportion de diplômés du supérieur et celle de sans diplôme",
        "Y'a-t-il un lien entre le pourcentage de cadres et celui de diplômés du supérieur",
        "C'est pas toujours facile de trouver des titres pas trop rébarbatifs"
    )
)
```

On est dans une situation similaire à la précédente, sauf que cette fois on doit itérer sur trois listes en parallèle. On va donc utiliser la fonction `pmap()` qui permet d'itérer sur autant de listes ou vecteurs que l'on souhaite. Plus précisément, comme on souhaite générer des graphiques on va utiliser la variante `pwalk()` qui ne retourne pas de résultat.

`pmap()` et `pwalk()` prennent deux principaux arguments :

- les vecteurs et listes sur lesquels itérer, eux-mêmes regroupés dans une liste
- une fonction acceptant autant d'arguments que de vecteur ou listes sur lesquels on itère

Dans notre exemple on aurait donc un appel de la forme suivante.

```{r include=FALSE}
data(rp2012)
rp2012_orig <- rp2012
rp2012 <- sample_n(rp2012, size = 500)
```

```{r}
pwalk(
    list(nuages$var1, nuages$var2, nuages$titre),
    function(var1, var2, titre) {
        plot(
            rp2012[[var1]], rp2012[[var2]],
            xlab = var1, ylab = var2, main = titre
        )
    }
)
```

Petite précision, si la liste est nommée, il faut que les noms des arguments de la fonction correspondent aux noms.

```{r}
pwalk(
    list(v1 = nuages$var1, v2 = nuages$var2, titre = nuages$titre),
    function(v1, v2, titre) {
        plot(
            rp2012[[v1]], rp2012[[v2]],
            xlab = v1, ylab = v2, main = titre
        )
    }
)
```


À noter que comme `nuages` est un tableau de données, donc une liste dont les éléments sont ses colonnes, on aurait obtenu le même résultat avec :

```{r eval=FALSE}
pwalk(
    nuages,
    function(var1, var2, titre) {
        plot(
            rp2012[[var1]], rp2012[[var2]],
            xlab = var1, ylab = var2, main = titre
        )
    }
)
```

Enfin, on peut utiliser la syntaxe "formule" pour la fonction anonyme, dans ce cas les arguments sont accessibles avec la notation `..1`, `..2`, etc. 

```{r eval=FALSE}
pwalk(
    nuages,
    ~ {
        plot(
            rp2012[[..1]], rp2012[[..2]],
            xlab = ..1, ylab = ..2, main = ..3
        )
    }
)
```

On notera que dans ce cas la syntaxe "formule" est sans doute moins lisible que la syntaxe classique avec `function()` qui permet de nommer les paramètres.

Comme pour `map()` et `map2()`, `pmap()` propose aussi les variantes `pmap_int()`, `pmap_chr()`, etc.

```{r include=FALSE}
rp2012 <- rp2012_orig
```



## Répéter une opération

Les fonctions de `purrr` peuvent être utilisées quand on souhaite juste répéter une opération un certain nombre de fois, à la place d'une boucle `for`.

Par exemple si on souhaite générer 10 vecteurs de 100 nombre aléatoires, on pourra remplacer :

```{r}
res <- list()
for (i in 1:10) {
    res[[i]] <- rnorm(100)
}
```

Par :

```{r}
res <- map(1:10, ~ rnorm(100))
```

Ce qui donne un code un peu plus compact et plus lisible.

```{block type='rmdnote'}
De la même manière, si on s'intéresse juste aux effets de bord, on pourra remplacer une boucle `for` par un appel à `walk()`, mais dans ce cas de figure le code résultant n'est pas forcément plus lisible.
```


## Quand ne pas utiliser `map`

Une fois qu'on a compris la logique de `map()` et de ses variantes, on peut être tenté.es de l'appliquer un peu systématiquement. Il faut cependant garder en tête que son usage n'est pas conseillé notamment dans les cas où il existe déjà une fonction vectorisée qui permet d'obtenir le même résultat.

Ainsi ça n'aurait pas de sens de faire `map(v, length)` quand on peut simplement faire `length(v)`.

Pour prendre un exemple un peu moins caricatural, de nombreuses fonctions de `stringr` par exemple s'appliquent à des vecteurs, il n'est donc pas utile de faire `map(txt, str_count("f"))` quand on peut faire simplement `str_count(txt, "f")`.

Par contre `map()` est utile quand on souhaite appliquer une fonction qui n'est pas vectorisée, comme c'est le cas par exemple avec `read_csv()` :

```{r eval=FALSE}
fichiers <- c("fichier1.csv", "fichier2.csv")
l <- fichiers %>% map(read_csv)
```

Ou quand on veut itérer sur un argument, par exemple ici sur l'argument `pattern` de `str_count()` :

```{r}
voyelle <- c(a = "a", e = "e", i = "i")
v <- c("brouette", "moto", "igloo")
voyelle %>% map(~ str_count(v, pattern = .x) )
```

On l'utilise également quand on veut appliquer une fonction non pas à une liste, mais aux éléments qu'elle contient :

```{r}
l <- list(1:3, c(2, 5))
l %>% map_int(length)
```

En termes de performance, `map()` n'est pas forcément plus rapide qu'une boucle `for`, puisque dans les deux cas on itère sur un ensemble de valeurs. Par contre une fonction vectorisée existante sera toujours (beaucoup) plus rapide.


## `purrr` vs *apply

Les fonctions de `purrr` ont des équivalents dans R "de base", ce sont notamment les fonctions de la famille `apply` : `lapply, `sapply`, `mapply`...

L'avantage de `map()` et des autres fonctions fournies par `purrr` et qu'elles sont plus explicites, on a des fonctions bien précises selon qu'on veut seulement appliquer une fonction (`map()`), générer des effets de bord (`walk`), modifier une liste sans changer son type (`modify()`), etc. `purrr` propose également de nombreuses fonctions utiles qui facilite le travail avec les vecteurs et listes.

Mais un des avantages principaux des fonctions de la famille `map()` est qu'elles sont consistantes et cohérentes dans le type de résultat qu'elles retournent : on est certain que `map()` ou `imap()` retourneront une liste, que `map_chr()` ou `map2_chr()` retourneront un vecteur de chaînes de caractères, etc.

Là encore, il n'est pas question de dire qu'il ne faut pas utiliser les fonctions `*apply`. Si vous en avez l'habitude et qu'elles fonctionnent pour vous, il n'y a pas forcément de raison de changer. Mais si vous n'avez pas l'habitude de ce type d'opérations ou si vous préférez une syntaxe plus cohérente et plus facile à retenir, les fonctions de `purrr` peuvent être intéressantes.

Si vous souhaitez en savoir plus, l'ouvrage en ligne *R for data science* contient [une comparaison plus détaillée](https://r4ds.had.co.nz/iteration.html#base-r) des deux familles de fonction. 


## Ressources

Au-delà de celles présentées ici, `purrr` propose de nombreuses autres fonctions facilitant la manipulation et les itérations sur les listes et les vecteurs. On peut en trouver la [liste complète](https://purrr.tidyverse.org/reference/index.html) et la documentation associée (en anglais) sur [le site de l'extension](https://purrr.tidyverse.org).


La section *Iteration* de l'ouvrage en ligne *R for data science* (en anglais) propose [une présentation de plusieurs fonctions de `purrr`](https://r4ds.had.co.nz/iteration.html#the-map-functions).

RStudio propose une [https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf](antisèche) (en anglais, format PDF) qui résume les différentes fonctions de l'extension.

Sur le blog en français de Lise Vaudor, on trouvera un billet [Itérer des fonctions avec purrr](https://perso.ens-lyon.fr/lise.vaudor/iterer-des-fonctions-avec-purrr/) et une suite [Practice makes purrr-fect](https://perso.ens-lyon.fr/lise.vaudor/practice-makes-purrr-fect/).


## Exercices

### `map` et ses variantes

**Exercice 1.1**

La liste suivante rassemble les notes obtenues par un ou une élève dans différentes matières.

```{r}
notes <- list(
    maths = c(12, 15, 8, 10),
    anglais = c(18, 11, 9),
    sport = c(5, 13),
    musique = 14
)
```

En utilisant `map()`, calculer une liste indiquant la moyenne dans chaque matière.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% map(mean)
```
</div>
\fi

En utilisant une variante de `map()`, simplifier le résultat pour obtenir un vecteur numérique.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% map_dbl(mean)
```
</div>
\fi

On a rajouté à la liste les notes obtenues en technologie, parmi lesquelles une note est manquante.

```{r}
notes <- list(
    maths = c(12, 15, 8, 10),
    anglais = c(18, 11, 9),
    sport = c(5, 13),
    musique = 14,
    techno = c(12, NA)
)
```

Calculer à nouveau un vecteur numérique des moyennes par matière, mais sans tenir compte de la valeur manquante.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% map_dbl(~ mean(.x, na.rm = TRUE) )
# Ou bien
notes %>% map_dbl(mean, na.rm = TRUE)
```
</div>
\fi

Calculer une liste qui contient pour chaque matière le nombre de notes, leur moyenne et leur écart-type.

\iffalse
<div class="solution-exo">
```{r}
# On peut aussi utiliser list() plutôt que c()
notes %>%
    map(~ c(
            nb_notes = length(.x),
            moyenne = mean(.x, na.rm = TRUE),
            ecart_type = sd(.x, na.rm = TRUE)
        )
    )
```
</div>
\fi

Calculer et retourner les mêmes résultats, mais cette fois sous la forme d'un tableau de données.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>%
    map_dfr(~ c(
            nb_notes = length(.x),
            moyenne = mean(.x, na.rm = TRUE),
            ecart_type = sd(.x, na.rm = TRUE)
        )
    )
```
</div>
\fi

**Exercice 1.2**

La liste suivante comporte les parcours biographiques de 5 personnes sous la forme de vecteurs indiquant leurs communes de résidence successive.

```{r}
parcours <- list(
    c("Lyon", "Flixevile", "Saint-Dié-en-Pouilly"),
    c("Sainte-Gabelle-sur-Sarthe"),
    c("Décines", "Meyzieu", "Demptezieu"),
    c("Meyzieu", "Lyon", "Paris", "Flixevile", "Lyon"),
    c("La Bâtie-Divisin", "Versailles")
)
```

À l'aide de `map()`, calculer une nouvelle liste comportant le nombre de villes de résidence pour chaque parcours.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
parcours %>% map(length)
```
</div>
\fi

Utiliser une variante de `map()` pour simplifier le résultat et obtenir un vecteur numérique plutôt qu'une liste.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
parcours %>% map_int(length)
```
</div>
\fi

Déterminer pour chaque parcours le nombre de fois où la personne a résidé à Lyon.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
parcours %>% map_int(~ sum(.x == "Lyon"))
```
</div>
\fi

L'équipe chargée de l'enquête vient de repérer une erreur de saisie : "Flixevile" s'écrit en réalité "Flixeville". Utiliser `map()` pour corriger la liste `parcours`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
parcours <- parcours %>% 
    map(~ ifelse(.x == "Flixevile", "Flixeville", .x))
```
</div>
\fi


**Exercice 1.3**

Le vecteur suivant contient les adresses de deux fichiers CSV contenant les données de `rp2012` pour les départements de l'Ain et du Rhône :

TODO: aller-plus-loin -> master
```{r}
urls <- c(
    "https://raw.githubusercontent.com/juba/tidyverse/aller-plus-loin/data/rp2012/rp2012_01.csv",
    "https://raw.githubusercontent.com/juba/tidyverse/aller-plus-loin/data/rp2012/rp2012_69.csv"
)
```

Utiliser `map()` pour charger ces deux tableaux de données dans une liste `l`.

\iffalse
<div class="solution-exo">
```{r}
l <- map(urls, read_csv)
```
</div>
\fi


Utiliser `map_dfr()` pour charger ces deux tableaux de données et les regrouper en une seule table `d`. Que constatez-vous ? 

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
d <- map_dfr(urls, read_csv)
```
</div>
\fi

Comparer la variable `code_insee` contenue dans les deux tableaux de `l`. D'où vient le problème ?

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
# Une variable a été importée en character, l'autre en numérique
l %>% map( ~.x$code_insee)
```
</div>
\fi

Trouver une solution pour corriger le problème.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
# En convertissant manuellement code_insee en character
d <- map_dfr(urls, ~{
    tab <- read_csv(.x)
    tab$code_insee <- as.character(tab$code_insee)
    tab
})
# Ou bien en utilisant l'option col_types de read_csv
d <- map_dfr(urls, read_csv, col_types = c("code_insee" = "c"))
```
</div>
\fi



### `modify` et itération sur les colonnes d'un tableau

**Exercice 2.1**

Soit le tableau de données `d` suivant :

```{r}
d <- tibble(
    prenom = c("pierre-edmond", "YVONNE", "charlotte-adélaïde"),
    nom = c("rateau", "de la grappinière", "QUIGNON"),
    age = c(19, 73, 27),
    taille = c(151, 182, NA)
)
```

Utliser la fonction `typeof()` pour afficher le type de toutes les colonnes de `d`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
d %>% map(typeof)
```
</div>
\fi

En utilisant `keep()` et `map()`, calculer la moyenne de toutes les variables numériques de `d`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
d %>%
    keep(is.numeric) %>%
    map(mean, na.rm = TRUE)
```
</div>
\fi

En utilisant `modify_if()`, appliquer `str_to_title()` à toutes les colonnes de type `character` pour corriger la capitalisation des noms et prénoms.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
d <- d %>% modify_if(is.character, str_to_title)
```
</div>
\fi

À l'aide de la fonction `discard()`, supprimer de `d` les colonnes qui comportent des `NA`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
d %>% discard(~ sum(is.na(.x)) > 0)
# Autre possibilité
d %>% discard(~ any(is.na(.x)))
```
</div>
\fi

### `imap` et `walk`


**Exercice 3.1**

On reprend la liste de notes vue dans un exercice précédent.

```{r}
notes <- list(
    maths = c(12, 15, 8, 10),
    anglais = c(18, 11, 9),
    sport = c(5, 13),
    musique = 14,
    techno = c(12, NA)
)
```

Sans utiliser de boucle `for`, afficher avec la fonction `message()` les valeurs de chaque moyenne tour à tour de manière à obtenir le résultat suivant :

```{r echo=FALSE}
notes %>% walk(~ message(mean(.x, na.rm = TRUE)))
```
\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% walk(~ message(mean(.x, na.rm = TRUE)))
```
</div>
\fi

De la même manière afficher pour chaque matière les messages suivants :

```{r echo=FALSE}
notes %>% iwalk(function(notes, matiere) {
    message("Votre moyenne en ", matiere, " est ", mean(notes, na.rm = TRUE))
})
```


\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% iwalk(function(notes, matiere) {
    message("Votre moyenne en ", matiere, " est ", mean(notes, na.rm = TRUE))
})
```
</div>
\fi

Construire un tableau de données avec une matière par ligne et deux colonnes contenant le nom de la matière et la valeur de la moyenne.

```{r echo=FALSE}
notes %>% imap_dfr(function(notes, matiere) {
    tibble(matiere = matiere, moyenne = mean(notes, na.rm = TRUE))
})
```

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
notes %>% imap_dfr(function(notes, matiere) {
    tibble(matiere = matiere, moyenne = mean(notes, na.rm = TRUE))
})
```
</div>
\fi

**Exercice 3.2**

Lors de la présentation des boucles `for`, on a vu la fonction suivante qui affiche les dimensions de chaque tableau de données contenus dans une liste.

```{r}
affiche_dimensions <- function(dfs) {
    for (i in seq_along(dfs)) {
        name <- names(dfs)[[i]]
        df <- dfs[[i]]
        message("Dimensions de ", name, " : ", nrow(df), "x", ncol(df))
    }
}

l <- list(
    hdv = hdv2003,
    rp = rp2012
)
affiche_dimensions(l)
```

Réécrire et simplifier `affiche_dimensions()` en utilisant `iwalk()`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
affiche_dimensions <- function(dfs) {
    iwalk(dfs, function(df, name) {
        message("Dimensions de ", name, " : ", nrow(df), "x", ncol(df))
    })
}
```
</div>
\fi


### `map2` et `pmap`

**Exercice 4.1**

Soit le tableau de données suivant, qui indique des couples de variables du jeu de données `hdv2003`.

```{r}
croisements <- tibble(
    v1 = c("qualif", "qualif", "sexe", "sexe"),
    v2 = c("clso",   "cinema", "clso", "cinema")
)
```

Calculer une liste qui contient tous les tableaux croisés entre les quatre couples de variables de `croisements`.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
map2(croisements$v1, croisements$v2,
    ~table(hdv2003[[.x]], hdv2003[[.y]]) 
)
```
</div>
\fi

Modifier le code précédent pour obtenir, pour chaque croisement, une liste avec les noms des deux variables et le résultat du test du Khi2 sur le tableau croisé.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
khi2 <- map2(croisements$v1, croisements$v2,
    ~list(
        variables = paste(.x, .y),
        chisq = chisq.test(hdv2003[[.x]], hdv2003[[.y]])
    )
)
```
</div>
\fi

Filtrer la liste obtenue à l'étape précédente pour ne conserver que les éléments dont la p-value du test du Khi2 est inférieure à 0.001.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
khi2 %>% keep(~ .x$chisq$p.value < 0.001)
```
</div>
\fi

**Exercice 4.2**

Pour rappel, on peut simuler un tirage au sort de type "pile ou face" avec la fonction `sample()` de la manière suivante :

```{r}
sample(
    c("pile", "face"),
    size = 10,
    replace = TRUE,
    prob = c(0.5, 0.5)
)
```

Le tableau de données suivant définit trois types de tirages aléatoires différents. `elements` contient les éléments parmi lesquels on tire, `probas` les probabilités de chaque élément d'être tiré, et `n` le nombre de tirages.

```{r}
tirages <- list(
    elements = list(
        c("pile", "face"),
        c("boule rouge", "boule noire"),
        1:6
    ),
    probas = list(
        c(0.5, 0.5),
        c(0.1, 0.9),
        rep(1 / 6, 6)
    ),
    n = c(1000, 500, 800)
)
```

Créer une liste contenant les résultats de ces trois séries de tirages.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
resultats <- tirages %>%
    pmap(
        function(elements, probas, n) {
            sample(elements, size = n, replace = TRUE, prob = probas)
        }
    )
```
</div>
\fi

Représenter avec `barplot()` les résultats obtenus.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
resultats %>% walk(~barplot(table(.x)))
```
</div>
\fi



### Répéter une opération

**Exercice 5.1**

Comme vu précédemment, la fonction suivante permet de simuler 20 lancers de pièces et de stocker le résultat dans un vecteur de chaînes de caractères.

```{r}
sample(c("pile", "face"), size = 20, replace = TRUE)
```

À l'aide de `map` et de cette fonction, créer une liste contenant le résultat de 100 simulations de 20 lancers.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
sims <- map(
    1:100,
    ~sample(c("pile", "face"), size = 20, replace = TRUE)
)
```
</div>
\fi

Toujours à l'aide de `map`, calculer le nombre de "pile" obtenus pour chaque simulation.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
piles <- sims %>% map_int(~ sum(.x == "pile"))
```
</div>
\fi

Déterminer le nombre minimal et le nombre maximal de "pile" obtenus parmi toutes les simulations.

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
range(piles)
```
</div>
\fi

À l'aide de la fonction [head_while()](https://purrr.tidyverse.org/reference/head_while.html), déterminer pour chaque simulation le nombre de "pile" consécutifs obtenus avant le premier "face".

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
egal_pile <- function(v) { v == "pile"}
sims %>% map_int(
    ~ length(head_while(.x, egal_pile))
)
# En abrégé, moins lisible
sims %>% map_int(
    ~ length(head_while(.x, ~ .x == "pile"))
)
```
</div>
\fi


*Facultatif :* la fonction `rle()` permet de calculer les *run length encoding d'un vecteur.

```{r}
rle(c("pile", "face", "face", "face","pile", "pile"))
```

À l'aide de cette fonction, calculer pour chaque simulation la longueur de la plus grande série consécutive de "pile".

\iffalse
<div class="solution-exo">
```{r eval=FALSE}
sims %>% map_dbl(~{
    r <- rle(.x)
    longueurs_pile <- r$lengths[r$values == "pile"]
    max(longueurs_pile)
})
```
</div>
\fi

